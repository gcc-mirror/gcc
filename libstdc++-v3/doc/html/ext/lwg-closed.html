<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<!-- saved from url=(0059)http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>C++ Standard Library Closed Issues List</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
</style>
</head>
<body>
<table>
<tbody><tr>
  <td align="left">Doc. no.</td>
  <td align="left">D3183=10-0173</td>
</tr>
<tr>
  <td align="left">Date:</td>
  <td align="left">2010-11-29</td>
</tr>
<tr>
  <td align="left">Project:</td>
  <td align="left">Programming Language C++</td>
</tr>
<tr>
  <td align="left">Reply to:</td>
  <td align="left">Alisdair Meredith &lt;<a href="mailto:lwgchair@gmail.com">lwgchair@gmail.com</a>&gt;</td>
</tr>
</tbody></table>
<h1>C++ Standard Library Closed Issues List (Revision D73)</h1>
<p>Revised 2010-11-29 at 10:11:56 UTC</p>

  <p>Reference ISO/IEC IS 14882:2003(E)</p>
  <p>Also see:</p>
    <ul>
      <li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-toc.html">Table of Contents</a> for all library issues.</li>
      <li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html">Index by Section</a> for all library issues.</li>
      <li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html">Index by Status</a> for all library issues.</li>
      <li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html">Library Active Issues List</a></li>
      <li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html">Library Defect Reports List</a></li>
    </ul>

  <p>This document contains only library issues which have been closed
  by the Library Working Group as duplicates or not defects. That is,
  issues which have a status of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a> or
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>. See the <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html">Library Active Issues List</a> active issues and more
  information. See the <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html">Library Defect Reports List</a> for issues considered
  defects.  The introductory material in that document also applies to
  this document.</p>

<h2>Revision History</h2>
<ul>
<li>D73: Batavia meeting preview<ul>
<li><b>Summary:</b><ul>
<li>80 open issues, down by 126.</li>
<li>1459 closed issues, up by 145.</li>
<li>1539 issues total, up by 19.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 11 New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1521">1521</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1523">1523</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2008">2008</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2012">2012</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2013">2013</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2014">2014</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2015">2015</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2016">2016</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2017">2017</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2018">2018</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2019">2019</a>.</li>
<li>Added the following 5 Open issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2001">2001</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2003">2003</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2005">2005</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2010">2010</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2011">2011</a>.</li>
<li>Added the following Resolved issue: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2002">2002</a>.</li>
<li>Added the following Review issue: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2009">2009</a>.</li>
<li>Added the following Tentatively NAD issue: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2006">2006</a>.</li>
<li>Added the following 3 Tentatively Ready issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2000">2000</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2004">2004</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2007">2007</a>.</li>
<li>Added the following WP issue: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1522">1522</a>.</li>
<li>Changed the following 3 issues from New to Deferred: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1213">1213</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1214">1214</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1330">1330</a>.</li>
<li>Changed the following issue from Open to Deferred: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1450">1450</a>.</li>
<li>Changed the following 14 issues from Open to Dup: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1350">1350</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1351">1351</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1352">1352</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1375">1375</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1411">1411</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1443">1443</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1451">1451</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1454">1454</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1458">1458</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1463">1463</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1470">1470</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1475">1475</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1476">1476</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1477">1477</a>.</li>
<li>Changed the following issue from New to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1331">1331</a>.</li>
<li>Changed the following 8 issues from Open to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#579">579</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1359">1359</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1361">1361</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1373">1373</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1376">1376</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1398">1398</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1446">1446</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1473">1473</a>.</li>
<li>Changed the following 2 issues from Tentatively NAD to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1190">1190</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1200">1200</a>.</li>
<li>Changed the following issue from WP to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#822">822</a>.</li>
<li>Changed the following 11 issues from Open to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1395">1395</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1442">1442</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1471">1471</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1472">1472</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1489">1489</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1495">1495</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1496">1496</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1509">1509</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1510">1510</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1511">1511</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1512">1512</a>.</li>
<li>Changed the following issue from Review to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1281">1281</a>.</li>
<li>Changed the following issue from New to NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1289">1289</a>.</li>
<li>Changed the following 6 issues from Open to NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1406">1406</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1422">1422</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1484">1484</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1488">1488</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1493">1493</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1499">1499</a>.</li>
<li>Changed the following 2 issues from Tentatively NAD Future to NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1173">1173</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1188">1188</a>.</li>
<li>Changed the following 2 issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1252">1252</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1297">1297</a>.</li>
<li>Changed the following 3 issues from New to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1279">1279</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1318">1318</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1332">1332</a>.</li>
<li>Changed the following 6 issues from Open to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1385">1385</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1401">1401</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1408">1408</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1418">1418</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1420">1420</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1438">1438</a>.</li>
<li>Changed the following 42 issues from NAD Editorial to Resolved: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#353">353</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#431">431</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#482">482</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#525">525</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#594">594</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#625">625</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#635">635</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#658">658</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#697">697</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#719">719</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#742">742</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#786">786</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#815">815</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#816">816</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#823">823</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#827">827</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#834">834</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#884">884</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#932">932</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#947">947</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#950">950</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#953">953</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#983">983</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1054">1054</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1055">1055</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1075">1075</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1100">1100</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1116">1116</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1117">1117</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1122">1122</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1135">1135</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1151">1151</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1174">1174</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1258">1258</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1260">1260</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1283">1283</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1293">1293</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1307">1307</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1321">1321</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1394">1394</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1405">1405</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1407">1407</a>.</li>
<li>Changed the following 5 issues from New to Resolved: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1290">1290</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1322">1322</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1324">1324</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1326">1326</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1328">1328</a>.</li>
<li>Changed the following 46 issues from Open to Resolved: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#801">801</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1268">1268</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1327">1327</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1344">1344</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1346">1346</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1347">1347</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1355">1355</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1356">1356</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1357">1357</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1365">1365</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1366">1366</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1377">1377</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1378">1378</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1379">1379</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1380">1380</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1382">1382</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1383">1383</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1389">1389</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1390">1390</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1391">1391</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1392">1392</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1393">1393</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1397">1397</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1409">1409</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1410">1410</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1412">1412</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1445">1445</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1447">1447</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1453">1453</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1455">1455</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1462">1462</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1464">1464</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1465">1465</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1466">1466</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1467">1467</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1468">1468</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1469">1469</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1481">1481</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1482">1482</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1490">1490</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1491">1491</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1492">1492</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1498">1498</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1501">1501</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1508">1508</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1513">1513</a>.</li>
<li>Changed the following issue from Open to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1480">1480</a>.</li>
<li>Changed the following 2 issues from Open to Tentatively NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1371">1371</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1413">1413</a>.</li>
<li>Changed the following issue from New to Tentatively NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1320">1320</a>.</li>
<li>Changed the following 3 issues from New to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1215">1215</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1253">1253</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1310">1310</a>.</li>
<li>Changed the following issue from Open to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1497">1497</a>.</li>
<li>Changed the following 24 issues from NAD Editorial to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1360">1360</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1363">1363</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1367">1367</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1372">1372</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1381">1381</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1384">1384</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1386">1386</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1387">1387</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1388">1388</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1399">1399</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1400">1400</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1402">1402</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1403">1403</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1416">1416</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1417">1417</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1423">1423</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1424">1424</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1425">1425</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1426">1426</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1427">1427</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1429">1429</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1430">1430</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1431">1431</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1441">1441</a>.</li>
<li>Changed the following issue from New to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1294">1294</a>.</li>
<li>Changed the following 10 issues from Open to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1354">1354</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1362">1362</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1368">1368</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1370">1370</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1428">1428</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1435">1435</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1436">1436</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1437">1437</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1439">1439</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1440">1440</a>.</li>
<li>Changed the following 2 issues from Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#868">868</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#951">951</a>.</li>
<li>Changed the following 33 issues from Tentatively Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#956">956</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1118">1118</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1171">1171</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1181">1181</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1183">1183</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1191">1191</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1198">1198</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1207">1207</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1234">1234</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1240">1240</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1249">1249</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1292">1292</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1295">1295</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1316">1316</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1319">1319</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1323">1323</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1325">1325</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1333">1333</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1334">1334</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1335">1335</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1337">1337</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1338">1338</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1339">1339</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1340">1340</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1404">1404</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1414">1414</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1432">1432</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1449">1449</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1516">1516</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1517">1517</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1518">1518</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1519">1519</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1520">1520</a>.</li>
</ul></li>
</ul>
</li>
<li>R72: 
2010-10-18 pre-Batavia mailing.
<ul>
<li><b>Summary:</b><ul>
<li>206 open issues, up by 141.</li>
<li>1314 closed issues, up by 36.</li>
<li>1520 issues total, up by 177.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following Dup issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1433">1433</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1444">1444</a>.</li>
<li>Added the following NAD Editorial issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1360">1360</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1363">1363</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1367">1367</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1372">1372</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1381">1381</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1384">1384</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1386">1386</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1387">1387</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1388">1388</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1394">1394</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1399">1399</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1400">1400</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1402">1402</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1403">1403</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1405">1405</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1407">1407</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1415">1415</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1416">1416</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1417">1417</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1419">1419</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1423">1423</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1424">1424</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1425">1425</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1426">1426</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1427">1427</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1429">1429</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1430">1430</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1431">1431</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1434">1434</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1441">1441</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1483">1483</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1500">1500</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1506">1506</a>.</li>
<li>Added the following Open issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1344">1344</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1345">1345</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1346">1346</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1347">1347</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1348">1348</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1349">1349</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1350">1350</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1351">1351</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1352">1352</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1353">1353</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1354">1354</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1355">1355</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1356">1356</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1357">1357</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1358">1358</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1359">1359</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1361">1361</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1362">1362</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1364">1364</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1365">1365</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1366">1366</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1368">1368</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1369">1369</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1370">1370</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1371">1371</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1373">1373</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1374">1374</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1375">1375</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1376">1376</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1377">1377</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1378">1378</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1379">1379</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1380">1380</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1382">1382</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1383">1383</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1385">1385</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1389">1389</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1390">1390</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1391">1391</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1392">1392</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1393">1393</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1395">1395</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1396">1396</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1397">1397</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1398">1398</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1401">1401</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1406">1406</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1408">1408</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1409">1409</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1410">1410</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1411">1411</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1412">1412</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1413">1413</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1418">1418</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1420">1420</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1421">1421</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1422">1422</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1428">1428</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1435">1435</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1436">1436</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1437">1437</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1438">1438</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1439">1439</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1440">1440</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1442">1442</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1443">1443</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1445">1445</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1446">1446</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1447">1447</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1448">1448</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1450">1450</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1451">1451</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1452">1452</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1453">1453</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1454">1454</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1455">1455</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1456">1456</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1457">1457</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1458">1458</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1459">1459</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1460">1460</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1461">1461</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1462">1462</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1463">1463</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1464">1464</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1465">1465</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1466">1466</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1467">1467</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1468">1468</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1469">1469</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1470">1470</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1471">1471</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1472">1472</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1473">1473</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1474">1474</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1475">1475</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1476">1476</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1477">1477</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1478">1478</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1479">1479</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1480">1480</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1481">1481</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1482">1482</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1484">1484</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1485">1485</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1486">1486</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1487">1487</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1488">1488</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1489">1489</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1490">1490</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1491">1491</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1492">1492</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1493">1493</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1494">1494</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1495">1495</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1496">1496</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1497">1497</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1498">1498</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1499">1499</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1501">1501</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1502">1502</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1503">1503</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1504">1504</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1505">1505</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1507">1507</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1508">1508</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1509">1509</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1510">1510</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1511">1511</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1512">1512</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1513">1513</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1514">1514</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1515">1515</a>.</li>
<li>Added the following Tentatively Ready issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1404">1404</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1414">1414</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1432">1432</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1449">1449</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1516">1516</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1517">1517</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1518">1518</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1519">1519</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1520">1520</a>.</li>
<li>Changed the following issues from New to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1260">1260</a>.</li>
<li>Changed the following issues from New to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1181">1181</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1240">1240</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1249">1249</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1292">1292</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1295">1295</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1316">1316</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1319">1319</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1323">1323</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1325">1325</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1333">1333</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1334">1334</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1335">1335</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1337">1337</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1338">1338</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1339">1339</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1340">1340</a>.</li>
<li>Changed the following issues from Open to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#956">956</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1118">1118</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1183">1183</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1234">1234</a>.</li>
</ul></li>
</ul>
</li>
<li>R71: 
2010-08-25 post-Rapperswil mailing.
<ul>
<li><b>Summary:</b><ul>
<li>65 open issues, up by 2.</li>
<li>1278 closed issues, up by 7.</li>
<li>1343 issues total, up by 9.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1335">1335</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2008">2008</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1337">1337</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1338">1338</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1339">1339</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1340">1340</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2009">2009</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2010">2010</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2011">2011</a>.</li>
<li>Changed the following issues from Open to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#996">996</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1119">1119</a>.</li>
<li>Changed the following issues from Open to NAD Concepts: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1076">1076</a>.</li>
<li>Changed the following issues from Open to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#953">953</a>.</li>
<li>Changed the following issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1169">1169</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1175">1175</a>.</li>
<li>Changed the following issues from Open to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#951">951</a>.</li>
<li>Changed the following issues from Review to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#868">868</a>.</li>
<li>Changed the following issues from New to Tentatively NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1190">1190</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1200">1200</a>.</li>
<li>Changed the following issues from New to Tentatively NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1188">1188</a>.</li>
<li>Changed the following issues from Open to Tentatively NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1173">1173</a>.</li>
<li>Changed the following issues from New to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1198">1198</a>.</li>
<li>Changed the following issues from Open to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1171">1171</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1191">1191</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1207">1207</a>.</li>
<li>Changed the following issues from Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1187">1187</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1206">1206</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1278">1278</a>.</li>
</ul></li>
</ul>
</li>
<li>R70: 
2010-03-26 post-Pittsburgh mailing.
<ul>
<li><b>Summary:</b><ul>
<li>63 open issues, down by 203.</li>
<li>1271 closed issues, up by 219.</li>
<li>1334 issues total, up by 16.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following NAD Editorial issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1321">1321</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1329">1329</a>.</li>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1319">1319</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1320">1320</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1322">1322</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1323">1323</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1324">1324</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1325">1325</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1326">1326</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1328">1328</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1330">1330</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1331">1331</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1332">1332</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1333">1333</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1334">1334</a>.</li>
<li>Added the following Open issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1327">1327</a>.</li>
<li>Changed the following issues from Tentatively Dup to Dup: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1219">1219</a>.</li>
<li>Changed the following issues from New to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1302">1302</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1308">1308</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1313">1313</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1314">1314</a>.</li>
<li>Changed the following issues from Open to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#887">887</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1008">1008</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1068">1068</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1069">1069</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1153">1153</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1156">1156</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1228">1228</a>.</li>
<li>Changed the following issues from Tentatively NAD to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#631">631</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#726">726</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#959">959</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1056">1056</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1099">1099</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1125">1125</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1176">1176</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1202">1202</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1223">1223</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1224">1224</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1246">1246</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1251">1251</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1259">1259</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1263">1263</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1265">1265</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1296">1296</a>.</li>
<li>Changed the following issues from Tentatively NAD Concepts to NAD Concepts: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#910">910</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1186">1186</a>.</li>
<li>Changed the following issues from New to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1185">1185</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1210">1210</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1212">1212</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1225">1225</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1244">1244</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1266">1266</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1269">1269</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1272">1272</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1275">1275</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1291">1291</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1305">1305</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1307">1307</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1311">1311</a>.</li>
<li>Changed the following issues from Open to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#299">299</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#397">397</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#408">408</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#446">446</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#594">594</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#625">625</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#742">742</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#834">834</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#915">915</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1093">1093</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1151">1151</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1211">1211</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1248">1248</a>.</li>
<li>Changed the following issues from Ready to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#485">485</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#932">932</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#940">940</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#950">950</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#983">983</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1100">1100</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1135">1135</a>.</li>
<li>Changed the following issues from Tentatively NAD Editorial to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#815">815</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#816">816</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#889">889</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1106">1106</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1115">1115</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1233">1233</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1239">1239</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1258">1258</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1283">1283</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1301">1301</a>.</li>
<li>Changed the following issues from Tentatively Ready to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1090">1090</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1226">1226</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1273">1273</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1274">1274</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1293">1293</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1300">1300</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1304">1304</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1315">1315</a>.</li>
<li>Changed the following issues from New to NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1154">1154</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1317">1317</a>.</li>
<li>Changed the following issues from Ready to NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1052">1052</a>.</li>
<li>Changed the following issues from Tentatively NAD Future to NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1112">1112</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1121">1121</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1201">1201</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1238">1238</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1282">1282</a>.</li>
<li>Changed the following issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1234">1234</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1268">1268</a>.</li>
<li>Changed the following issues from Tentatively Ready to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#579">579</a>.</li>
<li>Changed the following issues from New to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1187">1187</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1206">1206</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1278">1278</a>.</li>
<li>Changed the following issues from New to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1281">1281</a>.</li>
<li>Changed the following issues from Ready to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#868">868</a>.</li>
<li>Changed the following issues from New to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1159">1159</a>.</li>
<li>Changed the following issues from Open to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#427">427</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#430">430</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#774">774</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#819">819</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#835">835</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#861">861</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#885">885</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#896">896</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#900">900</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#911">911</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1079">1079</a>.</li>
<li>Changed the following issues from Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#296">296</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#471">471</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#473">473</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#539">539</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#671">671</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#836">836</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#854">854</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#860">860</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#865">865</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#871">871</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#872">872</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#920">920</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#921">921</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#939">939</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#954">954</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#957">957</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#960">960</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#962">962</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#963">963</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#967">967</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#968">968</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#974">974</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1011">1011</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1030">1030</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1094">1094</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1095">1095</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1097">1097</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1098">1098</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1104">1104</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1123">1123</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1134">1134</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1136">1136</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1144">1144</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1157">1157</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1194">1194</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1204">1204</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1216">1216</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1227">1227</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1237">1237</a>.</li>
<li>Changed the following issues from Tentatively Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#556">556</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#676">676</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#704">704</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#724">724</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#727">727</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#780">780</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#811">811</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#817">817</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#870">870</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#891">891</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#893">893</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#929">929</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#978">978</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#987">987</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#999">999</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1033">1033</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1034">1034</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1071">1071</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1089">1089</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1108">1108</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1110">1110</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1113">1113</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1114">1114</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1126">1126</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1130">1130</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1131">1131</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1133">1133</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1137">1137</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1138">1138</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1152">1152</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1158">1158</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1170">1170</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1177">1177</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1180">1180</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1182">1182</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1189">1189</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1192">1192</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1193">1193</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1195">1195</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1197">1197</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1199">1199</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1205">1205</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1208">1208</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1209">1209</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1218">1218</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1220">1220</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1221">1221</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1222">1222</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1231">1231</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1241">1241</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1245">1245</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1247">1247</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1250">1250</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1254">1254</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1255">1255</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1256">1256</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1257">1257</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1261">1261</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1262">1262</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1264">1264</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1267">1267</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1270">1270</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1271">1271</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1276">1276</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1277">1277</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1280">1280</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1284">1284</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1285">1285</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1286">1286</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1287">1287</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1288">1288</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1298">1298</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1299">1299</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1303">1303</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1306">1306</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1309">1309</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1312">1312</a>.</li>
</ul></li>
</ul>
</li>
<li>R69: 
2010-02-12 pre-Pittsburgh mailing.
<ul>
<li><b>Summary:</b><ul>
<li>266 open issues, up by 61.</li>
<li>1052 closed issues, down by 3.</li>
<li>1318 issues total, up by 58.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1266">1266</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1268">1268</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1269">1269</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1272">1272</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1275">1275</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1278">1278</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1279">1279</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1281">1281</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1289">1289</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1290">1290</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1291">1291</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1292">1292</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1294">1294</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1295">1295</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1297">1297</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1302">1302</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1305">1305</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1307">1307</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1308">1308</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1310">1310</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1311">1311</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1313">1313</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1314">1314</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1316">1316</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1317">1317</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1318">1318</a>.</li>
<li>Added the following Tentatively NAD issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1263">1263</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1265">1265</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1296">1296</a>.</li>
<li>Added the following Tentatively NAD Editorial issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1283">1283</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1301">1301</a>.</li>
<li>Added the following Tentatively NAD Future issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1282">1282</a>.</li>
<li>Added the following Tentatively Ready issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1261">1261</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1262">1262</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1264">1264</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1267">1267</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1270">1270</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1271">1271</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1273">1273</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1274">1274</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1276">1276</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1277">1277</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1280">1280</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1284">1284</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1285">1285</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1286">1286</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1287">1287</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1288">1288</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1293">1293</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1298">1298</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1299">1299</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1300">1300</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1303">1303</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1304">1304</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1306">1306</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1309">1309</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1312">1312</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1315">1315</a>.</li>
<li>Changed the following issues from NAD to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#101">101</a>.</li>
<li>Changed the following issues from NAD Future to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1248">1248</a>.</li>
<li>Changed the following issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1207">1207</a>.</li>
<li>Changed the following issues from Ready to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1079">1079</a>.</li>
<li>Changed the following issues from New to Tentatively Dup: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1219">1219</a>.</li>
<li>Changed the following issues from New to Tentatively NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1125">1125</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1176">1176</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1202">1202</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1223">1223</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1224">1224</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1246">1246</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1251">1251</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1259">1259</a>.</li>
<li>Changed the following issues from Open to Tentatively NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#726">726</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#959">959</a>.</li>
<li>Changed the following issues from Review to Tentatively NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#631">631</a>.</li>
<li>Changed the following issues from Open to Tentatively NAD Concepts: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#910">910</a>.</li>
<li>Changed the following issues from New to Tentatively NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1258">1258</a>.</li>
<li>Changed the following issues from Open to Tentatively NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#815">815</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1106">1106</a>.</li>
<li>Changed the following issues from Ready to Tentatively NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#816">816</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#889">889</a>.</li>
<li>Changed the following issues from NAD to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#579">579</a>.</li>
<li>Changed the following issues from NAD Editorial to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1195">1195</a>.</li>
<li>Changed the following issues from New to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1131">1131</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1133">1133</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1137">1137</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1170">1170</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1180">1180</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1182">1182</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1193">1193</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1197">1197</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1199">1199</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1205">1205</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1209">1209</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1218">1218</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1221">1221</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1222">1222</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1245">1245</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1250">1250</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1254">1254</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1255">1255</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1256">1256</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1257">1257</a>.</li>
<li>Changed the following issues from Open to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#704">704</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#724">724</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#811">811</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#817">817</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#870">870</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#891">891</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1033">1033</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1034">1034</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1089">1089</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1110">1110</a>.</li>
<li>Changed the following issues from Ready to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#893">893</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#978">978</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1177">1177</a>.</li>
<li>Changed the following issues from Review to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#556">556</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#676">676</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#727">727</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#780">780</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#929">929</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1130">1130</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1247">1247</a>.</li>
<li>Changed the following issues from Pending WP to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#970">970</a>.</li>
</ul></li>
</ul>
</li>
<li>R68: 
2009-11-06 post-Santa Cruz mailing.
<ul>
<li><b>Summary:</b><ul>
<li>205 open issues, down by 77.</li>
<li>1055 closed issues, up by 120.</li>
<li>1260 issues total, up by 43.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following Dup issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1230">1230</a>.</li>
<li>Added the following NAD issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1229">1229</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1236">1236</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1243">1243</a>.</li>
<li>Added the following NAD Editorial issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1232">1232</a>.</li>
<li>Added the following NAD Future issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1235">1235</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1242">1242</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1248">1248</a>.</li>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1218">1218</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1219">1219</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1221">1221</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1222">1222</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1223">1223</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1224">1224</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1225">1225</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1234">1234</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1240">1240</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1244">1244</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1245">1245</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1246">1246</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1249">1249</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1250">1250</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1251">1251</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1252">1252</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1253">1253</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1254">1254</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1255">1255</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1256">1256</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1257">1257</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1258">1258</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1259">1259</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1260">1260</a>.</li>
<li>Added the following Open issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1228">1228</a>.</li>
<li>Added the following Ready issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1227">1227</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1237">1237</a>.</li>
<li>Added the following Review issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1247">1247</a>.</li>
<li>Added the following Tentatively NAD Editorial issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1233">1233</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1239">1239</a>.</li>
<li>Added the following Tentatively NAD Future issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1238">1238</a>.</li>
<li>Added the following Tentatively Ready issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1220">1220</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1226">1226</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1231">1231</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1241">1241</a>.</li>
<li>Changed the following issues from New to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1132">1132</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1148">1148</a>.</li>
<li>Changed the following issues from Open to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#96">96</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#458">458</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#463">463</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#916">916</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#917">917</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#919">919</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#955">955</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#977">977</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1009">1009</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1020">1020</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1035">1035</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1042">1042</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1051">1051</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1064">1064</a>.</li>
<li>Changed the following issues from Review to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#668">668</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#930">930</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1091">1091</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1102">1102</a>.</li>
<li>Changed the following issues from Tentatively NAD to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#588">588</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#617">617</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#971">971</a>.</li>
<li>Changed the following issues from Tentatively NAD Future to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1062">1062</a>.</li>
<li>Changed the following issues from NAD Concepts to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1143">1143</a>.</li>
<li>Changed the following issues from New to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1116">1116</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1117">1117</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1122">1122</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1129">1129</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1145">1145</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1146">1146</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1147">1147</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1155">1155</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1166">1166</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1172">1172</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1174">1174</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1179">1179</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1195">1195</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1196">1196</a>.</li>
<li>Changed the following issues from Open to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#431">431</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#580">580</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#635">635</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#719">719</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#823">823</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#827">827</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#879">879</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#880">880</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#908">908</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#923">923</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#924">924</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#926">926</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#944">944</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#947">947</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#958">958</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1046">1046</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1048">1048</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1054">1054</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1055">1055</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1075">1075</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1088">1088</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1160">1160</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1161">1161</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1162">1162</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1163">1163</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1165">1165</a>.</li>
<li>Changed the following issues from Review to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#828">828</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#897">897</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#976">976</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1043">1043</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1047">1047</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1049">1049</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1050">1050</a>.</li>
<li>Changed the following issues from New to NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1120">1120</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1150">1150</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1184">1184</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1203">1203</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1217">1217</a>.</li>
<li>Changed the following issues from Open to NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#484">484</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#532">532</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#851">851</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#933">933</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#935">935</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#936">936</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#961">961</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1041">1041</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1053">1053</a>.</li>
<li>Changed the following issues from Tentatively NAD Future to NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1031">1031</a>.</li>
<li>Changed the following issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1118">1118</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1119">1119</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1151">1151</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1153">1153</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1156">1156</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1171">1171</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1173">1173</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1183">1183</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1191">1191</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1211">1211</a>.</li>
<li>Changed the following issues from Ready to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#430">430</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#834">834</a>.</li>
<li>Changed the following issues from Review to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#397">397</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#408">408</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#835">835</a>.</li>
<li>Changed the following issues from Tentatively NAD to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#625">625</a>.</li>
<li>Changed the following issues from New to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1123">1123</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1134">1134</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1135">1135</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1136">1136</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1144">1144</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1177">1177</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1194">1194</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1204">1204</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1216">1216</a>.</li>
<li>Changed the following issues from Open to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#296">296</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#471">471</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#485">485</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#539">539</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#816">816</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#860">860</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#865">865</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#872">872</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#920">920</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#932">932</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#939">939</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#940">940</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#960">960</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#963">963</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#974">974</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#978">978</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1011">1011</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1030">1030</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1079">1079</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1098">1098</a>.</li>
<li>Changed the following issues from Review to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#473">473</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#671">671</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#836">836</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#854">854</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#868">868</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#871">871</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#889">889</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#893">893</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#921">921</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#950">950</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#954">954</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#957">957</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#962">962</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#967">967</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#968">968</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#983">983</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1052">1052</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1094">1094</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1095">1095</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1097">1097</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1100">1100</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1104">1104</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1157">1157</a>.</li>
<li>Changed the following issues from New to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1130">1130</a>.</li>
<li>Changed the following issues from Open to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#556">556</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#631">631</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#676">676</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#727">727</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#929">929</a>.</li>
<li>Changed the following issues from Open to Tentatively NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1056">1056</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1099">1099</a>.</li>
<li>Changed the following issues from New to Tentatively NAD Concepts: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1186">1186</a>.</li>
<li>Changed the following issues from New to Tentatively NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1115">1115</a>.</li>
<li>Changed the following issues from New to Tentatively NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1121">1121</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1201">1201</a>.</li>
<li>Changed the following issues from Open to Tentatively NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1112">1112</a>.</li>
<li>Changed the following issues from New to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1126">1126</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1138">1138</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1152">1152</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1158">1158</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1189">1189</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1192">1192</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1208">1208</a>.</li>
<li>Changed the following issues from Open to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#987">987</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#999">999</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1071">1071</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1090">1090</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1108">1108</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1113">1113</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1114">1114</a>.</li>
<li>Changed the following issues from Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#149">149</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#419">419</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#498">498</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#564">564</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#565">565</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#630">630</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#659">659</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#696">696</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#711">711</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#716">716</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#723">723</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#788">788</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#822">822</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#838">838</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#847">847</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#857">857</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#859">859</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#876">876</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#881">881</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#883">883</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#886">886</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#934">934</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1004">1004</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1178">1178</a>.</li>
<li>Changed the following issues from Tentatively Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1012">1012</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1019">1019</a>.</li>
</ul></li>
</ul>
</li>
<li>R67: 
2009-09-25 pre-Santa Cruz mailing.
<ul>
<li><b>Summary:</b><ul>
<li>282 open issues, up by 32.</li>
<li>935 closed issues, down by 1.</li>
<li>1217 issues total, up by 31.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1187">1187</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1188">1188</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1189">1189</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1190">1190</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1191">1191</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1192">1192</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1193">1193</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1194">1194</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1195">1195</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1196">1196</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1197">1197</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1198">1198</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1199">1199</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1200">1200</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1201">1201</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1202">1202</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1203">1203</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1204">1204</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1205">1205</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1206">1206</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1207">1207</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1208">1208</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1209">1209</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1210">1210</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1211">1211</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1212">1212</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1213">1213</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1214">1214</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1215">1215</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1216">1216</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1217">1217</a>.</li>
<li>Changed the following issues from NAD to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#296">296</a>.</li>
<li>Changed the following issues from WP to Pending WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#970">970</a>.</li>
<li>Changed the following issues from Open to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#976">976</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1052">1052</a>.</li>
<li>Changed the following issues from Ready to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#780">780</a>.</li>
</ul></li>
</ul>
</li>
<li>R66: 
2009-07-31 post-Frankfurt mailing.
<ul>
<li><b>Summary:</b><ul>
<li>250 open issues, down by 128.</li>
<li>936 closed issues, up by 171.</li>
<li>1186 issues total, up by 43.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following NAD issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1164">1164</a>.</li>
<li>Added the following NAD Concepts issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1149">1149</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1167">1167</a>.</li>
<li>Added the following NAD Editorial issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1168">1168</a>.</li>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1144">1144</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1145">1145</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1146">1146</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1147">1147</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1148">1148</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1150">1150</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1151">1151</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1152">1152</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1153">1153</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1154">1154</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1155">1155</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1156">1156</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1158">1158</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1159">1159</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1166">1166</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1169">1169</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1170">1170</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1171">1171</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1172">1172</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1173">1173</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1174">1174</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1175">1175</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1176">1176</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1177">1177</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1179">1179</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1180">1180</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1181">1181</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1182">1182</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1183">1183</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1184">1184</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1185">1185</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1186">1186</a>.</li>
<li>Added the following Open issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1160">1160</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1161">1161</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1162">1162</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1163">1163</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1165">1165</a>.</li>
<li>Added the following Ready issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1178">1178</a>.</li>
<li>Added the following Review issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1157">1157</a>.</li>
<li>Changed the following issues from Open to Dup: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#750">750</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#895">895</a>.</li>
<li>Changed the following issues from Open to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#111">111</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#128">128</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#138">138</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#190">190</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#219">219</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#290">290</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#309">309</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#342">342</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#343">343</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#382">382</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#394">394</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#398">398</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#417">417</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#418">418</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#421">421</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#459">459</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#466">466</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#492">492</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#502">502</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#503">503</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#546">546</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#573">573</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#582">582</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#585">585</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#597">597</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#606">606</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#614">614</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#632">632</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#721">721</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#747">747</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#751">751</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#833">833</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#941">941</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#992">992</a>.</li>
<li>Changed the following issues from Review to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1003">1003</a>.</li>
<li>Changed the following issues from Tentatively NAD to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#568">568</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#644">644</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#667">667</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#669">669</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#701">701</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#702">702</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#785">785</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#863">863</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#901">901</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#903">903</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#946">946</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#988">988</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#995">995</a>.</li>
<li>Changed the following issues from Tentatively Ready to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1002">1002</a>.</li>
<li>Changed the following issues from New to NAD Concepts: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1124">1124</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1127">1127</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1128">1128</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1139">1139</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1140">1140</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1141">1141</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1142">1142</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1143">1143</a>.</li>
<li>Changed the following issues from Open to NAD Concepts: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#902">902</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#989">989</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1000">1000</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1007">1007</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1010">1010</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1015">1015</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1016">1016</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1017">1017</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1018">1018</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1026">1026</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1027">1027</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1028">1028</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1029">1029</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1032">1032</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1036">1036</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1057">1057</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1059">1059</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1072">1072</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1078">1078</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1081">1081</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1082">1082</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1083">1083</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1084">1084</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1085">1085</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1086">1086</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1092">1092</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1096">1096</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1105">1105</a>.</li>
<li>Changed the following issues from Review to NAD Concepts: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1001">1001</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1005">1005</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1080">1080</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1087">1087</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1111">1111</a>.</li>
<li>Changed the following issues from Tentatively NAD to NAD Concepts: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#912">912</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#918">918</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1074">1074</a>.</li>
<li>Changed the following issues from Tentatively NAD Editorial to NAD Concepts: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#927">927</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1109">1109</a>.</li>
<li>Changed the following issues from Tentatively Ready to NAD Concepts: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#906">906</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#913">913</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#914">914</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#928">928</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1024">1024</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1063">1063</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1067">1067</a>.</li>
<li>Changed the following issues from Open to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#718">718</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#873">873</a>.</li>
<li>Changed the following issues from Tentatively NAD Editorial to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#424">424</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#825">825</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#830">830</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#837">837</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#862">862</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#867">867</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#884">884</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#945">945</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#952">952</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#969">969</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#972">972</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#973">973</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#979">979</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1023">1023</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1058">1058</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1060">1060</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1061">1061</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1077">1077</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1101">1101</a>.</li>
<li>Changed the following issues from Tentatively Ready to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1013">1013</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1107">1107</a>.</li>
<li>Changed the following issues from Open to NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#255">255</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#423">423</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#523">523</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#708">708</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#760">760</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#839">839</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#877">877</a>.</li>
<li>Changed the following issues from CD1 to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#823">823</a>.</li>
<li>Changed the following issues from NAD Editorial to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#299">299</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#484">484</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#532">532</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#556">556</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#594">594</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#631">631</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#676">676</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#704">704</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#724">724</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#742">742</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#811">811</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#870">870</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#872">872</a>.</li>
<li>Changed the following issues from Review to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#879">879</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#919">919</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#929">929</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#939">939</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#987">987</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1009">1009</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1093">1093</a>.</li>
<li>Changed the following issues from Tentatively NAD to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#458">458</a>.</li>
<li>Changed the following issues from Tentatively NAD Future to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#96">96</a>.</li>
<li>Changed the following issues from Tentatively Ready to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#910">910</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#915">915</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#932">932</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#940">940</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#974">974</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#976">976</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#999">999</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1011">1011</a>.</li>
<li>Changed the following issues from Open to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#149">149</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#419">419</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#430">430</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#498">498</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#564">564</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#565">565</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#630">630</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#659">659</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#696">696</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#711">711</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#716">716</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#723">723</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#788">788</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#834">834</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#838">838</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#847">847</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#857">857</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#859">859</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#876">876</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#881">881</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#883">883</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#886">886</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1004">1004</a>.</li>
<li>Changed the following issues from Review to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#780">780</a>.</li>
<li>Changed the following issues from Tentatively NAD to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#822">822</a>.</li>
<li>Changed the following issues from Tentatively Ready to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#934">934</a>.</li>
<li>Changed the following issues from NAD to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#871">871</a>.</li>
<li>Changed the following issues from Open to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#397">397</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#408">408</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#473">473</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#671">671</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#836">836</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#868">868</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#889">889</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#893">893</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#930">930</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#954">954</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#962">962</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#967">967</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#968">968</a>.</li>
<li>Changed the following issues from Tentatively NAD to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#668">668</a>.</li>
<li>Changed the following issues from Tentatively Ready to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#950">950</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1100">1100</a>.</li>
<li>Changed the following issues from Open to Tentatively NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#588">588</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#617">617</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#625">625</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#971">971</a>.</li>
<li>Changed the following issues from Open to Tentatively NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1031">1031</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1062">1062</a>.</li>
<li>Changed the following issues from Open to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1012">1012</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1019">1019</a>.</li>
<li>Changed the following issues from Tentatively Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#688">688</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#765">765</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#810">810</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#814">814</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#853">853</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#869">869</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#878">878</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#888">888</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#890">890</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#898">898</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#899">899</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#904">904</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#907">907</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#909">909</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#922">922</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#925">925</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#931">931</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#938">938</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#943">943</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#948">948</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#949">949</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#965">965</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#970">970</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#975">975</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#981">981</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#982">982</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#984">984</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#986">986</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#990">990</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#991">991</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#993">993</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#994">994</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#997">997</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#998">998</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1006">1006</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1014">1014</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1021">1021</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1037">1037</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1038">1038</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1039">1039</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1040">1040</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1044">1044</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1045">1045</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1065">1065</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1066">1066</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1070">1070</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1073">1073</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1103">1103</a>.</li>
</ul></li>
</ul>
</li>
<li>R65: 
2009-06-19 pre-Frankfurt mailing.
<ul>
<li><b>Summary:</b><ul>
<li>378 open issues, up by 32.</li>
<li>765 closed issues, up by 0.</li>
<li>1143 issues total, up by 32.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1115">1115</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1116">1116</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1117">1117</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1118">1118</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1119">1119</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1120">1120</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1121">1121</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1122">1122</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1123">1123</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1124">1124</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1125">1125</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1126">1126</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1127">1127</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1128">1128</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1129">1129</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1130">1130</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1131">1131</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1132">1132</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1133">1133</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1134">1134</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1135">1135</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1136">1136</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1137">1137</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1138">1138</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1139">1139</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1140">1140</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1141">1141</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1142">1142</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1143">1143</a>.</li>
<li>Added the following Open issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1112">1112</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1113">1113</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1114">1114</a>.</li>
<li>Changed the following issues from Pending NAD Editorial to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#937">937</a>.</li>
<li>Changed the following issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#696">696</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#716">716</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#727">727</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#865">865</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#900">900</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#911">911</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#916">916</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#917">917</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#920">920</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#933">933</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#935">935</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#941">941</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#947">947</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#951">951</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#953">953</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#954">954</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#955">955</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#956">956</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#977">977</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#978">978</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#985">985</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#989">989</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#996">996</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1033">1033</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1054">1054</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1056">1056</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1057">1057</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1059">1059</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1062">1062</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1068">1068</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1069">1069</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1071">1071</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1072">1072</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1076">1076</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1090">1090</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1092">1092</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1096">1096</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1098">1098</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1099">1099</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1105">1105</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1106">1106</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1108">1108</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1110">1110</a>.</li>
<li>Changed the following issues from Review to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#817">817</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#971">971</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#992">992</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1004">1004</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1010">1010</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1012">1012</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1015">1015</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1019">1019</a>.</li>
<li>Changed the following issues from New to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#780">780</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#835">835</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#897">897</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#919">919</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#939">939</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#957">957</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#983">983</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1001">1001</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1080">1080</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1091">1091</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1093">1093</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1094">1094</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1095">1095</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1097">1097</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1102">1102</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1104">1104</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1111">1111</a>.</li>
<li>Changed the following issues from Open to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#921">921</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#987">987</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1087">1087</a>.</li>
<li>Changed the following issues from New to Tentatively NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#568">568</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#701">701</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#702">702</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#785">785</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#863">863</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#903">903</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#912">912</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#918">918</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#946">946</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#995">995</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1074">1074</a>.</li>
<li>Changed the following issues from Open to Tentatively NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#458">458</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#644">644</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#667">667</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#668">668</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#669">669</a>.</li>
<li>Changed the following issues from Review to Tentatively NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#901">901</a>.</li>
<li>Changed the following issues from Tentatively Ready to Tentatively NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#822">822</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#988">988</a>.</li>
<li>Changed the following issues from New to Tentatively NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#837">837</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#862">862</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#867">867</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#927">927</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#945">945</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#952">952</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#969">969</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#972">972</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#973">973</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#979">979</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1058">1058</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1060">1060</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1061">1061</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1077">1077</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1101">1101</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1109">1109</a>.</li>
<li>Changed the following issues from Open to Tentatively NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#424">424</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#825">825</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#830">830</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#884">884</a>.</li>
<li>Changed the following issues from Review to Tentatively NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1023">1023</a>.</li>
<li>Changed the following issues from Open to Tentatively NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#96">96</a>.</li>
<li>Changed the following issues from New to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#810">810</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#898">898</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#906">906</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#910">910</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#913">913</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#914">914</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#915">915</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#925">925</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#974">974</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#976">976</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#981">981</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#982">982</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#984">984</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#990">990</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#998">998</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#999">999</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1063">1063</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1067">1067</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1070">1070</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1073">1073</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1100">1100</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1103">1103</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1107">1107</a>.</li>
<li>Changed the following issues from Open to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#688">688</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#814">814</a>.</li>
<li>Changed the following issues from Review to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#899">899</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#907">907</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#909">909</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#934">934</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#938">938</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#940">940</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#943">943</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#950">950</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#965">965</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#970">970</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#975">975</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#986">986</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#991">991</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#993">993</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#994">994</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#997">997</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1002">1002</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1006">1006</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1011">1011</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1013">1013</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1014">1014</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1021">1021</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1024">1024</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1037">1037</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1038">1038</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1039">1039</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1040">1040</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1044">1044</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1045">1045</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1065">1065</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1066">1066</a>.</li>
</ul></li>
</ul>
</li>
<li>R64: 
2009-05-01 mid-term mailing.
<ul>
<li><b>Summary:</b><ul>
<li>346 open issues, up by 19.</li>
<li>765 closed issues, up by 0.</li>
<li>1111 issues total, up by 19.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1093">1093</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1094">1094</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1095">1095</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1096">1096</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1097">1097</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1098">1098</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1099">1099</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1100">1100</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1101">1101</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1102">1102</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1103">1103</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1104">1104</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1105">1105</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1106">1106</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1107">1107</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1108">1108</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1109">1109</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1110">1110</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1111">1111</a>.</li>
<li>Changed the following issues from DR to CD1: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#130">130</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#386">386</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#406">406</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#409">409</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#413">413</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#434">434</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#438">438</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#444">444</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#445">445</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#455">455</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#457">457</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#460">460</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#469">469</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#533">533</a>.</li>
<li>Changed the following issues from Review to New: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1070">1070</a>.</li>
</ul></li>
</ul>
</li>
<li>R63: 
2009-03-20 post-Summit mailing.
<ul>
<li><b>Summary:</b><ul>
<li>327 open issues, up by 96.</li>
<li>765 closed issues, up by 14.</li>
<li>1092 issues total, up by 110.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following NAD Editorial issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1022">1022</a>.</li>
<li>Added the following NAD Future issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1025">1025</a>.</li>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#983">983</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#984">984</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#985">985</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#989">989</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#990">990</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#995">995</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#996">996</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#998">998</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#999">999</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1001">1001</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1033">1033</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1054">1054</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1056">1056</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1057">1057</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1058">1058</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1059">1059</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1060">1060</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1061">1061</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1062">1062</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1063">1063</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1067">1067</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1068">1068</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1069">1069</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1071">1071</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1072">1072</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1073">1073</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1074">1074</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1076">1076</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1077">1077</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1080">1080</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1090">1090</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1091">1091</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1092">1092</a>.</li>
<li>Added the following Open issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#987">987</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1000">1000</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1007">1007</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1008">1008</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1016">1016</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1017">1017</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1018">1018</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1020">1020</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1026">1026</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1027">1027</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1028">1028</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1029">1029</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1030">1030</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1031">1031</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1032">1032</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1034">1034</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1035">1035</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1036">1036</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1041">1041</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1042">1042</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1046">1046</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1048">1048</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1051">1051</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1052">1052</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1053">1053</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1055">1055</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1064">1064</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1075">1075</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1078">1078</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1079">1079</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1081">1081</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1082">1082</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1083">1083</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1084">1084</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1085">1085</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1086">1086</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1087">1087</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1088">1088</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1089">1089</a>.</li>
<li>Added the following Review issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#986">986</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#991">991</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#992">992</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#993">993</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#994">994</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#997">997</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1002">1002</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1003">1003</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1004">1004</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1005">1005</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1006">1006</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1009">1009</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1010">1010</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1011">1011</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1012">1012</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1013">1013</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1014">1014</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1015">1015</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1019">1019</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1021">1021</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1023">1023</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1024">1024</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1037">1037</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1038">1038</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1039">1039</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1040">1040</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1043">1043</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1044">1044</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1045">1045</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1047">1047</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1049">1049</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1050">1050</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1065">1065</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1066">1066</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1070">1070</a>.</li>
<li>Added the following Tentatively Ready issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#988">988</a>.</li>
<li>Changed the following issues from New to Dup: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#905">905</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#942">942</a>.</li>
<li>Changed the following issues from New to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#980">980</a>.</li>
<li>Changed the following issues from New to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#874">874</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#875">875</a>.</li>
<li>Changed the following issues from Open to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#732">732</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#793">793</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#794">794</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#800">800</a>.</li>
<li>Changed the following issues from Pending NAD Editorial to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#683">683</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#892">892</a>.</li>
<li>Changed the following issues from Ready to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#803">803</a>.</li>
<li>Changed the following issues from NAD to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#466">466</a>.</li>
<li>Changed the following issues from NAD Future to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#111">111</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#138">138</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#149">149</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#219">219</a>.</li>
<li>Changed the following issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#880">880</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#891">891</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#893">893</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#902">902</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#908">908</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#921">921</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#923">923</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#924">924</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#926">926</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#930">930</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#936">936</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#944">944</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#958">958</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#959">959</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#960">960</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#961">961</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#962">962</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#963">963</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#964">964</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#966">966</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#967">967</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#968">968</a>.</li>
<li>Changed the following issues from Ready to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#788">788</a>.</li>
<li>Changed the following issues from New to Pending NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#937">937</a>.</li>
<li>Changed the following issues from New to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#879">879</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#899">899</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#901">901</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#907">907</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#909">909</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#929">929</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#934">934</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#938">938</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#940">940</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#943">943</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#950">950</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#965">965</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#970">970</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#971">971</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#975">975</a>.</li>
<li>Changed the following issues from Open to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#817">817</a>.</li>
<li>Changed the following issues from New to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#904">904</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#922">922</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#928">928</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#931">931</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#932">932</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#948">948</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#949">949</a>.</li>
<li>Changed the following issues from Open to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#890">890</a>.</li>
<li>Changed the following issues from Review to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#765">765</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#822">822</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#853">853</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#869">869</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#878">878</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#888">888</a>.</li>
<li>Changed the following issues from Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#752">752</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#753">753</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#758">758</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#821">821</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#866">866</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#894">894</a>.</li>
</ul></li>
</ul>
</li>
<li>R62: 
2009-02-06 pre-Summit mailing.
<ul>
<li><b>Summary:</b><ul>
<li>231 open issues, up by 44.</li>
<li>751 closed issues, up by 0.</li>
<li>982 issues total, up by 44.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#939">939</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#940">940</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#941">941</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#942">942</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#943">943</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#944">944</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#945">945</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#946">946</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#947">947</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#948">948</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#949">949</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#950">950</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#951">951</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#952">952</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#953">953</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#954">954</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#955">955</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#956">956</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#957">957</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#958">958</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#959">959</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#960">960</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#961">961</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#962">962</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#963">963</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#964">964</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#965">965</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#966">966</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#967">967</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#968">968</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#969">969</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#970">970</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#971">971</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#972">972</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#973">973</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#974">974</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#975">975</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#976">976</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#977">977</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#978">978</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#979">979</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#980">980</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#981">981</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#982">982</a>.</li>
</ul></li>
</ul>
</li>
<li>R61: 
2008-12-05 mid-term mailing.
<ul>
<li><b>Summary:</b><ul>
<li>187 open issues, up by 20.</li>
<li>751 closed issues, up by 0.</li>
<li>938 issues total, up by 20.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#919">919</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#920">920</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#921">921</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#922">922</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#923">923</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#924">924</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#925">925</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#926">926</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#927">927</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#928">928</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#929">929</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#930">930</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#931">931</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#932">932</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#933">933</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#934">934</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#935">935</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#936">936</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#937">937</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#938">938</a>.</li>
</ul></li>
</ul>
</li>
<li>R60: 
2008-10-03 post-San Francisco mailing.
<ul>
<li><b>Summary:</b><ul>
<li>167 open issues, down by 25.</li>
<li>751 closed issues, up by 65.</li>
<li>918 issues total, up by 40.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following CD1 issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#882">882</a>.</li>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#879">879</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#880">880</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#891">891</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#893">893</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#897">897</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#898">898</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#899">899</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#900">900</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#901">901</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#902">902</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#903">903</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#904">904</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#905">905</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#906">906</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#907">907</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#908">908</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#909">909</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#910">910</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#911">911</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#912">912</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#913">913</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#914">914</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#915">915</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#916">916</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#917">917</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#918">918</a>.</li>
<li>Added the following Open issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#881">881</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#883">883</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#884">884</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#885">885</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#886">886</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#887">887</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#889">889</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#890">890</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#895">895</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#896">896</a>.</li>
<li>Added the following Pending NAD Editorial issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#892">892</a>.</li>
<li>Added the following Ready issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#894">894</a>.</li>
<li>Added the following Review issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#888">888</a>.</li>
<li>Changed the following issues from New to CD1: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#818">818</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#820">820</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#843">843</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#845">845</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#846">846</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#856">856</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#858">858</a>.</li>
<li>Changed the following issues from Ready to CD1: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#180">180</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#387">387</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#396">396</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#522">522</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#629">629</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#691">691</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#713">713</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#714">714</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#720">720</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#728">728</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#762">762</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#769">769</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#771">771</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#772">772</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#776">776</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#779">779</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#787">787</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#805">805</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#806">806</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#807">807</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#808">808</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#809">809</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#813">813</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#824">824</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#829">829</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#842">842</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#844">844</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#848">848</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#850">850</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#852">852</a>.</li>
<li>Changed the following issues from Review to CD1: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#23">23</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#675">675</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#692">692</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#698">698</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#709">709</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#734">734</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#804">804</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#823">823</a>.</li>
<li>Changed the following issues from WP to CD1: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#44">44</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#49">49</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#76">76</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#91">91</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#92">92</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#98">98</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#103">103</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#109">109</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#117">117</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#118">118</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#120">120</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#123">123</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#136">136</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#153">153</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#165">165</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#167">167</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#171">171</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#179">179</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#182">182</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#183">183</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#184">184</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#185">185</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#186">186</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#187">187</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#198">198</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#200">200</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#201">201</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#202">202</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#206">206</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#214">214</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#221">221</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#225">225</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#226">226</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#228">228</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#229">229</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#230">230</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#231">231</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#232">232</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#233">233</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#234">234</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#235">235</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#237">237</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#238">238</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#239">239</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#240">240</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#241">241</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#242">242</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#243">243</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#247">247</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#248">248</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#250">250</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#251">251</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#252">252</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#253">253</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#254">254</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#256">256</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#258">258</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#259">259</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#260">260</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#261">261</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#262">262</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#263">263</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#264">264</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#265">265</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#266">266</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#268">268</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#270">270</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#271">271</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#272">272</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#273">273</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#274">274</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#275">275</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#276">276</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#278">278</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#280">280</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#281">281</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#282">282</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#283">283</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#284">284</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#285">285</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#286">286</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#288">288</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#291">291</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#292">292</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#294">294</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#295">295</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#297">297</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#298">298</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#300">300</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#301">301</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#303">303</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#305">305</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#306">306</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#307">307</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#308">308</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#310">310</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#311">311</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#312">312</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#315">315</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#316">316</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#317">317</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#318">318</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#319">319</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#320">320</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#321">321</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#322">322</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#324">324</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#325">325</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#327">327</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#328">328</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#329">329</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#331">331</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#333">333</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#334">334</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#335">335</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#336">336</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#337">337</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#338">338</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#339">339</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#340">340</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#341">341</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#345">345</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#346">346</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#347">347</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#349">349</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#352">352</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#354">354</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#355">355</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#358">358</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#359">359</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#360">360</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#362">362</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#363">363</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#364">364</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#365">365</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#369">369</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#370">370</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#371">371</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#373">373</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#375">375</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#376">376</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#379">379</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#380">380</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#381">381</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#383">383</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#384">384</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#389">389</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#391">391</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#395">395</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#400">400</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#401">401</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#402">402</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#403">403</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#404">404</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#405">405</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#407">407</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#410">410</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#411">411</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#412">412</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#414">414</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#415">415</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#416">416</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#420">420</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#422">422</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#425">425</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#426">426</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#428">428</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#432">432</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#435">435</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#436">436</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#441">441</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#442">442</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#443">443</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#448">448</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#449">449</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#453">453</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#456">456</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#461">461</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#464">464</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#465">465</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#467">467</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#468">468</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#474">474</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#475">475</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#478">478</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#488">488</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#495">495</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#496">496</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#497">497</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#505">505</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#507">507</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#508">508</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#518">518</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#519">519</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#520">520</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#521">521</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#524">524</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#527">527</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#530">530</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#531">531</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#534">534</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#535">535</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#537">537</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#538">538</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#540">540</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#541">541</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#542">542</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#543">543</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#545">545</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#550">550</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#551">551</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#552">552</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#559">559</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#561">561</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#562">562</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#563">563</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#566">566</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#567">567</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#574">574</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#575">575</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#576">576</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#577">577</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#578">578</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#581">581</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#586">586</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#589">589</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#593">593</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#595">595</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#596">596</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#607">607</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#608">608</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#609">609</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#610">610</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#611">611</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#612">612</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#613">613</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#616">616</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#618">618</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#619">619</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#620">620</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#621">621</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#622">622</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#623">623</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#624">624</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#628">628</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#634">634</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#638">638</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#640">640</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#643">643</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#646">646</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#650">650</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#651">651</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#652">652</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#654">654</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#655">655</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#660">660</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#661">661</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#664">664</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#665">665</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#666">666</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#672">672</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#673">673</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#674">674</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#677">677</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#678">678</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#679">679</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#680">680</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#681">681</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#682">682</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#685">685</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#687">687</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#689">689</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#693">693</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#694">694</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#695">695</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#699">699</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#700">700</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#703">703</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#705">705</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#706">706</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#710">710</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#712">712</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#715">715</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#722">722</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#740">740</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#743">743</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#744">744</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#746">746</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#749">749</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#755">755</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#759">759</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#761">761</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#766">766</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#768">768</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#770">770</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#775">775</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#777">777</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#778">778</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#781">781</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#782">782</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#783">783</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#789">789</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#792">792</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#798">798</a>.</li>
<li>Changed the following issues from Open to Dup: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#670">670</a>.</li>
<li>Changed the following issues from New to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#849">849</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#855">855</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#871">871</a>.</li>
<li>Changed the following issues from Open to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#454">454</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#832">832</a>.</li>
<li>Changed the following issues from New to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#811">811</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#812">812</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#841">841</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#864">864</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#870">870</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#872">872</a>.</li>
<li>Changed the following issues from Open to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#299">299</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#484">484</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#556">556</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#631">631</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#676">676</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#704">704</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#724">724</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#742">742</a>.</li>
<li>Changed the following issues from Pending NAD Editorial to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#532">532</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#594">594</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#717">717</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#725">725</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#738">738</a>.</li>
<li>Changed the following issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#721">721</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#751">751</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#814">814</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#816">816</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#817">817</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#819">819</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#827">827</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#836">836</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#838">838</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#847">847</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#857">857</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#859">859</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#860">860</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#861">861</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#868">868</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#873">873</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#876">876</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#877">877</a>.</li>
<li>Changed the following issues from Pending NAD Editorial to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#424">424</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#625">625</a>.</li>
<li>Changed the following issues from Review to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#851">851</a>.</li>
<li>Changed the following issues from New to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#788">788</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#821">821</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#866">866</a>.</li>
<li>Changed the following issues from Open to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#753">753</a>.</li>
<li>Changed the following issues from Review to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#752">752</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#758">758</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#803">803</a>.</li>
<li>Changed the following issues from New to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#765">765</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#822">822</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#853">853</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#854">854</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#869">869</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#878">878</a>.</li>
<li>Changed the following issues from TC to TC1: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1">1</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#3">3</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#5">5</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#7">7</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#8">8</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#9">9</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#11">11</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#13">13</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#14">14</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#15">15</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#16">16</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#17">17</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#18">18</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#19">19</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#20">20</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#21">21</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#22">22</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#24">24</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#25">25</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#26">26</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#27">27</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#28">28</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#29">29</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#30">30</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#31">31</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#32">32</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#33">33</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#34">34</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#35">35</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#36">36</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#37">37</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#38">38</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#39">39</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#40">40</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#41">41</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#42">42</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#46">46</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#47">47</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#48">48</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#50">50</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#51">51</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#52">52</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#53">53</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#54">54</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#55">55</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#56">56</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#57">57</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#59">59</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#60">60</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#61">61</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#62">62</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#63">63</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#64">64</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#66">66</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#68">68</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#69">69</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#70">70</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#71">71</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#74">74</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#75">75</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#78">78</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#79">79</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#80">80</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#83">83</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#86">86</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#90">90</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#106">106</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#108">108</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#110">110</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#112">112</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#114">114</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#115">115</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#119">119</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#122">122</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#124">124</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#125">125</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#126">126</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#127">127</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#129">129</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#132">132</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#133">133</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#134">134</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#137">137</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#139">139</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#141">141</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#142">142</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#144">144</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#146">146</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#147">147</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#148">148</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#150">150</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#151">151</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#152">152</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#154">154</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#155">155</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#156">156</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#158">158</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#159">159</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#160">160</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#161">161</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#164">164</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#168">168</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#169">169</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#170">170</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#172">172</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#173">173</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#174">174</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#175">175</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#176">176</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#181">181</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#189">189</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#193">193</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#195">195</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#199">199</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#208">208</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#209">209</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#210">210</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#211">211</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#212">212</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#217">217</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#220">220</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#222">222</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#223">223</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#224">224</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#227">227</a>.</li>
</ul></li>
</ul>
</li>
<li>R59: 
2008-08-22 pre-San Francisco mailing.
<ul>
<li><b>Summary:</b><ul>
<li>192 open issues, up by 9.</li>
<li>686 closed issues, up by 0.</li>
<li>878 issues total, up by 9.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#870">870</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#871">871</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#872">872</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#873">873</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#874">874</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#875">875</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#876">876</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#877">877</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#878">878</a>.</li>
</ul></li>
</ul>
</li>
<li>R58: 
2008-07-28 mid-term mailing.
<ul>
<li><b>Summary:</b><ul>
<li>183 open issues, up by 12.</li>
<li>686 closed issues, down by 4.</li>
<li>869 issues total, up by 8.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#862">862</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#863">863</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#864">864</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#865">865</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#866">866</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#867">867</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#868">868</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#869">869</a>.</li>
<li>Changed the following issues from Pending NAD Editorial to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#393">393</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#557">557</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#592">592</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#754">754</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#757">757</a>.</li>
<li>Changed the following issues from Pending WP to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#644">644</a>.</li>
<li>Changed the following issues from WP to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#387">387</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#629">629</a>.</li>
<li>Changed the following issues from Pending NAD Editorial to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#709">709</a>.</li>
</ul></li>
</ul>
</li>
<li>R57: 
2008-06-27 post-Sophia Antipolis mailing.
<ul>
<li><b>Summary:</b><ul>
<li>171 open issues, down by 20.</li>
<li>690 closed issues, up by 43.</li>
<li>861 issues total, up by 23.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following NAD issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#840">840</a>.</li>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#841">841</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#843">843</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#845">845</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#846">846</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#847">847</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#849">849</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#853">853</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#854">854</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#855">855</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#856">856</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#857">857</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#858">858</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#859">859</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#860">860</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#861">861</a>.</li>
<li>Added the following Open issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#839">839</a>.</li>
<li>Added the following Ready issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#842">842</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#844">844</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#848">848</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#850">850</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#852">852</a>.</li>
<li>Added the following Review issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#851">851</a>.</li>
<li>Changed the following issues from New to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#826">826</a>.</li>
<li>Changed the following issues from Open to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#570">570</a>.</li>
<li>Changed the following issues from New to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#786">786</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#831">831</a>.</li>
<li>Changed the following issues from Open to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#756">756</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#767">767</a>.</li>
<li>Changed the following issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#723">723</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#726">726</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#794">794</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#815">815</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#825">825</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#830">830</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#833">833</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#834">834</a>.</li>
<li>Changed the following issues from Ready to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#471">471</a>.</li>
<li>Changed the following issues from Review to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#539">539</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#711">711</a>.</li>
<li>Changed the following issues from New to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#713">713</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#714">714</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#769">769</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#772">772</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#779">779</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#787">787</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#805">805</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#806">806</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#807">807</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#808">808</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#809">809</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#813">813</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#824">824</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#829">829</a>.</li>
<li>Changed the following issues from Open to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#180">180</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#396">396</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#522">522</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#720">720</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#762">762</a>.</li>
<li>Changed the following issues from Review to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#691">691</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#728">728</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#771">771</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#776">776</a>.</li>
<li>Changed the following issues from New to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#692">692</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#698">698</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#752">752</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#804">804</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#823">823</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#828">828</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#832">832</a>.</li>
<li>Changed the following issues from Open to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#23">23</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#675">675</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#734">734</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#803">803</a>.</li>
<li>Changed the following issues from Ready to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#758">758</a>.</li>
<li>Changed the following issues from Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#387">387</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#518">518</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#550">550</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#574">574</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#595">595</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#596">596</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#612">612</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#618">618</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#629">629</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#638">638</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#672">672</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#673">673</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#685">685</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#710">710</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#715">715</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#722">722</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#740">740</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#743">743</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#744">744</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#746">746</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#749">749</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#755">755</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#759">759</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#761">761</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#766">766</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#768">768</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#770">770</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#775">775</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#777">777</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#778">778</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#781">781</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#782">782</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#783">783</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#789">789</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#792">792</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#798">798</a>.</li>
</ul></li>
</ul>
</li>
<li>R56: 
2008-05-16 pre-Sophia Antipolis mailing.
<ul>
<li><b>Summary:</b><ul>
<li>191 open issues, up by 24.</li>
<li>647 closed issues, up by 1.</li>
<li>838 issues total, up by 25.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#814">814</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#815">815</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#816">816</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#817">817</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#818">818</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#819">819</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#820">820</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#821">821</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#822">822</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#823">823</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#824">824</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#825">825</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#826">826</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#827">827</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#828">828</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#829">829</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#830">830</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#831">831</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#832">832</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#833">833</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#834">834</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#835">835</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#836">836</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#837">837</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#838">838</a>.</li>
<li>Changed the following issues from New to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#802">802</a>.</li>
</ul></li>
</ul>
</li>
<li>R55: 
2008-03-14 post-Bellevue mailing.
<ul>
<li><b>Summary:</b><ul>
<li>167 open issues, down by 39.</li>
<li>646 closed issues, up by 65.</li>
<li>813 issues total, up by 26.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following Dup issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#795">795</a>.</li>
<li>Added the following NAD issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#790">790</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#791">791</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#796">796</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#797">797</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#799">799</a>.</li>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#788">788</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#794">794</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#802">802</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#804">804</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#805">805</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#806">806</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#807">807</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#808">808</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#809">809</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#810">810</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#811">811</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#812">812</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#813">813</a>.</li>
<li>Added the following Open issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#793">793</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#800">800</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#801">801</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#803">803</a>.</li>
<li>Added the following Ready issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#789">789</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#792">792</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#798">798</a>.</li>
<li>Changed the following issues from NAD Future to Dup: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#116">116</a>.</li>
<li>Changed the following issues from NAD Future to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#188">188</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#323">323</a>.</li>
<li>Changed the following issues from New to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#729">729</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#730">730</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#731">731</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#733">733</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#735">735</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#736">736</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#737">737</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#739">739</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#741">741</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#745">745</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#748">748</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#763">763</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#764">764</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#773">773</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#784">784</a>.</li>
<li>Changed the following issues from Open to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#388">388</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#462">462</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#579">579</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#627">627</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#653">653</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#686">686</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#707">707</a>.</li>
<li>Changed the following issues from NAD Future to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#140">140</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#390">390</a>.</li>
<li>Changed the following issues from Open to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#529">529</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#626">626</a>.</li>
<li>Changed the following issues from Review to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#645">645</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#684">684</a>.</li>
<li>Changed the following issues from NAD Future to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#128">128</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#180">180</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#190">190</a>.</li>
<li>Changed the following issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#617">617</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#718">718</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#719">719</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#720">720</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#724">724</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#732">732</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#734">734</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#742">742</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#747">747</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#750">750</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#753">753</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#756">756</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#760">760</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#762">762</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#767">767</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#774">774</a>.</li>
<li>Changed the following issues from Ready to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#675">675</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#676">676</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#688">688</a>.</li>
<li>Changed the following issues from New to Pending NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#709">709</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#717">717</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#725">725</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#738">738</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#754">754</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#757">757</a>.</li>
<li>Changed the following issues from Open to Pending NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#424">424</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#557">557</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#625">625</a>.</li>
<li>Changed the following issues from New to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#710">710</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#715">715</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#722">722</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#740">740</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#743">743</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#744">744</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#746">746</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#749">749</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#755">755</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#758">758</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#759">759</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#761">761</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#766">766</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#768">768</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#770">770</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#775">775</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#777">777</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#778">778</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#781">781</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#782">782</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#783">783</a>.</li>
<li>Changed the following issues from Open to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#387">387</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#471">471</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#550">550</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#612">612</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#629">629</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#673">673</a>.</li>
<li>Changed the following issues from Review to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#518">518</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#574">574</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#596">596</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#618">618</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#638">638</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#672">672</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#685">685</a>.</li>
<li>Changed the following issues from New to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#711">711</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#728">728</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#771">771</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#776">776</a>.</li>
<li>Changed the following issues from Open to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#539">539</a>.</li>
<li>Changed the following issues from Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#561">561</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#562">562</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#563">563</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#567">567</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#581">581</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#620">620</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#621">621</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#622">622</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#623">623</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#624">624</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#661">661</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#664">664</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#665">665</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#666">666</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#674">674</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#679">679</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#680">680</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#687">687</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#689">689</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#693">693</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#694">694</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#695">695</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#700">700</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#703">703</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#705">705</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#706">706</a>.</li>
<li>Changed the following issues from Tentatively Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#527">527</a>.</li>
</ul></li>
</ul>
</li>
<li>R54: 
2008-02-01 pre-Bellevue mailing.
<ul>
<li><b>Summary:</b><ul>
<li>206 open issues, up by 23.</li>
<li>581 closed issues, up by 0.</li>
<li>787 issues total, up by 23.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#765">765</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#766">766</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#767">767</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#768">768</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#769">769</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#770">770</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#771">771</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#772">772</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#773">773</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#774">774</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#775">775</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#776">776</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#777">777</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#778">778</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#779">779</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#780">780</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#781">781</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#782">782</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#783">783</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#784">784</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#785">785</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#786">786</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#787">787</a>.</li>
<li>Changed the following issues from NAD Future to Dup: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#105">105</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#348">348</a>.</li>
<li>Changed the following issues from NAD Future to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#353">353</a>.</li>
<li>Changed the following issues from New to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#697">697</a>.</li>
<li>Changed the following issues from NAD Future to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#388">388</a>.</li>
<li>Changed the following issues from Open to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#527">527</a>.</li>
</ul></li>
</ul>
</li>
<li>R53: 
2007-12-09 mid-term mailing.
<ul>
<li><b>Summary:</b><ul>
<li>183 open issues, up by 11.</li>
<li>581 closed issues, down by 1.</li>
<li>764 issues total, up by 10.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#755">755</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#756">756</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#757">757</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#758">758</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#759">759</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#760">760</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#761">761</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#762">762</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#763">763</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#764">764</a>.</li>
<li>Changed the following issues from NAD to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#463">463</a>.</li>
<li>Changed the following issues from Pending WP to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#607">607</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#608">608</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#654">654</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#655">655</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#677">677</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#682">682</a>.</li>
</ul></li>
</ul>
</li>
<li>R52: 
2007-10-19 post-Kona mailing.
<ul>
<li><b>Summary:</b><ul>
<li>172 open issues, up by 4.</li>
<li>582 closed issues, up by 27.</li>
<li>754 issues total, up by 31.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#724">724</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#725">725</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#726">726</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#727">727</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#728">728</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#729">729</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#730">730</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#731">731</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#732">732</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#733">733</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#734">734</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#735">735</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#736">736</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#737">737</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#738">738</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#739">739</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#740">740</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#741">741</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#742">742</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#743">743</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#744">744</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#745">745</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#746">746</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#747">747</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#748">748</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#749">749</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#750">750</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#751">751</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#752">752</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#753">753</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#754">754</a>.</li>
<li>Changed the following issues from NAD Future to Dup: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#77">77</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#350">350</a>.</li>
<li>Changed the following issues from New to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#639">639</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#657">657</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#663">663</a>.</li>
<li>Changed the following issues from Open to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#548">548</a>.</li>
<li>Changed the following issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#546">546</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#550">550</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#564">564</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#565">565</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#573">573</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#585">585</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#588">588</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#627">627</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#629">629</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#630">630</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#632">632</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#635">635</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#653">653</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#659">659</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#667">667</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#668">668</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#669">669</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#670">670</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#671">671</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#673">673</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#686">686</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#704">704</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#707">707</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#708">708</a>.</li>
<li>Changed the following issues from New to Pending NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#393">393</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#592">592</a>.</li>
<li>Changed the following issues from New to Pending WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#607">607</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#608">608</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#654">654</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#655">655</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#677">677</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#682">682</a>.</li>
<li>Changed the following issues from New to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#561">561</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#562">562</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#563">563</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#567">567</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#581">581</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#595">595</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#620">620</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#621">621</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#622">622</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#623">623</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#624">624</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#661">661</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#664">664</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#665">665</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#666">666</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#674">674</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#675">675</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#676">676</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#679">679</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#687">687</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#688">688</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#689">689</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#693">693</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#694">694</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#695">695</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#700">700</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#703">703</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#705">705</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#706">706</a>.</li>
<li>Changed the following issues from Open to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#680">680</a>.</li>
<li>Changed the following issues from New to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#574">574</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#596">596</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#618">618</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#638">638</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#645">645</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#672">672</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#684">684</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#685">685</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#691">691</a>.</li>
<li>Changed the following issues from New to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#552">552</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#634">634</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#650">650</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#651">651</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#652">652</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#678">678</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#681">681</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#699">699</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#712">712</a>.</li>
<li>Changed the following issues from Open to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#258">258</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#401">401</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#524">524</a>.</li>
<li>Changed the following issues from Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#488">488</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#577">577</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#660">660</a>.</li>
</ul></li>
</ul>
</li>
<li>R51: 
2007-09-09 pre-Kona mailing.
<ul>
<li><b>Summary:</b><ul>
<li>168 open issues, up by 15.</li>
<li>555 closed issues, up by 0.</li>
<li>723 issues total, up by 15.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#709">709</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#710">710</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#711">711</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#712">712</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#713">713</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#714">714</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#715">715</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#716">716</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#717">717</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#718">718</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#719">719</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#720">720</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#721">721</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#722">722</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#723">723</a>.</li>
</ul></li>
</ul>
</li>
<li>R50: 
2007-08-05 post-Toronto mailing.
<ul>
<li><b>Summary:</b><ul>
<li>153 open issues, down by 5.</li>
<li>555 closed issues, up by 17.</li>
<li>708 issues total, up by 12.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#697">697</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#698">698</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#699">699</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#700">700</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#701">701</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#702">702</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#703">703</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#704">704</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#705">705</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#706">706</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#707">707</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#708">708</a>.</li>
<li>Changed the following issues from New to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#583">583</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#584">584</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#662">662</a>.</li>
<li>Changed the following issues from Open to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#528">528</a>.</li>
<li>Changed the following issues from New to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#637">637</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#647">647</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#658">658</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#690">690</a>.</li>
<li>Changed the following issues from Open to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#525">525</a>.</li>
<li>Changed the following issues from Pending NAD Editorial to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#553">553</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#571">571</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#591">591</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#633">633</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#636">636</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#641">641</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#642">642</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#648">648</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#649">649</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#656">656</a>.</li>
<li>Changed the following issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#579">579</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#631">631</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#680">680</a>.</li>
<li>Changed the following issues from Pending WP to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#258">258</a>.</li>
<li>Changed the following issues from Ready to Pending WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#644">644</a>.</li>
<li>Changed the following issues from New to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#577">577</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#660">660</a>.</li>
<li>Changed the following issues from Open to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#488">488</a>.</li>
<li>Changed the following issues from Open to Review: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#518">518</a>.</li>
<li>Changed the following issues from Ready to TRDec: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#604">604</a>.</li>
<li>Changed the following issues from DR to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#453">453</a>.</li>
<li>Changed the following issues from Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#531">531</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#551">551</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#566">566</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#628">628</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#640">640</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#643">643</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#646">646</a>.</li>
</ul></li>
</ul>
</li>
<li>R49: 
2007-06-23 pre-Toronto mailing.
<ul>
<li><b>Summary:</b><ul>
<li>158 open issues, up by 13.</li>
<li>538 closed issues, up by 7.</li>
<li>696 issues total, up by 20.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#677">677</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#678">678</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#679">679</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#680">680</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#681">681</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#682">682</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#684">684</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#685">685</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#686">686</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#687">687</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#688">688</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#689">689</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#690">690</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#691">691</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#692">692</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#693">693</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#694">694</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#695">695</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#696">696</a>.</li>
<li>Added the following Pending NAD Editorial issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#683">683</a>.</li>
<li>Changed the following issues from New to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#587">587</a>.</li>
<li>Changed the following issues from Open to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#590">590</a>.</li>
<li>Changed the following issues from New to Pending NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#636">636</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#642">642</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#648">648</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#649">649</a>.</li>
</ul></li>
</ul>
</li>
<li>R48: 
2007-05-06 post-Oxford mailing.
<ul>
<li><b>Summary:</b><ul>
<li>145 open issues, down by 33.</li>
<li>531 closed issues, up by 53.</li>
<li>676 issues total, up by 20.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#657">657</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#658">658</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#659">659</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#660">660</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#661">661</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#662">662</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#663">663</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#664">664</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#665">665</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#666">666</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#667">667</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#668">668</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#669">669</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#670">670</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#671">671</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#672">672</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#673">673</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#674">674</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#675">675</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#676">676</a>.</li>
<li>Changed the following issues from Tentatively Ready to Dup: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#479">479</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#536">536</a>.</li>
<li>Changed the following issues from Tentatively Ready to NAD: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#385">385</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#463">463</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#466">466</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#470">470</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#515">515</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#526">526</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#547">547</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#560">560</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#572">572</a>.</li>
<li>Changed the following issues from NAD to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#351">351</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#357">357</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#368">368</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#499">499</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#504">504</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#512">512</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#513">513</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#514">514</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#516">516</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#544">544</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#549">549</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#555">555</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#558">558</a>.</li>
<li>Changed the following issues from Tentatively Ready to NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#482">482</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#615">615</a>.</li>
<li>Changed the following issues from NAD_Future to NAD Future: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#77">77</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#105">105</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#111">111</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#116">116</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#128">128</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#138">138</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#140">140</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#149">149</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#180">180</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#188">188</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#190">190</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#219">219</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#323">323</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#348">348</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#350">350</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#353">353</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#388">388</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#390">390</a>.</li>
<li>Changed the following issues from Tentatively Ready to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#471">471</a>.</li>
<li>Changed the following issues from New to Pending NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#633">633</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#641">641</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#656">656</a>.</li>
<li>Changed the following issues from Tentatively Ready to Pending NAD Editorial: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#532">532</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#553">553</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#571">571</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#591">591</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#594">594</a>.</li>
<li>Changed the following issues from Tentatively Ready to Pending WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#258">258</a>.</li>
<li>Changed the following issues from New to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#566">566</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#628">628</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#640">640</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#643">643</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#644">644</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#646">646</a>.</li>
<li>Changed the following issues from Review to Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#531">531</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#551">551</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#604">604</a>.</li>
<li>Changed the following issues from Ready to TRDec: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#598">598</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#599">599</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#600">600</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#601">601</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#602">602</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#603">603</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#605">605</a>.</li>
<li>Changed the following issues from Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#543">543</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#545">545</a>.</li>
<li>Changed the following issues from Tentatively Ready to WP: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#201">201</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#206">206</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#233">233</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#254">254</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#416">416</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#422">422</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#456">456</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#534">534</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#542">542</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#559">559</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#575">575</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#576">576</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#578">578</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#586">586</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#589">589</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#593">593</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#609">609</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#610">610</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#611">611</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#613">613</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#616">616</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#619">619</a>.</li>
</ul></li>
</ul>
</li>
<li>R47: 
2007-03-09 pre-Oxford mailing.
<ul>
<li><b>Summary:</b><ul>
<li>178 open issues, up by 37.</li>
<li>478 closed issues, up by 0.</li>
<li>656 issues total, up by 37.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following New issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#620">620</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#621">621</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#622">622</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#623">623</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#624">624</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#627">627</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#628">628</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#629">629</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#630">630</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#631">631</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#632">632</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#633">633</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#634">634</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#635">635</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#636">636</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#637">637</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#638">638</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#639">639</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#640">640</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#641">641</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#642">642</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#643">643</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#644">644</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#645">645</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#646">646</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#647">647</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#648">648</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#649">649</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#650">650</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#651">651</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#652">652</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#653">653</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#654">654</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#655">655</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#656">656</a>.</li>
<li>Added the following Open issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#625">625</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#626">626</a>.</li>
<li>Changed the following issues from New to Open: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#570">570</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#580">580</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#582">582</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#590">590</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#612">612</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#614">614</a>.</li>
<li>Changed the following issues from New to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#547">547</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#553">553</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#560">560</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#571">571</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#572">572</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#575">575</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#576">576</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#578">578</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#586">586</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#589">589</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#591">591</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#593">593</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#594">594</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#609">609</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#610">610</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#611">611</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#613">613</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#615">615</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#616">616</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#619">619</a>.</li>
<li>Changed the following issues from Open to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#201">201</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#206">206</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#233">233</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#254">254</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#258">258</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#385">385</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#416">416</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#422">422</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#456">456</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#463">463</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#466">466</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#470">470</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#471">471</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#479">479</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#482">482</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#515">515</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#526">526</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#532">532</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#536">536</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#542">542</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#559">559</a>.</li>
<li>Changed the following issues from Review to Tentatively Ready: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#534">534</a>.</li>
</ul></li>
</ul>
</li>
<li>R46: 
2007-01-12 mid-term mailing.
<ul>
<li><b>Summary:</b><ul>
<li>141 open issues, up by 11.</li>
<li>478 closed issues, down by 1.</li>
<li>619 issues total, up by 10.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#610">610</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#611">611</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#612">612</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#613">613</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#614">614</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#615">615</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#616">616</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#617">617</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#618">618</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#619">619</a>.</li>
</ul></li>
</ul>
</li>
<li>R45: 
2006-11-03 post-Portland mailing.
<ul>
<li><b>Summary:</b><ul>
<li>130 open issues, up by 0.</li>
<li>479 closed issues, up by 17.</li>
<li>609 issues total, up by 17.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#520">520</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#521">521</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#530">530</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#535">535</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#537">537</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#538">538</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#540">540</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#541">541</a> to WP.</li>
<li>Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#504">504</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#512">512</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#516">516</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#544">544</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#549">549</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#554">554</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#555">555</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#558">558</a> to NAD.</li>
<li>Moved issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#569">569</a> to Dup.</li>
<li>Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#518">518</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#523">523</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#524">524</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#542">542</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#556">556</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#557">557</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#559">559</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#597">597</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#606">606</a> to Open.</li>
<li>Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#543">543</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#545">545</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#549">549</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#549">549</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#598">598</a> - <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#603">603</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#605">605</a> to Ready.</li>
<li>Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#531">531</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#551">551</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#604">604</a> to Review.</li>
<li>Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#593">593</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#594">594</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#595">595</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#596">596</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#597">597</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#598">598</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#599">599</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#600">600</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#601">601</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#602">602</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#603">603</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#604">604</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#605">605</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#606">606</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#607">607</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#608">608</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#609">609</a>.</li>
</ul></li>
</ul>
</li>
<li>R44: 
2006-09-08 pre-Portland mailing.
<ul>
<li><b>Summary:</b><ul>
<li>130 open issues, up by 6.</li>
<li>462 closed issues, down by 1.</li>
<li>592 issues total, up by 5.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#583">583</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#584">584</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#585">585</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#586">586</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#587">587</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#588">588</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#589">589</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#590">590</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#591">591</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#592">592</a>.</li>
</ul></li>
</ul>
</li>
<li>R43: 
2006-06-23 mid-term mailing.
<ul>
<li><b>Summary:</b><ul>
<li>124 open issues, up by 14.</li>
<li>463 closed issues, down by 1.</li>
<li>587 issues total, up by 13.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#575">575</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#576">576</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#577">577</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#578">578</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#579">579</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#580">580</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#581">581</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#582">582</a>.</li>
<li>Reopened <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#255">255</a>.</li>
<li>Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#520">520</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#541">541</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#544">544</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#569">569</a> to Tentatively Ready.</li>
</ul></li>
</ul>
</li>
<li>R42: 
2006-04-21 post-Berlin mailing.
<ul>
<li><b>Summary:</b><ul>
<li>110 open issues, down by 16.</li>
<li>464 closed issues, up by 24.</li>
<li>574 issues total, up by 8.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#567">567</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#568">568</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#569">569</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#570">570</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#571">571</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#572">572</a>.</li>
<li>Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#499">499</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#501">501</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#506">506</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#509">509</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#510">510</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#511">511</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#513">513</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#514">514</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#517">517</a> to NAD.</li>
<li>Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#502">502</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#503">503</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#515">515</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#516">516</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#522">522</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#525">525</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#526">526</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#527">527</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#528">528</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#529">529</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#532">532</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#536">536</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#539">539</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#548">548</a> to Open.</li>
<li>Moved issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#504">504</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#512">512</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#521">521</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#530">530</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#531">531</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#535">535</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#537">537</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#538">538</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#540">540</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#549">549</a> to Ready.</li>
<li>Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#247">247</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#294">294</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#362">362</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#369">369</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#371">371</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#376">376</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#384">384</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#475">475</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#478">478</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#495">495</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#497">497</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#505">505</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#507">507</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#508">508</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#519">519</a> to WP.</li>
<li>Moved issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#534">534</a> to Review.</li>
</ul></li>
</ul>
</li>
<li>R41: 
2006-02-24 pre-Berlin mailing.
<ul>
<li><b>Summary:</b><ul>
<li>126 open issues, up by 31.</li>
<li>440 closed issues, up by 0.</li>
<li>566 issues total, up by 31.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#536">536</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#537">537</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#538">538</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#539">539</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#540">540</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#541">541</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#542">542</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#543">543</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#544">544</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#545">545</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#546">546</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#547">547</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#548">548</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#549">549</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#550">550</a> ,<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#551">551</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#552">552</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#553">553</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#554">554</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#555">555</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#556">556</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#557">557</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#558">558</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#559">559</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#560">560</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#561">561</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#562">562</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#563">563</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#564">564</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#565">565</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#566">566</a>.</li>
<li>Moved <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#342">342</a> from Ready to Open.</li>
<li>Reopened <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#309">309</a>.</li>
</ul></li>
</ul>
</li>
<li>R40: 
2005-12-16 mid-term mailing.
<ul>
<li><b>Summary:</b><ul>
<li>95 open issues.</li>
<li>440 closed issues.</li>
<li>535 issues total.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#529">529</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#530">530</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#531">531</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#532">532</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#533">533</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#534">534</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#535">535</a>.</li>
</ul></li>
</ul>
</li>
<li>R39: 
2005-10-14 post-Mont Tremblant mailing.
Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#526">526</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#528">528</a>.
Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#280">280</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#461">461</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#464">464</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#465">465</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#467">467</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#468">468</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#474">474</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#496">496</a> from Ready to WP as per the vote from Mont Tremblant.
Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#247">247</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#294">294</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#342">342</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#362">362</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#369">369</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#371">371</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#376">376</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#384">384</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#475">475</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#478">478</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#495">495</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#497">497</a> from Review to Ready.
Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#498">498</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#504">504</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#506">506</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#509">509</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#510">510</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#511">511</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#512">512</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#513">513</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#514">514</a> from New to Open.
Moved issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#505">505</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#507">507</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#508">508</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#519">519</a> from New to Ready.
Moved issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#500">500</a> from New to NAD.
Moved issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#518">518</a> from New to Review.
</li>
<li>R38: 
2005-07-03 pre-Mont Tremblant mailing.
Merged open TR1 issues in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#504">504</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#522">522</a>.
Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#523">523</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#523">523</a>
</li>
<li>R37: 
2005-06 mid-term mailing.
Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#498">498</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#503">503</a>.
</li>
<li>R36: 
2005-04 post-Lillehammer mailing. All issues in "ready" status except
for <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#454">454</a> were moved to "DR" status, and all issues
previously in "DR" status were moved to "WP".
</li>
<li>R35: 
2005-03 pre-Lillehammer mailing.
</li>
<li>R34: 
2005-01 mid-term mailing.  Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#488">488</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#494">494</a>.
</li>
<li>R33: 
2004-11 post-Redmond mailing. Reflects actions taken in Redmond.
</li>
<li>R32: 
2004-09 pre-Redmond mailing: reflects new proposed resolutions and
new issues received after the 2004-07 mailing.  Added
new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#479">479</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#481">481</a>.
</li>
<li>R31: 
2004-07 mid-term mailing: reflects new proposed resolutions and
new issues received after the post-Sydney mailing.  Added
new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#463">463</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#478">478</a>.
</li>
<li>R30: 
Post-Sydney mailing: reflects decisions made at the Sydney meeting.
Voted all "Ready" issues from R29 into the working paper.
Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#460">460</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#462">462</a>.
</li>
<li>R29: 
Pre-Sydney mailing.  Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#441">441</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#457">457</a>.
</li>
<li>R28: 
Post-Kona mailing: reflects decisions made at the Kona meeting.
Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#432">432</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#440">440</a>.
</li>
<li>R27: 
Pre-Kona mailing.  Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#404">404</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#431">431</a>.
</li>
<li>R26: 
Post-Oxford mailing: reflects decisions made at the Oxford meeting.
All issues in Ready status were voted into DR status.  All issues in
DR status were voted into WP status.
</li>
<li>R25: 
Pre-Oxford mailing.  Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#390">390</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#402">402</a>.
</li>
<li>R24: 
Post-Santa Cruz mailing: reflects decisions made at the Santa Cruz
meeting.  All Ready issues from R23 with the exception of <iref ref="253">, which has been given a new proposed resolution, were
moved to DR status.  Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#383">383</a>-<iref ref="389">.  (Issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#387">387</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#389">389</a> were discussed
at the meeting.)  Made progress on issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#225">225</a>, <iref ref="226">, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#229">229</a>: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#225">225</a> and <iref ref="229"> have been moved to Ready status, and the only remaining
concerns with <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#226">226</a> involve wording.
</iref></iref></iref></iref></li>
<li>R23: 
Pre-Santa Cruz mailing.  Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#367">367</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#382">382</a>.
Moved issues in the TC to TC status.
</li>
<li>R22: 
Post-Curaao mailing.  Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#362">362</a>-<iref ref="366">.
</iref></li>
<li>R21: 
Pre-Curaao mailing.  Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#351">351</a>-<iref ref="361">.
</iref></li>
<li>R20: 
Post-Redmond mailing; reflects actions taken in Redmond.  Added
new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#336">336</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#350">350</a>, of which issues 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#347">347</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#350">350</a> were added since Redmond, hence
not discussed at the meeting.  

All Ready issues were moved to DR status, with the exception of issues
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#284">284</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#241">241</a>, and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#267">267</a>.

Noteworthy issues discussed at Redmond include 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#120">120</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#202">202</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#226">226</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#233">233</a>, 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#270">270</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#253">253</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#254">254</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#323">323</a>.
</li>
<li>R19: 
Pre-Redmond mailing.  Added new issues 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#323">323</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#335">335</a>.
</li>
<li>R18: 
Post-Copenhagen mailing; reflects actions taken in Copenhagen.
Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#312">312</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#317">317</a>, and discussed
new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#271">271</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#314">314</a>.

Changed status of issues
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#103">103</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#118">118</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#136">136</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#153">153</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#165">165</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#171">171</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#183">183</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#184">184</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#185">185</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#186">186</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#214">214</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#221">221</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#234">234</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#237">237</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#243">243</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#248">248</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#251">251</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#252">252</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#256">256</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#260">260</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#261">261</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#262">262</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#263">263</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#265">265</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#268">268</a>
to DR.

Changed status of issues
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#49">49</a>  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#109">109</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#117">117</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#182">182</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#228">228</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#230">230</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#232">232</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#235">235</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#238">238</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#241">241</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#242">242</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#250">250</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#259">259</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#264">264</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#266">266</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#267">267</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#271">271</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#272">272</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#273">273</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#275">275</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#281">281</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#284">284</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#285">285</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#286">286</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#288">288</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#292">292</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#295">295</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#297">297</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#298">298</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#301">301</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#303">303</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#306">306</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#307">307</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#308">308</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#312">312</a>
to Ready.

Closed issues 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#111">111</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#277">277</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#279">279</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#287">287</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#289">289</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#293">293</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#302">302</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#313">313</a>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#314">314</a>
as NAD.

</li>
<li>R17: 
Pre-Copenhagen mailing.  Converted issues list to XML.  Added proposed
resolutions for issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#49">49</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#76">76</a>, <iref ref="91">, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#235">235</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#250">250</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#267">267</a>.
Added new issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#278">278</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#311">311</a>.
</iref></li>
<li>R16:  
post-Toronto mailing; reflects actions taken in Toronto. Added new
issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#265">265</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#277">277</a>.  Changed status of issues
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#3">3</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#8">8</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#9">9</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#19">19</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#26">26</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#31">31</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#61">61</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#63">63</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#86">86</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#108">108</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#112">112</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#114">114</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#115">115</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#122">122</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#127">127</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#129">129</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#134">134</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#137">137</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#142">142</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#144">144</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#146">146</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#147">147</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#159">159</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#164">164</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#170">170</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#181">181</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#199">199</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#208">208</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#209">209</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#210">210</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#211">211</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#212">212</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#217">217</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#220">220</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#222">222</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#223">223</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#224">224</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#227">227</a> to "DR".  Reopened issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#23">23</a>. Reopened
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#187">187</a>. Changed issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#2">2</a> and
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#4">4</a> to NAD. Fixed a typo in issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#17">17</a>. Fixed
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#70">70</a>: signature should be changed both places it
appears. Fixed issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#160">160</a>: previous version didn't fix
the bug in enough places.
</li>
<li>R15: 
pre-Toronto mailing. Added issues
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#233">233</a>-<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#264">264</a>. Some small HTML formatting
changes so that we pass Weblint tests.
</li>
<li>R14: 
post-Tokyo II mailing; reflects committee actions taken in
Tokyo. Added issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#228">228</a> to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#232">232</a>. (00-0019R1/N1242)
</li>
<li>R13: 
pre-Tokyo II updated: Added issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#212">212</a> to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#227">227</a>.
</li>
<li>R12: 
pre-Tokyo II mailing: Added issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#199">199</a> to
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#211">211</a>. Added "and paragraph 5" to the proposed resolution
of issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#29">29</a>.  Add further rationale to issue
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#178">178</a>.
</li>
<li>R11: 
post-Kona mailing: Updated to reflect LWG and full committee actions
in Kona (99-0048/N1224). Note changed resolution of issues
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#4">4</a> and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#38">38</a>. Added issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#196">196</a>
to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#198">198</a>. Closed issues list split into "defects" and
"closed" documents.  Changed the proposed resolution of issue
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#4">4</a> to NAD, and changed the wording of proposed resolution
of issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#38">38</a>.
</li>
<li>R10: 
pre-Kona updated.  Added proposed resolutions <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#83">83</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#86">86</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#91">91</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#92">92</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#109">109</a>. Added issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#190">190</a> to
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#195">195</a>. (99-0033/D1209, 14 Oct 99)
</li>
<li>R9: 
pre-Kona mailing.  Added issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#140">140</a> to
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#189">189</a>. Issues list split into separate "active" and
"closed" documents. (99-0030/N1206, 25 Aug 99)
</li>
<li>R8: 
post-Dublin mailing. Updated to reflect LWG and full committee actions
in Dublin. (99-0016/N1193, 21 Apr 99)
</li>
<li>R7: 
pre-Dublin updated: Added issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#130">130</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#131">131</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#132">132</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#133">133</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#134">134</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#135">135</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#136">136</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#137">137</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#138">138</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#139">139</a> (31 Mar 99)
</li>
<li>R6: 
pre-Dublin mailing. Added issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#127">127</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#128">128</a>,
and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#129">129</a>.  (99-0007/N1194, 22 Feb 99)
</li>
<li>R5: 
update issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#103">103</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#112">112</a>; added issues
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#114">114</a> to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#126">126</a>. Format revisions to prepare
for making list public. (30 Dec 98)
</li>
<li>R4: 
post-Santa Cruz II updated: Issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#110">110</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#111">111</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#112">112</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#113">113</a> added, several
issues corrected. (22 Oct 98)
</li>
<li>R3: 
post-Santa Cruz II: Issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#94">94</a> to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#109">109</a>
added, many issues updated to reflect LWG consensus (12 Oct 98)
</li>
<li>R2: 
pre-Santa Cruz II: Issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#73">73</a> to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#93">93</a> added,
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#17">17</a> updated. (29 Sep 98)
</li>
<li>R1: 
Correction to issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#55">55</a> resolution, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#60">60</a> code
format, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#64">64</a> title. (17 Sep 98)
</li>
</ul>

<h2>Closed Issues</h2>
<hr>
<h3><a name="2"></a>2. Auto_ptr conversions effects incorrect</h3>
<p><b>Section:</b> D.12.1.3 [auto.ptr.conv] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Nathan Myers <b>Opened:</b> 1997-12-04 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Paragraph 1 in "Effects", says "Calls
p-&gt;release()" where it clearly must be "Calls
p.release()". (As it is, it seems to require using
auto_ptr&lt;&gt;::operator-&gt; to refer to X::release, assuming that
exists.)</p>


<p><b>Proposed resolution:</b></p>
<p>Change 20.7.4.3 [meta.unary.prop] paragraph 1 Effects from 
"Calls p-&gt;release()" to "Calls p.release()".</p>


<p><b>Rationale:</b></p>
<p>Not a defect: the proposed change is already found in the standard.
[Originally classified as a defect, later reclassified.]</p>





<hr>
<h3><a name="4"></a>4. Basic_string size_type and difference_type should be implementation defined</h3>
<p><b>Section:</b> 21.4 [basic.string] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 1997-11-16 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#basic.string">issues</a> in [basic.string].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>In Morristown we changed the size_type and difference_type typedefs
for all the other containers to implementation defined with a
reference to 23.2 [container.requirements].  This should probably also have been
done for strings. </p>


<p><b>Rationale:</b></p>
<p>Not a defect.  [Originally classified as a defect, later
reclassified.]  basic_string, unlike the other standard library
template containers, is severely constrained by its use of
char_traits. Those types are dictated by the traits class, and are far
from implementation defined.</p>





<hr>
<h3><a name="6"></a>6. File position not an offset unimplementable</h3>
<p><b>Section:</b> 27.5.3 [fpos] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 1997-12-15 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#fpos">issues</a> in [fpos].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Table 88, in I/O, is too strict; it's unimplementable on systems
where a file position isn't just an offset. It also never says just
what fpos&lt;&gt; is really supposed to be.  [Here's my summary, which
Jerry agrees is more or less accurate. "I think I now know what
the class really is, at this point: it's a magic cookie that
encapsulates an mbstate_t and a file position (possibly represented as
an fpos_t), it has syntactic support for pointer-like arithmetic, and
implementors are required to have real, not just syntactic, support
for arithmetic." This isn't standardese, of course.] </p>


<p><b>Rationale:</b></p>
<p>Not a defect. The LWG believes that the Standard is already clear,
and that the above summary is what the Standard in effect says.</p>





<hr>
<h3><a name="10"></a>10. Codecvt&lt;&gt;::do unclear</h3>
<p><b>Section:</b> 22.4.1.5 [locale.codecvt.byname] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 1998-01-14 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.codecvt.byname">issues</a> in [locale.codecvt.byname].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#19">19</a></p>
<p><b>Discussion:</b></p>
<p>Section 22.2.1.5.2 says that codecvt&lt;&gt;::do_in and do_out
should return the value noconv if "no conversion was
needed". However, I don't see anything anywhere that defines what
it means for a conversion to be needed or not needed. I can think of
several circumstances where one might plausibly think that a
conversion is not "needed", but I don't know which one is
intended here. </p>


<p><b>Rationale:</b></p>






<hr>
<h3><a name="12"></a>12. Way objects hold allocators unclear</h3>
<p><b>Section:</b> 20.2.5 [allocator.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Angelika Langer <b>Opened:</b> 1998-02-23 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>I couldn't find a statement in the standard saying whether the allocator object held by
a container is held as a copy of the constructor argument or whether a pointer of
reference is maintained internal. There is an according statement for compare objects and
how they are maintained by the associative containers, but I couldn't find anything
regarding allocators. </p>

<p>Did I overlook it? Is it an open issue or known defect? Or is it deliberately left
unspecified? </p>


<p><b>Rationale:</b></p>
<p>Not a defect. The LWG believes that the Standard is already
clear.&nbsp; See 23.2 [container.requirements], paragraph 8.</p>





<hr>
<h3><a name="43"></a>43. Locale table correction</h3>
<p><b>Section:</b> 22.4.1.5 [locale.codecvt.byname] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Brendan Kehoe <b>Opened:</b> 1998-06-01 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.codecvt.byname">issues</a> in [locale.codecvt.byname].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#33">33</a></p>
<p><b>Discussion:</b></p>


<p><b>Rationale:</b></p>






<hr>
<h3><a name="45"></a>45. Stringstreams read/write pointers initial position unclear</h3>
<p><b>Section:</b> 27.8.3 [ostringstream] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Matthias Mueller <b>Opened:</b> 1998-05-27 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>In a comp.lang.c++.moderated Matthias Mueller wrote:</p>

<p>"We are not sure how to interpret the CD2 (see 27.3 [iostream.forward], 27.8.3.1 [ostringstream.cons], 27.8.1.1 [stringbuf.cons])
with respect to the question as to what the correct initial positions
of the write and&nbsp; read pointers of a stringstream should
be."</p>

<p>"Is it the same to output two strings or to initialize the stringstream with the
first and to output the second?"</p>

<p><i>[PJ Plauger, Bjarne Stroustrup, Randy Smithey, Sean Corfield, and
Jerry Schwarz have all offered opinions; see reflector messages
lib-6518, 6519, 6520, 6521, 6523, 6524.]</i></p>




<p><b>Rationale:</b></p>
<p>The LWG believes the Standard is correct as written. The behavior
of stringstreams is consistent with fstreams, and there is a
constructor which can be used to obtain the desired effect. This
behavior is known to be different from strstreams.</p>





<hr>
<h3><a name="58"></a>58. Extracting a char from a wide-oriented stream</h3>
<p><b>Section:</b> 27.7.1.2.3 [istream::extractors] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 1998-07-01 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream::extractors">issues</a> in [istream::extractors].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>27.6.1.2.3 has member functions for extraction of signed char and
unsigned char, both singly and as strings. However, it doesn't say
what it means to extract a <tt>char</tt> from a
<tt>basic_streambuf&lt;charT, Traits&gt;</tt>. </p>

<p>basic_streambuf, after all, has no members to extract a char, so
basic_istream must somehow convert from charT to signed char or
unsigned char. The standard doesn't say how it is to perform that
conversion. </p>


<p><b>Rationale:</b></p>
<p>The Standard is correct as written.  There is no such extractor and
this is the intent of the LWG.</p>




<hr>
<h3><a name="65"></a>65. Underspecification of strstreambuf::seekoff</h3>
<p><b>Section:</b> D.9.1.3 [depr.strstreambuf.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 1998-08-18 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#depr.strstreambuf.virtuals">issues</a> in [depr.strstreambuf.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>The standard says how this member function affects the current
stream position. (<tt>gptr</tt> or <tt>pptr</tt>) However, it does not
say how this member function affects the beginning and end of the
get/put area. </p>

<p>This is an issue when seekoff is used to position the get pointer
beyond the end of the current read area. (Which is legal. This is
implicit in the definition of <i>seekhigh</i> in D.7.1, paragraph 4.)
</p>


<p><b>Rationale:</b></p>
<p>The LWG agrees that seekoff() is underspecified, but does not wish
to invest effort in this deprecated feature.</p>





<hr>
<h3><a name="67"></a>67. Setw useless for strings</h3>
<p><b>Section:</b> 21.4.8.9 [string.io] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Steve Clamage <b>Opened:</b> 1998-07-09 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#string.io">issues</a> in [string.io].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#25">25</a></p>
<p><b>Discussion:</b></p>
<p>In a comp.std.c++ posting Michel Michaud wrote: What
should be output by: </p>

<pre>   string text("Hello");
   cout &lt;&lt; '[' &lt;&lt; setw(10) &lt;&lt; right &lt;&lt; text &lt;&lt; ']';
</pre>

<p>Shouldn't it be:</p>

<pre>   [     Hello]</pre>

<p>Another person replied: Actually, according to the FDIS, the width
of the field should be the minimum of width and the length of the
string, so the output shouldn't have any padding. I think that this is
a typo, however, and that what is wanted is the maximum of the
two. (As written, setw is useless for strings. If that had been the
intent, one wouldn't expect them to have mentioned using its value.)
</p>

<p>It's worth pointing out that this is a recent correction anyway;
IIRC, earlier versions of the draft forgot to mention formatting
parameters whatsoever.</p>


<p><b>Rationale:</b></p>






<hr>
<h3><a name="72"></a>72. Do_convert phantom member function</h3>
<p><b>Section:</b> 22.4.1.4 [locale.codecvt] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Nathan Myers <b>Opened:</b> 1998-08-24 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.codecvt">issues</a> in [locale.codecvt].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#24">24</a></p>
<p><b>Discussion:</b></p>
<p>In 22.4.1.4 [locale.codecvt] par 3, and in 22.4.1.4.2 [locale.codecvt.virtuals] par 8, a nonexistent member function
"do_convert" is mentioned. This member was replaced with
"do_in" and "do_out", the proper referents in the
contexts above.</p>


<p><b>Rationale:</b></p>





<hr>
<h3><a name="73"></a>73. <tt>is_open</tt> should be const</h3>
<p><b>Section:</b> 27.9.1 [fstreams] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 1998-08-27 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#fstreams">issues</a> in [fstreams].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Classes <tt>basic_ifstream</tt>, <tt>basic_ofstream</tt>, and
<tt>basic_fstream</tt> all have a member function <tt>is_open</tt>. It
should be a <tt>const</tt> member function, since it does nothing but
call one of <tt>basic_filebuf</tt>'s const member functions. </p>


<p><b>Rationale:</b></p>
<p>Not a defect. This is a deliberate feature; const streams would be
meaningless.</p>




<hr>
<h3><a name="77"></a>77. Valarray operator[] const returning value</h3>
<p><b>Section:</b> 26.6.2.3 [valarray.access] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Levente Farkas <b>Opened:</b> 1998-09-09 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#valarray.access">issues</a> in [valarray.access].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#389">389</a></p>
<p><b>Discussion:</b></p>
<p>valarray:<br>
<br>
&nbsp;&nbsp;&nbsp; <tt>T operator[] (size_t) const;</tt><br>
<br>
why not <br>
<br>
&nbsp;&nbsp;&nbsp; <tt>const T&amp; operator[] (size_t) const;</tt><br>
<br>
as in vector ???<br>
<br>
One can't copy even from a const valarray eg:<br>
<br>
&nbsp;&nbsp;&nbsp; <tt>memcpy(ptr, &amp;v[0], v.size() * sizeof(double));<br>
</tt><br>
[I] find this bug in valarray is very difficult.</p>


<p><b>Rationale:</b></p>
<p>The LWG believes that the interface was deliberately designed that
way. That is what valarray was designed to do; that's where the
"value array" name comes from. LWG members further comment
that "we don't want valarray to be a full STL container."
26.6.2.3 [valarray.access] specifies properties that indicate "an
absence of aliasing" for non-constant arrays; this allows
optimizations, including special hardware optimizations, that are not
otherwise possible. </p>





<hr>
<h3><a name="81"></a>81. Wrong declaration of slice operations</h3>
<p><b>Section:</b> 26.6.5 [template.slice.array], 26.6.7 [template.gslice.array], 26.6.8 [template.mask.array], 26.6.9 [template.indirect.array] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Nico Josuttis <b>Opened:</b> 1998-09-29 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#template.slice.array">issues</a> in [template.slice.array].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Isn't the definition of copy constructor and assignment operators wrong?
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Instead of</p>

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; slice_array(const slice_array&amp;); 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; slice_array&amp; operator=(const slice_array&amp;);</pre>

<p>IMHO they have to be</p>

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;slice_array(const slice_array&lt;T&gt;&amp;); 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;slice_array&amp; operator=(const slice_array&lt;T&gt;&amp;);</pre>

<p>Same for gslice_array. </p>


<p><b>Rationale:</b></p>
<p>Not a defect. The Standard is correct as written. </p>




<hr>
<h3><a name="82"></a>82. Missing constant for set elements</h3>
<p><b>Section:</b> 23.2.4 [associative.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Nico Josuttis <b>Opened:</b> 1998-09-29 <b>Last modified:</b> 2010-10-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Paragraph 5 specifies:</p>

<blockquote><p>
For set and multiset the value type is the same as the key type. For
map and multimap it is equal to pair&lt;const Key, T&gt;.  
</p></blockquote>

<p>Strictly speaking, this is not correct because for set and multiset
the value type is the same as the <b>constant</b> key type.</p>


<p><b>Rationale:</b></p>
<p>Not a defect. The Standard is correct as written; it uses a
different mechanism (const &amp;) for <tt>set</tt> and
<tt>multiset</tt>. See issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#103">103</a> for a related
issue.</p>




<hr>
<h3><a name="84"></a>84. Ambiguity with string::insert()</h3>
<p><b>Section:</b> 21.4.5 [string.access] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Nico Josuttis <b>Opened:</b> 1998-09-29 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>If I try</p>
<pre>    s.insert(0,1,' ');</pre>

<p>&nbsp; I get an nasty ambiguity. It might be</p>
<pre>    s.insert((size_type)0,(size_type)1,(charT)' ');</pre>

<p>which inserts 1 space character at position 0, or</p>
<pre>    s.insert((char*)0,(size_type)1,(charT)' ')</pre>

<p>which inserts 1 space character at iterator/address 0 (bingo!), or</p>
<pre>    s.insert((char*)0, (InputIterator)1, (InputIterator)' ')</pre>

<p>which normally inserts characters from iterator 1 to iterator '
'. But according to 23.1.1.9 (the "do the right thing" fix)
it is equivalent to the second. However, it is still ambiguous,
because of course I mean the first!</p>


<p><b>Rationale:</b></p>
<p>Not a defect. The LWG believes this is a "genetic
misfortune" inherent in the design of string and thus not a
defect in the Standard as such .</p>




<hr>
<h3><a name="85"></a>85. String char types</h3>
<p><b>Section:</b> 21 [strings] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Nico Josuttis <b>Opened:</b> 1998-09-29 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#strings">issues</a> in [strings].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>The standard seems not to require that charT is equivalent to
traits::char_type. So, what happens if charT is not equivalent to
traits::char_type?</p>


<p><b>Rationale:</b></p>
<p>There is already wording in 21.2 [char.traits] paragraph 3 that
requires them to be the same.</p>




<hr>
<h3><a name="87"></a>87. Error in description of string::compare()</h3>
<p><b>Section:</b> 21.4.6.8 [string::swap] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Nico Josuttis <b>Opened:</b> 1998-09-29 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#string::swap">issues</a> in [string::swap].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#5">5</a></p>
<p><b>Discussion:</b></p>
<p>The following compare() description is obviously a bug:</p>

<pre>int compare(size_type pos, size_type n1, 
            charT *s, size_type n2 = npos) const;
</pre>

<p>because without passing n2 it should compare up to the end of the
string instead of comparing npos characters (which throws an
exception) </p>


<p><b>Rationale:</b></p>





<hr>
<h3><a name="88"></a>88. Inconsistency between string::insert() and string::append()</h3>
<p><b>Section:</b> 21.4.6.4 [string::insert], 21.4.6.2 [string::append] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Nico Josuttis <b>Opened:</b> 1998-09-29 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#string::insert">issues</a> in [string::insert].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Why does </p>
<pre>  template&lt;class InputIterator&gt; 
       basic_string&amp; append(InputIterator first, InputIterator last);</pre>

<p>return a string, while</p>
<pre>  template&lt;class InputIterator&gt; 
       void insert(iterator p, InputIterator first, InputIterator last);</pre>

<p>returns nothing ?</p>


<p><b>Rationale:</b></p>
<p>The LWG believes this stylistic inconsistency is not sufficiently 
serious to constitute a defect.</p>




<hr>
<h3><a name="89"></a>89. Missing throw specification for string::insert() and string::replace()</h3>
<p><b>Section:</b> 21.4.6.4 [string::insert], 21.4.6.6 [string::replace] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Nico Josuttis <b>Opened:</b> 1998-09-29 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#string::insert">issues</a> in [string::insert].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#83">83</a></p>
<p><b>Discussion:</b></p>
<p>All insert() and replace() members for strings with an iterator as
first argument lack a throw specification. The throw
specification should probably be: length_error if size exceeds
maximum. </p>


<p><b>Rationale:</b></p>
<p>Considered a duplicate because it will be solved by the resolution
of issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#83">83</a>.</p>





<hr>
<h3><a name="93"></a>93. Incomplete Valarray Subset Definitions</h3>
<p><b>Section:</b> 26.6 [numarray] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Nico Josuttis <b>Opened:</b> 1998-09-29 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#numarray">issues</a> in [numarray].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>You can easily create subsets, but you can't easily combine them
with other subsets.  Unfortunately, you almost always needs an
explicit type conversion to valarray. This is because the standard
does not specify that valarray subsets provide the same operations as
valarrays. </p>

<p>For example, to multiply two subsets and assign the result to a third subset, you can't
write the following:</p>

<pre>va[slice(0,4,3)] = va[slice(1,4,3)] * va[slice(2,4,3)];</pre>

<p>Instead, you have to code as follows:</p>

<pre>va[slice(0,4,3)] = static_cast&lt;valarray&lt;double&gt; &gt;(va[slice(1,4,3)]) * 
                   static_cast&lt;valarray&lt;double&gt; &gt;(va[slice(2,4,3)]);</pre>

<p>This is tedious and error-prone. Even worse, it costs performance because each cast
creates a temporary objects, which could be avoided without the cast. </p>


<p><b>Proposed resolution:</b></p>
<p>Extend all valarray subset types so that they offer all valarray operations.</p>


<p><b>Rationale:</b></p>
<p>This is not a defect in the Standard; it is a request for an extension.</p>




<hr>
<h3><a name="94"></a>94. May library implementors add template parameters to Standard Library classes?</h3>
<p><b>Section:</b> 17.6.4 [conforming] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 1998-01-22 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Is it a permitted extension for library implementors to add template parameters to
standard library classes, provided that those extra parameters have defaults? For example,
instead of defining <tt>template &lt;class T, class Alloc = allocator&lt;T&gt; &gt; class
vector;</tt> defining it as <tt>template &lt;class T, class Alloc = allocator&lt;T&gt;,
int N = 1&gt; class vector;</tt> </p>

<p>The standard may well already allow this (I can't think of any way that this extension
could break a conforming program, considering that users are not permitted to
forward-declare standard library components), but it ought to be explicitly permitted or
forbidden. </p>

<p>comment from Steve Cleary via comp.std.c++:</p>
<blockquote>
<p>I disagree [with the proposed resolution] for the following reason:
consider user library code with template template parameters. For
example, a user library object may be templated on the type of
underlying sequence storage to use (deque/list/vector), since these
classes all take the same number and type of template parameters; this
would allow the user to determine the performance tradeoffs of the
user library object. A similar example is a user library object
templated on the type of underlying set storage (set/multiset) or map
storage (map/multimap), which would allow users to change (within
reason) the semantic meanings of operations on that object.</p>
<p>I think that additional template parameters should be forbidden in
the Standard classes. Library writers don't lose any expressive power,
and can still offer extensions because additional template parameters
may be provided by a non-Standard implementation class:</p>
<pre> 
   template &lt;class T, class Allocator = allocator&lt;T&gt;, int N = 1&gt;
   class __vector
   { ... };
   template &lt;class T, class Allocator = allocator&lt;T&gt; &gt;
   class vector: public __vector&lt;T, Allocator&gt;
   { ... };
</pre>

</blockquote>



<p><b>Proposed resolution:</b></p>
<p>Add a new subclause [presumably 17.4.4.9] following 17.6.4.12 [res.on.exception.handling]:</p>

<blockquote>
  <p>17.4.4.9 Template Parameters</p> <p>A specialization of a
  template class described in the C++ Standard Library behaves the
  same as if the implementation declares no additional template
  parameters.</p> <p>Footnote: Additional template parameters with
  default values are thus permitted.</p>
</blockquote>

<p>Add "template parameters" to the list of subclauses at
the end of 17.6.4 [conforming] paragraph 1.</p>

<p><i>[Kona: The LWG agreed the standard needs clarification. After
discussion with John Spicer, it seems added template parameters can be
detected by a program using template-template parameters. A straw vote
- "should implementors be allowed to add template
parameters?" found no consensus ; 5 - yes, 7 - no.]</i></p>




<p><b>Rationale:</b></p>
<p>
There is no ambiguity; the standard is clear as written.  Library
implementors are not permitted to add template parameters to standard
library classes.  This does not fall under the "as if" rule,
so it would be permitted only if the standard gave explicit license
for implementors to do this.  This would require a change in the 
standard.
</p>

<p>
The LWG decided against making this change, because it would break
user code involving template template parameters or specializations
of standard library class templates.
</p>





<hr>
<h3><a name="95"></a>95. Members added by the implementation</h3>
<p><b>Section:</b> 17.6.4.5 [member.functions] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> AFNOR <b>Opened:</b> 1998-10-07 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>In 17.3.4.4/2 vs 17.3.4.7/0 there is a hole; an implementation could add virtual
members a base class and break user derived classes.</p>

<p>Example: </p>

<blockquote>
  <pre>// implementation code:
struct _Base { // _Base is in the implementer namespace
        virtual void foo ();
};
class vector : _Base // deriving from a class is allowed
{ ... };

// user code:
class vector_checking : public vector 
{
        void foo (); // don't want to override _Base::foo () as the 
                     // user doesn't know about _Base::foo ()
};</pre>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>Clarify the wording to make the example illegal.</p>


<p><b>Rationale:</b></p>
<p>This is not a defect in the Standard.&nbsp; The example is already
illegal.&nbsp; See 17.6.4.5 [member.functions] paragraph 2.</p>




<hr>
<h3><a name="96"></a>96. Vector&lt;bool&gt; is not a container</h3>
<p><b>Section:</b> 23.4.1 [vector] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> AFNOR <b>Opened:</b> 1998-10-07 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#vector">issues</a> in [vector].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><tt>vector&lt;bool&gt;</tt> is not a container as its reference and
pointer types are not references and pointers. </p>

<p>Also it forces everyone to have a space optimization instead of a
speed one.</p>

<p><b>See also:</b> 99-0008 == N1185 Vector&lt;bool&gt; is
Nonconforming, Forces Optimization Choice.</p>

<p><i>[In Santa Cruz the LWG felt that this was Not A Defect.]</i></p>


<p><i>[In Dublin many present felt that failure to meet Container
requirements was a defect. There was disagreement as to whether
or not the optimization requirements constituted a defect.]</i></p>


<p><i>[The LWG looked at the following resolutions in some detail:
<br>
&nbsp;&nbsp;&nbsp;&nbsp; * Not A Defect.<br>
&nbsp;&nbsp;&nbsp;&nbsp; * Add a note explaining that vector&lt;bool&gt; does not meet
Container requirements.<br>
&nbsp;&nbsp;&nbsp;&nbsp; * Remove vector&lt;bool&gt;.<br>
&nbsp;&nbsp;&nbsp;&nbsp; * Add a new category of container requirements which
vector&lt;bool&gt; would meet.<br>
&nbsp;&nbsp;&nbsp;&nbsp; * Rename vector&lt;bool&gt;.<br>
<br>
No alternative had strong, wide-spread, support and every alternative
had at least one "over my dead body" response.<br>
<br>
There was also mention of a transition scheme something like (1) add
vector_bool and deprecate vector&lt;bool&gt; in the next standard. (2)
Remove vector&lt;bool&gt; in the following standard.]</i></p>


<p><i>[Modifying container requirements to permit returning proxies
(thus allowing container requirements conforming vector&lt;bool&gt;)
was also discussed.]</i></p>


<p><i>[It was also noted that there is a partial but ugly workaround in
that vector&lt;bool&gt; may be further specialized with a customer
allocator.]</i></p>


<p><i>[Kona: Herb Sutter presented his paper J16/99-0035==WG21/N1211,
vector&lt;bool&gt;: More Problems, Better Solutions. Much discussion
of a two step approach: a) deprecate, b) provide replacement under a
new name.  LWG straw vote on that: 1-favor, 11-could live with, 2-over
my dead body.  This resolution was mentioned in the LWG report to the
full committee, where several additional committee members indicated
over-my-dead-body positions.]</i></p>


<p>Discussed at Lillehammer.  General agreement that we should
  deprecate vector&lt;bool&gt; and introduce this functionality under
  a different name, e.g. bit_vector.  This might make it possible to
  remove the vector&lt;bool&gt; specialization in the standard that comes
  after C++0x. There was also a suggestion that
  in C++0x we could additional say that it's implementation defined
  whether vector&lt;bool&gt; refers to the specialization or to the
  primary template, but there wasn't general agreement that this was a
  good idea.</p>

<p>We need a paper for the new bit_vector class.</p>

<p><i>[
Batavia:
]</i></p>

<blockquote>
The LWG feels we need something closer to SGI's <tt>bitvector</tt> to ease migration
from <tt>vector&lt;bool&gt;</tt>.  Although some of the funcitonality from
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2050.pdf">N2050</a>
could well be used in such a template.  The concern is easing the API migration for those
users who want to continue using a bit-packed container.  Alan and Beman to work.
</blockquote>

<p><i>[
Post Summit Alisdair adds:
]</i></p>


<blockquote>
<p>
<tt>vector&lt;bool&gt;</tt> is now a conforming container under the revised terms of C++0x,
which supports containers of proxies.
</p>
<p>
Recommend NAD.
</p>
<p>
Two issues remain:
</p>
<p>
i/ premature optimization in the specification.
There is still some sentiment that deprecation is the correct way to go,
although it is still not clear what it would mean to deprecate a single
specialization of a template.
</p>
<p>
Recommend: Create a new issue for the discussion, leave as Open.
</p>
<p>
ii/ Request for a new bitvector class to guarantee the optimization, perhaps
with a better tuned interface.
</p>
<p>
This is a clear extension request that may be handled via a future TR.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We note that most of this issue has become moot over time,
and agree with Alisdair's recommendations.
Move to NAD Future for reconsideration of part (ii).
</blockquote>

<p><i>[
2009-07-29 Alisdair reopens:
]</i></p>


<blockquote>
<p>
This infamous issue was closed as NAD Future when concepts introduced
support for proxy iterators, so the only remaining requirement was to
provide a better type to support bitsets of dynamic length.  I fear we
must re-open this issue until the post-concept form of iterators is
available, and hopefully will support the necessary proxy functionality
to allow us to close this issue as NAD.
</p>

<p>
I recommend we spawn a separate issue (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1184">1184</a>) requesting a dynamic length bitset
and pre-emptively file it as NAD Future.  It is difficult to resolve #96
when it effectively contains two separate sub-issues.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Mark as NAD, and give rationale.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
We now have:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2050.pdf">N2050</a>
and
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2160.html">N2160</a>.
</p>



<p><b>Rationale:</b></p>
<p>
We want to support proxy iterators but that is going to be separate
work. Don't want to see this issue come back in these kinds of terms.
We're interested in a separate container, and proxy iterators, but both
of those are separate issues.
</p>
<p>
We've looked at a lot of ways to fix this that would be close to this,
but those things would break existing code. Attempts to fix this
directly have not been tractable, and removing it has not been
tractable. Therefore we are closing.
</p>





<hr>
<h3><a name="97"></a>97. Insert inconsistent definition</h3>
<p><b>Section:</b> 23 [containers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> AFNOR <b>Opened:</b> 1998-10-07 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#containers">issues</a> in [containers].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><tt>insert(iterator, const value_type&amp;)</tt> is defined both on
sequences and on set, with unrelated semantics: insert here (in
sequences), and insert with hint (in associative containers). They
should have different names (B.S. says: do not abuse overloading).</p>


<p><b>Rationale:</b></p>
<p>This is not a defect in the Standard. It is a genetic misfortune of
the design, for better or for worse.</p>




<hr>
<h3><a name="99"></a>99. Reverse_iterator comparisons completely wrong</h3>
<p><b>Section:</b> 24.5.1.3.13 [reverse.iter.op==] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> AFNOR <b>Opened:</b> 1998-10-07 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>The &lt;, &gt;, &lt;=, &gt;= comparison operator are wrong: they
return the opposite of what they should.</p>

<p>Note: same problem in CD2, these were not even defined in CD1.  SGI
STL code is correct; this problem is known since the Morristown
meeting but there it was too late</p>


<p><b>Rationale:</b></p>
<p>This is not a defect in the Standard. A careful reading shows the Standard is correct
as written. A review of several implementations show that they implement
exactly what the Standard says.</p>




<hr>
<h3><a name="100"></a>100. Insert iterators/ostream_iterators overconstrained</h3>
<p><b>Section:</b> 24.5.2 [insert.iterators], 24.6.4 [ostreambuf.iterator] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> AFNOR <b>Opened:</b> 1998-10-07 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#insert.iterators">issues</a> in [insert.iterators].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Overspecified For an insert iterator it, the expression *it is
required to return a reference to it. This is a simple possible
implementation, but as the SGI STL documentation says, not the only
one, and the user should not assume that this is the case.</p>


<p><b>Rationale:</b></p>
<p>The LWG believes this causes no harm and is not a defect in the
standard. The only example anyone could come up with caused some
incorrect code to work, rather than the other way around.</p>





<hr>
<h3><a name="101"></a>101. No way to free storage for vector and deque</h3>
<p><b>Section:</b> 23.4.1 [vector], 23.3.1 [array] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> AFNOR <b>Opened:</b> 1998-10-07 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#vector">issues</a> in [vector].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>Reserve can not free storage, unlike string::reserve</p>

<p><i>[
2010-02-13 Alisdair adds:
]</i></p>


<blockquote>
<p>
This issue has been revisited and addressed (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#755">755</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#850">850</a>). This issues should be reclassified to NAD Editorial to reflect
this action.
</p>
</blockquote>



<p><b>Rationale:</b></p>
<p>This is not a defect in the Standard. The LWG has considered this
issue in the past and sees no need to change the Standard. Deque has
no reserve() member function. For vector, shrink-to-fit can be
expressed in a single line of code (where <tt>v</tt> is
<tt>vector&lt;T&gt;</tt>):
</p>

<blockquote>
  <p><tt>vector&lt;T&gt;(v).swap(v);&nbsp; // shrink-to-fit v</tt></p>
</blockquote>





<hr>
<h3><a name="102"></a>102. Bug in insert range in associative containers</h3>
<p><b>Section:</b> 23.2.4 [associative.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> AFNOR <b>Opened:</b> 1998-10-07 <b>Last modified:</b> 2010-10-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#264">264</a></p>
<p><b>Discussion:</b></p>
<p>Table 69 of Containers say that a.insert(i,j) is linear if [i, j) is ordered. It seems
impossible to implement, as it means that if [i, j) = [x], insert in an associative
container is O(1)!</p>


<p><b>Proposed resolution:</b></p>
<p>N+log (size()) if [i,j) is sorted according to value_comp()</p>


<p><b>Rationale:</b></p>
<p>Subsumed by issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#264">264</a>.</p>





<hr>
<h3><a name="104"></a>104. Description of basic_string::operator[] is unclear</h3>
<p><b>Section:</b> 21.4.4 [string.capacity] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> AFNOR <b>Opened:</b> 1998-10-07 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#string.capacity">issues</a> in [string.capacity].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>It is not clear that undefined behavior applies when pos == size ()
for the non const version.</p>


<p><b>Proposed resolution:</b></p>
<p>Rewrite as: Otherwise, if pos &gt; size () or pos == size () and
the non-const version is used, then the behavior is undefined.</p>


<p><b>Rationale:</b></p>
<p>The Standard is correct. The proposed resolution already appears in
the Standard.</p>




<hr>
<h3><a name="105"></a>105. fstream ctors argument types desired</h3>
<p><b>Section:</b> 27.9 [file.streams] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> AFNOR <b>Opened:</b> 1998-10-07 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#454">454</a></p>
<p><b>Discussion:</b></p>


<p>fstream ctors take a const char* instead of string.<br>
fstream ctors can't take wchar_t</p>

<p>An extension to add a const wchar_t* to fstream would make the
implementation non conforming.</p>


<p><b>Rationale:</b></p>
<p>This is not a defect in the Standard. It might be an
interesting extension for the next Standard. </p>




<hr>
<h3><a name="107"></a>107. Valarray constructor is strange</h3>
<p><b>Section:</b> 26.6.2 [template.valarray] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> AFNOR <b>Opened:</b> 1998-10-07 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#template.valarray">issues</a> in [template.valarray].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>The order of the arguments is (elem, size) instead of the normal
(size, elem) in the rest of the library. Since elem often has an
integral or floating point type, both types are convertible to each
other and reversing them leads to a well formed program.</p>


<p><b>Proposed resolution:</b></p>
<p>Inverting the arguments could silently break programs. Introduce
the two signatures (const T&amp;, size_t) and (size_t, const T&amp;),
but make the one we do not want private so errors result in a
diagnosed access violation. This technique can also be applied to STL
containers.</p>


<p><b>Rationale:</b></p>
<p>The LWG believes that while the order of arguments is unfortunate,
it does not constitute a defect in the standard. The LWG believes that
the proposed solution will not work for valarray&lt;size_t&gt; and
perhaps other cases.</p>




<hr>
<h3><a name="111"></a>111. istreambuf_iterator::equal overspecified, inefficient</h3>
<p><b>Section:</b> 24.6.3.5 [istreambuf.iterator::equal] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Nathan Myers <b>Opened:</b> 1998-10-15 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istreambuf.iterator::equal">issues</a> in [istreambuf.iterator::equal].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>The member istreambuf_iterator&lt;&gt;::equal is specified to be
unnecessarily inefficient. While this does not affect the efficiency
of conforming implementations of iostreams, because they can
"reach into" the iterators and bypass this function, it does
affect users who use istreambuf_iterators. </p>

<p>The inefficiency results from a too-scrupulous definition, which
requires a "true" result if neither iterator is at eof. In
practice these iterators can only usefully be compared with the
"eof" value, so the extra test implied provides no benefit,
but slows down users' code. </p>

<p>The solution is to weaken the requirement on the function to return
true only if both iterators are at eof. </p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Reopened by Alisdair.
</blockquote>

<p><i>[
Post Summit Daniel adds:
]</i></p>


<blockquote>
<p>
Recommend NAD. The proposed wording would violate the axioms of
concept requirement <tt>EqualityComparable</tt> axioms as part of concept <tt>InputIterator</tt>
and more specifically it would violate the explicit wording of
24.2.3 [input.iterators]/7:
</p>

<blockquote>
If two iterators <tt>a</tt> and <tt>b</tt> of the same type are equal, then either <tt>a</tt>
and <tt>b</tt> are both
dereferenceable or else neither is dereferenceable.
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Agree NAD.
</blockquote>

</blockquote>



<p><b>Proposed resolution:</b></p>
<p>Replace 24.6.3.5 [istreambuf.iterator::equal],
paragraph 1, </p>

<blockquote>
  <p>-1- Returns: true if and only if both iterators are at end-of-stream, or neither is at
  end-of-stream, regardless of what streambuf object they use. </p>
</blockquote>

<p>with</p>

<blockquote>
  <p>-1- Returns: true if and only if both iterators are at
  end-of-stream, regardless of what streambuf object they use. </p>
</blockquote>



<p><b>Rationale:</b></p>
<p>It is not clear that this is a genuine defect.  Additionally, the
LWG was reluctant to make a change that would result in 
operator== not being a equivalence relation.  One consequence of
this change is that an algorithm that's passed the range [i, i)
would no longer treat it as an empty range.</p>





<hr>
<h3><a name="113"></a>113. Missing/extra iostream sync semantics</h3>
<p><b>Section:</b> 27.7.1.1 [istream], 27.7.1.3 [istream.unformatted] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Steve Clamage <b>Opened:</b> 1998-10-13 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream">issues</a> in [istream].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>In 27.6.1.1, class basic_istream has a member function sync, described in 27.6.1.3,
paragraph 36. </p>

<p>Following the chain of definitions, I find that the various sync functions have defined
semantics for output streams, but no semantics for input streams. On the other hand,
basic_ostream has no sync function. </p>

<p>The sync function should at minimum be added to basic_ostream, for internal
consistency. </p>

<p>A larger question is whether sync should have assigned semantics for input streams. </p>

<p>Classic iostreams said streambuf::sync flushes pending output and attempts to return
unread input characters to the source. It is a protected member function. The filebuf
version (which is public) has that behavior (it backs up the read pointer). Class
strstreambuf does not override streambuf::sync, and so sync can't be called on a
strstream. </p>

<p>If we can add corresponding semantics to the various sync functions, we should. If not,
we should remove sync from basic_istream.</p>


<p><b>Rationale:</b></p>
<p>A sync function is not needed in basic_ostream because the flush function provides the
desired functionality.</p>

<p>As for the other points, the LWG finds the standard correct as written.</p>





<hr>
<h3><a name="116"></a>116. bitset cannot be constructed with a const char*</h3>
<p><b>Section:</b> 20.5 [template.bitset] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Judy Ward <b>Opened:</b> 1998-11-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#template.bitset">issues</a> in [template.bitset].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#778">778</a></p>
<p><b>Discussion:</b></p>



<p>The following code does not compile with the EDG compiler:</p>

<blockquote>
  <pre>#include &lt;bitset&gt;
using namespace std;
bitset&lt;32&gt; b("111111111");</pre>
</blockquote>

<p>If you cast the ctor argument to a string, i.e.:</p>

<blockquote>
  <pre>bitset&lt;32&gt; b(string("111111111"));</pre>
</blockquote>

<p>then it will compile. The reason is that bitset has the following templatized
constructor:</p>

<blockquote>
  <pre>template &lt;class charT, class traits, class Allocator&gt;
explicit bitset (const basic_string&lt;charT, traits, Allocator&gt;&amp; str, ...);</pre>
</blockquote>

<p>According to the compiler vendor, Steve Adamcyk at EDG, the user
cannot pass this template constructor a <tt>const char*</tt> and
expect a conversion to <tt>basic_string</tt>.  The reason is
"When you have a template constructor, it can get used in
contexts where type deduction can be done. Type deduction basically
comes up with exact matches, not ones involving conversions."
</p>

<p>I don't think the intention when this constructor became
templatized was for construction from a <tt>const char*</tt> to no
longer work.</p>


<p><b>Proposed resolution:</b></p>
<p>Add to 20.5 [template.bitset] a bitset constructor declaration</p>

<blockquote>
  <pre>explicit bitset(const char*);</pre>
</blockquote>

<p>and in Section 20.5.1 [bitset.cons] add:</p>

<blockquote>
  <pre>explicit bitset(const char* str);</pre>
  <p>Effects: <br>
  &nbsp;&nbsp;&nbsp; Calls <tt>bitset((string) str, 0, string::npos);</tt></p>
</blockquote>


<p><b>Rationale:</b></p>
<p>Although the problem is real, the standard is designed that way so
it is not a defect.  Education is the immediate workaround. A future
standard may wish to consider the Proposed Resolution as an
extension.</p>





<hr>
<h3><a name="121"></a>121. Detailed definition for ctype&lt;wchar_t&gt; specialization</h3>
<p><b>Section:</b> 22.3.1.1.1 [locale.category] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Judy Ward <b>Opened:</b> 1998-12-15 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.category">issues</a> in [locale.category].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Section 22.1.1.1.1 has the following listed in Table 51: ctype&lt;char&gt; ,
ctype&lt;wchar_t&gt;. </p>

<p>Also Section 22.4.1.1 [locale.ctype] says: </p>

<blockquote>
  <p>The instantiations required in Table 51 (22.1.1.1.1) namely ctype&lt;char&gt; and
  ctype&lt;wchar_t&gt; , implement character classing appropriate to the implementation's
  native character set. </p>
</blockquote>

<p>However, Section 22.4.1.3 [facet.ctype.special]
only has a detailed description of the ctype&lt;char&gt; specialization, not the
ctype&lt;wchar_t&gt; specialization. </p>


<p><b>Proposed resolution:</b></p>
<p>Add the ctype&lt;wchar_t&gt; detailed class description to Section 
22.4.1.3 [facet.ctype.special]. </p>


<p><b>Rationale:</b></p>
<p>Specialization for wchar_t is not needed since the default is acceptable.</p>





<hr>
<h3><a name="128"></a>128. Need open_mode() function for file stream, string streams, file buffers, and string&nbsp; buffers</h3>
<p><b>Section:</b> 27.8 [string.streams], 27.9 [file.streams] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Angelika Langer <b>Opened:</b> 1999-02-22 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#string.streams">issues</a> in [string.streams].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>The following question came from Thorsten Herlemann:</p>

<blockquote>
  <p>You can set a mode when constructing or opening a file-stream or
  filebuf, e.g.  ios::in, ios::out, ios::binary, ... But how can I get
  that mode later on, e.g. in my own operator &lt;&lt; or operator
  &gt;&gt; or when I want to check whether a file-stream or
  file-buffer object passed as parameter is opened for input or output
  or binary? Is there no possibility? Is this a design-error in the
  standard C++ library? </p>
</blockquote>

<p>It is indeed impossible to find out what a stream's or stream
buffer's open mode is, and without that knowledge you don't know
how certain operations behave. Just think of the append mode. </p>

<p>Both streams and stream buffers should have a <tt>mode()</tt> function that returns the
current open mode setting. </p>

<p><i>[
post Bellevue:  Alisdair requested to re-Open.
]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
Neither Howard nor Bill has received a customer request for this.
</p>
<p>
No consensus for change. The programmer can save this information to the side.
</p>
<p>
Moved to NAD.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>For stream buffers, add a function to the base class as a non-virtual function
qualified as const to 27.6.2 [streambuf]:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;<tt>openmode mode() const</tt>;</p>

<p><b>&nbsp;&nbsp;&nbsp; Returns</b> the current open mode.</p>

<p>With streams, I'm not sure what to suggest. In principle, the mode
could already be returned by <tt>ios_base</tt>, but the mode is only
initialized for file and string stream objects, unless I'm overlooking
anything. For this reason it should be added to the most derived
stream classes. Alternatively, it could be added to <tt>basic_ios</tt>
and would be default initialized in <tt>basic_ios&lt;&gt;::init()</tt>.</p>


<p><b>Rationale:</b></p>
<p>This might be an interesting extension for some future, but it is
not a defect in the current standard. The Proposed Resolution is
retained for future reference.</p>





<hr>
<h3><a name="131"></a>131. list::splice throws nothing</h3>
<p><b>Section:</b> 23.3.4.4 [list.ops] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 1999-03-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#list.ops">issues</a> in [list.ops].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>What happens if a splice operation causes the size() of a list to grow 
beyond max_size()?</p>


<p><b>Rationale:</b></p>
<p>Size() cannot grow beyond max_size().&nbsp; </p>





<hr>
<h3><a name="135"></a>135. basic_iostream doubly initialized</h3>
<p><b>Section:</b> 27.7.1.5.1 [iostream.cons] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 1999-03-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>-1- Effects Constructs an object of class basic_iostream, assigning
initial values to the base classes by calling
basic_istream&lt;charT,traits&gt;(sb) (lib.istream) and
basic_ostream&lt;charT,traits&gt;(sb) (lib.ostream)</p>

<p>The called for basic_istream and basic_ostream constructors call
init(sb). This means that the basic_iostream's virtual base class is
initialized twice.</p>


<p><b>Proposed resolution:</b></p>
<p>Change 27.6.1.5.1, paragraph 1 to:</p>

<p>-1- Effects Constructs an object of class basic_iostream, assigning
initial values to the base classes by calling
basic_istream&lt;charT,traits&gt;(sb) (lib.istream).</p>


<p><b>Rationale:</b></p>
<p>The LWG agreed that the <tt> init()</tt> function is called
twice, but said that this is harmless and so not a defect in the
standard.</p>




<hr>
<h3><a name="138"></a>138. Class ctype_byname&lt;char&gt; redundant and misleading</h3>
<p><b>Section:</b> 22.4.1.4 [locale.codecvt] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Angelika Langer <b>Opened:</b> 1999-03-18 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.codecvt">issues</a> in [locale.codecvt].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Section 22.4.1.4 [locale.codecvt] specifies that
ctype_byname&lt;char&gt; must be a specialization of the ctype_byname
template.</p>

<p>It is common practice in the standard that specializations of class templates are only
mentioned where the interface of the specialization deviates from the interface of the
template that it is a specialization of. Otherwise, the fact whether or not a required
instantiation is an actual instantiation or a specialization is left open as an
implementation detail. </p>

<p>Clause 22.2.1.4 deviates from that practice and for that reason is misleading. The
fact, that ctype_byname&lt;char&gt; is specified as a specialization suggests that there
must be something "special" about it, but it has the exact same interface as the
ctype_byname template. Clause 22.2.1.4 does not have any explanatory value, is at best
redundant, at worst misleading - unless I am missing anything. </p>

<p>Naturally, an implementation will most likely implement ctype_byname&lt;char&gt; as a
specialization, because the base class ctype&lt;char&gt; is a specialization with an
interface different from the ctype template, but that's an implementation detail and need
not be mentioned in the standard. </p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Reopened by Alisdair.
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Moved to NAD.
</blockquote>



<p><b>Rationale:</b></p>
<p> The standard as written is mildly misleading, but the correct fix
is to deal with the underlying problem in the ctype_byname base class,
not in the specialization. See issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#228">228</a>.</p>




<hr>
<h3><a name="140"></a>140. map&lt;Key, T&gt;::value_type does not satisfy the assignable requirement</h3>
<p><b>Section:</b> 23.6.1 [map] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Mark Mitchell <b>Opened:</b> 1999-04-14 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#map">issues</a> in [map].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<blockquote>
  <p>23.2 [container.requirements]<br>
  <br>
  expression&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return type
  &nbsp;&nbsp;&nbsp;&nbsp; pre/post-condition<br>
  -------------&nbsp;&nbsp;&nbsp;&nbsp; ----------- &nbsp;&nbsp;&nbsp;&nbsp;
  -------------------<br>
  X::value_type&nbsp;&nbsp;&nbsp; T
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  T is assignable<br>
  <br>
  23.6.1 [map]<br>
  <br>
  A map satisfies all the requirements of a container.<br>
  <br>
  For a map&lt;Key, T&gt; ... the value_type is pair&lt;const Key, T&gt;.</p>
</blockquote>

<p>There's a contradiction here. In particular, `pair&lt;const Key,
T&gt;' is not assignable; the `const Key' cannot be assigned
to. So,&nbsp; map&lt;Key, T&gt;::value_type does not satisfy the
assignable requirement imposed by a container.</p>

<p><i>[See issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#103">103</a> for the slightly related issue of
modification of set keys.]</i></p>



<p><b>Rationale:</b></p>
<p>The LWG believes that the standard is inconsistent, but that this
is a design problem rather than a strict defect. May wish to
reconsider for the next standard.</p>




<hr>
<h3><a name="143"></a>143. C .h header wording unclear</h3>
<p><b>Section:</b> D.7 [depr.c.headers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Christophe de Dinechin <b>Opened:</b> 1999-05-04 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>[depr.c.headers] paragraph 2 reads:</p>

<blockquote>

<p>Each C header, whose name has the form name.h, behaves as if each
name placed in the Standard library namespace by the corresponding
cname header is also placed within the namespace scope of the
namespace std and is followed by an explicit using-declaration
(_namespace.udecl_)</p>

</blockquote>

<p>I think it should mention the global name space somewhere...&nbsp;
Currently, it indicates that name placed in std is also placed in
std...</p>

<p>I don't know what is the correct wording. For instance, if struct
tm is defined in time.h, ctime declares std::tm. However, the current
wording seems ambiguous regarding which of the following would occur
for use of both ctime and time.h:</p>

<blockquote>
  <pre>// version 1:
namespace std {
        struct tm { ... };
}
using std::tm;

// version 2:
struct tm { ... };
namespace std {
        using ::tm;
}

// version 3:
struct tm { ... };
namespace std {
        struct tm { ... };
}</pre>
</blockquote>

<p>I think version 1 is intended.</p>

<p><i>[Kona: The LWG agreed that the wording is not clear. It also
agreed that version 1 is intended, version 2 is not equivalent to
version 1, and version 3 is clearly not intended. The example below
was constructed by Nathan Myers to illustrate why version 2 is not
equivalent to version 1.</i></p>

<p><i>Although not equivalent, the LWG is unsure if (2) is enough of
a problem to be prohibited. Points discussed in favor of allowing
(2):</i></p>

<blockquote>
  <ul>
    <li><i>It may be a convenience to implementors.</i></li>
    <li><i>The only cases that fail are structs, of which the C library
      contains only a few.</i></li>
  </ul>
</blockquote>

<p><i>]</i></p>

<p><b>Example:</b></p>

<blockquote>

<pre>#include &lt;time.h&gt;
#include &lt;utility&gt;

int main() {
    std::tm * t;
    make_pair( t, t ); // okay with version 1 due to Koenig lookup
                       // fails with version 2; make_pair not found
    return 0;
}</pre>

</blockquote>


<p><b>Proposed resolution:</b></p>

<p>Replace D.7 [depr.c.headers] paragraph 2 with:</p>

<blockquote>

<p> Each C header, whose name has the form name.h, behaves as if each
name placed in the Standard library namespace by the corresponding
cname header is also placed within the namespace scope of the
namespace std by name.h and is followed by an explicit
using-declaration (_namespace.udecl_) in global scope.</p>

</blockquote>



<p><b>Rationale:</b></p>
<p> The current wording in the standard is the result of a difficult
compromise that averted delay of the standard. Based on discussions
in Tokyo it is clear that there is no still no consensus on stricter
wording, so the issue has been closed. It is suggested that users not
write code that depends on Koenig lookup of C library functions.</p>




<hr>
<h3><a name="145"></a>145. adjustfield lacks default value</h3>
<p><b>Section:</b> 27.5.4.1 [basic.ios.cons] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Angelika Langer <b>Opened:</b> 1999-05-12 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#basic.ios.cons">issues</a> in [basic.ios.cons].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>There is no initial value for the adjustfield defined, although
many people believe that the default adjustment were right. This is a
common misunderstanding. The standard only defines that, if no
adjustment is specified, all the predefined inserters must add fill
characters before the actual value, which is "as if" the
right flag were set. The flag itself need not be set.</p>

<p>When you implement a user-defined inserter you cannot rely on right
being the default setting for the adjustfield. Instead, you must be
prepared to find none of the flags set and must keep in mind that in
this case you should make your inserter behave "as if" the
right flag were set. This is surprising to many people and complicates
matters more than necessary.</p>

<p>Unless there is a good reason why the adjustfield should not be
initialized I would suggest to give it the default value that
everybody expects anyway.</p>



<p><b>Rationale:</b></p>
<p>This is not a defect. It is deliberate that the default is no bits
set. Consider Arabic or Hebrew, for example. See 22.4.2.2.2 [facet.num.put.virtuals] paragraph 19, Table 61 - Fill padding.</p>




<hr>
<h3><a name="157"></a>157. Meaningless error handling for <tt>pword()</tt> and <tt>iword()</tt></h3>
<p><b>Section:</b> 27.5.2.5 [ios.base.storage] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 1999-07-20 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ios.base.storage">issues</a> in [ios.base.storage].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#41">41</a></p>
<p><b>Discussion:</b></p>
<p>According to paragraphs 2 and 4 of 27.5.2.5 [ios.base.storage], the
functions <tt>iword()</tt> and <tt>pword()</tt> "set the
<tt>badbit</tt> (which might throw an exception)" on
failure. ... but what does it mean for <tt>ios_base</tt> to set the
<tt>badbit</tt>? The state facilities of the IOStream library are
defined in <tt>basic_ios</tt>, a derived class! It would be possible
to attempt a down cast but then it would be necessary to know the
character type used...</p>


<p><b>Rationale:</b></p>





<hr>
<h3><a name="162"></a>162. Really "formatted input functions"?</h3>
<p><b>Section:</b> 27.7.1.2.3 [istream::extractors] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 1999-07-20 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream::extractors">issues</a> in [istream::extractors].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#60">60</a></p>
<p><b>Discussion:</b></p>
<p>It appears to be somewhat nonsensical to consider the functions
defined in the paragraphs 1 to 5 to be "Formatted input
function" but since these functions are defined in a section
labeled "Formatted input functions" it is unclear to me
whether these operators are considered formatted input functions which
have to conform to the "common requirements" from 27.7.1.2.1 [istream.formatted.reqmts]: If this is the case, all manipulators, not just
<tt>ws</tt>, would skip whitespace unless <tt>noskipws</tt> is set
(... but setting <tt>noskipws</tt> using the manipulator syntax would
also skip whitespace :-)</p>

<p>See also issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#166">166</a> for the same problem in formatted
output</p>


<p><b>Rationale:</b></p>





<hr>
<h3><a name="163"></a>163. Return of <tt>gcount()</tt> after a call to <tt>gcount</tt></h3>
<p><b>Section:</b> 27.7.1.3 [istream.unformatted] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 1999-07-20 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream.unformatted">issues</a> in [istream.unformatted].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#60">60</a></p>
<p><b>Discussion:</b></p>
<p>It is not clear which functions are to be considered unformatted
input functions. As written, it seems that all functions in 27.7.1.3 [istream.unformatted] are unformatted input functions. However, it does not
really make much sense to construct a sentry object for
<tt>gcount()</tt>, <tt>sync()</tt>, ... Also it is unclear what
happens to the <tt>gcount()</tt> if eg. <tt>gcount()</tt>,
<tt>putback()</tt>, <tt>unget()</tt>, or <tt>sync()</tt> is called:
These functions don't extract characters, some of them even
"unextract" a character. Should this still be reflected in
<tt>gcount()</tt>? Of course, it could be read as if after a call to
<tt>gcount()</tt> <tt>gcount()</tt> return <tt>0</tt> (the last
unformatted input function, <tt>gcount()</tt>, didn't extract any
character) and after a call to <tt>putback()</tt> <tt>gcount()</tt>
returns <tt>-1</tt> (the last unformatted input function
<tt>putback()</tt> did "extract" back into the
stream). Correspondingly for <tt>unget()</tt>. Is this what is
intended?  If so, this should be clarified. Otherwise, a corresponding
clarification should be used.</p>


<p><b>Rationale:</b></p>





<hr>
<h3><a name="166"></a>166. Really "formatted output functions"?</h3>
<p><b>Section:</b> 27.7.2.6.3 [ostream.inserters] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 1999-07-20 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#60">60</a></p>
<p><b>Discussion:</b></p>
<p>From 27.7.2.6.1 [ostream.formatted.reqmts] it appears that all the functions
defined in 27.7.2.6.3 [ostream.inserters] have to construct a
<tt>sentry</tt> object. Is this really intended?</p> 

<p>This is basically the same problem as issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#162">162</a> but
for output instead of input.</p>


<p><b>Rationale:</b></p>





<hr>
<h3><a name="177"></a>177. Complex operators cannot be explicitly instantiated</h3>
<p><b>Section:</b> 26.4.6 [complex.ops] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Judy Ward <b>Opened:</b> 1999-07-02 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#complex.ops">issues</a> in [complex.ops].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>A user who tries to explicitly instantiate a complex non-member operator will
get compilation errors. Below is a simplified example of the reason why. The
problem is that iterator_traits cannot be instantiated on a non-pointer type
like float, yet when the compiler is trying to decide which operator+ needs to
be instantiated it must instantiate the declaration to figure out the first
argument type of a reverse_iterator operator.</p>
<pre>namespace std {
template &lt;class Iterator&gt; 
struct iterator_traits
{
    typedef typename Iterator::value_type value_type;
};

template &lt;class T&gt; class reverse_iterator;

// reverse_iterator operator+
template &lt;class T&gt; 
reverse_iterator&lt;T&gt; operator+
(typename iterator_traits&lt;T&gt;::difference_type, const reverse_iterator&lt;T&gt;&amp;);

template &lt;class T&gt; struct complex {};

// complex operator +
template &lt;class T&gt;
complex&lt;T&gt; operator+ (const T&amp; lhs, const complex&lt;T&gt;&amp; rhs) 
{ return complex&lt;T&gt;();} 
}

// request for explicit instantiation
template std::complex&lt;float&gt; std::operator+&lt;float&gt;(const float&amp;, 
     const std::complex&lt;float&gt;&amp;);</pre>
<p>See also c++-stdlib reflector messages: lib-6814, 6815, 6816.</p>


<p><b>Rationale:</b></p>
<p>Implementors can make minor changes and the example will
work. Users are not affected in any case.</p> <p>According to John
Spicer, It is possible to explicitly instantiate these operators using
different syntax: change "std::operator+&lt;float&gt;" to
"std::operator+".</p>

<p>The proposed resolution of issue 120 is that users will not be able
to explicitly instantiate standard library templates. If that
resolution is accepted then library implementors will be the only ones
that will be affected by this problem, and they must use the indicated
syntax.</p>




<hr>
<h3><a name="178"></a>178. Should clog and cerr initially be tied to cout?</h3>
<p><b>Section:</b> 27.4.1 [narrow.stream.objects] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Judy Ward <b>Opened:</b> 1999-07-02 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#narrow.stream.objects">issues</a> in [narrow.stream.objects].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Section 27.3.1 says "After the object cerr is initialized,
cerr.flags() &amp; unitbuf is nonzero. Its state is otherwise the same as
required for ios_base::init (lib.basic.ios.cons).  It doesn't say
anything about the the state of clog.  So this means that calling
cerr.tie() and clog.tie() should return 0 (see Table 89 for
ios_base::init effects).
</p>
<p>
Neither of the popular standard library implementations
that I tried does this, they both tie cerr and clog
to &amp;cout. I would think that would be what users expect.
</p>


<p><b>Rationale:</b></p>
<p>The standard is clear as written.</p>
<p>27.3.1/5 says that "After the object cerr is initialized, cerr.flags()
&amp; unitbuf is nonzero. Its state is otherwise the same as required for
ios_base::init (27.4.4.1)." Table 89 in 27.4.4.1, which gives the
postconditions of basic_ios::init(), says that tie() is 0. (Other issues correct
ios_base::init to basic_ios::init().)</p>




<hr>
<h3><a name="188"></a>188. valarray helpers missing augmented assignment operators</h3>
<p><b>Section:</b> 26.6.2.6 [valarray.cassign] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Gabriel Dos Reis <b>Opened:</b> 1999-08-15 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#valarray.cassign">issues</a> in [valarray.cassign].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>26.5.2.6 defines augmented assignment operators
valarray&lt;T&gt;::op=(const T&amp;), but fails to provide
corresponding versions for the helper classes. Thus making the
following illegal:</p>
<blockquote>
<pre>#include &lt;valarray&gt;

int main()
{
std::valarray&lt;double&gt; v(3.14, 1999);

v[99] *= 2.0; // Ok

std::slice s(0, 50, 2);

v[s] *= 2.0; // ERROR
}</pre>
</blockquote>
<p>I can't understand the intent of that omission.  It makes the
valarray library less intuitive and less useful.</p>


<p><b>Rationale:</b></p>
<p>Although perhaps an unfortunate
design decision, the omission is not a defect in the current
standard.&nbsp; A future standard may wish to add the missing
operators.</p>




<hr>
<h3><a name="190"></a>190. min() and max() functions should be std::binary_functions</h3>
<p><b>Section:</b> 25.4.7 [alg.min.max] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Mark Rintoul <b>Opened:</b> 1999-08-26 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.min.max">issues</a> in [alg.min.max].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Both std::min and std::max are defined as template functions.  This
is very different than the definition of std::plus (and similar
structs) which are defined as function objects which inherit
std::binary_function.<br>
<br>
        This lack of inheritance leaves std::min and std::max somewhat useless in standard library algorithms which require
a function object that inherits std::binary_function.</p>

<p><i>[
post Bellevue:  Alisdair requested to re-Open.
]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
C++0x has lambdas to address this problem now.
</p>
<p>
Moved to NAD.
</p>
</blockquote>



<p><b>Rationale:</b></p>
<p>Although perhaps an unfortunate design decision, the omission is not a defect
in the current standard.&nbsp; A future standard may wish to consider additional
function objects.</p>




<hr>
<h3><a name="191"></a>191. Unclear complexity for algorithms such as binary search</h3>
<p><b>Section:</b> 25.4.3 [alg.binary.search] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Nico Josuttis <b>Opened:</b> 1999-10-10 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.binary.search">issues</a> in [alg.binary.search].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>The complexity of binary_search() is stated as "At most
log(last-first) + 2 comparisons", which seems to say that the
algorithm has logarithmic complexity. However, this algorithms is
defined for forward iterators. And for forward iterators, the need to
step element-by-element results into linear complexity. But such a
statement is missing in the standard. The same applies to
lower_bound(), upper_bound(), and equal_range().&nbsp;<br>
<br>
However, strictly speaking the standard contains no bug here. So this
might considered to be a clarification or improvement.
</p>


<p><b>Rationale:</b></p>
<p>The complexity is expressed in terms of comparisons, and that
complexity can be met even if the number of iterators accessed is
linear. Paragraph 1 already says exactly what happens to
iterators.</p>




<hr>
<h3><a name="192"></a>192. a.insert(p,t) is inefficient and overconstrained</h3>
<p><b>Section:</b> 23.2.4 [associative.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Ed Brey <b>Opened:</b> 1999-06-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#233">233</a></p>
<p><b>Discussion:</b></p>
<p>As defined in 23.1.2, paragraph 7 (table 69), a.insert(p,t) suffers from
several problems:</p>
<table border="1" cellpadding="5">
  <tbody><tr>
    <td><b>expression</b></td>
    <td><b>return type</b></td>
    <td><b>pre/post-condition</b></td>
    <td><b>complexity</b></td>
  </tr>
  <tr>
    <td><tt>a.insert(p,t)</tt></td>
    <td><tt>iterator</tt></td>
    <td>inserts t if and only if there is no element with key equivalent to the key of 
       t in containers with unique keys; always inserts t in containers with equivalent 
       keys. always returns the iterator pointing to the element with key equivalent to 
       the key of t . iterator p is a hint pointing to where the insert should start to search.</td>
    <td>logarithmic in general, but amortized constant if t is inserted right after p .</td>
  </tr>
</tbody></table>
<p>1. For a container with unique keys, only logarithmic complexity is
guaranteed if no element is inserted, even though constant complexity is always
possible if p points to an element equivalent to t.</p>
<p>2. For a container with equivalent keys, the amortized constant complexity
guarantee is only useful if no key equivalent to t exists in the container.
Otherwise, the insertion could occur in one of multiple locations, at least one
of which would not be right after p.</p>
<p>3. By guaranteeing amortized constant complexity only when t is inserted
after p, it is impossible to guarantee constant complexity if t is inserted at
the beginning of the container. Such a problem would not exist if amortized
constant complexity was guaranteed if t is inserted before p, since there is
always some p immediately before which an insert can take place.</p>
<p>4. For a container with equivalent keys, p does not allow specification of
where to insert the element, but rather only acts as a hint for improving
performance. This negates the added functionality that p would provide if it
specified where within a sequence of equivalent keys the insertion should occur.
Specifying the insert location provides more control to the user, while
providing no disadvantage to the container implementation.</p>


<p><b>Proposed resolution:</b></p>
<p>In 23.2.4 [associative.reqmts] paragraph 7, replace the row in table 69
for a.insert(p,t) with the following two rows:</p>
<table border="1" cellpadding="5">
  <tbody><tr>
    <td><b>expression</b></td>
    <td><b>return type</b></td>
    <td><b>pre/post-condition</b></td>
    <td><b>complexity</b></td>
  </tr>
  <tr>
    <td><tt>a_uniq.insert(p,t)</tt></td>
    <td><tt>iterator</tt></td>
    <td>inserts t if and only if there is no element with key equivalent to the
      key of t. returns the iterator pointing to the element with key equivalent
      to the key of t.</td>
    <td>logarithmic in general, but amortized constant if t is inserted right
      before p or p points to an element with key equivalent to t.</td>
  </tr>
  <tr>
    <td><tt>a_eq.insert(p,t)</tt></td>
    <td><tt>iterator</tt></td>
    <td>inserts t and returns the iterator pointing to the newly inserted
      element. t is inserted right before p if doing so preserves the container
      ordering.</td>
    <td>logarithmic in general, but amortized constant if t is inserted right
      before p.</td>
  </tr>
</tbody></table>



<p><b>Rationale:</b></p>
<p>Too big a change.&nbsp; Furthermore, implementors report checking
both before p and after p, and don't want to change this behavior.</p>





<hr>
<h3><a name="194"></a>194. rdbuf() functions poorly specified</h3>
<p><b>Section:</b> 27.5.4 [ios] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Steve Clamage <b>Opened:</b> 1999-09-07 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>In classic iostreams, base class ios had an rdbuf function that returned a
pointer to the associated streambuf. Each derived class had its own rdbuf
function that returned a pointer of a type reflecting the actual type derived
from streambuf. Because in ARM C++, virtual function overrides had to have the
same return type, rdbuf could not be virtual.</p>
<p>In standard iostreams, we retain the non-virtual rdbuf function design, and
in addition have an overloaded rdbuf function that sets the buffer pointer.
There is no need for the second function to be virtual nor to be implemented in
derived classes.</p>
<p>Minor question: Was there a specific reason not to make the original rdbuf
function virtual?</p>
<p>Major problem: Friendly compilers warn about functions in derived classes
that hide base-class overloads. Any standard implementation of iostreams will
result in such a warning on each of the iostream classes, because of the
ill-considered decision to overload rdbuf only in a base class.</p>
<p>In addition, users of the second rdbuf function must use explicit
qualification or a cast to call it from derived classes. An explicit
qualification or cast to basic_ios would prevent access to any later overriding
version if there was one.</p>
<p>What I'd like to do in an implementation is add a using- declaration for the
second rdbuf function in each derived class. It would eliminate warnings about
hiding functions, and would enable access without using explicit qualification.
Such a change I don't think would change the behavior of any valid program, but
would allow invalid programs to compile:</p>
<blockquote>
  <pre> filebuf mybuf;
 fstream f;
 f.rdbuf(mybuf); // should be an error, no visible rdbuf</pre>
</blockquote>
<p>I'd like to suggest this problem as a defect, with the proposed resolution to
require the equivalent of a using-declaration for the rdbuf function that is not
replaced in a later derived class. We could discuss whether replacing the
function should be allowed.</p>


<p><b>Rationale:</b></p>
<p>For historical reasons, the standard is correct as written. There is a subtle difference between the base
class <tt> rdbuf()</tt> and derived class <tt>rdbuf()</tt>. The derived
class <tt> rdbuf()</tt> always returns the original streambuf, whereas the base class
<tt> rdbuf()</tt> will return the "current streambuf" if that has been changed by the variant you mention.</p>

<p>Permission is not required to add such an extension.  See 
17.6.4.5 [member.functions].</p>




<hr>
<h3><a name="196"></a>196. Placement new example has alignment problems</h3>
<p><b>Section:</b> 18.6.1.3 [new.delete.placement] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Herb Sutter <b>Opened:</b> 1998-12-15 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#new.delete.placement">issues</a> in [new.delete.placement].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#114">114</a></p>
<p><b>Discussion:</b></p>
<p>The example in 18.6.1.3 [new.delete.placement] paragraph 4 reads: </p>

<blockquote>

<p>[Example: This can be useful for constructing an object at a known address:<br>
<br>
<tt>&nbsp;&nbsp; char place[sizeof(Something)];<br>
&nbsp;&nbsp; Something* p = new (place) Something();<br>
<br>
</tt>end example] </p>

</blockquote>

<p>This example has potential alignment problems. </p>


<p><b>Rationale:</b></p>





<hr>
<h3><a name="197"></a>197. max_size() underspecified</h3>
<p><b>Section:</b> 20.2.5 [allocator.requirements], 23.2 [container.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Andy Sawyer <b>Opened:</b> 1999-10-21 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Must the value returned by max_size() be unchanged from call to call? </p>

<p>Must the value returned from max_size() be meaningful? </p>

<p>Possible meanings identified in lib-6827: </p>

<p>1) The largest container the implementation can support given "best
case" conditions - i.e. assume the run-time platform is "configured to
the max", and no overhead from the program itself. This may possibly
be determined at the point the library is written, but certainly no
later than compile time.<br>
<br>
2) The largest container the program could create, given "best case"
conditions - i.e. same platform assumptions as (1), but take into
account any overhead for executing the program itself. (or, roughly
"storage=storage-sizeof(program)"). This does NOT include any resource
allocated by the program. This may (or may not) be determinable at
compile time.<br>
<br>
3) The largest container the current execution of the program could
create, given knowledge of the actual run-time platform, but again,
not taking into account any currently allocated resource. This is
probably best determined at program start-up.<br>
<br>
4) The largest container the current execution program could create at
the point max_size() is called (or more correctly at the point
max_size() returns :-), given it's current environment (i.e. taking
into account the actual currently available resources). This,
obviously, has to be determined dynamically each time max_size() is
called. </p>


<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>max_size() isn't useful for very many things, and the existing
  wording is sufficiently clear for the few cases that max_size() can
  be used for.  None of the attempts to change the existing wording
  were an improvement.</p>

<p>It is clear to the LWG that the value returned by max_size() can't
  change from call to call.</p>






<hr>
<h3><a name="203"></a>203. basic_istream::sentry::sentry() is uninstantiable with ctype&lt;user-defined type&gt;</h3>
<p><b>Section:</b> 27.7.1.1.3 [istream::sentry] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Matt McClure and Dietmar Khl <b>Opened:</b> 2000-01-01 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream::sentry">issues</a> in [istream::sentry].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>27.6.1.1.2 Paragraph 4 states:</p>
<blockquote>
  <p>To decide if the character c is a whitespace character, the constructor      
     performs ''as if'' it executes the following code fragment:&nbsp;</p>
  <pre>const ctype&lt;charT&gt;&amp; ctype = use_facet&lt;ctype&lt;charT&gt; &gt;(is.getloc());
if (ctype.is(ctype.space,c)!=0)
// c is a whitespace character.</pre>
</blockquote>

<p> But Table 51 in 22.1.1.1.1 only requires an implementation to
provide specializations for ctype&lt;char&gt; and
ctype&lt;wchar_t&gt;.  If sentry's constructor is implemented using
ctype, it will be uninstantiable for a user-defined character type
charT, unless the implementation has provided non-working (since it
would be impossible to define a correct ctype&lt;charT&gt; specialization
for an arbitrary charT) definitions of ctype's virtual member
functions.</p>

<p>
It seems the intent the standard is that sentry should behave, in
every respect, not just during execution, as if it were implemented
using ctype, with the burden of providing a ctype specialization
falling on the user.  But as it is written, nothing requires the
translation of sentry's constructor to behave as if it used the above
code, and it would seem therefore, that sentry's constructor should be
instantiable for all character types.
</p>

<p> 
Note: If I have misinterpreted the intent of the standard with
respect to sentry's constructor's instantiability, then a note should
be added to the following effect:
</p>

<blockquote><p>
An implementation is forbidden from using the above code if it renders
the constructor uninstantiable for an otherwise valid character
type.
</p></blockquote>

<p>In any event, some clarification is needed.</p>



<p><b>Rationale:</b></p>
<p>It is possible but not easy to instantiate on types other than char
or wchar_t; many things have to be done first. That is by intention
and is not a defect.</p>




<hr>
<h3><a name="204"></a>204. distance(first, last) when "last" is before "first"</h3>
<p><b>Section:</b> 24.4.4 [iterator.operations] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Rintala Matti <b>Opened:</b> 2000-01-28 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iterator.operations">issues</a> in [iterator.operations].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Section 24.3.4 describes the function distance(first, last) (where first and
last are iterators) which calculates "the number of increments or
decrements needed to get from 'first' to 'last'".</p>
<p>The function should work for forward, bidirectional and random access
iterators, and there is a requirement 24.3.4.5 which states that "'last'
must be reachable from 'first'".</p>
<p>With random access iterators the function is easy to implement as "last
- first".</p>
<p>With forward iterators it's clear that 'first' must point to a place before
'last', because otherwise 'last' would not be reachable from 'first'.</p>
<p>But what about bidirectional iterators? There 'last' is reachable from
'first' with the -- operator even if 'last' points to an earlier position than
'first'. However, I cannot see how the distance() function could be implemented
if the implementation does not know which of the iterators points to an earlier
position (you cannot use ++ or -- on either iterator if you don't know which
direction is the "safe way to travel").</p>
<p>The paragraph 24.3.4.1 states that "for ... bidirectional iterators they
use ++ to provide linear time implementations". However, the ++ operator is
not mentioned in the reachability requirement. Furthermore 24.3.4.4 explicitly
mentions that distance() returns the number of increments _or decrements_,
suggesting that it could return a negative number also for bidirectional
iterators when 'last' points to a position before 'first'.</p>
<p>Is a further requirement is needed to state that for forward and
bidirectional iterators "'last' must be reachable from 'first' using the ++
operator". Maybe this requirement might also apply to random access
iterators so that distance() would work the same way for every iterator
category?</p>


<p><b>Rationale:</b></p>
<p>"Reachable" is defined in the standard in X [iterator.concepts] paragraph 6.
The definition is only in terms of operator++(). The LWG sees no defect in
the standard.</p>




<hr>
<h3><a name="205"></a>205.  numeric_limits unclear on how to determine floating point types</h3>
<p><b>Section:</b> 18.3.1.2 [numeric.limits.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Steve Cleary <b>Opened:</b> 2000-01-28 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#numeric.limits.members">issues</a> in [numeric.limits.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>In several places in 18.3.1.2 [numeric.limits.members], a member is
described as "Meaningful for all floating point types."
However, no clear method of determining a floating point type is
provided.</p>

<p>In 18.3.1.5 [numeric.special], paragraph 1 states ". . . (for
example, epsilon() is only meaningful if is_integer is
false). . ." which suggests that a type is a floating point type
if is_specialized is true and is_integer is false; however, this is
unclear.</p>

<p>When clarifying this, please keep in mind this need of users: what
exactly is the definition of floating point? Would a fixed point or
rational representation be considered one? I guess my statement here
is that there could also be types that are neither integer or
(strictly) floating point.</p>


<p><b>Rationale:</b></p>
<p>It is up to the implementor of a user define type to decide if it is a
floating point type.</p>




<hr>
<h3><a name="207"></a>207. ctype&lt;char&gt; members return clause incomplete</h3>
<p><b>Section:</b> 22.4.1.3.2 [facet.ctype.char.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Robert Klarer <b>Opened:</b> 1999-11-02 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#facet.ctype.char.members">issues</a> in [facet.ctype.char.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#153">153</a></p>
<p><b>Discussion:</b></p>
<p>
The <tt>widen</tt> and <tt>narrow</tt> member functions are described
in 22.2.1.3.2, paragraphs 9-11.  In each case we have two overloaded
signatures followed by a <b>Returns</b> clause.  The <b>Returns</b>
clause only describes one of the overloads.
</p>


<p><b>Proposed resolution:</b></p>
<p>Change the returns clause in 22.4.1.3.2 [facet.ctype.char.members]
paragraph 10 from:</p>
<p>&nbsp;&nbsp;&nbsp; Returns: do_widen(low, high, to).</p>

<p>to:</p>
<p>&nbsp;&nbsp;&nbsp; Returns: do_widen(c) or do_widen(low, high, to), 
respectively.</p>

<p>Change the returns clause in 22.4.1.3.2 [facet.ctype.char.members] paragraph 11
from:</p> 
<p>&nbsp;&nbsp;&nbsp; Returns: do_narrow(low, high, to).</p>

<p>to:</p>
<p>&nbsp;&nbsp;&nbsp; Returns: do_narrow(c) or do_narrow(low, high, to), 
respectively.</p>


<p><b>Rationale:</b></p>
<p>Subsumed by issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#153">153</a>, which addresses the same
paragraphs.</p>






<hr>
<h3><a name="213"></a>213. Math function overloads ambiguous</h3>
<p><b>Section:</b> 26.8 [c.math] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Nico Josuttis <b>Opened:</b> 2000-02-26 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#c.math">issues</a> in [c.math].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Due to the additional overloaded versions of numeric functions for
float and long double according to Section 26.5, calls such as int x;
std::pow (x, 4) are ambiguous now in a standard conforming
implementation. Current implementations solve this problem very
different (overload for all types, don't overload for float and long
double, use preprocessor, follow the standard and get
ambiguities).</p> <p>This behavior should be standardized or at least
identified as implementation defined.</p>


<p><b>Rationale:</b></p>
<p>These math issues are an
understood and accepted consequence of the design. They have
been discussed several times in the past. Users must write casts
or write floating point expressions as arguments.</p>




<hr>
<h3><a name="215"></a>215. Can a map's key_type be const?</h3>
<p><b>Section:</b> 23.2.4 [associative.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Judy Ward <b>Opened:</b> 2000-02-29 <b>Last modified:</b> 2010-10-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>A user noticed that this doesn't compile with the Rogue Wave library because
the rb_tree class declares a key_allocator, and allocator&lt;const int&gt; is
not legal, I think:</p>
<blockquote>
  <pre>map &lt; const int, ... &gt; // legal?</pre>
</blockquote>
<p>which made me wonder whether it is legal for a map's key_type to be const. In
email from Matt Austern he said:</p>
<blockquote>
<p>I'm not sure whether it's legal to declare a map with a const key type. I
hadn't thought about that question until a couple weeks ago. My intuitive
feeling is that it ought not to be allowed, and that the standard ought to say
so. It does turn out to work in SGI's library, though, and someone in the
compiler group even used it. Perhaps this deserves to be written up as an issue
too.</p>
</blockquote>


<p><b>Rationale:</b></p>
<p>The "key is assignable" requirement from table 69 in
23.2.4 [associative.reqmts] already implies the key cannot be const.</p>




<hr>
<h3><a name="216"></a>216. setbase manipulator description flawed</h3>
<p><b>Section:</b> 27.7.3 [std.manip] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Hyman Rosen <b>Opened:</b> 2000-02-29 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#std.manip">issues</a> in [std.manip].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#193">193</a></p>
<p><b>Discussion:</b></p>
<p>27.7.3 [std.manip] paragraph 5 says:</p>
<blockquote>
<pre>smanip setbase(int base);</pre>
<p> Returns: An object s of unspecified type such that if out is an
(instance of) basic_ostream then the expression out&lt;&lt;s behaves
as if f(s) were called, in is an (instance of) basic_istream then the
expression in&gt;&gt;s behaves as if f(s) were called. Where f can be
defined as:</p>
<pre>ios_base&amp; f(ios_base&amp; str, int base)
{
  // set basefield
  str.setf(n == 8 ? ios_base::oct :
                n == 10 ? ios_base::dec :
                n == 16 ? ios_base::hex :
                  ios_base::fmtflags(0), ios_base::basefield);
  return str;
}</pre>
</blockquote>
<p>There are two problems here. First, f takes two parameters, so the
description needs to say that out&lt;&lt;s and in&gt;&gt;s behave as if f(s,base)
had been called. Second, f is has a parameter named base, but is written as if
the parameter was named n.</p>
<p>Actually, there's a third problem. The paragraph has grammatical errors.
There needs to be an "and" after the first comma, and the "Where
f" sentence fragment needs to be merged into its preceding sentence. You
may also want to format the function a little better. The formatting above is
more-or-less what the Standard contains.</p>


<p><b>Rationale:</b></p>
<p>The resolution of this defect is subsumed by the proposed resolution for
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#193">193</a>.</p>

<p><i>[Tokyo: The LWG agrees that this is a defect and notes that it
occurs additional places in the section, all requiring fixes.]</i></p>








<hr>
<h3><a name="218"></a>218. Algorithms do not use binary predicate objects for default comparisons</h3>
<p><b>Section:</b> 25.4 [alg.sorting] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Pablo Halpern <b>Opened:</b> 2000-03-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.sorting">issues</a> in [alg.sorting].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Many of the algorithms take an argument, pred, of template parameter type
BinaryPredicate or an argument comp of template parameter type Compare. These
algorithms usually have an overloaded version that does not take the predicate
argument. In these cases pred is usually replaced by the use of operator== and
comp is replaced by the use of operator&lt;.</p>
<p>This use of hard-coded operators is inconsistent with other parts of the
library, particularly the containers library, where equality is established
using equal_to&lt;&gt; and ordering is established using less&lt;&gt;. Worse,
the use of operator&lt;, would cause the following innocent-looking code to have
undefined behavior:</p>
<blockquote>
  <pre>vector&lt;string*&gt; vec;
sort(vec.begin(), vec.end());</pre>
</blockquote>
<p>The use of operator&lt; is not defined for pointers to unrelated objects. If
std::sort used less&lt;&gt; to compare elements, then the above code would be
well-defined, since less&lt;&gt; is explicitly specialized to produce a total
ordering of pointers.</p>


<p><b>Rationale:</b></p>
<p>This use of operator== and operator&lt; was a very deliberate, conscious, and
explicitly made design decision; these operators are often more efficient. The
predicate forms are available for users who don't want to rely on operator== and
operator&lt;.</p>




<hr>
<h3><a name="219"></a>219. find algorithm missing version that takes a binary predicate argument</h3>
<p><b>Section:</b> 25.2.5 [alg.find] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Pablo Halpern <b>Opened:</b> 2000-03-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.find">issues</a> in [alg.find].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>The find function always searches for a value using operator== to compare the
value argument to each element in the input iterator range. This is inconsistent
with other find-related functions such as find_end and find_first_of, which
allow the caller to specify a binary predicate object to be used for determining
equality. The fact that this can be accomplished using a combination of find_if
and bind_1st or bind_2nd does not negate the desirability of a consistent,
simple, alternative interface to find.</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Reopened by Alisdair.
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
The same thing can be achieved using find_if (as noted in the issue).
</p>
<p>
Moved to NAD.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<blockquote>
<p>In section 25.2.5 [alg.find], add a second prototype for find
(between the existing prototype and the prototype for find_if), as
follows:</p>
<pre>    template&lt;class InputIterator, class T, class BinaryPredicate&gt;
      InputIterator find(InputIterator first, InputIterator last,
                         const T&amp; value, BinaryPredicate bin_pred);</pre>
<p>Change the description of the return from:</p>
<blockquote>
  <p>Returns: The first iterator i in the range [first, last) for which the following corresponding
  conditions hold: *i == value, pred(*i) != false. Returns last if no such iterator is found.</p>
</blockquote>
<p>&nbsp;to:</p>
<blockquote>
  <p>Returns: The first iterator i in the range [first, last) for which the following&nbsp;
  corresponding condition holds: *i == value, bin_pred(*i,value) != false, pred(*)
  != false. Return last if no such iterator is found.</p>
</blockquote>
</blockquote>


<p><b>Rationale:</b></p>
<p>This is request for a pure extension, so it is not a defect in the
current standard.&nbsp; As the submitter pointed out, "this can
be accomplished using a combination of find_if and bind_1st or
bind_2nd".</p>




<hr>
<h3><a name="236"></a>236. ctype&lt;char&gt;::is() member modifies facet</h3>
<p><b>Section:</b> 22.4.1.3.2 [facet.ctype.char.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 2000-04-24 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#facet.ctype.char.members">issues</a> in [facet.ctype.char.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#28">28</a></p>
<p><b>Discussion:</b></p>
<p>The description of the <tt>is()</tt> member in paragraph 4 of 22.4.1.3.2 [facet.ctype.char.members] is broken: According to this description, the
second form of the <tt>is()</tt> method modifies the masks in the
<tt>ctype</tt> object. The correct semantics if, of course, to obtain
an array of masks. The corresponding method in the general case,
ie. the <tt>do_is()</tt> method as described in 22.4.1.1.2 [locale.ctype.virtuals] paragraph 1 does the right thing.</p>


<p><b>Proposed resolution:</b></p>
  <p>Change paragraph 4 from</p>
    <blockquote><p>
    The second form, for all *p in the range [low, high), assigns
    vec[p-low] to table()[(unsigned char)*p].
    </p></blockquote>
  <p>to become</p>
    <blockquote><p>
    The second form, for all *p in the range [low, high), assigns
    table()[(unsigned char)*p] to vec[p-low].
  </p></blockquote>


<p><b>Rationale:</b></p>





<hr>
<h3><a name="244"></a>244. Must <tt>find</tt>'s third argument be CopyConstructible?</h3>
<p><b>Section:</b> 25.2.5 [alg.find] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Andrew Koenig <b>Opened:</b> 2000-05-02 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.find">issues</a> in [alg.find].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Is the following implementation of <tt>find</tt> acceptable?</p>

<pre>        template&lt;class Iter, class X&gt;
        Iter find(Iter begin, Iter end, const X&amp; x)
        {
            X x1 = x;           // this is the crucial statement
            while (begin != end &amp;&amp; *begin != x1)
                ++begin;
            return begin;
        }
</pre>

<p>If the answer is yes, then it is implementation-dependent as to
whether the following fragment is well formed:</p>

<pre>        vector&lt;string&gt; v;

        find(v.begin(), v.end(), "foo");
</pre>

<p>At issue is whether there is a requirement that the third argument
of find be CopyConstructible.  There may be no problem here, but
analysis is necessary.</p>


<p><b>Rationale:</b></p>
<p>There is no indication in the standard that find's third argument
is required to be Copy Constructible.  The LWG believes that no such
requirement was intended.  As noted above, there are times when a user
might reasonably pass an argument that is not Copy Constructible.</p>




<hr>
<h3><a name="245"></a>245. Which operations on <tt>istream_iterator</tt> trigger input operations?</h3>
<p><b>Section:</b> 24.6.1 [istream.iterator] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Andrew Koenig <b>Opened:</b> 2000-05-02 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream.iterator">issues</a> in [istream.iterator].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>I do not think the standard specifies what operation(s) on istream
iterators trigger input operations.  So, for example:</p>

<pre>        istream_iterator&lt;int&gt; i(cin);

        int n = *i++;
</pre>

<p>I do not think it is specified how many integers have been read
from cin.  The number must be at least 1, of course, but can it be 2?
More?</p>


<p><b>Rationale:</b></p>
<p>The standard is clear as written: the stream is read every time
operator++ is called, and it is also read either when the iterator is
constructed or when operator* is called for the first time.  In the
example above, exactly two integers are read from cin.</p>

<p>There may be a problem with the interaction between istream_iterator
and some STL algorithms, such as find.  There are no guarantees about
how many times find may invoke operator++.</p>




<hr>
<h3><a name="246"></a>246. <tt>a.insert(p,t)</tt> is incorrectly specified</h3>
<p><b>Section:</b> 23.2.4 [associative.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Mark Rodgers <b>Opened:</b> 2000-05-19 <b>Last modified:</b> 2010-10-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#233">233</a></p>
<p><b>Discussion:</b></p>
<p>Closed issue 192 raised several problems with the specification of
this function, but was rejected as Not A Defect because it was too big
a change with unacceptable impacts on existing implementations.
However, issues remain that could be addressed with a smaller change
and with little or no consequent impact.</p>

<ol>
   <li><p> The specification is inconsistent with the original
   proposal and with several implementations.</p>

   <p>The initial implementation by Hewlett Packard only ever looked
   immediately <i>before</i> p, and I do not believe there was any
   intention to standardize anything other than this behavior.
   Consequently, current implementations by several leading
   implementors also look immediately before p, and will only insert
   after p in logarithmic time.  I am only aware of one implementation
   that does actually look after p, and it looks before p as well.  It
   is therefore doubtful that existing code would be relying on the
   behavior defined in the standard, and it would seem that fixing
   this defect as proposed below would standardize existing
   practice.</p></li>

   <li><p>
   The specification is inconsistent with insertion for sequence
   containers.</p>

   <p>This is difficult and confusing to teach to newcomers.  All
   insert operations that specify an iterator as an insertion location
   should have a consistent meaning for the location represented by
   that iterator.</p></li>

   <li><p> As specified, there is no way to hint that the insertion
   should occur at the beginning of the container, and the way to hint
   that it should occur at the end is long winded and unnatural.</p>

   <p>For a container containing n elements, there are n+1 possible
   insertion locations and n+1 valid iterators.  For there to be a
   one-to-one mapping between iterators and insertion locations, the
   iterator must represent an insertion location immediately before
   the iterator.</p></li>

   <li><p> When appending sorted ranges using insert_iterators,
   insertions are guaranteed to be sub-optimal.</p>

   <p>In such a situation, the optimum location for insertion is
   always immediately after the element previously inserted.  The
   mechanics of the insert iterator guarantee that it will try and
   insert after the element after that, which will never be correct.
   However, if the container first tried to insert before the hint,
   all insertions would be performed in amortized constant
   time.</p></li>
</ol>


<p><b>Proposed resolution:</b></p>
<p>In 23.1.2 [lib.associative.reqmts] paragraph 7, table 69, make
the following changes in the row for a.insert(p,t):</p>

<p><i>assertion/note pre/post condition:</i>
<br>Change the last sentence from</p>
     <blockquote><p>
     "iterator p is a hint pointing to where the insert should
     start to search."
     </p></blockquote>
<p>to</p>
     <blockquote><p>
     "iterator p is a hint indicating that immediately before p
     may be a correct location where the insertion could occur."
     </p></blockquote>

<p><i>complexity:</i><br>
Change the words "right after" to "immediately before".</p>


<p><b>Rationale:</b></p>





<hr>
<h3><a name="249"></a>249. Return Type of <tt>auto_ptr::operator=</tt></h3>
<p><b>Section:</b> D.12.1 [auto.ptr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Joseph Gottman <b>Opened:</b> 2000-06-30 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#auto.ptr">issues</a> in [auto.ptr].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>According to section 20.4.5, the function
<tt>auto_ptr::operator=()</tt> returns a reference to an auto_ptr.
The reason that <tt>operator=()</tt> usually returns a reference is to
facilitate code like</p>

<pre>    int x,y,z;
    x = y = z = 1;
</pre>

<p>However, given analogous code for <tt>auto_ptr</tt>s,</p>
<pre>    auto_ptr&lt;int&gt; x, y, z;
    z.reset(new int(1));
    x = y = z;
</pre>

<p>the result would be that <tt>z</tt> and <tt>y</tt> would both be set to 
NULL, instead of all the <tt>auto_ptr</tt>s being set to the same value. 
This makes such cascading assignments useless and counterintuitive for 
<tt>auto_ptr</tt>s.</p>


<p><b>Proposed resolution:</b></p>
<p>Change <tt>auto_ptr::operator=()</tt> to return <tt>void</tt> instead
of an <tt>auto_ptr</tt> reference.</p>


<p><b>Rationale:</b></p>
<p>The return value has uses other than cascaded assignments: a user can
call an auto_ptr member function, pass the auto_ptr to a
function, etc.  Removing the return value could break working user
code.</p>




<hr>
<h3><a name="255"></a>255. Why do <tt>basic_streambuf&lt;&gt;::pbump()</tt> and <tt>gbump()</tt> take an int?</h3>
<p><b>Section:</b> 27.6.2 [streambuf] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Future">NAD Future</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2000-08-12 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#streambuf">issues</a> in [streambuf].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The basic_streambuf members gbump() and pbump() are specified to take an
int argument. This requirement prevents the functions from effectively
manipulating buffers larger than std::numeric_limits&lt;int&gt;::max()
characters. It also makes the common use case for these functions
somewhat difficult as many compilers will issue a warning when an
argument of type larger than int (such as ptrdiff_t on LLP64
architectures) is passed to either of the function. Since it's often the
result of the subtraction of two pointers that is passed to the
functions, a cast is necessary to silence such warnings. Finally, the
usage of a native type in the functions signatures is inconsistent with
other member functions (such as sgetn() and sputn()) that manipulate the
underlying character buffer. Those functions take a streamsize argument.
</p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
This is part of a bigger problem. If anyone cares enough, they should
write a paper solving the bigger problem of offset types in iostreams.
</p>
<p>
This is related to the paper about large file sizes. Beman has already
agreed to drop the section of that paper that deals with this.
</p>
<p>
int is big enough for reasonable buffers.
</p>
<p>
Move to NAD Future.
</p>
<p>
This is related to LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#423">423</a>.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change the signatures of these functions in the synopsis of template
class basic_streambuf (27.5.2) and in their descriptions (27.5.2.3.1, p4
and 27.5.2.3.2, p4) to take a streamsize argument.
</p>

<p>
Although this change has the potential of changing the ABI of the
library, the change will affect only platforms where int is different
than the definition of streamsize. However, since both functions are
typically inline (they are on all known implementations), even on such
platforms the change will not affect any user code unless it explicitly
relies on the existing type of the functions (e.g., by taking their
address). Such a possibility is IMO quite remote.
</p>

<p>
Alternate Suggestion from Howard Hinnant, c++std-lib-7780:
</p>

<p>
This is something of a nit, but I'm wondering if streamoff wouldn't be a 
better choice than streamsize.  The argument to pbump and gbump MUST be 
signed.  But the standard has this to say about streamsize 
(27.4.1/2/Footnote):
</p>

<blockquote><p>
     [Footnote: streamsize is used in most places where ISO C would use
     size_t.  Most of the uses of streamsize could use size_t, except for
     the strstreambuf constructors, which require negative values. It
     should probably be the signed type corresponding to size_t (which is
     what Posix.2 calls ssize_t). --- end footnote]
</p></blockquote>

<p>
This seems a little weak for the argument to pbump and gbump.  Should we 
ever really get rid of strstream, this footnote might go with it, along 
with the reason to make streamsize signed.
</p>


<p><b>Rationale:</b></p>
<p>The LWG believes this change is too big for now.  We may wish to
reconsider this for a future revision of the standard.  One
possibility is overloading pbump, rather than changing the
signature.</p>
<p><i>[
[2006-05-04: Reopened at the request of Chris (Krzysztof ?elechowski)]
]</i></p>





<hr>
<h3><a name="257"></a>257. STL functional object and iterator inheritance.</h3>
<p><b>Section:</b> X [base], 24.4.2 [iterator.basic] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Robert Dick  <b>Opened:</b> 2000-08-17 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#base">issues</a> in [base].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
According to the November 1997 Draft Standard, the results of deleting an
object of a derived class through a pointer to an object of its base class are
undefined if the base class has a non-virtual destructor.  Therefore, it is
potentially dangerous to publicly inherit from such base classes.
</p>

<p>Defect:
<br>
The STL design encourages users to publicly inherit from a number of classes
which do nothing but specify interfaces, and which contain non-virtual
destructors.
</p>

<p>Attribution:
<br>
Wil Evers and William E. Kempf suggested this modification for functional
objects.
</p>


<p><b>Proposed resolution:</b></p>
<p>
When a base class in the standard library is useful only as an interface
specifier, i.e., when an object of the class will never be directly
instantiated, specify that the class contains a protected destructor.  This
will prevent deletion through a pointer to the base class without performance,
or space penalties (on any implementation I'm aware of).
</p>

<p>
As an example, replace...
</p>

<pre>    template &lt;class Arg, class Result&gt;
    struct unary_function {
            typedef Arg    argument_type;
            typedef Result result_type;
    };
</pre>

<p>
... with...
</p>

<pre>    template &lt;class Arg, class Result&gt;
    struct unary_function {
            typedef Arg    argument_type;
            typedef Result result_type;
    protected:
            ~unary_function() {}
    };
</pre>

<p>
Affected definitions:
<br>
  &nbsp;20.3.1 [lib.function.objects] -- unary_function, binary_function
  <br>
  &nbsp;24.3.2 [lib.iterator.basic] -- iterator
</p>


<p><b>Rationale:</b></p>
<p>
The standard is clear as written; this is a request for change, not a
defect in the strict sense.  The LWG had several different objections
to the proposed change.  One is that it would prevent users from
creating objects of type <tt>unary_function</tt> and
<tt>binary_function</tt>.  Doing so can sometimes be legitimate, if users
want to pass temporaries as traits or tag types in generic code.
</p>





<hr>
<h3><a name="267"></a>267. interaction of strstreambuf::overflow() and seekoff()</h3>
<p><b>Section:</b> D.9.1.3 [depr.strstreambuf.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2000-10-05 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#depr.strstreambuf.virtuals">issues</a> in [depr.strstreambuf.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It appears that the interaction of the strstreambuf members overflow()
and seekoff() can lead to undefined behavior in cases where defined
behavior could reasonably be expected. The following program
demonstrates this behavior:
</p>

<pre>    #include &lt;strstream&gt;

    int main ()
    {
         std::strstreambuf sb;
         sb.sputc ('c');

         sb.pubseekoff (-1, std::ios::end, std::ios::in);
         return !('c' == sb.sgetc ());
    }
</pre>

<p>
D.7.1.1, p1 initializes strstreambuf with a call to basic_streambuf&lt;&gt;(),
which in turn sets all pointers to 0 in 27.5.2.1, p1.
</p>
 
<p>
27.5.2.2.5, p1 says that basic_streambuf&lt;&gt;::sputc(c) calls
overflow(traits::to_int_type(c)) if a write position isn't available (it
isn't due to the above).
</p>

<p>
D.7.1.3, p3 says that strstreambuf::overflow(off, ..., ios::in) makes at
least one write position available (i.e., it allows the function to make
any positive number of write positions available).
</p>

<p>
D.7.1.3, p13 computes newoff = seekhigh - eback(). In D.7.1, p4 we see
seekhigh = epptr() ? epptr() : egptr(), or seekhigh = epptr() in this
case. newoff is then epptr() - eback().
</p>

<p>
D.7.1.4, p14 sets gptr() so that gptr() == eback() + newoff + off, or
gptr() == epptr() + off holds.
</p>

<p>
If strstreambuf::overflow() made exactly one write position available
then gptr() will be set to just before epptr(), and the program will
return 0. Buf if the function made more than one write position
available, epptr() and gptr() will both point past pptr() and the
behavior of the program is undefined.
</p>


<p><b>Proposed resolution:</b></p>


   <p>Change the last sentence of D.9.1 [depr.strstreambuf] paragraph 4 from</p>

      <blockquote><p>
      Otherwise, seeklow equals gbeg and seekhigh is either pend, if
      pend is not a null pointer, or gend.
      </p></blockquote>

   <p>to become</p>

      <blockquote><p>
      Otherwise, seeklow equals gbeg and seekhigh is either gend if
      0 == pptr(), or pbase() + max where max is the maximum value of
      pptr() - pbase() ever reached for this stream.
      </p></blockquote>

<p><i>[
  pre-Copenhagen: Dietmar provided wording for proposed resolution.
]</i></p>


<p><i>[
  post-Copenhagen: Fixed a typo: proposed resolution said to fix
  4.7.1, not D.7.1.
]</i></p>




<p><b>Rationale:</b></p>
<p>This is related to issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#65">65</a>: it's not clear what it
means to seek beyond the current area.  Without resolving issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#65">65</a> we can't resolve this.  As with issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#65">65</a>, 
the library working group does not wish to invest time nailing down
corner cases in a deprecated feature.</p>





<hr>
<h3><a name="269"></a>269. cstdarg and unnamed parameters</h3>
<p><b>Section:</b> 18.8 [support.exception] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> J. Stephen Adamczyk <b>Opened:</b> 2000-10-10 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#support.exception">issues</a> in [support.exception].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
One of our customers asks whether this is valid C++:
</p>

<pre>   #include &lt;cstdarg&gt;

   void bar(const char *, va_list);

   void
   foo(const char *file, const char *, ...)
   {
     va_list ap;
     va_start(ap, file);
     bar(file, ap);
     va_end(ap);
   }
</pre>

<p>
The issue being whether it is valid to use cstdarg when the final
parameter before the "..." is unnamed.  cstdarg is, as far
as I can tell, inherited verbatim from the C standard. and the
definition there (7.8.1.1 in the ISO C89 standard) refers to "the
identifier of the rightmost parameter".  What happens when there
is no such identifier?
</p>

<p>
My personal opinion is that this should be allowed, but some tweak
might be required in the C++ standard.
</p>


<p><b>Rationale:</b></p>
<p>
Not a defect, the C and C++ standards are clear.  It is impossible to
use varargs if the parameter immediately before "..." has no
name, because that is the parameter that must be passed to va_start.
The example given above is broken, because va_start is being passed
the wrong parameter.
</p>

<p>
There is no support for extending varargs to provide additional
functionality beyond what's currently there.  For reasons of C/C++
compatibility, it is especially important not to make gratuitous
changes in this part of the C++ standard.  The C committee has already
been requested not to touch this part of the C standard unless
necessary.
</p>




<hr>
<h3><a name="277"></a>277. Normative encouragement in allocator requirements unclear</h3>
<p><b>Section:</b> 20.2.5 [allocator.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2000-11-07 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 20.1.5, paragraph 5, the standard says that "Implementors are
encouraged to supply libraries that can accept allocators that
encapsulate more general memory models and that support non-equal
instances." This is intended as normative encouragement to
standard library implementors.  However, it is possible to interpret
this sentence as applying to nonstandard third-party libraries.
</p>


<p><b>Proposed resolution:</b></p>
<p>
In 20.1.5, paragraph 5, change "Implementors" to
"Implementors of the library described in this International
Standard".
</p>


<p><b>Rationale:</b></p>
<p>The LWG believes the normative encouragement is already
sufficiently clear, and that there are no important consequences
even if it is misunderstood.</p>





<hr>
<h3><a name="279"></a>279. const and non-const iterators should have equivalent typedefs</h3>
<p><b>Section:</b> 23.2 [container.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Steve Cleary <b>Opened:</b> 2000-11-27 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
This came from an email from Steve Cleary to Fergus in reference to
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#179">179</a>. The library working group briefly discussed
this in Toronto and believes it should be a separate issue.
</p>

<p>
Steve said: "We may want to state that the const/non-const iterators must have
the same difference type, size_type, and category."
</p>

<p>
(Comment from Judy)
I'm not sure if the above sentence should be true for all
const and non-const iterators in a particular container, or if it means 
the container's iterator can't be compared with the container's
const_iterator unless the above it true. I suspect the former.
</p>


<p><b>Proposed resolution:</b></p>
<p>
In <b>Section:</b> 23.2 [container.requirements],
table 65, in the assertion/note pre/post condition for X::const_iterator,
add the following:
</p>

<blockquote>
<p>
typeid(X::const_iterator::difference_type) == typeid(X::iterator::difference_type)
</p>

<p>
typeid(X::const_iterator::size_type) == typeid(X::iterator::size_type)
</p>

<p>
typeid(X::const_iterator::category) == typeid(X::iterator::category)
</p>
</blockquote>


<p><b>Rationale:</b></p>
<p>Going through the types one by one: Iterators don't have a
<tt>size_type</tt>.  We already know that the difference types are
identical, because the container requirements already say that the
difference types of both X::iterator and X::const_iterator are both
X::difference_type.  The standard does not require that X::iterator
and X::const_iterator have the same iterator category, but the LWG
does not see this as a defect: it's possible to imagine cases in which
it would be useful for the categories to be different.</p>

<p>It may be desirable to require X::iterator and X::const_iterator to
have the same value type, but that is a new issue. (Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#322">322</a>.)</p>






<hr>
<h3><a name="287"></a>287. conflicting ios_base fmtflags</h3>
<p><b>Section:</b> 27.5.2.2 [fmtflags.state] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Judy Ward <b>Opened:</b> 2000-12-30 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#fmtflags.state">issues</a> in [fmtflags.state].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The Effects clause for ios_base::setf(fmtflags fmtfl) says
"Sets fmtfl in flags()".  What happens if the user first calls
ios_base::scientific and then calls ios_base::fixed or vice-versa?
This is an issue for all of the conflicting flags, i.e. ios_base::left
and ios_base::right or ios_base::dec, ios_base::hex and ios_base::oct.
</p>

<p>
I see three possible solutions: 
</p>

<ol>
<li>Set ios_base::failbit whenever the user specifies a conflicting
flag with one previously explicitly set. If the constructor is
supposed to set ios_base::dec (see discussion below), then
the user setting hex or oct format after construction will not
set failbit. </li>
<li>The last call to setf "wins", i.e. it clears any conflicting
previous setting.</li>
<li>All the flags that the user specifies are set, but when actually 
interpreting them, fixed always override scientific, right always 
overrides left, dec overrides hex which overrides oct.</li>
</ol>

<p>
Most existing implementations that I tried seem to conform to resolution #3,
except that when using the iomanip manipulator hex or oct then that always 
overrides dec, but calling setf(ios_base::hex) doesn't. 
</p>

<p>
There is a sort of related issue, which is that although the ios_base
constructor says that each ios_base member has an indeterminate value
after construction, all the existing implementations I tried explicitly set 
ios_base::dec.
</p>


<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>
<tt>adjustfield</tt>, <tt>basefield</tt>, and <tt>floatfield</tt>
are each multi-bit fields.  It is possible to set multiple bits within
each of those fields.  (For example, <tt>dec</tt> and
<tt>oct</tt>). These fields are used by locale facets.  The LWG
reviewed the way in which each of those three fields is used, and
believes that in each case the behavior is well defined for any
possible combination of bits.  See for example Table 58, in 22.4.2.2.2 [facet.num.put.virtuals], noting the requirement in paragraph 6 of that
section.
</p>
<p>
Users are advised to use manipulators, or else use the two-argument
version of <tt>setf</tt>, to avoid unexpected behavior.
</p>





<hr>
<h3><a name="289"></a>289. &lt;cmath&gt; requirements missing C float and long double versions</h3>
<p><b>Section:</b> 26.8 [c.math] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Judy Ward <b>Opened:</b> 2000-12-30 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#c.math">issues</a> in [c.math].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
    In ISO/IEC 9899:1990 Programming Languages C we find the following
    concerning &lt;math.h&gt;:
</p>

<blockquote><p>
         7.13.4 Mathematics &lt;math.h&gt;
         <br>
         The names of all existing functions declared in the &lt;math.h&gt;
         header, suffixed with f or l, are reserved respectively for
         corresponding functions with float and long double arguments
         are return values.
</p></blockquote>

<p>
    For example, <tt>float&nbsp;sinf(float)</tt>
    is reserved.
</p>

<p>
    In the C99 standard, &lt;math.h&gt; must contain declarations
    for these functions.
</p>

<p>
So, is it acceptable for an implementor to add these prototypes to the
C++ versions of the math headers? Are they required?
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add these Functions to Table 80, section 26.5 and to Table 99,
section C.2:
</p>

<pre>    acosf asinf atanf atan2f ceilf cosf coshf 
    expf fabsf floorf fmodf frexpf ldexpf 
    logf log10f modff powf sinf sinhf sqrtf 
    tanf tanhf 
    acosl asinl atanl atan2l ceill cosl coshl 
    expl fabsl floorl fmodl frexpl ldexpl 
    logl log10l modfl powl sinl sinhl sqrtl 
    tanl tanhl
</pre>

<p>
There should probably be a note saying that these functions
are optional and, if supplied, should match the description in
the 1999 version of the C standard. In the next round
of C++ standardization they can then become mandatory. 
</p>


<p><b>Rationale:</b></p>
<p>The C90 standard, as amended, already permits (but does not
require) these functions, and the C++ standard incorporates the
C90 standard by reference.  C99 is not an issue, because it is
never referred to by the C++ standard.</p>





<hr>
<h3><a name="290"></a>290. Requirements to for_each and its function object</h3>
<p><b>Section:</b> 25.2.4 [alg.foreach] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Angelika Langer <b>Opened:</b> 2001-01-03 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.foreach">issues</a> in [alg.foreach].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>The specification of the for_each algorithm does not have a
"Requires" section, which means that there are no
restrictions imposed on the function object whatsoever. In essence it
means that I can provide any function object with arbitrary side
effects and I can still expect a predictable result. In particular I
can expect that the function object is applied exactly last - first
times, which is promised in the "Complexity" section.
</p>

<p>I don't see how any implementation can give such a guarantee
without imposing requirements on the function object.
</p>

<p>Just as an example: consider a function object that removes
elements from the input sequence.  In that case, what does the
complexity guarantee (applies f exactly last - first times) mean?
</p>

<p>One can argue that this is obviously a nonsensical application and
a theoretical case, which unfortunately it isn't.  I have seen
programmers shooting themselves in the foot this way, and they did not
understand that there are restrictions even if the description of the
algorithm does not say so.
</p>
<p><i>[Lillehammer: This is more general than for_each.  We don't want
  the function object in transform invalidiating iterators
  either. There should be a note somewhere in clause 17 (17, not 25)
  saying that user code operating on a range may not invalidate
  iterators unless otherwise specified.  Bill will provide wording.]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
Moved to NAD.
</p>
<p>
It was felt that the current description is adequate, and that there are
limits to what the standard can reasonably say to prohibit perverse uses
of the library.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>






<hr>
<h3><a name="293"></a>293. Order of execution in transform algorithm</h3>
<p><b>Section:</b> 25.3.4 [alg.transform] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Angelika Langer <b>Opened:</b> 2001-01-04 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.transform">issues</a> in [alg.transform].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>This issue is related to issue 242.  In case that the resolution
proposed for issue 242 is accepted, we have have the following
situation: The 4 numeric algorithms (accumulate and consorts) as well
as transform would allow a certain category of side effects.  The
numeric algorithms specify that they invoke the functor "for
every iterator i in the range [first, last) in order". transform,
in contrast, would not give any guarantee regarding order of
invocation of the functor, which means that the functor can be invoked
in any arbitrary order.
</p>

<p>Why would that be a problem?  Consider an example: say the
transformator that is a simple enumerator ( or more generally
speaking, "is order-sensitive" ).  Since a standard
compliant implementation of transform is free to invoke the enumerator
in no definite order, the result could be a garbled enumeration.
Strictly speaking this is not a problem, but it is certainly at odds
with the prevalent understanding of transform as an algorithms that
assigns "a new _corresponding_ value" to the output
elements.
</p>

<p>All implementations that I know of invoke the transformator in
definite order, namely starting from first and proceeding to last -
1. Unless there is an optimization conceivable that takes advantage of
the indefinite order I would suggest to specify the order, because it
eliminate the uncertainty that users would otherwise have regarding
the order of execution of their potentially order-sensitive function
objects.
</p>


<p><b>Proposed resolution:</b></p>
<p>In section 25.2.3 - Transform [lib.alg.transform] change:</p>
<blockquote><p>
-1- Effects: Assigns through every iterator i in the range [result,
result + (last1 - first1)) a new corresponding
value equal to op(*(first1 + (i - result)) or binary_op(*(first1 +
(i - result), *(first2 + (i - result))).
</p></blockquote>
<p>to:</p>
<blockquote><p>
-1- Effects: Computes values by  invoking the operation op or binary_op 
for every iterator in the range [first1, last1) in order. Assigns through
every iterator i in the range [result, result + (last1 - first1)) a new
corresponding
value equal to op(*(first1 + (i - result)) or binary_op(*(first1 +
(i - result), *(first2 + (i - result))).
</p></blockquote>


<p><b>Rationale:</b></p>
<p>For Input Iterators an order is already guaranteed, because
only one order is possible.  If a user who passes a Forward
Iterator to one of these algorithms really needs a specific
order of execution, it's possible to achieve that effect by
wrapping it in an Input Iterator adaptor.</p>





<hr>
<h3><a name="299"></a>299. Incorrect return types for iterator dereference</h3>
<p><b>Section:</b> 24.2.6 [bidirectional.iterators], 24.2.7 [random.access.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> John Potter <b>Opened:</b> 2001-01-22 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#bidirectional.iterators">issues</a> in [bidirectional.iterators].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In section 24.2.6 [bidirectional.iterators],
Table 75 gives the return type of *r-- as convertible to T.  This is
not consistent with Table 74 which gives the return type of *r++ as
T&amp;.  *r++ = t is valid while *r-- = t is invalid.
</p>

<p>
In section 24.2.7 [random.access.iterators],
Table 76 gives the return type of a[n] as convertible to T.  This is
not consistent with the semantics of *(a + n) which returns T&amp; by
Table 74.  *(a + n) = t is valid while a[n] = t is invalid.
</p>

<p>
Discussion from the Copenhagen meeting: the first part is
uncontroversial.  The second part, operator[] for Random Access
Iterators, requires more thought.  There are reasonable arguments on
both sides.  Return by value from operator[] enables some potentially
useful iterators, e.g. a random access "iota iterator" (a.k.a
"counting iterator" or "int iterator").  There isn't any obvious way
to do this with return-by-reference, since the reference would be to a
temporary.  On the other hand, <tt>reverse_iterator</tt> takes an
arbitrary Random Access Iterator as template argument, and its
operator[] returns by reference.  If we decided that the return type
in Table 76 was correct, we would have to change
<tt>reverse_iterator</tt>.  This change would probably affect user
code.
</p>

<p>
History: the contradiction between <tt>reverse_iterator</tt> and the
Random Access Iterator requirements has been present from an early
stage.  In both the STL proposal adopted by the committee
(N0527==94-0140) and the STL technical report (HPL-95-11 (R.1), by
Stepanov and Lee), the Random Access Iterator requirements say that
operator[]'s return value is "convertible to T".  In N0527
reverse_iterator's operator[] returns by value, but in HPL-95-11
(R.1), and in the STL implementation that HP released to the public,
reverse_iterator's operator[] returns by reference.  In 1995, the
standard was amended to reflect the contents of HPL-95-11 (R.1).  The
original intent for operator[] is unclear.
</p>

<p>
In the long term it may be desirable to add more fine-grained 
iterator requirements, so that access method and traversal strategy
can be decoupled.  (See "Improved Iterator Categories and
Requirements", N1297 = 01-0011, by Jeremy Siek.)  Any decisions
about issue 299 should keep this possibility in mind.
</p>

<p>Further discussion: I propose a compromise between John Potter's
resolution, which requires <tt>T&amp;</tt> as the return type of
<tt>a[n]</tt>, and the current wording, which requires convertible to
<tt>T</tt>. The compromise is to keep the convertible to <tt>T</tt>
for the return type of the expression <tt>a[n]</tt>, but to also add
<tt>a[n] = t</tt> as a valid expression. This compromise "saves" the
common case uses of random access iterators, while at the same time
allowing iterators such as counting iterator and caching file
iterators to remain random access iterators (iterators where the
lifetime of the object returned by <tt>operator*()</tt> is tied to the
lifetime of the iterator).
</p>

<p>
Note that the compromise resolution necessitates a change to
<tt>reverse_iterator</tt>. It would need to use a proxy to support
<tt>a[n] = t</tt>.
</p>

<p>
Note also there is one kind of mutable random access iterator that
will no longer meet the new requirements. Currently, iterators that
return an r-value from <tt>operator[]</tt> meet the requirements for a
mutable random access iterartor, even though the expression <tt>a[n] =
t</tt> will only modify a temporary that goes away. With this proposed
resolution, <tt>a[n] = t</tt> will be required to have the same
operational semantics as <tt>*(a + n) = t</tt>.
</p>

<p><i>[
2009-07-28 Reopened by Alisdair.  No longer solved by concepts.
]</i></p>


<p><i>[
2009-09-18 Alisdair adds:
]</i></p>


<blockquote>
<p>
Why can't we write through the reference returned from operator[] on a
random access iterator?
</p>

<p>
Recommended solution:
</p>

<p>
In table Table 104 -- Random access iterator requirements, replace
</p>

<blockquote>
a[n] : convertible to <del><tt>const T &amp;</tt></del>
<ins><tt>T&amp;</tt> if <tt>X</tt> is mutable, otherwise convertible to <tt>const T&amp;</tt></ins>
</blockquote>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Leave Open. Alisdair to spearhead a paper on revivification.
</blockquote>

<p><i>[
2010 Pittsburgh:  Moved to NAD Editorial.  Rationale added below.
]</i></p>




<p><b>Rationale:</b></p>
<p>
Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3066.html">N3066</a>.
</p>


<p><b>Proposed resolution:</b></p>

<p>
In section 24.1.4 [lib.bidirectdional.iterators], change the return
type in table 75 from "convertible to <tt>T</tt>" to
<tt>T&amp;</tt>.
</p>

<p>
In section 24.1.5 [lib.random.access.iterators], change the
operational semantics for <tt>a[n]</tt> to " the r-value of
<tt>a[n]</tt> is equivalent to the r-value of <tt>*(a +
n)</tt>". Add a new row in the table for the expression <tt>a[n] = t</tt>
with a return type of convertible to <tt>T</tt> and operational semantics of
<tt>*(a + n) = t</tt>.
</p>

<p><i>[Lillehammer: Real problem, but should be addressed as part of
  iterator redesign]</i></p>




<p><b>Rationale:</b></p>
<p><i>[
San Francisco:
]</i></p>


<blockquote>
Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2758.pdf">N2758</a>.
</blockquote>







<hr>
<h3><a name="302"></a>302. Need error indication from codecvt&lt;&gt;::do_length</h3>
<p><b>Section:</b> 22.4.1.5 [locale.codecvt.byname] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Gregory Bumgardner <b>Opened:</b> 2001-01-25 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.codecvt.byname">issues</a> in [locale.codecvt.byname].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The effects of <tt>codecvt&lt;&gt;::do_length()</tt> are described in
22.2.1.5.2, paragraph 10.  As implied by that paragraph, and clarified
in issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#75">75</a>, <tt>codecvt&lt;&gt;::do_length()</tt> must
process the source data and update the <tt>stateT</tt> argument just
as if the data had been processed by <tt>codecvt&lt;&gt;::in()</tt>.
However, the standard does not specify how <tt>do_length()</tt> would
report a translation failure, should the source sequence contain
untranslatable or illegal character sequences.
</p>

<p>
The other conversion methods return an "error" result value
to indicate that an untranslatable character has been encountered, but
<tt>do_length()</tt> already has a return value (the number of source
characters that have been processed by the method).
</p>


<p><b>Proposed resolution:</b></p>
<p>
This issue cannot be resolved without modifying the interface. An exception
cannot be used, as there would be no way to determine how many characters
have been processed and the state object would be left in an indeterminate
state.
</p>

<p>
A source compatible solution involves adding a fifth argument to length()
and do_length() that could be used to return position of the offending
character sequence. This argument would have a default value that would
allow it to be ignored:
</p>

<pre>  int length(stateT&amp; state, 
             const externT* from, 
             const externT* from_end, 
             size_t max,
             const externT** from_next = 0);

  virtual
  int do_length(stateT&amp; state, 
                const externT* from, 
                const externT* from_end, 
                size_t max,
                const externT** from_next);
</pre>

<p>
Then an exception could be used to report any translation errors and
the from_next argument, if used, could then be used to retrieve the
location of the offending character sequence.
</p>


<p><b>Rationale:</b></p>
<p>The standard is already clear: the return value is the number of
"valid complete characters".  If it encounters an invalid sequence of
external characters, it stops.</p>





<hr>
<h3><a name="304"></a>304. Must <tt>*a</tt> return an lvalue when <tt>a</tt> is an input iterator?</h3>
<p><b>Section:</b> X [iterator.concepts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Dave Abrahams <b>Opened:</b> 2001-02-05 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iterator.concepts">issues</a> in [iterator.concepts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
We all "know" that input iterators are allowed to produce
values when dereferenced of which there is no other in-memory copy.
</p>

<p>
But: Table 72, with a careful reading, seems to imply that this can only be
the case if the value_type has no members (e.g. is a built-in type).
</p>

<p>The problem occurs in the following entry:</p>

<pre>  a-&gt;m     pre: (*a).m is well-defined
           Equivalent to (*a).m
</pre>

<p>
<tt>*a.m</tt> can be well-defined if <tt>*a</tt> is not a reference
type, but since <tt>operator-&gt;()</tt> must return a pointer for
<tt>a-&gt;m</tt> to be well-formed, it needs something to return a
pointer <i>to</i>. This seems to indicate that <tt>*a</tt> must be
buffered somewhere to make a legal input iterator.
</p>

<p>I don't think this was intentional.</p>


<p><b>Rationale:</b></p>
<p>The current standard is clear and consistent.  Input iterators that
  return rvalues are in fact implementable.  They may in some cases
  require extra work, but it is still possible to define an operator-&gt;
  in such cases: it doesn't have to return a T*, but may return a
  proxy type.  No change to the standard is justified.</p>





<hr>
<h3><a name="309"></a>309. Does sentry catch exceptions?</h3>
<p><b>Section:</b> 27.7 [iostream.format] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2001-03-19 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iostream.format">issues</a> in [iostream.format].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The descriptions of the constructors of basic_istream&lt;&gt;::sentry
(27.7.1.1.3 [istream::sentry]) and basic_ostream&lt;&gt;::sentry
(27.7.2.4 [ostream::sentry]) do not explain what the functions do in
case an exception is thrown while they execute. Some current
implementations allow all exceptions to propagate, others catch them
and set ios_base::badbit instead, still others catch some but let
others propagate.
</p>

<p>
The text also mentions that the functions may call setstate(failbit)
(without actually saying on what object, but presumably the stream
argument is meant).  That may have been fine for
basic_istream&lt;&gt;::sentry prior to issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#195">195</a>, since
the function performs an input operation which may fail. However,
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#195">195</a> amends 27.7.1.1.3 [istream::sentry], p2 to
clarify that the function should actually call setstate(failbit |
eofbit), so the sentence in p3 is redundant or even somewhat
contradictory.
</p>

<p>
The same sentence that appears in 27.7.2.4 [ostream::sentry], p3
doesn't seem to be very meaningful for basic_istream&lt;&gt;::sentry
which performs no input. It is actually rather misleading since it
would appear to guide library implementers to calling
setstate(failbit) when os.tie()-&gt;flush(), the only called function,
throws an exception (typically, it's badbit that's set in response to
such an event).
</p>

<p><b>Additional comments from Martin, who isn't comfortable with the
    current proposed resolution</b> (see c++std-lib-11530)</p>

<p>
The istream::sentry ctor says nothing about how the function
deals with exemptions (27.6.1.1.2, p1 says that the class is
responsible for doing "exception safe"(*) prefix and suffix
operations but it doesn't explain what level of exception
safety the class promises to provide). The mockup example
of a "typical implementation of the sentry ctor" given in
27.6.1.1.2, p6, removed in ISO/IEC 14882:2003, doesn't show
exception handling, either. Since the ctor is not classified
as a formatted or unformatted input function, the text in
27.6.1.1, p1 through p4 does not apply. All this would seem
to suggest that the sentry ctor should not catch or in any
way handle exceptions thrown from any functions it may call.
Thus, the typical implementation of an istream extractor may
look something like [1].
</p>

<p>
The problem with [1] is that while it correctly sets ios::badbit
if an exception is thrown from one of the functions called from
the sentry ctor, if the sentry ctor reaches EOF while extracting
whitespace from a stream that has eofbit or failbit set in
exceptions(), it will cause an ios::failure to be thrown, which
will in turn cause the extractor to set ios::badbit.
</p>

<p>
The only straightforward way to prevent this behavior is to
move the definition of the sentry object in the extractor
above the try block (as suggested by the example in 22.2.8,
p9 and also indirectly supported by 27.6.1.3, p1). See [2].
But such an implementation will allow exceptions thrown from
functions called from the ctor to freely propagate to the
caller regardless of the setting of ios::badbit in the stream
object's exceptions().
</p>

<p>
So since neither [1] nor [2] behaves as expected, the only
possible solution is to have the sentry ctor catch exceptions
thrown from called functions, set badbit, and propagate those
exceptions if badbit is also set in exceptions(). (Another
solution exists that deals with both kinds of sentries, but
the code is non-obvious and cumbersome -- see [3].)
</p>

<p>
Please note that, as the issue points out, current libraries
do not behave consistently, suggesting  that implementors are
not quite clear on the exception handling in istream::sentry,
despite the fact that some LWG members might feel otherwise.
(As documented by the parenthetical comment here:
http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/papers/2003/n1480.html#309)
</p>

<p>
Also please note that those LWG members who in Copenhagen
felt that "a sentry's constructor should not catch exceptions,
because sentries should only be used within (un)formatted input
functions and that exception handling is the responsibility of
those functions, not of the sentries," as noted here
http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/papers/2001/n1310.html#309
would in effect be either arguing for the behavior described
in [1] or for extractors implemented along the lines of [3].
</p>

<p>
The original proposed resolution (Revision 25 of the issues
list) clarifies the role of the sentry ctor WRT exception
handling by making it clear that extractors (both library
or user-defined) should be implemented along the lines of
[2] (as opposed to [1]) and that no exception thrown from
the callees should propagate out of either function unless
badbit is also set in exceptions().
</p>


<p>[1] Extractor that catches exceptions thrown from sentry:</p>

<blockquote>
<pre>struct S { long i; };

istream&amp; operator&gt;&gt; (istream &amp;strm, S &amp;s)
{
    ios::iostate err = ios::goodbit;
    try {
        const istream::sentry guard (strm, false);
        if (guard) {
            use_facet&lt;num_get&lt;char&gt; &gt;(strm.getloc ())
                .get (istreambuf_iterator&lt;char&gt;(strm),
                      istreambuf_iterator&lt;char&gt;(),
                      strm, err, s.i);
        }
    }
    catch (...) {
        bool rethrow;
        try {
            strm.setstate (ios::badbit);
            rethrow = false;
        }
        catch (...) {
            rethrow = true;
        }
        if (rethrow)
            throw;
    }
    if (err)
        strm.setstate (err);
    return strm;
}
</pre>
</blockquote>

<p>[2] Extractor that propagates exceptions thrown from sentry:</p>

<blockquote>
<pre>istream&amp; operator&gt;&gt; (istream &amp;strm, S &amp;s)
{
    istream::sentry guard (strm, false);
    if (guard) {
        ios::iostate err = ios::goodbit;
        try {
            use_facet&lt;num_get&lt;char&gt; &gt;(strm.getloc ())
                .get (istreambuf_iterator&lt;char&gt;(strm),
                      istreambuf_iterator&lt;char&gt;(),
                      strm, err, s.i);
        }
        catch (...) {
            bool rethrow;
            try {
                strm.setstate (ios::badbit);
                rethrow = false;
            }
            catch (...) {
                rethrow = true;
            }
            if (rethrow)
                throw;
        }
        if (err)
            strm.setstate (err);
    }
    return strm;
}
</pre>
</blockquote>

<p>
[3] Extractor that catches exceptions thrown from sentry
but doesn't set badbit if the exception was thrown as a
result of a call to strm.clear().
</p>

<blockquote>
<pre>istream&amp; operator&gt;&gt; (istream &amp;strm, S &amp;s)
{
    const ios::iostate state = strm.rdstate ();
    const ios::iostate except = strm.exceptions ();
    ios::iostate err = std::ios::goodbit;
    bool thrown = true;
    try {
        const istream::sentry guard (strm, false);
        thrown = false;
        if (guard) {
            use_facet&lt;num_get&lt;char&gt; &gt;(strm.getloc ())
                .get (istreambuf_iterator&lt;char&gt;(strm),
                      istreambuf_iterator&lt;char&gt;(),
                      strm, err, s.i);
        }
    }
    catch (...) {
        if (thrown &amp;&amp; state &amp; except)
            throw;
        try {
            strm.setstate (ios::badbit);
            thrown = false;
        }
        catch (...) {
            thrown = true;
        }
        if (thrown)
            throw;
    }
    if (err)
        strm.setstate (err);

    return strm;
}
</pre>
</blockquote>

<p>
[Pre-Berlin] Reopened at the request of Paolo Carlini and Steve Clamage.
</p>

<p>
[Pre-Portland] A relevant newsgroup post:
</p>

<p>
The current proposed resolution of issue #309
(http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#309)  is
unacceptable.   I write commerical software and coding around this
makes my code ugly, non-intuitive, and requires comments referring
people to this very issue.   Following is the full explanation of my
experience.
</p>
<p>
In the course of writing software for commercial use, I constructed
std::ifstream's based on user-supplied pathnames on typical POSIX
systems.
</p>
<p>
It was expected that some files that opened successfully might not read
successfully -- such as a pathname which actually refered to a
directory.   Intuitively, I expected the streambuffer underflow() code
to throw an exception in this situation, and recent implementations of
libstdc++'s basic_filebuf do just that (as well as many of my own
custom streambufs).
</p>
<p>
I also intuitively expected that the istream code would convert these
exceptions to the "badbit' set on the stream object, because I had not
requested exceptions.    I refer to 27.6.1.1. P4.
</p>
<p>
However, this was not the case on at least two implementations -- if
the first thing I did with an istream was call operator&gt;&gt;( T&amp; ) for T
among the basic arithmetic types and std::string.   Looking further I
found that the sentry's constructor was invoking the exception when it
pre-scanned for whitespace, and the extractor function (operator&gt;&gt;())
was not catching exceptions in this situation.
</p>
<p>
So, I was in a situation where setting 'noskipws' would change the
istream's behavior even though no characters (whitespace or not) could
ever be successfully read.
</p>
<p>
Also, calling .peek() on the istream before calling the extractor()
changed the behavior (.peek() had the effect of setting the badbit
ahead of time).
</p>
<p>
I found this all to be so inconsistent and inconvenient for me and my
code design, that I filed a bugzilla entry for libstdc++.   I was then
told that the bug cannot be fixed until issue #309 is resolved by the
committee.
</p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
Moved to NAD.
</p>
<p>
See the rationale in the issue. Paolo, who requested that the issue be
reopened, agreed with the rationale.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>The LWG agrees there is minor variation between implementations,
  but believes that it doesn't matter. This is a rarely used corner
  case. There is no evidence that this has any commercial importance
  or that it causes actual portability problems for customers trying
  to write code that runs on multiple implementations.</p>





<hr>
<h3><a name="313"></a>313. set_terminate and set_unexpected question</h3>
<p><b>Section:</b> 18.8.3.3 [terminate] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Judy Ward <b>Opened:</b> 2001-04-03 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#terminate">issues</a> in [terminate].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
According to section 18.7.3.3 of the standard, std::terminate() is
supposed to call the terminate_handler in effect immediately after
evaluating the throw expression.
</p>

<p>
Question: what if the terminate_handler in effect is itself
std::terminate?
</p>

<p>For example:</p>

<pre>  #include &lt;exception&gt;

  int main () {
      std::set_terminate(std::terminate);
      throw 5;
      return 0;
  }
</pre>

<p>
Is the implementation allowed to go into an infinite loop?
</p>

<p>
I think the same issue applies to std::set_unexpected.
</p>


<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>Infinite recursion is to be expected: users who set the terminate
handler to <tt>terminate</tt> are explicitly asking for <tt>terminate</tt>
to call itself.</p>





<hr>
<h3><a name="314"></a>314. Is the stack unwound when terminate() is called?</h3>
<p><b>Section:</b> 18.8.3.3 [terminate] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Detlef Vollmann <b>Opened:</b> 2001-04-11 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#terminate">issues</a> in [terminate].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The standard appears to contradict itself about whether the stack is
unwound when the implementation calls terminate().
</p>

<p>From 18.7.3.3p2:</p>
<blockquote><p>
    Calls the terminate_handler function in effect immediately
    after evaluating the throw-expression (lib.terminate.handler),
    if called by the implementation [...]
</p></blockquote>

<p>So the stack is guaranteed not to be unwound.</p>

<p>But from 15.3p9:</p>
<blockquote><p>
    [...]whether or not the stack is unwound before this call
    to terminate() is implementation-defined (except.terminate).
</p></blockquote>

<p>
And 15.5.1 actually defines that in most cases the stack is unwound.
</p>


<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>There is definitely no contradiction between the core and library
clauses; nothing in the core clauses says that stack unwinding happens
after <tt>terminate</tt> is called.  18.7.3.3p2 does not say anything
about when terminate() is called; it merely specifies which
<tt>terminate_handler</tt> is used.</p>





<hr>
<h3><a name="323"></a>323. abs() overloads in different headers</h3>
<p><b>Section:</b> 26.8 [c.math] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Dave Abrahams <b>Opened:</b> 2001-06-04 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#c.math">issues</a> in [c.math].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Currently the standard mandates the following overloads of
abs():</p>

<pre>    abs(long), abs(int) in &lt;cstdlib&gt;

    abs(float), abs(double), abs(long double) in &lt;cmath&gt;

    template&lt;class T&gt; T abs(const complex&lt;T&gt;&amp;) in &lt;complex&gt;

    template&lt;class T&gt; valarray&lt;T&gt; abs(const valarray&lt;T&gt;&amp;); in &lt;valarray&gt;
</pre>

<p>
The problem is that having only some overloads visible of a function
that works on "implicitly inter-convertible" types is dangerous in
practice. The headers that get included at any point in a translation
unit can change unpredictably during program
development/maintenance. The wrong overload might be unintentionally
selected.
</p>

<p>
Currently, there is nothing that mandates the simultaneous visibility
of these overloads. Indeed, some vendors have begun fastidiously
reducing dependencies among their (public) headers as a QOI issue: it
helps people to write portable code by refusing to compile unless all
the correct headers are #included.
</p>

<p>The same issue may exist for other functions in the library.</p>

<p>Redmond: PJP reports that C99 adds two new kinds of abs: complex,
and int_max_abs.</p>

<p>Related issue: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#343">343</a>.</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
The situation is not sufficiently severe to warrant a change.
</blockquote>




<p><b>Rationale:</b></p>
<p>The programs that could potentially be broken by this situation are
  already fragile, and somewhat contrived: For example, a user-defined
  class that has conversion overloads both to <tt>long</tt> and
  to <tt>float</tt>.  If <tt>x</tt> is a value of such a class, then
  <tt>abs(x)</tt> would give the <tt>long</tt> version if the user
  included &lt;cstdlib&gt;, the <tt>float</tt> version if the user
  included &lt;cmath&gt;, and would be diagnosed as ambiguous at
  compile time if the user included both headers.  The LWG couldn't
  find an example of a program whose meaning would be changed (as
  opposed to changing it from well-formed to ill-formed) simply by
  adding another standard header.</p>

<p>Since the harm seems minimal, and there don't seem to be any simple
  and noninvasive solutions, this is being closed as NAD.  It is
  marked as "Future" for two reasons.  First, it might be useful to
  define an <tt>&lt;all&gt;</tt> header that would include all
  Standard Library headers.  Second, we should at least make sure that
  future library extensions don't make this problem worse.</p>





<hr>
<h3><a name="326"></a>326. Missing typedef in moneypunct_byname</h3>
<p><b>Section:</b> 22.4.6.4 [locale.moneypunct.byname] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2001-07-05 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>The definition of the moneypunct facet contains the typedefs char_type
and string_type. Only one of these names, string_type, is defined in
the derived facet, moneypunct_byname.</p>


<p><b>Proposed resolution:</b></p>
<p>For consistency with the numpunct facet, add a typedef for
char_type to the definition of the moneypunct_byname facet in
22.4.6.4 [locale.moneypunct.byname].</p>


<p><b>Rationale:</b></p>
<p>The absence of the typedef is irrelevant.  Users can still access
the typedef, because it is inherited from the base class.</p>





<hr>
<h3><a name="330"></a>330. Misleading "exposition only" value in class locale definition</h3>
<p><b>Section:</b> 22.3.1 [locale] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2001-07-15 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale">issues</a> in [locale].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The "exposition only" value of the std::locale::none constant shown in
the definition of class locale is misleading in that it on many
systems conflicts with the value assigned to one if the LC_XXX
constants (specifically, LC_COLLATE on AIX, LC_ALL on HP-UX, LC_CTYPE
on Linux and SunOS). This causes incorrect behavior when such a
constant is passed to one of the locale member functions that accept a
locale::category argument and interpret it as either the C LC_XXX
constant or a bitmap of locale::category values. At least three major
implementations adopt the suggested value without a change and
consequently suffer from this problem.
</p>

<p>
For instance, the following code will (presumably) incorrectly copy facets
belonging to the collate category from the German locale on AIX:
</p>

<pre>  std::locale l (std::locale ("C"), "de_DE", std::locale::none);
</pre>


<p><b>Rationale:</b></p>
<p>The LWG agrees that it may be difficult to implement locale member
functions in such a way that they can take either <tt>category</tt>
arguments or the LC_ constants defined in &lt;cctype&gt;.  In light of
this requirement (22.3.1.1.1 [locale.category], paragraph 2), and in light
of the requirement in the preceding paragraph that it is possible to
combine <tt>category</tt> bitmask elements with bitwise operations,
defining the <tt>category</tt> elements is delicate,
particularly if an implementor is constrained to work with a
preexisting C library.  (Just using the existing LC_ constants would
not work in general.)  There's no set of "exposition only" values that
could give library implementors proper guidance in such a delicate
matter.  The non-normative example we're giving is no worse than
any other choice would be.</p>

<p>See issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#347">347</a>.</p>





<hr>
<h3><a name="332"></a>332. Consider adding increment and decrement operators to std::fpos&lt; T &gt; </h3>
<p><b>Section:</b> 27.5.3 [fpos] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> PremAnand M. Rao <b>Opened:</b> 2001-08-27 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#fpos">issues</a> in [fpos].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Increment and decrement operators are missing from 
Table 88 -- Position type requirements in 27.5.3 [fpos].
</p>


<p><b>Proposed resolution:</b></p>
<p>
Table 88 (section 27.4.3) -- Position type requirements
be updated to include increment and decrement operators.
</p>

<pre>expression        return type     operational    note

++p               fpos&amp;           p += O(1)
p++               fpos            { P tmp = p;
                                    ++p;
                                    return tmp; }
--p               fpos&amp;           p -= O(1)
p--               fpos            { P tmp = p;
                                    --p;
                                    return tmp; }
</pre>



<p><b>Rationale:</b></p>
<p>The LWG believes this is a request for extension, not a defect
report.  Additionally, nobody saw a clear need for this extension;
<tt>fpos</tt> is used only in very limited ways.</p>





<hr>
<h3><a name="342"></a>342. seek and eofbit</h3>
<p><b>Section:</b> 27.7.1.3 [istream.unformatted] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2001-10-09 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream.unformatted">issues</a> in [istream.unformatted].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>I think we have a defect.</p>

<p>According to lwg issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#60">60</a> which is now a dr, the
description of seekg in 27.7.1.3 [istream.unformatted] paragraph 38 now looks
like:</p>

<blockquote><p>
Behaves as an unformatted input function (as described in 27.6.1.3, 
paragraph 1), except that it does not count the number of characters 
extracted and does not affect the value returned by subsequent calls to 
gcount(). After constructing a sentry object, if fail() != true, 
executes rdbuf()-&gt;pubseekpos( pos).
</p></blockquote>

<p>And according to lwg issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#243">243</a> which is also now a dr,
27.6.1.3, paragraph 1 looks like:</p>

<blockquote><p>
Each unformatted input function begins execution by constructing an 
object of class sentry with the default argument noskipws (second) 
argument true. If the sentry object returns true, when converted to a 
value of type bool, the function endeavors to obtain the requested 
input.  Otherwise, if the sentry constructor exits by throwing an 
exception or if the sentry object returns false, when converted to a 
value of type bool, the function returns without attempting to obtain 
any input. In either case the number of extracted characters is set to 
0; unformatted input functions taking a character array of non-zero 
size as an argument shall also store a null character (using charT()) 
in the first location of the array. If an exception is thrown during 
input then ios::badbit is turned on in *this'ss error state. If 
(exception()&amp;badbit)!= 0 then the exception is rethrown. It also counts 
the number of characters extracted. If no exception has been thrown it 
ends by storing the count in a member object and returning the value 
specified. In any event the sentry object is destroyed before leaving 
the unformatted input function.
</p></blockquote>

<p>And finally 27.6.1.1.2/5 says this about sentry:</p>

<blockquote><p>
If, after any preparation is completed, is.good() is true, ok_ != false 
otherwise, ok_ == false.
</p></blockquote>

<p>
So although the seekg paragraph says that the operation proceeds if 
!fail(), the behavior of unformatted functions says the operation 
proceeds only if good().  The two statements are contradictory when only 
eofbit is set.  I don't think the current text is clear which condition 
should be respected.
</p>

<p><b>Further discussion from Redmond:</b></p>

<p>PJP: It doesn't seem quite right to say that <tt>seekg</tt> is
"unformatted". That makes specific claims about sentry that
aren't quite appropriate for seeking, which has less fragile failure
modes than actual input.  If we do really mean that it's unformatted
input, it should behave the same way as other unformatted input.  On
the other hand, "principle of least surprise" is that seeking from EOF
ought to be OK.</p>

<p>
Pre-Berlin:  Paolo points out several problems with the proposed resolution in
Ready state:
</p>

<ul>
<li>It should apply to both overloads of seekg.</li>
<li>tellg has similar issues, except that it should not call clear().</li>
<li>The point about clear() seems to apply to seekp().</li>
<li>Depending on the outcome of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#419">419</a>
if the sentry
sets <tt>failbit</tt> when it finds <tt>eofbit</tt> already set, then
you can never seek away from the end of stream.</li>
</ul>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
Moved to NAD. Will reopen if proposed resolution is supplied.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>

<p>Change 27.7.1.3 [istream.unformatted] to:</p>
<blockquote><p>
Behaves as an unformatted input function (as described in 27.6.1.3,
paragraph 1), except that it does not count the number of characters
extracted, does not affect the value returned by subsequent calls to
gcount(), and does not examine the value returned by the sentry
object. After constructing a sentry object, if <tt>fail() !=
true</tt>, executes <tt>rdbuf()-&gt;pubseekpos(pos)</tt>.  In
case of success, the function calls clear().
In case of failure, the function calls <tt>setstate(failbit)</tt>
(which may throw <tt>ios_base::failure</tt>).
</p></blockquote>

<p><i>[Lillehammer: Matt provided wording.]</i></p>




<p><b>Rationale:</b></p>
<p>In C, fseek does clear EOF.  This is probably what most users would
  expect.  We agree that having eofbit set should not deter a seek,
  and that a successful seek should clear eofbit. Note
  that <tt>fail()</tt> is true only if <tt>failbit</tt>
  or <tt>badbit</tt> is set, so using <tt>!fail()</tt>, rather
  than <tt>good()</tt>, satisfies this goal.</p>





<hr>
<h3><a name="343"></a>343. Unspecified library header dependencies</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2001-10-09 <b>Last modified:</b> 2010-10-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The synopses of the C++ library headers clearly show which names are
required to be defined in each header. Since in order to implement the
classes and templates defined in these headers declarations of other
templates (but not necessarily their definitions) are typically
necessary the standard in 17.4.4, p1 permits library implementers to
include any headers needed to implement the definitions in each header.
</p>

<p>
For instance, although it is not explicitly specified in the synopsis of
&lt;string&gt;, at the point of definition of the std::basic_string template
the declaration of the std::allocator template must be in scope. All
current implementations simply include &lt;memory&gt; from within &lt;string&gt;,
either directly or indirectly, to bring the declaration of
std::allocator into scope.
</p>

<p>
Additionally, however, some implementation also include &lt;istream&gt; and
&lt;ostream&gt; at the top of &lt;string&gt; to bring the declarations of
std::basic_istream and std::basic_ostream into scope (which are needed
in order to implement the string inserter and extractor operators
(21.3.7.9 [lib.string.io])). Other implementations only include
&lt;iosfwd&gt;, since strictly speaking, only the declarations and not the
full definitions are necessary.
</p>

<p>
Obviously, it is possible to implement &lt;string&gt; without actually
providing the full definitions of all the templates std::basic_string
uses (std::allocator, std::basic_istream, and std::basic_ostream).
Furthermore, not only is it possible, doing so is likely to have a
positive effect on compile-time efficiency.
</p>

<p>
But while it may seem perfectly reasonable to expect a program that uses
the std::basic_string insertion and extraction operators to also
explicitly include &lt;istream&gt; or &lt;ostream&gt;, respectively, it doesn't seem
reasonable to also expect it to explicitly include &lt;memory&gt;. Since
what's reasonable and what isn't is highly subjective one would expect
the standard to specify what can and what cannot be assumed.
Unfortunately, that isn't the case.
</p>

<p>The examples below demonstrate the issue.</p>

<p>Example 1:</p>

<p>It is not clear whether the following program is complete:</p>

<pre>#include &lt;string&gt;

extern std::basic_ostream&lt;char&gt; &amp;strm;

int main () {
    strm &lt;&lt; std::string ("Hello, World!\n");
}
</pre>    

<p>or whether one must explicitly include &lt;memory&gt; or
&lt;ostream&gt; (or both) in addition to &lt;string&gt; in order for
the program to compile.</p>


<p>Example 2:</p>

<p>Similarly, it is unclear whether the following program is complete:</p>

<pre>#include &lt;istream&gt;

extern std::basic_iostream&lt;char&gt; &amp;strm;

int main () {
    strm &lt;&lt; "Hello, World!\n";
}
</pre>

<p>
or whether one needs to explicitly include &lt;ostream&gt;, and
perhaps even other headers containing the definitions of other
required templates:</p>

<pre>#include &lt;ios&gt;
#include &lt;istream&gt;
#include &lt;ostream&gt;
#include &lt;streambuf&gt;

extern std::basic_iostream&lt;char&gt; &amp;strm;

int main () {
    strm &lt;&lt; "Hello, World!\n";
}
</pre>

<p>Example 3:</p>

<p>Likewise, it seems unclear whether the program below is complete:</p>
<pre>#include &lt;iterator&gt;

bool foo (std::istream_iterator&lt;int&gt; a, std::istream_iterator&lt;int&gt; b)
{
    return a == b;
}

int main () { }
</pre>

<p>or whether one should be required to include &lt;istream&gt;.</p>

<p>There are many more examples that demonstrate this lack of a
requirement.  I believe that in a good number of cases it would be
unreasonable to require that a program explicitly include all the
headers necessary for a particular template to be specialized, but I
think that there are cases such as some of those above where it would
be desirable to allow implementations to include only as much as
necessary and not more.</p>

<p><i>[
post Bellevue:
]</i></p>


<blockquote>
Position taken in prior reviews is that the idea of a table of header
dependencies is a good one. Our view is that a full paper is needed to
do justice to this, and we've made that recommendation to the issue
author.
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
NAD. Handled by LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1178">1178</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
For every C++ library header, supply a minimum set of other C++ library
headers that are required to be included by that header. The proposed
list is below (C++ headers for C Library Facilities, table 12 in
17.4.1.2, p3, are omitted):
</p>

<pre>+------------+--------------------+
| C++ header |required to include |
+============+====================+
|&lt;algorithm&gt; |                    |
+------------+--------------------+
|&lt;bitset&gt;    |                    |
+------------+--------------------+
|&lt;complex&gt;   |                    |
+------------+--------------------+
|&lt;deque&gt;     |&lt;memory&gt;            |
+------------+--------------------+
|&lt;exception&gt; |                    |
+------------+--------------------+
|&lt;fstream&gt;   |&lt;ios&gt;               |
+------------+--------------------+
|&lt;functional&gt;|                    |
+------------+--------------------+
|&lt;iomanip&gt;   |&lt;ios&gt;               |
+------------+--------------------+
|&lt;ios&gt;       |&lt;streambuf&gt;         |
+------------+--------------------+
|&lt;iosfwd&gt;    |                    |
+------------+--------------------+
|&lt;iostream&gt;  |&lt;istream&gt;, &lt;ostream&gt;|
+------------+--------------------+
|&lt;istream&gt;   |&lt;ios&gt;               |
+------------+--------------------+
|&lt;iterator&gt;  |                    |
+------------+--------------------+
|&lt;limits&gt;    |                    |
+------------+--------------------+
|&lt;list&gt;      |&lt;memory&gt;            |
+------------+--------------------+
|&lt;locale&gt;    |                    |
+------------+--------------------+
|&lt;map&gt;       |&lt;memory&gt;            |
+------------+--------------------+
|&lt;memory&gt;    |                    |
+------------+--------------------+
|&lt;new&gt;       |&lt;exception&gt;         |
+------------+--------------------+
|&lt;numeric&gt;   |                    |
+------------+--------------------+
|&lt;ostream&gt;   |&lt;ios&gt;               |
+------------+--------------------+
|&lt;queue&gt;     |&lt;deque&gt;             |
+------------+--------------------+
|&lt;set&gt;       |&lt;memory&gt;            |
+------------+--------------------+
|&lt;sstream&gt;   |&lt;ios&gt;, &lt;string&gt;     |
+------------+--------------------+
|&lt;stack&gt;     |&lt;deque&gt;             |
+------------+--------------------+
|&lt;stdexcept&gt; |                    |
+------------+--------------------+
|&lt;streambuf&gt; |&lt;ios&gt;               |
+------------+--------------------+
|&lt;string&gt;    |&lt;memory&gt;            |
+------------+--------------------+
|&lt;strstream&gt; |                    |
+------------+--------------------+
|&lt;typeinfo&gt;  |&lt;exception&gt;         |
+------------+--------------------+
|&lt;utility&gt;   |                    |
+------------+--------------------+
|&lt;valarray&gt;  |                    |
+------------+--------------------+
|&lt;vector&gt;    |&lt;memory&gt;            |
+------------+--------------------+
</pre>


<p><b>Rationale:</b></p>
<p>The portability problem is real.  A program that works correctly on
one implementation might fail on another, because of different header
dependencies.  This problem was understood before the standard was
completed, and it was a conscious design choice.</p>
<p>One possible way to deal with this, as a library extension, would
be an &lt;all&gt; header.</p>

<p>
Hinnant:  It's time we dealt with this issue for C++0X.  Reopened.
</p>







<hr>
<h3><a name="344"></a>344. grouping + showbase</h3>
<p><b>Section:</b> 22.4.2 [category.numeric] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2001-10-13 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When both grouping and showbase are active and the basefield is octal, 
does the leading 0 participate in the grouping or not?  For example, 
should one format as: 0,123,456 or 0123,456?
</p>
<p>
An analogy can be drawn with hexadecimal.  It appears that 0x123,456 is 
preferred over 0x,123,456.  However, this analogy is not universally 
accepted to apply to the octal base.  The standard is not clear on how 
to format (or parse) in this manner.
</p>

<p><b>Proposed resolution:</b></p>
<p>
Insert into 22.4.3.1.2 [facet.numpunct.virtuals] paragraph 3, just before the last
sentence:
</p>
<blockquote><p>
The leading hexadecimal base specifier "0x" does not participate in 
grouping.  The leading '0' octal base specifier may participate in 
grouping.  It is unspecified if the leading '0' participates in 
formatting octal numbers.  In parsing octal numbers, the implementation 
is encouraged to accept both the leading '0' participating in the 
grouping, and not participating (e.g. 0123,456 or 0,123,456).
</p></blockquote>

<p><b>Rationale:</b></p>
<p>
The current behavior may be unspecified, but it's not clear that it
matters.  This is an obscure corner case, since grouping is usually
intended for the benefit of humans and oct/hex prefixes are usually
intended for the benefit of machines.  There is not a strong enough
consensus in the LWG for action.
</p>




<hr>
<h3><a name="348"></a>348. Minor issue with std::pair operator&lt;</h3>
<p><b>Section:</b> 20.3.5 [pairs] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Andy Sawyer <b>Opened:</b> 2001-10-23 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#pairs">issues</a> in [pairs].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#532">532</a></p>
<p><b>Discussion:</b></p>


<p>
The current wording of 20.2.2 [lib.pairs] p6 precludes the use of
operator&lt; on any pair type which contains a pointer.
</p>


<p><b>Proposed resolution:</b></p>
<p>In 20.3.5 [pairs] paragraph 6, replace:</p>
<pre>    Returns: x.first &lt; y.first || (!(y.first &lt; x.first) &amp;&amp; x.second &lt;
        y.second).
</pre>
<p>With:</p>
<pre>    Returns: std::less&lt;T1&gt;()( x.first, y.first ) ||
             (!std::less&lt;T1&gt;()( y.first, x.first) &amp;&amp; 
             std::less&lt;T2&gt;()( x.second, y.second ) )
</pre>



<p><b>Rationale:</b></p>
<p>This is an instance of a much more general problem.  If we want
  operator&lt; to translate to std::less for pairs of pointers, where
  do we draw the line?  The same issue applies to individual
  pointers, smart pointer wrappers, std::vector&lt;T*&gt;, and so
  on.</p>

<p>Andy Koenig suggests that the real issue here is that we aren't
  distinguishing adequately between two different orderings, a
  "useful ordering" and a "canonical ordering" that's used just
  because we sometimes need <i>some</i> ordering without caring much
  which ordering it is.  Another example of the later is typeinfo's
  <tt>before</tt>.</p>






<hr>
<h3><a name="350"></a>350. allocator&lt;&gt;::address</h3>
<p><b>Section:</b> 20.9.5.1 [allocator.members], 20.2.5 [allocator.requirements], 17.6.1.1 [contents] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Nathan Myers <b>Opened:</b> 2001-10-25 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#allocator.members">issues</a> in [allocator.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#634">634</a></p>
<p><b>Discussion:</b></p>
<p>See c++std-lib-9006 and c++std-lib-9007.  This issue is taken
verbatim from -9007.</p>

<p>
The core language feature allowing definition of operator&amp;() applied 
to any non-builtin type makes that operator often unsafe to use in 
implementing libraries, including the Standard Library.  The result
is that many library facilities fail for legal user code, such as
the fragment</p>
<pre>  class A { private: A* operator&amp;(); };
  std::vector&lt;A&gt; aa;

  class B { };
  B* operator&amp;(B&amp;) { return 0; }
  std::vector&lt;B&gt; ba;
</pre>

<p>
In particular, the requirements table for Allocator (Table 32) specifies
no semantics at all for member address(), and allocator&lt;&gt;::address is 
defined in terms of unadorned operator &amp;.
</p>



<p><b>Proposed resolution:</b></p>
<p>
In 20.6.1.1, Change the definition of allocator&lt;&gt;::address from:</p>
<blockquote><p>
  Returns: &amp;x
</p></blockquote>

<p>to:</p>

<p>
  Returns: The value that the built in operator&amp;(x) would return if not 
  overloaded.
</p>

<p>
In 20.1.6, Table 32, add to the Notes column of the a.address(r) and
a.address(s) lines, respectively: 
</p>

<pre>  allocator&lt;T&gt;::address(r)
  allocator&lt;T&gt;::address(s)
</pre> 

<p>In addition, in clause 17.4.1.1, add a statement:</p>

<blockquote><p>
 The Standard Library does not apply operator&amp; to any type for which
 operator&amp; may be overloaded.
</p></blockquote> 



<p><b>Rationale:</b></p>
<p>The LWG believes both examples are ill-formed.  The contained type
is required to be CopyConstructible (20.2.1 [utility.arg.requirements]), and that
includes the requirement that &amp;t return the usual types and
values. Since allocators are intended to be used in conjunction with
containers, and since the CopyConstructible requirements appear to
have been written to deal with the concerns of this issue, the LWG
feels it is NAD unless someone can come up with a well-formed example
exhibiting a problem.</p>

<p>It may well be that the CopyConstructible requirements are too
  restrictive and that either the container requirements or the
  CopyConstructive requirements should be relaxed, but that's a far
  larger issue.  Marking this issue as "future" as a pointer to that
  larger issue.</p>





<hr>
<h3><a name="351"></a>351. unary_negate and binary_negate: struct or class?</h3>
<p><b>Section:</b> 20.8 [function.objects] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Dale Riley <b>Opened:</b> 2001-11-12 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#function.objects">issues</a> in [function.objects].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 20.8 [function.objects] the header &lt;functional&gt; synopsis declares
the unary_negate and binary_negate function objects as struct.
However in 20.8.9 [negators] the unary_negate and binary_negate
function objects are defined as class.  Given the context, they are
not "basic function objects" like negate, so this is either a typo or
an editorial oversight.
</p>

<p><i>[Taken from comp.std.c++]</i></p>



<p><b>Proposed resolution:</b></p>
<p>Change the synopsis to reflect the useage in 20.8.9 [negators]</p>

<p><i>[Curaao: Since the language permits "struct", the LWG
views this as NAD. They suggest, however, that the Project Editor
might wish to make the change as editorial.]</i></p>







<hr>
<h3><a name="356"></a>356. Meaning of ctype_base::mask enumerators</h3>
<p><b>Section:</b> 22.4.1 [category.ctype] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2002-01-23 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#category.ctype">issues</a> in [category.ctype].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>What should the following program print?</p>

<pre>  #include &lt;locale&gt;
  #include &lt;iostream&gt;

  class my_ctype : public std::ctype&lt;char&gt;
  {
    typedef std::ctype&lt;char&gt; base;
  public:
    my_ctype(std::size_t refs = 0) : base(my_table, false, refs)
    {
      std::copy(base::classic_table(), base::classic_table() + base::table_size,
                my_table);
      my_table[(unsigned char) '_'] = (base::mask) (base::print | base::space);
    }
  private:
    mask my_table[base::table_size];
  };

  int main()
  {
    my_ctype ct;
    std::cout &lt;&lt; "isspace: " &lt;&lt; ct.is(std::ctype_base::space, '_') &lt;&lt; "    "
              &lt;&lt; "isalpha: " &lt;&lt; ct.is(std::ctype_base::alpha, '_') &lt;&lt; std::endl;
  }
</pre>

<p>The goal is to create a facet where '_' is treated as whitespace.</p>

<p>On gcc 3.0, this program prints "isspace: 1 isalpha: 0".  On
Microsoft C++ it prints "isspace: 1 isalpha: 1".</p>

<p>
I believe that both implementations are legal, and the standard does not
give enough guidance for users to be able to use std::ctype's
protected interface portably.</p>

<p>
The above program assumes that ctype_base::mask enumerators like
<tt>space</tt> and <tt>print</tt> are disjoint, and that the way to
say that a character is both a space and a printing character is to or
those two enumerators together.  This is suggested by the "exposition
only" values in 22.4.1 [category.ctype], but it is nowhere specified in
normative text.  An alternative interpretation is that the more
specific categories subsume the less specific.  The above program
gives the results it does on the Microsoft compiler because, on that
compiler, <tt>print</tt> has all the bits set for each specific
printing character class.
</p>

<p>From the point of view of std::ctype's public interface, there's no
important difference between these two techniques.  From the point of
view of the protected interface, there is.  If I'm defining a facet
that inherits from std::ctype&lt;char&gt;, I'm the one who defines the
value that table()['a'] returns.  I need to know what combination of
mask values I should use.  This isn't so very esoteric: it's exactly
why std::ctype has a protected interface.  If we care about users
being able to write their own ctype facets, we have to give them a
portable way to do it.
</p>

<p>
Related reflector messages:
lib-9224, lib-9226, lib-9229, lib-9270, lib-9272, lib-9273, lib-9274,
lib-9277, lib-9279.
</p>

<p>Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#339">339</a> is related, but not identical.  The
proposed resolution if issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#339">339</a> says that
ctype_base::mask must be a bitmask type. It does not say that the
ctype_base::mask elements are bitmask elements, so it doesn't
directly affect this issue.</p>

<p>More comments from Benjamin Kosnik, who believes that 
that C99 compatibility essentially requires what we're
calling option 1 below.</p>

<blockquote>
<pre>I think the C99 standard is clear, that isspace -&gt; !isalpha.
--------

#include &lt;locale&gt;
#include &lt;iostream&gt;

class my_ctype : public std::ctype&lt;char&gt;
{
private:
  typedef std::ctype&lt;char&gt; base;
  mask my_table[base::table_size];

public:
  my_ctype(std::size_t refs = 0) : base(my_table, false, refs)
  {
    std::copy(base::classic_table(), base::classic_table() + base::table_size,
              my_table);
    mask both = base::print | base::space;
    my_table[static_cast&lt;mask&gt;('_')] = both;
  }
};

int main()
{
  using namespace std;
  my_ctype ct;
  cout &lt;&lt; "isspace: " &lt;&lt; ct.is(ctype_base::space, '_') &lt;&lt; endl;
  cout &lt;&lt; "isprint: " &lt;&lt; ct.is(ctype_base::print, '_') &lt;&lt; endl;

  // ISO C99, isalpha iff upper | lower set, and !space.
  // 7.5, p 193
  // -&gt; looks like g++ behavior is correct.
  // 356 -&gt; bitmask elements are required for ctype_base
  // 339 -&gt; bitmask type required for mask
  cout &lt;&lt; "isalpha: " &lt;&lt; ct.is(ctype_base::alpha, '_') &lt;&lt; endl;
}
</pre>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>Informally, we have three choices:</p> 
<ol>
<li>Require that the enumerators are disjoint (except for alnum and
graph)</li>
<li>Require that the enumerators are not disjoint, and specify which
of them subsume which others.  (e.g. mandate that lower includes alpha
and print)</li>
<li>Explicitly leave this unspecified, which the result that the above
program is not portable.</li>
</ol>

<p>Either of the first two options is just as good from the standpoint
of portability.  Either one will require some implementations to
change.</p>


<p><b>Rationale:</b></p>
<p>The LWG agrees that this is a real ambiguity, and that both
interpretations are conforming under the existing standard. However,
there's no evidence that it's causing problems for real users. Users
who want to define ctype facets portably can test the ctype_base masks
to see which interpretation is being used.</p>





<hr>
<h3><a name="357"></a>357. &lt;cmath&gt; float functions cannot return HUGE_VAL</h3>
<p><b>Section:</b> 26.8 [c.math] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Ray Lischner <b>Opened:</b> 2002-02-26 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#c.math">issues</a> in [c.math].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The float versions of the math functions have no meaningful value to return 
for a range error. The long double versions have a value they can return, 
but it isn't necessarily the most reasonable value.
</p>

<p>
Section 26.5 [lib.c.math], paragraph 5, says that C++ "adds float and long 
double overloaded versions of these functions, with the same semantics," 
referring to the math functions from the C90 standard.
</p>

<p>
The C90 standard, in section 7.5.1, paragraph 3, says that functions return 
"the value of the macro HUGE_VAL" when they encounter a range error. 
Section 7.5, paragraph 2, defines HUGE_VAL as a macro that "expands to a 
positive double expression, not necessarily representable as a float."
</p>

<p>
Therefore, the float versions of the math functions have no way to
signal a range error. <i>[Curaao: The LWG notes that this isn't
strictly correct, since errno is set.]</i> The semantics require that they
return HUGE_VAL, but they cannot because HUGE_VAL might not be
representable as a float.
</p>

<p>
The problem with long double functions is less severe because HUGE_VAL is 
representable as a long double. On the other hand, it might not be a "huge" 
long double value, and might fall well within the range of normal return 
values for a long double function. Therefore, it does not make sense for a 
long double function to return a double (HUGE_VAL) for a range error.
</p>


<p><b>Proposed resolution:</b></p>
<p>Curaao: C99 was faced with a similar problem, which they fixed by
adding HUGE_VALF and HUGE_VALL in addition to HUGE_VAL.</p>

<p>C++ must also fix, but it should be done in the context of the
general C99 based changes to C++, not via DR. Thus the LWG in Curaao
felt the resolution should be NAD, FUTURE, but the issue is being held
open for one more meeting to ensure LWG members not present during the
discussion concur.</p>


<p><b>Rationale:</b></p>
<p>Will be fixed as part of more general work in the TR.</p>





<hr>
<h3><a name="361"></a>361. num_get&lt;&gt;::do_get (..., void*&amp;) checks grouping</h3>
<p><b>Section:</b> 22.4.2.2.2 [facet.num.put.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2002-03-12 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#facet.num.put.virtuals">issues</a> in [facet.num.put.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
22.2.2.2.2, p12 specifies that <tt>thousands_sep</tt> is to be inserted only
for integral types (issue 282 suggests that this should be done for
all arithmetic types).
</p>

<p>
22.2.2.1.2, p12 requires that grouping be checked for all extractors
including that for <tt>void*</tt>.
</p>

<p>
I don't think that's right. <tt>void*</tt> values should not be checked for
grouping, should they? (Although if they should, then <tt>num_put</tt> needs
to write them out, otherwise their extraction will fail.)
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change the first sentence of 22.2.2.2.2, p12 from
</p>
<blockquote><p>
    Digit grouping is checked. That is, the positions of discarded
    separators is examined for consistency with
    use_facet&lt;numpunct&lt;charT&gt; &gt;(loc).grouping().
    If they are not consistent then ios_base::failbit is assigned
    to err.
</p></blockquote>

<p>to</p>
<blockquote><p>
    Except for conversions to void*, digit grouping is checked...
</p></blockquote>



<p><b>Rationale:</b></p>
<p>This would be a change: as it stands, the standard clearly
  specifies that grouping applies to void*.  A survey of existing
  practice shows that most existing implementations do that, as they
  should.</p>





<hr>
<h3><a name="366"></a>366. Excessive const-qualification</h3>
<p><b>Section:</b> 27 [input.output] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Walter Brown, Marc Paterno <b>Opened:</b> 2002-05-10 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#input.output">issues</a> in [input.output].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The following member functions are declared const, yet return non-const
pointers. We believe they are should be changed, because they allow code
that may surprise the user. See document N1360 for details and
rationale.
</p>

<p><i>[Santa Cruz: the real issue is that we've got const member
functions that return pointers to non-const, and N1360 proposes
replacing them by overloaded pairs.  There isn't a consensus about
whether this is a real issue, since we've never said what our
constness policy is for iostreams.  N1360 relies on a distinction
between physical constness and logical constness; that distinction, or
those terms, does not appear in the standard.]</i></p>




<p><b>Proposed resolution:</b></p>
<p>In 27.4.4 and 27.4.4.2</p>
<p>Replace</p>
<pre>  basic_ostream&lt;charT,traits&gt;* tie() const;
</pre>
<p>with</p>
<pre>  basic_ostream&lt;charT,traits&gt;* tie();
  const basic_ostream&lt;charT,traits&gt;* tie() const;
</pre>

<p>and replace</p>
<pre>  basic_streambuf&lt;charT,traits&gt;* rdbuf() const;
</pre>
<p>with</p>
<pre>  basic_streambuf&lt;charT,traits&gt;* rdbuf();
  const basic_streambuf&lt;charT,traits&gt;* rdbuf() const;
</pre>

<p>In 27.5.2 and 27.5.2.3.1</p>
<p>Replace</p>
<pre>  char_type* eback() const;
</pre>
<p>with</p>
<pre>  char_type* eback();
  const char_type* eback() const;
</pre>

<p>Replace</p>
<pre>  char_type gptr() const;
</pre>
<p>with</p>
<pre>  char_type* gptr();
  const char_type* gptr() const;
</pre>

<p>Replace</p>
<pre>  char_type* egptr() const;
</pre>
<p>with</p>
<pre>  char_type* egptr();
  const char_type* egptr() const;
</pre>

<p>In 27.5.2 and 27.5.2.3.2</p>
<p>Replace</p>
<pre>  char_type* pbase() const;
</pre>
<p>with</p>
<pre>  char_type* pbase();
  const char_type* pbase() const;
</pre>

<p>Replace</p>
<pre>  char_type* pptr() const;
</pre>
<p>with</p>
<pre>  char_type* pptr();
  const char_type* pptr() const;
</pre>

<p>Replace</p>
<pre>  char_type* epptr() const;
</pre>
<p>with</p>
<pre>  char_type* epptr();
  const char_type* epptr() const;
</pre>

<p>In 27.7.2, 27.7.2.2, 27.7.3 27.7.3.2, 27.7.4, and 27.7.6</p>
<p>Replace</p>
<pre>  basic_stringbuf&lt;charT,traits,Allocator&gt;* rdbuf() const;
</pre>
<p>with</p>
<pre>  basic_stringbuf&lt;charT,traits,Allocator&gt;* rdbuf();
  const basic_stringbuf&lt;charT,traits,Allocator&gt;* rdbuf() const;
</pre>

<p>In  27.8.1.5, 27.8.1.7, 27.8.1.8, 27.8.1.10, 27.8.1.11, and 27.8.1.13</p>
<p>Replace</p>
<pre>  basic_filebuf&lt;charT,traits&gt;* rdbuf() const;
</pre>
<p>with</p>
<pre>  basic_filebuf&lt;charT,traits&gt;* rdbuf();
  const basic_filebuf&lt;charT,traits&gt;* rdbuf() const;
</pre>


<p><b>Rationale:</b></p>
<p>The existing specification is a bit sloppy, but there's no
  particular reason to change this other than tidiness, and there are
  a number of ways in which streams might have been designed
  differently if we were starting today.  There's no evidence that the
  existing constness policy is harming users.  We might consider
  a different constness policy as part of a full stream redesign.</p>





<hr>
<h3><a name="367"></a>367. remove_copy/remove_copy_if and Input Iterators</h3>
<p><b>Section:</b> 25.3.8 [alg.remove] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Anthony Williams <b>Opened:</b> 2002-05-13 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.remove">issues</a> in [alg.remove].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
remove_copy and remove_copy_if (25.3.8 [alg.remove]) permit their
input range to be marked with Input Iterators. However, since two
operations are required against the elements to copy (comparison and
assigment), when the input range uses Input Iterators, a temporary
copy must be taken to avoid dereferencing the iterator twice. This
therefore requires the value type of the InputIterator to be
CopyConstructible. If the iterators are at least Forward Iterators,
then the iterator can be dereferenced twice, or a reference to the
result maintained, so the temporary is not required.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add "If InputIterator does not meet the requirements of forward
iterator, then the value type of InputIterator must be copy
constructible. Otherwise copy constructible is not required." to
25.3.8 [alg.remove] paragraph 6.
</p>


<p><b>Rationale:</b></p>
<p>The assumption is that an input iterator can't be dereferenced
  twice.  There's no basis for that assumption in the Standard.</p>





<hr>
<h3><a name="368"></a>368. basic_string::replace has two "Throws" paragraphs</h3>
<p><b>Section:</b> 21.4.6.6 [string::replace] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2002-06-03 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#string::replace">issues</a> in [string::replace].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
21.4.6.6 [string::replace] basic_string::replace, second
signature, given in paragraph 1, has two "Throws" paragraphs (3 and
5).
</p>

<p>
In addition, the second "Throws" paragraph (5) includes specification
(beginning with "Otherwise, the function replaces ...") that should be
part of the "Effects" paragraph.
</p>


<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>This is editorial. Both "throws" statements are true. The bug is
  just that the second one should be a sentence, part of the "Effects"
  clause, not a separate "Throws".  The project editor has been
  notified.</p>





<hr>
<h3><a name="372"></a>372. Inconsistent description of stdlib exceptions</h3>
<p><b>Section:</b> 17.6.4.12 [res.on.exception.handling], 18.7.1 [type.info] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Randy Maddox <b>Opened:</b> 2002-07-22 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#res.on.exception.handling">issues</a> in [res.on.exception.handling].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>Paragraph 3 under clause 17.6.4.12 [res.on.exception.handling], Restrictions on
Exception Handling, states that "Any other functions defined in the
C++ Standard Library that do not have an exception-specification may
throw implementation-defined exceptions unless otherwise specified."
This statement is followed by a reference to footnote 178 at the
bottom of that page which states, apparently in reference to the C++
Standard Library, that "Library implementations are encouraged (but
not required) to report errors by throwing exceptions from (or derived
from) the standard exceptions."</p>

<p>These statements appear to be in direct contradiction to clause
18.7.1 [type.info], which states "The class exception defines the
base class for the types of objects thrown as exceptions by the C++
Standard library components ...".</p>

<p>Is this inconsistent?</p>



<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>Clause 17 is setting the overall library requirements, and it's
  clear and consistent.  This sentence from Clause 18 is descriptive,
  not setting a requirement on any other class.
</p>





<hr>
<h3><a name="374"></a>374. moneypunct::frac_digits returns int not unsigned</h3>
<p><b>Section:</b> 22.4.6.3.1 [locale.moneypunct.members], 22.4.6.3.2 [locale.moneypunct.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Ray Lischner <b>Opened:</b> 2002-08-08 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In section 22.4.6.3.1 [locale.moneypunct.members], frac_digits() returns type
"int". This implies that frac_digits() might return a negative value,
but a negative value is nonsensical. It should return "unsigned".
</p>

<p>
Similarly, in section 22.4.6.3.2 [locale.moneypunct.virtuals], do_frac_digits()
should return "unsigned".
</p>



<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>Regardless of whether the return value is int or unsigned, it's
always conceivable that frac_digits might return a nonsensical
value. (Is 4294967295 really any better than -1?)  The clients of
moneypunct, the get and put facets, can and do perform range
checks.</p>





<hr>
<h3><a name="377"></a>377. basic_string::insert and length_error</h3>
<p><b>Section:</b> 21.4.6.4 [string::insert] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Ray Lischner <b>Opened:</b> 2002-08-16 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#string::insert">issues</a> in [string::insert].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Section 21.4.6.4 [string::insert], paragraph 4, contains the following,
"Then throws length_error if size() &gt;= npos - rlen."
</p>

<p>
Related to DR 83, this sentence should probably be removed.
</p>


<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p><p>This requirement is redundant but correct.  No change is
needed.</p>




<hr>
<h3><a name="378"></a>378. locale immutability and locale::operator=()</h3>
<p><b>Section:</b> 22.3.1 [locale] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2002-09-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale">issues</a> in [locale].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#31">31</a></p>
<p><b>Discussion:</b></p>
<p>
I think there is a problem with 22.1.1, p6 which says that
</p>
<pre>    -6- An instance of locale is immutable; once a facet reference
        is obtained from it, that reference remains usable as long
        as the locale value itself exists.
</pre>
<p>
and 22.1.1.2, p4:
</p>
<pre>    const locale&amp; operator=(const locale&amp; other) throw();

    -4- Effects: Creates a copy of other, replacing the current value.
</pre>
<p>
How can a reference to a facet obtained from a locale object remain
valid after an assignment that clearly must replace all the facets
in the locale object? Imagine a program such as this
</p>
<pre>    std::locale loc ("de_DE");
    const std::ctype&lt;char&gt; &amp;r0 = std::use_facet&lt;std::ctype&lt;char&gt; &gt;(loc);
    loc = std::locale ("en_US");
    const std::ctype&lt;char&gt; &amp;r1 = std::use_facet&lt;std::ctype&lt;char&gt; &gt;(loc);
</pre>
<p>
Is r0 really supposed to be preserved and destroyed only when loc goes
out of scope?
</p>


<p><b>Proposed resolution:</b></p>
<p><i>[Summer '04 mid-meeting mailing: Martin and Dietmar believe this
  is a duplicate of issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#31">31</a> and recommend that it be
  closed.
]</i></p>






<hr>
<h3><a name="382"></a>382. codecvt do_in/out result</h3>
<p><b>Section:</b> 22.4.1.4 [locale.codecvt] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2002-08-30 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.codecvt">issues</a> in [locale.codecvt].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It seems that the descriptions of codecvt do_in() and do_out() leave
sufficient room for interpretation so that two implementations of
codecvt may not work correctly with the same filebuf. Specifically,
the following seems less than adequately specified:
</p>

<ol>
<li>
  the conditions under which the functions terminate
</li>
<li>
  precisely when the functions return ok
</li>
<li>
  precisely when the functions return partial
</li>
<li>
  the full set of conditions when the functions return error
</li>
</ol>

<ol>
<li>
   22.4.1.4.2 [locale.codecvt.virtuals], p2 says this about the effects of the
   function: ...Stops if it encounters a character it cannot
   convert...  This assumes that there *is* a character to
   convert. What happens when there is a sequence that doesn't form a
   valid source character, such as an unassigned or invalid UNICODE
   character, or a sequence that cannot possibly form a character
   (e.g., the sequence "\xc0\xff" in UTF-8)?
</li>
<li>
   Table 53 says that the function returns codecvt_base::ok
   to indicate that the function(s) "completed the conversion."
   Suppose that the source sequence is "\xc0\x80" in UTF-8,
   with from pointing to '\xc0' and (from_end==from + 1).
   It is not clear whether the return value should be ok
   or partial (see below).
</li>
<li>
   Table 53 says that the function returns codecvt_base::partial
   if "not all source characters converted." With the from pointers
   set up the same way as above, it is not clear whether the return
   value should be partial or ok (see above).
</li>
<li>
   Table 53, in the row describing the meaning of error mistakenly
   refers to a "from_type" character, without the symbol from_type
   having been defined. Most likely, the word "source" character
   is intended, although that is not sufficient. The functions
   may also fail when they encounter an invalid source sequence
   that cannot possibly form a valid source character (e.g., as
   explained in bullet 1 above).
</li>
</ol>
<p>
Finally, the conditions described at the end of 22.4.1.4.2 [locale.codecvt.virtuals], p4 don't seem to be possible:
</p>
<blockquote><p>
    "A return value of partial, if (from_next == from_end),
    indicates that either the destination sequence has not
    absorbed all the available destination elements, or that
    additional source elements are needed before another
    destination element can be produced."
</p></blockquote>
<p>
If the value is partial, it's not clear to me that (from_next
==from_end) could ever hold if there isn't enough room
in the destination buffer. In order for (from_next==from_end) to
hold, all characters in that range must have been successfully
converted (according to 22.4.1.4.2 [locale.codecvt.virtuals], p2) and since there are no
further source characters to convert, no more room in the
destination buffer can be needed.
</p>
<p>
It's also not clear to me that (from_next==from_end) could ever
hold if additional source elements are needed to produce another
destination character (not element as incorrectly stated in the
text). partial is returned if "not all source characters have
been converted" according to Table 53, which also implies that
(from_next==from) does NOT hold.
</p>
<p>
Could it be that the intended qualifying condition was actually
(from_next != from_end), i.e., that the sentence was supposed
to read
</p>
<blockquote><p>
    "A return value of partial, if (from_next != from_end),..."
</p></blockquote>
<p>
which would make perfect sense, since, as far as I understand it,
partial can only occur if (from_next != from_end)?
</p>
<p><i>[Lillehammer: Defer for the moment, but this really needs to be
  fixed. Right now, the description of codecvt is too vague for it to
  be a useful contract between providers and clients of codecvt
  facets.  (Note that both vendors and users can be both providers and
  clients of codecvt facets.) The major philosophical issue is whether
  the standard should only describe mappings that take a single wide
  character to multiple narrow characters (and vice versa), or whether
  it should describe fully general N-to-M conversions. When the
  original standard was written only the former was contemplated, but
  today, in light of the popularity of utf8 and utf16, that doesn't
  seem sufficient for C++0x. Bill supports general N-to-M conversions;
  we need to make sure Martin and Howard agree.]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
codecvt is meant to be a 1-to-N to N-to-1 conversion. It does not work
well for N-to-M conversions. wbuffer_convert now exists, and handles
N-to-M cases. Also, there is a new specialization of codecvt that
permits UTF-16 &lt;-&gt; UTF-8 conversions.
</p>
<p>
NAD without prejudice. Will reopen if proposed resolution is supplied.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>




<hr>
<h3><a name="385"></a>385. Does call by value imply the CopyConstructible requirement?</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2002-10-23 <b>Last modified:</b> 2010-10-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Many function templates have parameters that are passed by value;
a typical example is <tt>find_if</tt>'s <i>pred</i> parameter in
25.2.5 [alg.find].  Are the corresponding template parameters
(<tt>Predicate</tt> in this case) implicitly required to be
CopyConstructible, or does that need to be spelled out explicitly?
</p>

<p>
This isn't quite as silly a question as it might seem to be at first
sight.  If you call <tt>find_if</tt> in such a way that template
argument deduction applies, then of course you'll get call by value
and you need to provide a copy constructor.  If you explicitly provide
the template arguments, however, you can force call by reference by
writing something like <tt>find_if&lt;my_iterator,
my_predicate&amp;&gt;</tt>.  The question is whether implementation
are required to accept this, or whether this is ill-formed because
my_predicate&amp; is not CopyConstructible.
</p>

<p>
The scope of this problem, if it is a problem, is unknown.  Function
object arguments to generic algorithms in clauses 25 [algorithms]
and 26 [numerics] are obvious examples.  A review of the whole
library is necessary.
</p>
<p><i>[
This is really two issues.  First, predicates are typically passed by
value but we don't say they must be Copy Constructible.  They should
be. Second: is specialization allowed to transform value arguments
into references? References aren't copy constructible, so this should
not be allowed.
]</i></p>

<p><i>[
2007-01-12, Howard: First, despite the note above, references <b>are</b>
copy constructible. They just aren't assignable.  Second, this is very
closely related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#92">92</a> and should be consistent with that.
That issue already says that implementations are allowed to copy
function objects.  If one passes in a reference, it is copyable, but
susceptible to slicing if one passes in a reference to a base.  Third,
with rvalue reference in the language one only needs to satisfy
MoveConstructible to pass an rvalue "by value".  Though the function
might still copy the function object internally (requiring
CopyConstructible). Finally (and fwiw), if we wanted to, it is easy to
code all of the std::algorithms such that they do not copy function
objects internally.  One merely passes them by reference internally if
desired (this has been fully implemented and shipped for several years).
 If this were mandated, it would reverse <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#92">92</a>, allowing
function objects to reliably maintain state.  E.g. the example in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#92">92</a> would reliably remove only the third element.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
Recommend NAD.
</p>


<p><b>Rationale:</b></p>
<p>
Generic algorithms will be marked with concepts and these will imply a requirement
of MoveConstructible (not CopyConstructible).  The signature of the function will
then precisely describe and enforce the precise requirements.
</p>





<hr>
<h3><a name="388"></a>388. Use of complex as a key in associative containers</h3>
<p><b>Section:</b> 26.4 [complex.numbers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Gabriel Dos Reis <b>Opened:</b> 2002-11-08 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#complex.numbers">issues</a> in [complex.numbers].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Practice with std::complex&lt;&gt; and the associative containers
occasionally reveals artificial and distracting issues with constructs
resembling: std::set&lt;std::complex&lt;double&gt; &gt; s;
</p>

<p>
The main reason for the above to fail is the absence of an approriate
definition for std::less&lt;std::complex&lt;T&gt; &gt;. That in turn comes from
the definition of the primary template std::less&lt;&gt; in terms of
operator&lt;.
</p>

<p>
The usual argument goes as follows: Since there is no ordering over
the complex field compatible with field operations it makes little
sense to define a function operator&lt; operating on the datatype
std::complex&lt;T&gt;.  That is fine. However, that reasoning does not carry
over to std::less&lt;T&gt; which is used, among other things, by associative
containers as an ordering useful to meet complexity requirements.
</p>

<p>Related issue: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#348">348</a>.</p>

<p><i>[
Pre Bellevue: Reopened at the request of Alisdair.
]</i></p>


<p><i>[
Bellevue:
]</i></p>


<blockquote>
This is a request for a design change, and not a defect in the standard.
It is in scope to consider, but the group feels that it is not a change
that we need to do. Is there a total ordering for floating point values,
including NaN? There is not a clear enough solution or big enough
problem for us to solve. Solving this problem would require solving the
problem for floating point, which is equally unclear. The LWG noted that
users who want to put objects into an associative container for which
operator&lt; isn't defined can simply provide their own comparison function
object. NAD
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>Informally: Add a specialization of std::less for std::complex.</p>


<p><b>Rationale:</b></p>
<p>Discussed in Santa Cruz.  An overwhelming majority of the LWG
believes this should not be treated a DR: it's a request for a design
change, not a defect in the existing standard.  Most people (10-3)
believed that we probably don't want this change, period: as with
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#348">348</a>, it's hard to know where to draw the line.
The LWG noted that users who want to put objects into an associative
container for which <tt>operator&lt;</tt> isn't defined can simply
provide their own comparison function object.</p>





<hr>
<h3><a name="390"></a>390. CopyConstructible requirements too strict</h3>
<p><b>Section:</b> 20.2.1 [utility.arg.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Doug Gregor <b>Opened:</b> 2002-10-24 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#utility.arg.requirements">issues</a> in [utility.arg.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The CopyConstructible requirements in Table 30 state that for an
object t of type T (where T is CopyConstructible), the expression &amp;t
returns the address of t (with type T*). This requirement is overly
strict, in that it disallows types that overload operator&amp; to not
return a value of type T*. This occurs, for instance, in the <a href="http://www.boost.org/libs/lambda">Boost.Lambda</a> library, where
operator&amp; is overloaded for a Boost.Lambda function object to return
another function object.
</p>

<p>Example:</p>

<pre>  std::vector&lt;int&gt; u, v;
  int x;
  // ...
  std::transform(u.begin(), u.end(), std::back_inserter(v), _1 * x);
</pre>

<p>
_1 * x returns an unnamed function object with operator&amp; overloaded to
not return T* , therefore rendering the std::transform call ill-formed.
However, most standard library implementations will compile this code
properly, and the viability of such binder libraries is severely hindered
by the unnecessary restriction in the CopyConstructible requirements.
</p>

<p>
For reference, the address of an object can be retrieved without using
the address-of operator with the following function template:
</p>

<pre>  template &lt;typename T&gt; T* addressof(T&amp; v)
  {
    return reinterpret_cast&lt;T*&gt;(
         &amp;const_cast&lt;char&amp;&gt;(reinterpret_cast&lt;const volatile char &amp;&gt;(v)));
  }
</pre>

<p>
Note: this relates directly to library issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#350">350</a>, which
will need to be reexamined if the CopyConstructible requirements
change.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Remove the last two rows of Table 30, eliminating the requirements
that &amp;t and &amp;u return the address of t and u, respectively.
</p>


<p><b>Rationale:</b></p>
<p>This was a deliberate design decision.  Perhaps it should be
   reconsidered for C++0x. </p>





<hr>
<h3><a name="392"></a>392. 'equivalence' for input iterators</h3>
<p><b>Section:</b> 24.2.3 [input.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Corwin Joy <b>Opened:</b> 2002-12-11 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#input.iterators">issues</a> in [input.iterators].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
In section 24.2.3 [input.iterators] table 72 -
'Input Iterator Requirements' we have as a postcondition of *a:
"If a==b and (a, b) is in the domain of == then *a is equivalent to *b".
</p>

<p>
In section 24.6.3.5 [istreambuf.iterator::equal] it states that
"istreambuf_iterator::equal returns true if and only if both iterators
are at end-of-stream, or neither is at end-of-stream, <i>regardless of
what streambuf object they use</i>."  (My emphasis).
</p>

<p>
The defect is that either 'equivalent' needs to be more precisely
defined or the conditions for equality in 24.6.3.5 [istreambuf.iterator::equal]
are incorrect. (Or both).
</p>

<p>Consider the following example:</p>
<pre>   #include &lt;iostream&gt;
   #include &lt;fstream&gt;
   #include &lt;iterator&gt;
   using namespace std;

   int main() {
    ifstream file1("file1.txt"), file2("file2.txt");
    istreambuf_iterator&lt;char&gt; f1(file1), f2(file2);
    cout &lt;&lt; "f1 == f2 : " &lt;&lt; boolalpha &lt;&lt; (f1 == f2) &lt;&lt; endl;
    cout &lt;&lt; "f1 = " &lt;&lt; *f1 &lt;&lt; endl;
    cout &lt;&lt; "f2 = " &lt;&lt; *f2 &lt;&lt; endl;
    return 0;
   }
</pre>

<p>Now assuming that neither f1 or f2 are at the end-of-stream then
f1 == f2 by 24.6.3.5 [istreambuf.iterator::equal].</p>

<p>However, it is unlikely that *f1 will give the same value as *f2 except
by accident.</p>

<p>So what does *f1 'equivalent' to *f2 mean?  I think the standard should
be clearer on this point, or at least be explicit that this does not
mean that *f1 and *f2 are required to have the same value in the case
of input iterators.</p>


<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p><p>The two iterators aer not in the domain of ==</p>






<hr>
<h3><a name="393"></a>393. do_in/do_out operation on state unclear</h3>
<p><b>Section:</b> 22.4.1.4.2 [locale.codecvt.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alberto Barbati <b>Opened:</b> 2002-12-24 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.codecvt.virtuals">issues</a> in [locale.codecvt.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
this DR follows the discussion on the previous thread "codecvt::do_in
not consuming external characters". It's just a clarification issue
and not a request for a change.
</p>
<p>
Can do_in()/do_out() produce output characters without consuming input 
characters as a result of operation on state?
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add a note at the end of 22.4.1.4.2 [locale.codecvt.virtuals], 
paragraph 3:
</p>

<p>
[Note: As a result of operations on state, it can return ok or partial 
and set from_next == from and to_next != to. --end note]
</p>


<p><b>Rationale:</b></p>
<p>
The submitter believes that standard already provides an affirmative
answer to the question. However, the current wording has induced a few
library implementors to make the incorrect assumption that
do_in()/do_out() always consume at least one internal character when
they succeed.
</p>

<p>
The submitter also believes that the proposed resolution is not in
conflict with the related issue 76. Moreover, by explicitly allowing
operations on state to produce characters, a codecvt implementation
may effectively implement N-to-M translations without violating the
"one character at a time" principle described in such issue. On a side
note, the footnote in the proposed resolution of issue 76 that
informally rules out N-to-M translations for basic_filebuf should be
removed if this issue is accepted as valid.
</p>


<p><i>[
Kona (2007): The proposed resolution is to add a note. Since this is
non-normative, the issue is editorial, but we believe that the note is
correct. Proposed Disposition: NAD, Editorial
]</i></p>






<hr>
<h3><a name="394"></a>394. behavior of formatted output on failure</h3>
<p><b>Section:</b> 27.7.2.6.1 [ostream.formatted.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2002-12-27 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There is a contradiction in Formatted output about what bit is
supposed to be set if the formatting fails. On sentence says it's
badbit and another that it's failbit.
</p>
<p>
27.6.2.5.1, p1 says in the Common Requirements on Formatted output
functions:
</p>
<pre>     ... If the generation fails, then the formatted output function
     does setstate(ios::failbit), which might throw an exception.
</pre>
<p>
27.6.2.5.2, p1 goes on to say this about Arithmetic Inserters:
</p>
<p>
     ... The formatting conversion occurs as if it performed the
     following code fragment:
</p>
<pre>     bool failed =
         use_facet&lt;num_put&lt;charT,ostreambuf_iterator&lt;charT,traits&gt;
         &gt; &gt;
         (getloc()).put(*this, *this, fill(), val). failed();

     ... If failed is true then does setstate(badbit) ...
</pre>
<p>
The original intent of the text, according to Jerry Schwarz (see
c++std-lib-10500), is captured in the following paragraph:
</p>
<p>
In general "badbit" should mean that the stream is unusable because
of some underlying failure, such as disk full or socket closure;
"failbit" should mean that the requested formatting wasn't possible
because of some inconsistency such as negative widths.  So typically
if you clear badbit and try to output something else you'll fail
again, but if you clear failbit and try to output something else
you'll succeed.
</p>
<p>
In the case of the arithmetic inserters, since num_put cannot
report failure by any means other than exceptions (in response
to which the stream must set badbit, which prevents the kind of
recoverable error reporting mentioned above), the only other
detectable failure is if the iterator returned from num_put
returns true from failed().
</p>
<p>
Since that can only happen (at least with the required iostream
specializations) under such conditions as the underlying failure
referred to above (e.g., disk full), setting badbit would seem
to be the appropriate response (indeed, it is required in
27.6.2.5.2, p1). It follows that failbit can never be directly
set by the arithmetic (it can only be set by the sentry object
under some unspecified conditions).
</p>
<p>
The situation is different for other formatted output functions
which can fail as a result of the streambuf functions failing
(they may do so by means other than exceptions), and which are
then required to set failbit.
</p>
<p>
The contradiction, then, is that ostream::operator&lt;&lt;(int) will
set badbit if the disk is full, while operator&lt;&lt;(ostream&amp;,
char) will set failbit under the same conditions. To make the behavior
consistent, the Common requirements sections for the Formatted output
functions should be changed as proposed below.
</p>
<p><i>[Kona: There's agreement that this is a real issue.  What we
  decided at Kona: 1. An error from the buffer (which can be detected
  either directly from streambuf's member functions or by examining a
  streambuf_iterator) should always result in badbit getting set.
  2. There should never be a circumstance where failbit gets set.
  That represents a formatting error, and there are no circumstances
  under which the output facets are specified as signaling a
  formatting error. (Even more so for string output that for numeric
  because there's nothing to format.)  If we ever decide to make it
  possible for formatting errors to exist then the facets can signal
  the error directly, and that should go in clause 22, not clause 27.
  3. The phrase "if generation fails" is unclear and should be
  eliminated.  It's not clear whether it's intended to mean a buffer
  error (e.g. a full disk), a formatting error, or something else.
  Most people thought it was supposed to refer to buffer errors; if
  so, we should say so.  Martin will provide wording.]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
NAD. This issue is already fixed.
</blockquote>



<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>






<hr>
<h3><a name="397"></a>397. ostream::sentry dtor throws exceptions</h3>
<p><b>Section:</b> 27.7.2.4 [ostream::sentry] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-01-05 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ostream::sentry">issues</a> in [ostream::sentry].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
    <p>
17.4.4.8, p3 prohibits library dtors from throwing exceptions.
    </p>
    <p>
27.6.2.3, p4 says this about the ostream::sentry dtor:
    </p>
    <pre>    -4- If ((os.flags() &amp; ios_base::unitbuf) &amp;&amp; !uncaught_exception())
        is true, calls os.flush().
    </pre>
    <p>
27.6.2.6, p7 that describes ostream::flush() says:
    </p>
    <pre>    -7- If rdbuf() is not a null pointer, calls rdbuf()-&gt;pubsync().
        If that function returns ?-1 calls setstate(badbit) (which
        may throw ios_base::failure (27.4.4.3)).
    </pre>
    <p>
That seems like a defect, since both pubsync() and setstate() can
throw an exception. 
    </p>
<p><i>[
The contradiction is real.  Clause 17 says destructors may never
throw exceptions, and clause 27 specifies a destructor that does
throw.  In principle we might change either one.  We're leaning
toward changing clause 17: putting in an "unless otherwise specified"
clause, and then putting in a footnote saying the sentry destructor
is the only one that can throw.  PJP suggests specifying that
sentry::~sentry() should internally catch any exceptions it might cause.
]</i></p>


<p><i>[
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#418">418</a> and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#622">622</a> for related issues.
]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
Move to Review. Add "Throws: nothing" to the specification of ostream::sentry::~sentry().
</p>
</blockquote>

<p><i>[
2009-10-13 Daniel adds:
]</i></p>


<blockquote>
The proposed resolution of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#835">835</a> is written to match the outcome
of this issue.
</blockquote>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
Move to Open.  Our intent is to solve this issue with <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#835">835</a>.
</blockquote>

<p><i>[
2010-03-06 Martin updates wording.
]</i></p>


<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote>
Moved to NAD Editorial.
</blockquote>



<p><b>Rationale:</b></p>
<p>
Solved by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#835">835</a>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add after 27.7.2.4 [ostream::sentry] p17:
</p>

<blockquote>
<pre>~sentry();
</pre>
<blockquote>
<p>
-17- If <tt>(os.flags() &amp; ios_base::unitbuf)</tt>
is <tt>true</tt>, calls <tt>os.flush()</tt>.
</p>

<p><ins>
<i>Throws:</i> Nothing.
</ins></p>
</blockquote>
</blockquote>





<hr>
<h3><a name="398"></a>398. effects of end-of-file on unformatted input functions</h3>
<p><b>Section:</b> 27.7.2.4 [ostream::sentry] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-01-05 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ostream::sentry">issues</a> in [ostream::sentry].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
    <p>
While reviewing unformatted input member functions of istream
for their behavior when they encounter end-of-file during input
I found that the requirements vary, sometimes unexpectedly, and
in more than one case even contradict established practice (GNU
libstdc++ 3.2, IBM VAC++ 6.0, STLPort 4.5, SunPro 5.3, HP aCC
5.38, Rogue Wave libstd 3.1, and Classic Iostreams).
    </p>
    <p>
The following unformatted input member functions set eofbit if they
encounter an end-of-file (this is the expected behavior, and also
the behavior of all major implementations):
    </p>
    <pre>    basic_istream&lt;charT, traits&gt;&amp;
    get (char_type*, streamsize, char_type);
    </pre>
    <p>
    Also sets failbit if it fails to extract any characters.
    </p>
    <pre>    basic_istream&lt;charT, traits&gt;&amp;
    get (char_type*, streamsize);
    </pre>
    <p>
    Also sets failbit if it fails to extract any characters.
    </p>
    <pre>    basic_istream&lt;charT, traits&gt;&amp;
    getline (char_type*, streamsize, char_type);
    </pre>
    <p>
    Also sets failbit if it fails to extract any characters.
    </p>
    <pre>    basic_istream&lt;charT, traits&gt;&amp;
    getline (char_type*, streamsize);
    </pre>
    <p>
    Also sets failbit if it fails to extract any characters.
    </p>
    <pre>    basic_istream&lt;charT, traits&gt;&amp;
    ignore (int, int_type);
    </pre>
    <pre>    basic_istream&lt;charT, traits&gt;&amp;
    read (char_type*, streamsize);
    </pre>
    <p>
    Also sets failbit if it encounters end-of-file.
    </p>
    <pre>    streamsize readsome (char_type*, streamsize);
    </pre>

    <p>
The following unformated input member functions set failbit but
not eofbit if they encounter an end-of-file (I find this odd
since the functions make it impossible to distinguish a general
failure from a failure due to end-of-file; the requirement is
also in conflict with all major implementation which set both
eofbit and failbit):
    </p>
    <pre>    int_type get();
    </pre>
    <pre>    basic_istream&lt;charT, traits&gt;&amp;
    get (char_type&amp;);
    </pre>
    <p>
These functions only set failbit of they extract no characters,
otherwise they don't set any bits, even on failure (I find this
inconsistency quite unexpected; the requirement is also in
conflict with all major implementations which set eofbit
whenever they encounter end-of-file):
    </p>
    <pre>    basic_istream&lt;charT, traits&gt;&amp;
    get (basic_streambuf&lt;charT, traits&gt;&amp;, char_type);
    </pre>
    <pre>    basic_istream&lt;charT, traits&gt;&amp;
    get (basic_streambuf&lt;charT, traits&gt;&amp;);
    </pre>
    <p>
This function sets no bits (all implementations except for
STLport and Classic Iostreams set eofbit when they encounter
end-of-file):
    </p>
    <pre>    int_type peek ();
    </pre>
<p>Informally, what we want is a global statement of intent saying
  that eofbit gets set if we trip across EOF, and then we can take
  away the specific wording for individual functions.  A full review
  is necessary.  The wording currently in the standard is a mishmash,
  and changing it on an individual basis wouldn't make things better.
  Dietmar will do this work.</p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Moved to NAD.  See 27.7.1.1 [istream] p3.
</blockquote>



<p><b>Proposed resolution:</b></p>




<hr>
<h3><a name="399"></a>399. volations of unformatted input function requirements</h3>
<p><b>Section:</b> 27.7.1.3 [istream.unformatted] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-01-05 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream.unformatted">issues</a> in [istream.unformatted].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
    <p>
The Effects clauses for the two functions below violate the
general requirements on unformatted input functions outlined
in 27.6.1.3: they do not begin by constructing a sentry object.
Instead, they begin by calling widen ('\n'), which may throw
an exception. The exception is then allowed to propagate from
the unformatted input function irrespective of the setting of
exceptions().
    </p>
    <p>
Note that in light of 27.6.1.1, p3 and p4, the fact that the
functions allow exceptions thrown from widen() to propagate
may not strictly speaking be a defect (but the fact that the
functions do not start by constructing a sentry object still
is). However, since an exception thrown from ctype&lt;charT&gt;
::widen() during any other input operation (say, from within
a call to num_get&lt;charT&gt;::get()) will be caught and cause
badbit to be set, these two functions should not be treated
differently for the sake of consistency.
    </p>
  

<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>
Not a defect.  The standard is consistent, and the behavior required
by the standard is unambiguous.  Yes, it's theoretically possible for
widen to throw.  (Not that this will happen for the default ctype
facet or for most real-world replacement ctype facets.)  Users who
define ctype facets that can throw, and who care about this behavior,
can use alternative signatures that don't call widen.
</p>






<hr>
<h3><a name="408"></a>408. Is vector&lt;reverse_iterator&lt;char*&gt; &gt; forbidden?</h3>
<p><b>Section:</b> 24.2 [iterator.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Nathan Myers <b>Opened:</b> 2003-06-03 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iterator.requirements">issues</a> in [iterator.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I've been discussing iterator semantics with Dave Abrahams, and a 
surprise has popped up.  I don't think this has been discussed before.
</p>

<p>
X [iterator.concepts] says that the only operation that can be performed on "singular"
iterator values is to assign a non-singular value to them.  (It 
doesn't say they can be destroyed, and that's probably a defect.)  
Some implementations have taken this to imply that there is no need 
to initialize the data member of a reverse_iterator&lt;&gt; in the default
constructor.  As a result, code like
</p>
<blockquote><pre>  std::vector&lt;std::reverse_iterator&lt;char*&gt; &gt; v(7);
  v.reserve(1000);
</pre></blockquote>
<p>
invokes undefined behavior, because it must default-initialize the
vector elements, and then copy them to other storage.  Of course many 
other vector operations on these adapters are also left undefined,
and which those are is not reliably deducible from the standard.
</p>

<p>
I don't think that 24.1 was meant to make standard-library iterator 
types unsafe.  Rather, it was meant to restrict what operations may 
be performed by functions which take general user- and standard 
iterators as arguments, so that raw pointers would qualify as
iterators.  However, this is not clear in the text, others have come 
to the opposite conclusion.
</p>

<p>
One question is whether the standard iterator adaptors have defined
copy semantics.  Another is whether they have defined destructor
semantics: is
</p>
<blockquote><pre>  { std::vector&lt;std::reverse_iterator&lt;char*&gt; &gt;  v(7); }
</pre></blockquote>
<p>
undefined too?
</p>

<p>
Note this is not a question of whether algorithms are allowed to
rely on copy semantics for arbitrary iterators, just whether the
types we actually supply support those operations.  I believe the 
resolution must be expressed in terms of the semantics of the 
adapter's argument type.  It should make clear that, e.g., the 
reverse_iterator&lt;T&gt; constructor is actually required to execute
T(), and so copying is defined if the result of T() is copyable.
</p>

<p>
Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#235">235</a>, which defines reverse_iterator's default
constructor more precisely, has some relevance to this issue.
However, it is not the whole story.
</p>

<p>
The issue was whether 
</p>
<blockquote><pre>  reverse_iterator() { }
</pre></blockquote>
<p>
is allowed, vs. 
</p>
<blockquote><pre>  reverse_iterator() : current() { }
</pre></blockquote>

<p>
The difference is when T is char*, where the first leaves the member
uninitialized, and possibly equal to an existing pointer value, or
(on some targets) may result in a hardware trap when copied.
</p>

<p>
8.5 paragraph 5 seems to make clear that the second is required to
satisfy DR <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#235">235</a>, at least for non-class Iterator argument
types.
</p>

<p>
But that only takes care of reverse_iterator, and doesn't establish
a policy for all iterators.  (The reverse iterator adapter was just
an example.)  In particular, does my function
</p>
<blockquote><pre>  template &lt;typename Iterator&gt;
    void f() { std::vector&lt;Iterator&gt;  v(7); } 
</pre></blockquote>
<p>
evoke undefined behavior for some conforming iterator definitions?
I think it does, now, because vector&lt;&gt; will destroy those singular
iterator values, and that's explicitly disallowed.
</p>

<p>
24.1 shouldn't give blanket permission to copy all singular iterators,
because then pointers wouldn't qualify as iterators.  However, it
should allow copying of that subset of singular iterator values that
are default-initialized, and it should explicitly allow destroying any
iterator value, singular or not, default-initialized or not.
</p>

<p>Related issues: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#407">407</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1012">1012</a></p>
<p><i>[
We don't want to require all singular iterators to be copyable,
because that is not the case for pointers.  However, default
construction may be a special case.  Issue: is it really default
construction we want to talk about, or is it something like value
initialization?  We need to check with core to see whether default
constructed pointers are required to be copyable; if not, it would be
wrong to impose so strict a requirement for iterators.
]</i></p>


<p><i>[
2009-05-10 Alisdair provided wording.
]</i></p>


<blockquote>
The comments regarding destroying singular iterators have already been
resolved.  That just leaves copying (with moving implied).
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
This is related to LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1012">1012</a>.
</p>
<p>
Note that there is a bug in the proposed resolution to LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1012">1012</a>. The
change to  [reverse.iter.con] should be modified so that the word
"default" in the second sentence of the Effects clause is replaced by
"value."
</p>
<p>
We believe that the proposed fix to LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1012">1012</a> (now corrected) is
sufficient to solve the problem for reverse_iterator. However, Alisdair
pointed out that LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1012">1012</a> does not solve the general problem for authors
of iterator adaptors.
</p>
<p>
There are some problems with the proposed resolution. The phrase "safely
copyable" is not a term of art. Also, it mentions a
DefaultConstructible? concept.
</p>
<p>
Move to Review after Alisdair updates the wording.
</p>
</blockquote>

<p><i>[
2009-07-31 Alisdair revised wording:
]</i></p>


<p><i>[
2009-08-17 Alisdair and Daniel collaborate on slightly revised wording.
This issue depends upon <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#724">724</a>
]</i></p>


<p><i>[
2009-10-14 Daniel adds:
]</i></p>


<blockquote>
There is a clear dependency on <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1213">1213</a>, because the term "singular",
which is used as part of the resolution, is not properly defined yet.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Moved to Open. Alisdair will provide improved wording to make
this have "value semantics" and otherwise behave like a valid iterator.
</blockquote>

<p><i>[
2010 Pittsburgh:  Moved to NAD Editorial.  Rationale added below.
]</i></p>




<p><b>Rationale:</b></p>
<p>
Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3066.html">N3066</a>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add a new paragrpah to Iterator concepts 24.2 [iterator.requirements] after para 5 (the one describing
singular iterators)
</p>
<blockquote>
<p>
Just as a regular pointer to an array guarantees that there is a pointer
value pointing past the last element of the array, so for any iterator
type there is an iterator value that points past the last element of a
corresponding container. These values are called <i>past-the-end</i> values.
Values of an iterator <tt>i</tt> for which the expression <tt>*i</tt> is defined are called
<i>dereferenceable</i>. The library never assumes that past-the-end values are
dereferenceable. Iterators can also have singular values that are not
associated with any container. [<i>Example:</i> After the declaration of an
uninitialized pointer <tt>x</tt> (as with <tt>int* x;</tt>), <tt>x</tt> must always be assumed to
have a singular value of a pointer.  <i>end example</i>] Results of most
expressions are undefined for singular values; the only exceptions are
destroying an iterator that holds a singular value and the assignment of
a non-singular value to an iterator that holds a singular value. In this
case the singular value is overwritten the same way as any other value.
Dereferenceable values are always non-singular.
</p>
<p><ins>
After value-initialization, any iterator that satisfies the
<tt>DefaultConstructible</tt> requirements ([defaultconstructible]) shall not introduce undefined behaviour
when used <ins>as</ins> the
source of a copy or move operation, even if it would
otherwise be singular. [<i>Note:</i> This guarantee is not offered for
default-initialization (8.5 [dcl.init]), although the distinction only
matters for types with trivial default constructors such as pointers. 
<i>end note</i>]
</ins></p>


</blockquote>






<hr>
<h3><a name="417"></a>417. what does ctype::do_widen() return on failure</h3>
<p><b>Section:</b> 22.4.1.1.2 [locale.ctype.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-09-18 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.ctype.virtuals">issues</a> in [locale.ctype.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The Effects and Returns clauses of the do_widen() member function of
the ctype facet fail to specify the behavior of the function on failure.
That the function may not be able to simply cast the narrow character
argument to the type of the result since doing so may yield the wrong value
for some wchar_t encodings. Popular implementations of ctype&lt;wchar_t&gt; that
use mbtowc() and UTF-8 as the native encoding (e.g., GNU glibc) will fail
when the argument's MSB is set. There is no way for the the rest of locale
and iostream to reliably detect this failure. 
</p>
<p><i>[Kona: This is a real problem.  Widening can fail.  It's unclear
  what the solution should be.  Returning WEOF works for the wchar_t
  specialization, but not in general.  One option might be to add a
  default, like <i>narrow</i>.  But that's an incompatible change.
  Using <i>traits::eof</i> might seem like a good idea, but facets
  don't have access to traits (a recurring problem).  We could
  have <i>widen</i> throw an exception, but that's a scary option;
  existing library components aren't written with the assumption
  that <i>widen</i> can throw.]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
NAD. The behavior is specified for all of the facets that an
implementation is required to provide, for the basic character set.
</blockquote>



<p><b>Proposed resolution:</b></p>




<hr>
<h3><a name="418"></a>418. exceptions thrown during iostream cleanup</h3>
<p><b>Section:</b> 27.5.2.1.6 [ios::Init] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-09-18 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ios::Init">issues</a> in [ios::Init].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The dtor of the ios_base::Init object is supposed to call flush() on the
6 standard iostream objects cout, cerr, clog, wcout, wcerr, and wclog.
This call may cause an exception to be thrown.
</p>

<p>
17.4.4.8, p3 prohibits all library destructors from throwing exceptions.
</p>

<p>
The question is: What should this dtor do if one or more of these calls
to flush() ends up throwing an exception? This can happen quite easily
if one of the facets installed in the locale imbued in the iostream
object throws.
</p>
<p><i>[Kona: We probably can't do much better than what we've got, so
  the LWG is leaning toward NAD.  At the point where the standard
  stream objects are being cleaned up, the usual error reporting
  mechanism are all unavailable.  And exception from flush at this
  point will definitely cause problems.  A quality implementation
  might reasonably swallow the exception, or call abort, or do
  something even more drastic.]</i></p>


<p><i>[
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#397">397</a> and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#622">622</a> for related issues.
]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Moved to NAD, no consensus for change.
</blockquote>



<p><b>Proposed resolution:</b></p>




<hr>
<h3><a name="421"></a>421. is basic_streambuf copy-constructible?</h3>
<p><b>Section:</b> 27.6.2.1 [streambuf.cons] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-09-18 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#streambuf.cons">issues</a> in [streambuf.cons].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The reflector thread starting with c++std-lib-11346 notes that the class
template basic_streambuf, along with basic_stringbuf and basic_filebuf,
is copy-constructible but that the semantics of the copy constructors
are not defined anywhere. Further, different implementations behave
differently in this respect: some prevent copy construction of objects
of these types by declaring their copy ctors and assignment operators
private, others exhibit undefined behavior, while others still give
these operations well-defined semantics.
</p>

<p>
Note that this problem doesn't seem to be isolated to just the three
types mentioned above. A number of other types in the library section
of the standard provide a compiler-generated copy ctor and assignment
operator yet fail to specify their semantics.  It's believed that the
only types for which this is actually a problem (i.e. types where the
compiler-generated default may be inappropriate and may not have been
intended) are locale facets.  See issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#439">439</a>.
</p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
NAD. Option B is already in the Working Draft.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
27.5.2 [lib.streambuf]:  Add into the synopsis, public section, just above the destructor declaration:
</p>

<blockquote>
<pre>basic_streambuf(const basic_streambuf&amp; sb);
basic_streambuf&amp; operator=(const basic_streambuf&amp; sb);
</pre>
</blockquote>

<p>Insert after 27.5.2.1, paragraph 2:</p>
<blockquote>
<pre>basic_streambuf(const basic_streambuf&amp; sb);
</pre>

<p>Constructs a copy of sb.</p>
<p>Postcondtions:</p>
<pre>                eback() == sb.eback()
                gptr()  == sb.gptr()
                egptr() == sb.egptr()
                pbase() == sb.pbase()
                pptr()  == sb.pptr()
                epptr() == sb.epptr()
                getloc() == sb.getloc()
</pre>

<pre>basic_streambuf&amp; operator=(const basic_streambuf&amp; sb);
</pre>

<p>Assigns the data members of sb to this.</p>

<p>Postcondtions:</p>
<pre>                eback() == sb.eback()
                gptr()  == sb.gptr()
                egptr() == sb.egptr()
                pbase() == sb.pbase()
                pptr()  == sb.pptr()
                epptr() == sb.epptr()
                getloc() == sb.getloc()
</pre>

<p>Returns: *this.</p>
</blockquote>

<p>27.7.1 [lib.stringbuf]:</p>

<p><b>Option A:</b></p>

<blockquote>
<p>Insert into the basic_stringbuf synopsis in the private section:</p>

<pre>basic_stringbuf(const basic_stringbuf&amp;);             // not defined
basic_stringbuf&amp; operator=(const basic_stringbuf&amp;);  // not defined
</pre>
</blockquote>

<p><b>Option B:</b></p>

<blockquote>
<p>Insert into the basic_stringbuf synopsis in the public section:</p>

<pre>basic_stringbuf(const basic_stringbuf&amp; sb);
basic_stringbuf&amp; operator=(const basic_stringbuf&amp; sb);
</pre>

<p>27.7.1.1, insert after paragraph 4:</p>

<pre>basic_stringbuf(const basic_stringbuf&amp; sb);</pre>

<p>
Constructs an independent copy of sb as if with sb.str(), and with the openmode that sb was constructed with.
</p>

<p>Postcondtions: </p>
<pre>               str() == sb.str()
               gptr()  - eback() == sb.gptr()  - sb.eback()
               egptr() - eback() == sb.egptr() - sb.eback()
               pptr()  - pbase() == sb.pptr()  - sb.pbase()
               getloc() == sb.getloc()
</pre>

<p>
Note:  The only requirement on epptr() is that it point beyond the initialized range if an output sequence exists.  There is no requirement that epptr() - pbase() == sb.epptr() - sb.pbase().
</p>

<pre>basic_stringbuf&amp; operator=(const basic_stringbuf&amp; sb);</pre>
<p>
After assignment the basic_stringbuf has the same state as if it were initially copy constructed from sb, except that the basic_stringbuf is allowed to retain any excess capacity it might have, which may in turn effect the value of epptr().
</p>
</blockquote>

<p>27.8.1.1 [lib.filebuf]</p>

<p>Insert at the bottom of the basic_filebuf synopsis:</p>

<blockquote>
<pre>private:
  basic_filebuf(const basic_filebuf&amp;);             // not defined
  basic_filebuf&amp; operator=(const basic_filebuf&amp;);  // not defined
</pre>
</blockquote>
<p><i>[Kona: this is an issue for basic_streambuf itself and for its
  derived classes.  We are leaning toward allowing basic_streambuf to
  be copyable, and specifying its precise semantics.  (Probably the
  obvious: copying the buffer pointers.)  We are less sure whether
  the streambuf derived classes should be copyable.  Howard will
  write up a proposal.]</i></p>


<p><i>[Sydney: Dietmar presented a new argument against basic_streambuf
  being copyable: it can lead to an encapsulation violation. Filebuf
  inherits from streambuf. Now suppose you inhert a my_hijacking_buf
  from streambuf. You can copy the streambuf portion of a filebuf to a
  my_hijacking_buf, giving you access to the pointers into the
  filebuf's internal buffer. Perhaps not a very strong argument, but
  it was strong enough to make people nervous. There was weak
  preference for having streambuf not be copyable. There was weak
  preference for having stringbuf not be copyable even if streambuf
  is. Move this issue to open for now.
]</i></p>


<p><i>[
2007-01-12, Howard:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1862.html#27.5.2%20-%20Class%20template%20basic_streambuf%3CcharT,traits%3E">Rvalue Reference Recommendations for Chapter 27</a>
recommends protected copy constructor and assignment for <tt>basic_streambuf</tt> with the same semantics
as would be generated by the compiler.  These members aid in derived classes implementing move semantics.
A protected copy constructor and copy assignment operator do not expose encapsulation more so than it is
today as each data member of a <tt>basic_streambuf</tt> is already both readable and writable by derived
classes via various get/set protected member functions (<tt>eback()</tt>, <tt>setp()</tt>, etc.).  Rather
a protected copy constructor and copy assignment operator simply make the job of derived classes implementing
move semantics less tedious and error prone.
]</i></p>




<p><b>Rationale:</b></p>
<p>
27.5.2 [lib.streambuf]: The proposed basic_streambuf copy constructor
and assignment operator are the same as currently implied by the lack
of declarations: public and simply copies the data members.  This
resolution is not a change but a clarification of the current
standard.
</p>

<p>
27.7.1 [lib.stringbuf]: There are two reasonable options: A) Make
basic_stringbuf not copyable.  This is likely the status-quo of
current implementations.  B) Reasonable copy semantics of
basic_stringbuf can be defined and implemented.  A copyable
basic_streambuf is arguably more useful than a non-copyable one.  This
should be considered as new functionality and not the fixing of a
defect.  If option B is chosen, ramifications from issue 432 are taken
into account.
</p>

<p>
27.8.1.1 [lib.filebuf]: There are no reasonable copy semantics for
basic_filebuf.
</p>






<hr>
<h3><a name="423"></a>423. effects of negative streamsize in iostreams</h3>
<p><b>Section:</b> 27 [input.output] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Future">NAD Future</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-09-18 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#input.output">issues</a> in [input.output].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>

<p>
A third party test suite tries to exercise istream::ignore(N) with
a negative value of N and expects that the implementation will treat
N as if it were 0. Our implementation asserts that (N &gt;= 0) holds and
aborts the test.
</p>

<p>
I can't find anything in section 27 that prohibits such values but I don't
see what the effects of such calls should be, either (this applies to
a number of unformatted input functions as well as some member functions
of the basic_streambuf template).
</p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
This is related to LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#255">255</a>.
</p>
<p>
Move to NAD Future.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
I propose that we add to each function in clause 27 that takes an argument,
say N, of type streamsize a Requires clause saying that "N &gt;= 0." The intent
is to allow negative streamsize values in calls to precision() and width()
but disallow it in calls to streambuf::sgetn(), istream::ignore(), or
ostream::write().
</p>

<p><i>[Kona: The LWG agreed that this is probably what we want.  However, we
  need a review to find all places where functions in clause 27 take
  arguments of type streamsize that shouldn't be allowed to go
  negative.  Martin will do that review.]</i></p>






<hr>
<h3><a name="424"></a>424. normative notes</h3>
<p><b>Section:</b> 17.5.1.2 [structure.summary] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-09-18 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The text in 17.3.1.1, p1 says:
<br>

"Paragraphs labelled "Note(s):" or "Example(s):" are informative, other
paragraphs are normative."
<br>

The library section makes heavy use of paragraphs labeled "Notes(s),"
some of which are clearly intended to be normative (see list 1), while
some others are not (see list 2). There are also those where the intent
is not so clear (see list 3).
<br><br>

List 1 -- Examples of (presumably) normative Notes:
<br>

20.9.5.1 [allocator.members], p3,<br>
20.9.5.1 [allocator.members], p10,<br>
21.4.2 [string.cons], p11,<br>
22.3.1.2 [locale.cons], p11,<br>
23.3.2.3 [deque.modifiers], p2,<br>
25.4.7 [alg.min.max], p3,<br>
26.4.6 [complex.ops], p15,<br>
27.6.2.4.3 [streambuf.virt.get], p7.<br>
<br>

List 2 -- Examples of (presumably) informative Notes:
<br>

18.6.1.3 [new.delete.placement], p3,<br>
21.4.6.6 [string::replace], p14,<br>
22.4.1.4.2 [locale.codecvt.virtuals], p3,<br>
25.2.4 [alg.foreach], p4,<br>
26.4.5 [complex.member.ops], p1,<br>
27.5.2.5 [ios.base.storage], p6.<br>
<br>

List 3 -- Examples of Notes that are not clearly either normative
or informative:
<br>

22.3.1.2 [locale.cons], p8,<br>
22.3.1.5 [locale.statics], p6,<br>
27.6.2.4.5 [streambuf.virt.put], p4.<br>
<br>

None of these lists is meant to be exhaustive.
</p>

<p><i>[Definitely a real problem.  The big problem is there's material
  that doesn't quite fit any of the named paragraph categories
  (e.g. <b>Effects</b>).  Either we need a new kind of named
  paragraph, or we need to put more material in unnamed paragraphs
  jsut after the signature.  We need to talk to the Project Editor
  about how to do this.
]</i></p>


<p><i>[
Bellevue: Specifics of list 3: First 2 items correct in std (22.1.1.2,
22.1.1.5) Third item should be non-normative (27.5.2.4.5), which Pete
will handle editorially.
]</i></p>


<p><i>[
post San Francisco:  Howard: reopened, needs attention.
]</i></p>


<p><i>[Pete: I changed the paragraphs marked "Note" and "Notes" to use "Remark" and "Remarks".
Fixed as editorial.  This change has been in the WD since the post-Redmond mailing, in 2004.
Recommend NAD.]</i></p>


<p><i>[
Batavia:  We feel that the references in List 2 above should be changed from <i>Remarks</i>
to <i>Notes</i>.  We also feel that those items in List 3 need to be double checked for
the same change.  Alan and Pete to review.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
A spot-check of List 2 suggests the issue is still relevant,
and a review of List 3 still seems called-for.
</p>
<p>
Move to NAD Editorial.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>




<hr>
<h3><a name="429"></a>429. typo in basic_ios::clear(iostate)</h3>
<p><b>Section:</b> 27.5.4.3 [iostate.flags] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-09-18 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iostate.flags">issues</a> in [iostate.flags].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#412">412</a></p>
<p><b>Discussion:</b></p>
        <p>

The Effects clause in 27.4.4.3, p5 describing the effects of a call to
the ios_base member function clear(iostate state) says that the function
only throws if the respective bits are already set prior to the function
call. That's obviously not the intent. If it was, a call to clear(badbit)
on an object for which (rdstate() == goodbit &amp;&amp; exceptions() == badbit)
holds would not result in an exception being thrown.

        </p>
    
    <p><b>Proposed resolution:</b></p>
        <p>

The text ought to be changed from
<br>

"If (rdstate() &amp; exceptions()) == 0, returns. ..."
<br>

to
<br>

"If (state &amp; exceptions()) == 0, returns. ..."
        </p>


<p><b>Rationale:</b></p>






<hr>
<h3><a name="433"></a>433. Contradiction in specification of unexpected()</h3>
<p><b>Section:</b> D.13.3 [unexpected] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Vyatcheslav Sysoltsev <b>Opened:</b> 2003-09-29 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Clause 15.5.2 [except.unexpected] paragraph 1 says that "void unexpected();
is called (18.7.2) immediately after completing the stack unwinding
for the former function", but 18.7.2.4 (Effects) says that "void
unexpected(); . . . Calls the unexpected_handler function in effect
immediately after evaluating the throwexpression (18.7.2.2),".  Isn't
here a contradiction: 15.5.2 requires stack have been unwound when in
void unexpected() and therefore in unexpected_handler but 18.7.2.4
claims that unexpected_handler is called "in effect immediately" after
evaluation of throw expression is finished, so there is no space left
for stack to be unwound therefore?  I think the phrase "in effect
immediately" should be removed from the standard because it brings
ambiguity in understanding.
</p>


<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>There is no contradiction.  The phrase "in effect immediately" is
  just to clarify which handler is to be called.</p>





<hr>
<h3><a name="437"></a>437. Formatted output of function pointers is confusing</h3>
<p><b>Section:</b> 27.7.2.6.2 [ostream.inserters.arithmetic] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Ivan Godard <b>Opened:</b> 2003-10-24 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ostream.inserters.arithmetic">issues</a> in [ostream.inserters.arithmetic].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Given:
</p>
<pre>void f(int) {}
void(*g)(int) = f;
cout &lt;&lt; g;
</pre>

<p>
(with the expected #include and usings), the value printed is a rather
surprising "true". Rather useless too.
</p>

<p>The standard defines:</p>

<pre>ostream&amp; operator&lt;&lt;(ostream&amp;, void*);</pre>

<p>which picks up all data pointers and prints their hex value, but does
not pick up function pointers because there is no default conversion
from function pointer to void*. Absent that, we fall back to legacy
conversions from C and the function pointer is converted to bool.
</p>

<p>There should be an analogous inserter that prints the address of a
  function pointer.</p>


<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>This is indeed a wart, but there is no good way to solve it.  C
  doesn't provide a portable way of outputting the address of a
  function point either.</p>





<hr>
<h3><a name="439"></a>439. Should facets be copyable?</h3>
<p><b>Section:</b> 22.4 [locale.categories] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2003-11-02 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.categories">issues</a> in [locale.categories].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>The following facets classes have no copy constructors described in
  the standard, which, according to the standard, means that they are
  supposed to use the compiler-generated defaults.  Default copy
  behavior is probably inappropriate.  We should either make these
  classes uncopyable or else specify exactly what their constructors do.</p>

<p>Related issue: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#421">421</a>.</p>

<pre>        ctype_base
        ctype
        ctype_byname
        ctype&lt;char&gt;
        ctype_byname&lt;char&gt;
        codecvt_base
        codecvt
        codecvt_byname
        num_get
        num_put
        numpunct
        numpunct_byname
        collate
        collate_byname
        time_base
        time_get
        time_get_byname
        time_put
        time_put_byname
        money_get
        money_put
        money_base
        moneypunct
        moneypunct_byname
        messages_base
        messages
        messages_byname
</pre>



<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>The copy constructor in the base class is private.</p>





<hr>
<h3><a name="440"></a>440. Should std::complex use unqualified transcendentals?</h3>
<p><b>Section:</b> 26.4.8 [complex.transcendentals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2003-11-05 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Operations like <tt>pow</tt> and <tt>exp</tt> on
<tt>complex&lt;T&gt;</tt> are typically implemented in terms of
operations like <tt>sin</tt> and <tt>cos</tt> on <tt>T</tt>.  
Should implementations write this as <tt>std::sin</tt>, or as plain
unqualified <tt>sin</tt>?
</p>

<p>The issue, of course, is whether we want to use
argument-dependent lookup in the case where <tt>T</tt> is a
user-defined type.  This is similar to the issue of valarray
transcendentals, as discussed in issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#226">226</a>.</p>

<p>This issue differs from valarray transcendentals in two important
ways.  First, "the effect of instantiating the template
<tt>complex</tt> for types other than float, double or long double is
unspecified." (26.4.1 [complex.syn]) Second, the standard does not
dictate implementation, so there is no guarantee that a particular
real math function is used in the implementation of a particular
complex function.</p>



<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>If you instantiate std::complex for user-defined types, all bets
are off.</p>





<hr>
<h3><a name="446"></a>446. Iterator equality between different containers</h3>
<p><b>Section:</b> 24.2 [iterator.requirements], 23.2 [container.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Andy Koenig <b>Opened:</b> 2003-12-16 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iterator.requirements">issues</a> in [iterator.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
What requirements does the standard place on equality comparisons between
iterators that refer to elements of different containers.  For example, if
v1 and v2 are empty vectors, is v1.end() == v2.end() allowed to yield true?
Is it allowed to throw an exception?
</p>

<p>
The standard appears to be silent on both questions.
</p>
<p><i>[Sydney: The intention is that comparing two iterators from
different containers is undefined, but it's not clear if we say that,
or even whether it's something we should be saying in clause 23 or in
clause 24.  Intuitively we might want to say that equality is defined
only if one iterator is reachable from another, but figuring out how
to say it in any sensible way is a bit tricky: reachability is defined
in terms of equality, so we can't also define equality in terms of
reachability.
]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Daniel volunteered to work on this.
</blockquote>

<p><i>[
2009-09-20 Daniel provided wording.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Leave as Open. Alisdair has volunteered to refine the wording.
</blockquote>

<p><i>[
2010 Pittsburgh:  Moved to NAD Editorial.  Rationale added below.
]</i></p>




<p><b>Rationale:</b></p>
<p>
Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3066.html">N3066</a>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Insert a new paragraph between 24.2 [iterator.requirements]/7+8:
</p>

<blockquote>
<p>
[..] The result of the application of functions in the library to invalid
ranges is undefined.
</p>

<p><ins>The result of directly or indirectly evaluating any comparison function
or the binary - operator with two iterator values as arguments that
were obtained
from two different ranges <tt>r1</tt> and <tt>r2</tt> (including their past-the-end values) which
are not subranges of one common range is undefined, unless explicitly
described otherwise.</ins>
</p>

</blockquote>






<hr>
<h3><a name="447"></a>447. Wrong template argument for time facets</h3>
<p><b>Section:</b> 22.3.1.1.1 [locale.category] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2003-12-26 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.category">issues</a> in [locale.category].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#327">327</a></p>
<p><b>Discussion:</b></p>
<p>
22.1.1.1.1/4, table 52, "Required Instantiations", lists, among others:
</p>
<pre>    time_get&lt;char,InputIterator&gt;
    time_get_byname&lt;char,InputIterator&gt;
    time_get&lt;wchar_t,OutputIterator&gt;
    time_get_byname&lt;wchar_t,OutputIterator&gt;
</pre>

<p>
The second argument to the last two should be InputIterator, not
OutputIterator.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change the second template argument to InputIterator.
</p>


<p><b>Rationale:</b></p>






<hr>
<h3><a name="450"></a>450. set::find is inconsistent with associative container requirements</h3>
<p><b>Section:</b> 23.6.3 [set] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Bill Plauger <b>Opened:</b> 2004-01-30 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#set">issues</a> in [set].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#214">214</a></p>
<p><b>Discussion:</b></p>
<p>map/multimap have:</p>

<pre>    iterator find(const key_type&amp; x) const;
    const_iterator find(const key_type&amp; x) const;
</pre>

<p>
which is consistent with the table of associative container requirements.
But set/multiset have:
</p>
<pre>    iterator find(const key_type&amp;) const;
</pre>

<p>
set/multiset should look like map/multimap, and honor the requirements
table, in this regard.
</p>


<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>






<hr>
<h3><a name="451"></a>451. Associative erase should return an iterator</h3>
<p><b>Section:</b> 23.2.4 [associative.reqmts], 23.6 [associative] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Bill Plauger <b>Opened:</b> 2004-01-30 <b>Last modified:</b> 2010-10-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#130">130</a></p>
<p><b>Discussion:</b></p>
<p>map/multimap/set/multiset have:</p>
<pre>    void erase(iterator);
    void erase(iterator, iterator);
</pre>

<p>But there's no good reason why these can't return an iterator, as for
vector/deque/list:</p>
<pre>    iterator erase(iterator);
    iterator erase(iterator, iterator);
</pre>



<p><b>Proposed resolution:</b></p>
<p>
Informally: The table of associative container requirements, and the
relevant template classes, should return an iterator designating the
first element beyond the erased subrange.
</p>


<p><b>Rationale:</b></p>






<hr>
<h3><a name="452"></a>452.  locale::combine should be permitted to generate a named locale</h3>
<p><b>Section:</b> 22.3.1.3 [locale.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Bill Plauger <b>Opened:</b> 2004-01-30 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.members">issues</a> in [locale.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<pre>template&lt;class Facet&gt;
    locale::combine(const locale&amp;) const;
</pre>
<p>
is obliged to create a locale that has no name. This is overspecification
and overkill. The resulting locale should follow the usual rules -- it
has a name if the locale argument has a name and Facet is one of the
standard facets.
</p>

<p><i>[
 Sydney and post-Sydney (see c++std-lib-13439, c++std-lib-13440,
 c++std-lib-13443): agreed that it's overkill to say that the locale
 is obligated to be nameless.  However, we also can't require it to
 have a name.  At the moment, locale names are based on categories
 and not on individual facets.  If a locale contains two different
 facets of different names from the same category, then this would
 not fit into existing naming schemes.  We need to give
 implementations more freedom.  Bill will provide wording.
]</i></p>




<p><b>Rationale:</b></p>
<p>After further discussion the LWG decided to close this as NAD.
  The fundamental problem is that names right now are per-category,
  not per-facet.  The <tt>combine</tt> member function works at the
  wrong level of granularity.</p>





<hr>
<h3><a name="454"></a>454. basic_filebuf::open should accept wchar_t names</h3>
<p><b>Section:</b> 27.9.1.4 [filebuf.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Bill Plauger <b>Opened:</b> 2004-01-30 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#filebuf.members">issues</a> in [filebuf.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#105">105</a></p>
<p><b>Discussion:</b></p>
<pre>    basic_filebuf *basic_filebuf::open(const char *, ios_base::open_mode);
</pre>

<p>should be supplemented with the overload:</p>

<pre>    basic_filebuf *basic_filebuf::open(const wchar_t *, ios_base::open_mode);
</pre>

<p>
Depending on the operating system, one of these forms is fundamental and
the other requires an implementation-defined mapping to determine the
actual filename.
</p>

<p><i>[Sydney: Yes, we want to allow wchar_t filenames.  Bill will
  provide wording.]</i></p>


<p><i>[
In Toronto we noted that this is issue 5 from
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1569.htm">N1569</a>.
]</i></p>

<p>
How does this interact with the newly-defined character types, and how
do we avoid interface explosion considering <tt>std::string</tt> overloads that
were added? Propose another solution that is different than the
suggestion proposed by PJP.
</p>
<p>
Suggestion is to make a member template function for <tt>basic_string</tt> (for
<tt>char</tt>, <tt>wchar_t</tt>, <tt>u16char</tt>, <tt>u32char</tt> instantiations), and then just keep a
<tt>const char*</tt> member.
</p>
<p>
Goal is to do implicit conversion between character string literals to
appropriate <tt>basic_string</tt> type. Not quite sure if this is possible.
</p>
<p>
Implementors are free to add specific overloads for non-char character
types.
</p>

<p><i>[
Martin adds pre-Sophia Antipolis:
]</i></p>


<blockquote>
Please see <a href="http://wiki.dinkumware.com/twiki/pub/Wg21sophiaAntipolis/LibraryWorkingGroup/issue-454.html">issue 454: problems and solutions</a>.
</blockquote>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
<p>
Beman is concerned that making these changes to <tt>basic_filebuf</tt> is not
usefully changed unless <tt>fstream</tt> is also changed; this also only handles
<tt>wchar_t</tt> and not other character types.
</p>
<p>
The TR2 filesystem library is a more complete solution, but is not available soon.
</p>
</blockquote>

<p><i>[
Martin adds:  please reference
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2683.html">N2683</a> for
problems and solutions.
]</i></p>




<p><b>Proposed resolution:</b></p>

<p>Change from:</p>
<blockquote>
<pre>basic_filebuf&lt;charT,traits&gt;* open(
    const char* s,
    ios_base::openmode mode );
</pre>

<p>
Effects: If is_open() != false, returns a null pointer.
Otherwise, initializes the filebuf as required. It then
opens a file, if possible, whose name is the NTBS s ("as if"
by calling std::fopen(s,modstr)).</p>
</blockquote>

<p>to:</p>

<blockquote>
<pre>basic_filebuf&lt;charT,traits&gt;* open(
    const char* s,
    ios_base::openmode mode );

basic_filebuf&lt;charT,traits&gt;* open(
    const wchar_t* ws,
    ios_base::openmode mode );
</pre>

<p>
Effects: If is_open() != false, returns a null pointer.
Otherwise, initializes the filebuf as required. It then
opens a file, if possible, whose name is the NTBS s ("as if"
by calling std::fopen(s,modstr)).
For the second signature, the NTBS s is determined from the
WCBS ws in an implementation-defined manner.
</p>

<p>
(NOTE: For a system that "naturally" represents a filename
as a WCBS, the NTBS s in the first signature may instead
be mapped to a WCBS; if so, it follows the same mapping
rules as the first argument to open.)
</p>
</blockquote>



<p><b>Rationale:</b></p>
<p>
Slightly controversial, but by a 7-1 straw poll the LWG agreed to move
this to Ready.  The controversy was because the mapping between wide
names and files in a filesystem is implementation defined.  The
counterargument, which most but not all LWG members accepted, is that
the mapping between narrow files names and files is also
implemenation defined.</p>

<p><i>[Lillehammer: Moved back to "open" status, at Beman's urging.
(1) Why just basic_filebuf, instead of also basic_fstream (and
possibly other things too). (2) Why not also constructors that take
std::basic_string? (3) We might want to wait until we see Beman's
filesystem library; we might decide that it obviates this.]</i></p>


<p><i>[
post Bellevue:
]</i></p>


<blockquote>
<p>
Move again to Ready.
</p>
<p>
There is a timing issue here. Since the filesystem library will not be
in C++0x, this should be brought forward. This solution would remain
valid in the context of the proposed filesystem.
</p>
<p>
This issue has been kicking around for a while, and the wchar_t addition
alone would help many users. Thus, we suggest putting this on the
reflector list with an invitation for someone to produce proposed
wording that covers basic_fstream. In the meantime, we suggest that the
proposed wording be adopted as-is.
</p>
<p>
If more of the Lillehammer questions come back, they should be
introduced as separate issues.
</p>
</blockquote>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
Some existing implementations provide overload already. Expected
filesystem "path" object overloads neatly, without surprises; implying
NAD.
</blockquote>







<hr>
<h3><a name="458"></a>458. 24.1.5 contains unintended limitation for operator-</h3>
<p><b>Section:</b> 24.2.7 [random.access.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Daniel Frey <b>Opened:</b> 2004-02-27 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#random.access.iterators">issues</a> in [random.access.iterators].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 24.1.5 [lib.random.access.iterators], table 76 the operational
semantics for the expression "r -= n" are defined as "return r += -n".
This means, that the expression -n must be valid, which is not the case
for unsigned types.
</p>

<p><i>[
Sydney: Possibly not a real problem, since difference type is required
to be a signed integer type. However, the wording in the standard may
be less clear than we would like.
]</i></p>


<p><i>[
Post Summit Alisdair adds:
]</i></p>


<blockquote>
<p>
This issue refers to a requirements table we have removed.
</p>
<p>
The issue might now relate to 24.2.7 [random.access.iterators] p5.
However, the rationale in the issue already recognises that the
<tt>difference_type</tt> must be signed, so this really looks NAD.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with Alisdair's observations.
</p>
<p>
Move to NAD.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
<p>
Need to look at again without concepts.
</p>
<p>
There was a question about this phrase in the discussion: "the
expression -n must be valid, which is not the case for unsigned types."
If n is an object ofthe iterator difference_type (eg ptrdiff_t), then it
is never unsigned.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
The group reviewed the wording in the draft and agreed that n is of
difference type, the difference type is signed, and the current wording
is correct.  Moved to NAD.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
To remove this limitation, I suggest to change the
operational semantics for this column to:
</p>
<blockquote><pre>    { Distance m = n;
      if (m &gt;= 0)
        while (m--) --r;
      else
        while (m++) ++r;
      return r; }
</pre></blockquote>






<hr>
<h3><a name="459"></a>459. Requirement for widening in stage 2 is overspecification</h3>
<p><b>Section:</b> 22.4.2.1.2 [facet.num.get.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2004-03-16 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#facet.num.get.virtuals">issues</a> in [facet.num.get.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>When parsing strings of wide-character digits, the standard
  requires the library to widen narrow-character "atoms" and compare
  the widened atoms against the characters that are being parsed.
  Simply narrowing the wide characters would be far simpler, and
  probably more efficient.  The two choices are equivalent except in
  convoluted test cases, and many implementations already ignore the
  standard and use narrow instead of widen.</p>

<p>
First, I disagree that using narrow() instead of widen() would
necessarily have unfortunate performance implications. A possible
implementation of narrow() that allows num_get to be implemented
in a much simpler and arguably comparably efficient way as calling
widen() allows, i.e. without making a virtual call to do_narrow every
time, is as follows:
</p>

<pre>  inline char ctype&lt;wchar_t&gt;::narrow (wchar_t wc, char dflt) const
  {
      const unsigned wi = unsigned (wc);

      if (wi &gt; UCHAR_MAX)
          return typeid (*this) == typeid (ctype&lt;wchar_t&gt;) ?
                 dflt : do_narrow (wc, dflt);

      if (narrow_ [wi] &lt; 0) {
         const char nc = do_narrow (wc, dflt);
         if (nc == dflt)
             return dflt;
         narrow_ [wi] = nc;
      }

      return char (narrow_ [wi]);
  }
</pre>

<p>
Second, I don't think the change proposed in the issue (i.e., to use
narrow() instead of widen() during Stage 2) would be at all
drastic. Existing implementations with the exception of libstdc++
currently already use narrow() so the impact of the change on programs
would presumably be isolated to just a single implementation. Further,
since narrow() is not required to translate alternate wide digit
representations such as those mentioned in issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#303">303</a> to
their narrow equivalents (i.e., the portable source characters '0'
through '9'), the change does not necessarily imply that these
alternate digits would be treated as ordinary digits and accepted as
part of numbers during parsing. In fact, the requirement in 22.4.1.1.2 [locale.ctype.virtuals], p13 forbids narrow() to translate an alternate
digit character, wc, to an ordinary digit in the basic source
character set unless the expression
(ctype&lt;charT&gt;::is(ctype_base::digit, wc) == true) holds. This in
turn is prohibited by the C standard (7.25.2.1.5, 7.25.2.1.5, and
5.2.1, respectively) for charT of either char or wchar_t.
</p>

<p><i>[Sydney: To a large extent this is a nonproblem. As long as
you're only trafficking in char and wchar_t we're only dealing with a
stable character set, so you don't really need either 'widen' or
'narrow': can just use literals. Finally, it's not even clear whether
widen-vs-narrow is the right question; arguably we should be using
codecvt instead.]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
NAD. The standard is clear enough as written.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>Change stage 2 so that implementations are permitted to use either
technique to perform the comparison:</p>
<ol>
  <li> call widen on the atoms and compare (either by using
      operator== or char_traits&lt;charT&gt;::eq) the input with
      the widened atoms, or</li>
  <li> call narrow on the input and compare the narrow input
      with the atoms</li>
  <li> do (1) or (2) only if charT is not char or wchar_t,
      respectively; i.e., avoid calling widen or narrow
      if it the source and destination types are the same</li>
</ol>





<hr>
<h3><a name="462"></a>462. Destroying objects with static storage duration</h3>
<p><b>Section:</b> 3.6.3 [basic.start.term], 18.4 [cstdint] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Bill Plauger <b>Opened:</b> 2004-03-23 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
3.6.3 Termination spells out in detail the interleaving of static
destructor calls and calls to functions registered with atexit. To
match this behavior requires intimate cooperation between the code
that calls destructors and the exit/atexit machinery. The former
is tied tightly to the compiler; the latter is a primitive mechanism
inherited from C that traditionally has nothing to do with static
construction and destruction. The benefits of intermixing destructor
calls with atexit handler calls is questionable at best, and <i>very</i>
difficult to get right, particularly when mixing third-party C++
libraries with different third-party C++ compilers and C libraries
supplied by still other parties.
</p>

<p>
I believe the right thing to do is defer all static destruction
until after all atexit handlers are called. This is a change in
behavior, but one that is likely visible only to perverse test
suites. At the very least, we should <i>permit</i> deferred destruction
even if we don't require it.
</p>

<p><i>[If this is to be changed, it should probably be changed by CWG.
  At this point, however, the LWG is leaning toward NAD.  Implementing
  what the standard says is hard work, but it's not impossible and
  most vendors went through that pain years ago.  Changing this
  behavior would be a user-visible change, and would break at least
  one real application.]</i></p>


<p><i>[
Batavia:  Send to core with our recommendation that we should permit deferred
destruction but not require it.
]</i></p>


<p><i>[
Howard:  The course of action recommended in Batavia would undo LWG
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#3">3</a> and break current code implementing the "phoenix
singleton". Search the net for "phoenix singleton atexit" to get a feel
for the size of the adverse impact this change would have.  Below is
sample code which implements the phoenix singleton and would break if
<tt>atexit</tt> is changed in this way:
]</i></p>


<blockquote><pre>#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
#include &lt;type_traits&gt;
#include &lt;new&gt;

class A
{
    bool alive_;
    A(const A&amp;);
    A&amp; operator=(const A&amp;);
public:
    A() : alive_(true) {std::cout &lt;&lt; "A()\n";}
    ~A() {alive_ = false; std::cout &lt;&lt; "~A()\n";}
    void use()
    {
        if (alive_)
            std::cout &lt;&lt; "A is alive\n";
        else
            std::cout &lt;&lt; "A is dead\n";
    }
};

void deallocate_resource();

// This is the phoenix singleton pattern
A&amp; get_resource(bool create = true)
{
    static std::aligned_storage&lt;sizeof(A), std::alignment_of&lt;A&gt;::value&gt;::type buf;
    static A* a;
    if (create)
    {
        if (a != (A*)&amp;buf)
        {
            a = ::new (&amp;buf) A;
            std::atexit(deallocate_resource);
        }
    }
    else
    {
        a-&gt;~A();
        a = (A*)&amp;buf + 1;
    }
    return *a;
}

void deallocate_resource()
{
    get_resource(false);
}

void use_A(const char* message)
{
    A&amp; a = get_resource();
    std::cout &lt;&lt; "Using A " &lt;&lt; message &lt;&lt; "\n";
    a.use();
}

struct B
{
    ~B() {use_A("from ~B()");}
};

B b;

int main()
{
    use_A("from main()");
}
</pre></blockquote>

<p>
The correct output is:
</p>

<blockquote><pre>A()
Using A from main()
A is alive
~A()
A()
Using A from ~B()
A is alive
~A()
</pre></blockquote>

<p><i>[
Bellevue: Confirmed no interaction with <tt>quick_exit</tt>.
Strong feeling against mandating the change. Leaning towards NAD rather than permitting the change,
as this would make common implementations of pheonix-singleton pattern implementation defined, as noted by Howard.
Bill agrees issue is no longer serious, and accepts NAD.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="463"></a>463. auto_ptr usability issues</h3>
<p><b>Section:</b> D.12.1 [auto.ptr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Rani Sharoni <b>Opened:</b> 2003-12-07 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#auto.ptr">issues</a> in [auto.ptr].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
TC1 CWG DR #84 effectively made the template&lt;class Y&gt; operator auto_ptr&lt;Y&gt;()
member of auto_ptr (20.4.5.3/4) obsolete.
</p>

<p>
The sole purpose of this obsolete conversion member is to enable copy
initialization base from r-value derived (or any convertible types like
cv-types) case:
</p>
<pre>#include &lt;memory&gt;
using std::auto_ptr;

struct B {};
struct D : B {};

auto_ptr&lt;D&gt; source();
int sink(auto_ptr&lt;B&gt;);
int x1 = sink( source() ); // #1 EDG - no suitable copy constructor
</pre>

<p>
The excellent analysis of conversion operations that was given in the final
auto_ptr proposal
(http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/papers/1997/N1128.pdf)
explicitly specifies this case analysis (case 4). DR #84 makes the analysis
wrong and actually comes to forbid the loophole that was exploited by the
auto_ptr designers.
</p>

<p>
I didn't encounter any compliant compiler (e.g. EDG, GCC, BCC and VC) that
ever allowed this case. This is probably because it requires 3 user defined
conversions and in fact current compilers conform to DR #84.
</p>

<p>
I was surprised to discover that the obsolete conversion member actually has
negative impact of the copy initialization base from l-value derived
case:</p>
<pre>auto_ptr&lt;D&gt; dp;
int x2 = sink(dp); // #2 EDG - more than one user-defined conversion applies
</pre>

<p>
I'm sure that the original intention was allowing this initialization using
the template&lt;class Y&gt; auto_ptr(auto_ptr&lt;Y&gt;&amp; a) constructor (20.4.5.1/4) but
since in this copy initialization it's merely user defined conversion (UDC)
and the obsolete conversion member is UDC with the same rank (for the early
overloading stage) there is an ambiguity between them.
</p>

<p>
Removing the obsolete member will have impact on code that explicitly
invokes it:
</p>
<pre>int y = sink(source().operator auto_ptr&lt;B&gt;());
</pre>

<p>
IMHO no one ever wrote such awkward code and the reasonable workaround for
#1 is:
</p>
<pre>int y = sink( auto_ptr&lt;B&gt;(source()) );
</pre>

<p>
I was even more surprised to find out that after removing the obsolete
conversion member the initialization was still ill-formed:
int x3 = sink(dp); // #3 EDG - no suitable copy constructor
</p>

<p>
This copy initialization semantically requires copy constructor which means
that both template conversion constructor and the auto_ptr_ref conversion
member (20.4.5.3/3) are required which is what was explicitly forbidden in
DR #84. This is a bit amusing case in which removing ambiguity results with
no candidates.
</p>

<p>
I also found exception safety issue with auto_ptr related to auto_ptr_ref:
</p>
<pre>int f(auto_ptr&lt;B&gt;, std::string);
auto_ptr&lt;B&gt; source2();

// string constructor throws while auto_ptr_ref
// "holds" the pointer
int x4 = f(source2(), "xyz"); // #4
</pre>

<p>
The theoretic execution sequence that will cause a leak:
</p>
<ol>
<li>call auto_ptr&lt;B&gt;::operator auto_ptr_ref&lt;B&gt;()</li>
<li>call string::string(char const*) and throw</li>
</ol>

<p>
According to 20.4.5.3/3 and 20.4.5/2 the auto_ptr_ref conversion member
returns auto_ptr_ref&lt;Y&gt; that holds *this and this is another defect since
the type of *this is auto_ptr&lt;X&gt; where X might be different from Y. Several
library vendors (e.g. SGI) implement auto_ptr_ref&lt;Y&gt; with Y* as member which
is much more reasonable. Other vendor implemented auto_ptr_ref as
defectively required and it results with awkward and catastrophic code:
int oops = sink(auto_ptr&lt;B&gt;(source())); // warning recursive on all control
paths
</p>

<p>
Dave Abrahams noticed that there is no specification saying that
auto_ptr_ref copy constructor can't throw.
</p>

<p>
My proposal comes to solve all the above issues and significantly simplify
auto_ptr implementation. One of the fundamental requirements from auto_ptr
is that it can be constructed in an intuitive manner (i.e. like ordinary
pointers) but with strict ownership semantics which yield that source
auto_ptr in initialization must be non-const. My idea is to add additional
constructor template with sole propose to generate ill-formed, diagnostic
required, instance for const auto_ptr arguments during instantiation of
declaration. This special constructor will not be instantiated for other
types which is achievable using 14.8.2/2 (SFINAE). Having this constructor
in hand makes the constructor template&lt;class Y&gt; auto_ptr(auto_ptr&lt;Y&gt; const&amp;)
legitimate since the actual argument can't be const yet non const r-value
are acceptable.
</p>

<p>
This implementation technique makes the "private auxiliary class"
auto_ptr_ref obsolete and I found out that modern C++ compilers (e.g. EDG,
GCC and VC) consume the new implementation as expected and allow all
intuitive initialization and assignment cases while rejecting illegal cases
that involve const auto_ptr arguments.
</p>

<p>The proposed auto_ptr interface:</p>

<pre>namespace std {
    template&lt;class X&gt; class auto_ptr {
    public:
        typedef X element_type;

        // 20.4.5.1 construct/copy/destroy:
        explicit auto_ptr(X* p=0) throw();
        auto_ptr(auto_ptr&amp;) throw();
        template&lt;class Y&gt; auto_ptr(auto_ptr&lt;Y&gt; const&amp;) throw();
        auto_ptr&amp; operator=(auto_ptr&amp;) throw();
        template&lt;class Y&gt; auto_ptr&amp; operator=(auto_ptr&lt;Y&gt;) throw();
        ~auto_ptr() throw();

        // 20.4.5.2 members:
        X&amp; operator*() const throw();
        X* operator-&gt;() const throw();
        X* get() const throw();
        X* release() throw();
        void reset(X* p=0) throw();

    private:
        template&lt;class U&gt;
        auto_ptr(U&amp; rhs, typename
unspecified_error_on_const_auto_ptr&lt;U&gt;::type = 0);
    };
}
</pre>

<p>
One compliant technique to implement the unspecified_error_on_const_auto_ptr
helper class is using additional private auto_ptr member class template like
the following:
</p>
<pre>template&lt;typename T&gt; struct unspecified_error_on_const_auto_ptr;

template&lt;typename T&gt;
struct unspecified_error_on_const_auto_ptr&lt;auto_ptr&lt;T&gt; const&gt;
{ typedef typename auto_ptr&lt;T&gt;::const_auto_ptr_is_not_allowed type; };
</pre>

<p>
There are other techniques to implement this helper class that might work
better for different compliers (i.e. better diagnostics) and therefore I
suggest defining its semantic behavior without mandating any specific
implementation. IMO, and I didn't found any compiler that thinks otherwise,
14.7.1/5 doesn't theoretically defeat the suggested technique but I suggest
verifying this with core language experts.
</p>

<p><b>Further changes in standard text:</b></p>
<p>Remove section 20.4.5.3</p>

<p>Change 20.4.5/2 to read something like:
Initializing auto_ptr&lt;X&gt; from const auto_ptr&lt;Y&gt; will result with unspecified
ill-formed declaration that will require unspecified diagnostic.</p>

<p>Change 20.4.5.1/4,5,6 to read:</p>

<pre>template&lt;class Y&gt; auto_ptr(auto_ptr&lt;Y&gt; const&amp; a) throw();</pre>
<p> 4 Requires: Y* can be implicitly converted to X*.</p>
<p> 5 Effects: Calls const_cast&lt;auto_ptr&lt;Y&gt;&amp;&gt;(a).release().</p>
<p> 6 Postconditions: *this holds the pointer returned from a.release().</p>

<p>Change 20.4.5.1/10</p>
<pre>template&lt;class Y&gt; auto_ptr&amp; operator=(auto_ptr&lt;Y&gt; a) throw();
</pre>
<p>
10 Requires: Y* can be implicitly converted to X*. The expression delete
get() is well formed.
</p>

<p>LWG TC DR #127 is obsolete.</p>

<p>
Notice that the copy constructor and copy assignment operator should remain
as before and accept non-const auto_ptr&amp; since they have effect on the form
of the implicitly declared copy constructor and copy assignment operator of
class that contains auto_ptr as member per 12.8/5,10:
</p>
<pre>struct X {
    // implicit X(X&amp;)
    // implicit X&amp; operator=(X&amp;)
    auto_ptr&lt;D&gt; aptr_;
};
</pre>

<p>
In most cases this indicates about sloppy programming but preserves the
current auto_ptr behavior.
</p>

<p>
Dave Abrahams encouraged me to suggest fallback implementation in case that
my suggestion that involves removing of auto_ptr_ref will not be accepted.
In this case removing the obsolete conversion member to auto_ptr&lt;Y&gt; and
20.4.5.3/4,5 is still required in order to eliminate ambiguity in legal
cases. The two constructors that I suggested will co exist with the current
members but will make auto_ptr_ref obsolete in initialization contexts.
auto_ptr_ref will be effective in assignment contexts as suggested in DR
#127 and I can't see any serious exception safety issues in those cases
(although it's possible to synthesize such). auto_ptr_ref&lt;X&gt; semantics will
have to be revised to say that it strictly holds pointer of type X and not
reference to an auto_ptr for the favor of cases in which auto_ptr_ref&lt;Y&gt; is
constructed from auto_ptr&lt;X&gt; in which X is different from Y (i.e. assignment
from r-value derived to base).
</p>

<p><i>[Redmond: punt for the moment. We haven't decided yet whether we
  want to fix auto_ptr for C++-0x, or remove it and replace it with
  move_ptr and unique_ptr.]</i></p>


<p><i>[
Oxford 2007: Recommend NAD.  We're just going to deprecate it.  It still works for simple use cases
and people know how to deal with it.  Going forward <tt>unique_ptr</tt> is the recommended
tool.
]</i></p>


<p><i>[
2007-11-09: Reopened at the request of David Abrahams, Alisdair Meredith and Gabriel Dos Reis.
]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
This is a complicated issue, so we agreed to defer discussion until
later in the week so that interested parties can read up on it.
</blockquote>

<p><i>[
209-10-04 Daniel adds:
]</i></p>


<blockquote>
<p>
I suggest to close this issue as NAD. The reasons are two-fold: First, the
suggested proposed resolution uses no longer appropriate language means
to solve this issue, which has the effect that the recommended resolution is
another - but better - form of hack. Second, either following the suggested
resolution or the now more natural alternative via the added member set
</p>

<blockquote><pre>template&lt;class Y&gt; auto_ptr(auto_ptr&lt;Y&gt;&amp;&amp;) throw();
template&lt;class Y&gt; auto_ptr&amp; operator=(auto_ptr&lt;Y&gt;&amp;&amp;) throw();
</pre></blockquote>

<p>
would still have a non-zero probability to break user-code that actively
references <tt>auto_ptr_ref</tt>. This risk seems to indicate that a
decision which would not touch the current spec of <tt>auto_ptr</tt> at
all (but deprecating it) and instead recommending to use
<tt>unique_ptr</tt> for new code instead might have the best
cost-benefit ratio. IMO the current solution of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1100">1100</a> can
be considered as an active user-support for this transition.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Mark as NAD. Alisdair will open a new issue (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1247">1247</a>) with
proposed wording to handle <tt>auto_ptr_ref</tt>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change the synopsis in D.12.1 [auto.ptr]:
</p>

<blockquote><pre>namespace std { 
  <del>template &lt;class Y&gt; struct auto_ptr_ref {};</del>

  <ins>// exposition only</ins>
  <ins>template &lt;class T&gt; struct constant_object;</ins>

  <ins>// exposition only</ins>
  <ins>template &lt;class T&gt;</ins>
  <ins>struct cannot_transfer_ownership_from</ins>
    <ins>: constant_object&lt;T&gt; {};</ins>

  template &lt;class X&gt; class auto_ptr { 
  public: 
    typedef X element_type; 

    // D.9.1.1 construct/copy/destroy: 
    explicit auto_ptr(X* p =0) throw(); 
    auto_ptr(auto_ptr&amp;) throw(); 
    template&lt;class Y&gt; auto_ptr(auto_ptr&lt;Y&gt;<ins> const</ins>&amp;) throw(); 
    auto_ptr&amp; operator=(auto_ptr&amp;) throw(); 
    template&lt;class Y&gt; auto_ptr&amp; operator=(auto_ptr&lt;Y&gt;<del>&amp;</del>) throw();
    <del>auto_ptr&amp; operator=(auto_ptr_ref&lt;X&gt; r) throw();</del>
    ~auto_ptr() throw(); 

    // D.9.1.2 members: 
    X&amp; operator*() const throw();
    X* operator-&gt;() const throw();
    X* get() const throw();
    X* release() throw();
    void reset(X* p =0) throw();

    <del>// D.9.1.3 conversions:</del>
    <del>auto_ptr(auto_ptr_ref&lt;X&gt;) throw();</del>
    <del>template&lt;class Y&gt; operator auto_ptr_ref&lt;Y&gt;() throw();</del>
    <del>template&lt;class Y&gt; operator auto_ptr&lt;Y&gt;() throw();</del>

    <ins>// exposition only</ins>
    <ins>template&lt;class U&gt;</ins>
    <ins>auto_ptr(U&amp; rhs, typename cannot_transfer_ownership_from&lt;U&gt;::error = 0);</ins>
  }; 

  template &lt;&gt; class auto_ptr&lt;void&gt; 
  { 
  public: 
    typedef void element_type; 
  }; 

}
</pre></blockquote>

<p>
Remove D.12.1.3 [auto.ptr.conv].
</p>

<p>
Change D.12.1 [auto.ptr], p3:
</p>

<blockquote>
The <tt>auto_ptr</tt> provides a semantics of strict ownership. An
<tt>auto_ptr</tt> owns the object it holds a pointer to. Copying an
<tt>auto_ptr</tt> copies the pointer and transfers ownership to the
destination. If more than one <tt>auto_ptr</tt> owns the same object at
the same time the behavior of the program is undefined. <ins>Templates
<tt>constant_object</tt> and <tt>cannot_transfer_ownership_from</tt>,
and the final constructor of <tt>auto_ptr</tt> are for exposition only.
For any types <tt>X</tt> and <tt>Y</tt>, initializing
<tt>auto_ptr&lt;X&gt;</tt> from <tt>const auto_ptr&lt;Y&gt;</tt> is
ill-formed, diagnostic required.</ins> [<i>Note:</i> The uses of
<tt>auto_ptr</tt> include providing temporary exception-safety for
dynamically allocated memory, passing ownership of dynamically allocated
memory to a function, and returning dynamically allocated memory from a
function. <tt>auto_ptr</tt> does not meet the <tt>CopyConstructible</tt>
and <tt>Assignable</tt> requirements for Standard Library container
elements and thus instantiating a Standard Library container with an
<tt>auto_ptr</tt> results in undefined behavior. <i>-- end note</i>]
</blockquote>

<p>
Change D.12.1.1 [auto.ptr.cons], p5:
</p>

<blockquote>
<pre>template&lt;class Y&gt; auto_ptr(auto_ptr&lt;Y&gt;<ins> const</ins>&amp; a) throw();
</pre>
<blockquote>
<p>
<i>Requires:</i> <tt>Y*</tt> can be implicitly converted to <tt>X*</tt>.
</p>
<p>
<i>Effects:</i> Calls <ins><tt>const_cast&lt;auto_ptr&lt;Y&gt;&amp;&gt;(</tt></ins><tt>a</tt><ins><tt>)</tt></ins><tt>.release()</tt>.
</p>
<p>
<i>Postconditions:</i> <tt>*this</tt> holds the pointer returned from <tt>a.release()</tt>.
</p>
</blockquote>
</blockquote>

<p>
Change D.12.1.1 [auto.ptr.cons], p10:
</p>

<blockquote>
<pre>template&lt;class Y&gt; auto_ptr&amp; operator=(auto_ptr&lt;Y&gt;<del>&amp;</del> a) throw();
</pre>
<blockquote>
<p>
<i>Requires:</i> <tt>Y*</tt> can be implicitly converted to <tt>X*</tt>.
The expression <tt>delete get()</tt> is well formed.
</p>
<p>
<i>Effects:</i> Calls <tt>reset(a.release())</tt>.
</p>
<p>
<i>Returns:</i> <tt>*this</tt>.
</p>
</blockquote>
</blockquote>






<hr>
<h3><a name="466"></a>466. basic_string ctor should prevent null pointer error</h3>
<p><b>Section:</b> 21.4.1 [string.require] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Daniel Frey <b>Opened:</b> 2004-06-10 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#string.require">issues</a> in [string.require].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Today, my colleagues and me wasted a lot of time. After some time, I
found the problem. It could be reduced to the following short example:
</p>

<pre>  #include &lt;string&gt;
  int main() { std::string( 0 ); }
</pre>

<p>The problem is that the tested compilers (GCC 2.95.2, GCC 3.3.1 and
Comeau online) compile the above without errors or warnings! The
programs (at least for the GCC) resulted in a SEGV.</p>

<p>I know that the standard explicitly states that the ctor of string
requires a char* which is not zero. STLs could easily detect the above
case with a private ctor for basic_string which takes a single 'int'
argument. This would catch the above code at compile time and would not
ambiguate any other legal ctors.</p>

<p><i>[Redmond: No great enthusiasm for doing this.  If we do,
  however, we want to do it for all places that take <tt>charT*</tt>
  pointers, not just the single-argument constructor.  The other
  question is whether we want to catch this at compile time (in which
  case we catch the error of a literal 0, but not an expression whose
  value is a null pointer), at run time, or both.
  Recommend NAD.  Relegate this functionality to debugging implementations.]</i></p>


<p><i>[
Post Summit: Alisdair requests this be re-opened as several new language facilities are
designed to solve exactly this kind of problem.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We are unable to achieve consensus on an approach to a resolution.
There is some sentiment for treating this as a QOI matter.
It is also possible
that when <tt>string</tt> is brought into the concepts world,
this issue might be addressed in that context.
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
We considered three options:
</p>

<ul>
<li>The proposed resolution.</li>
<li>NAD</li>
<li>Interpret a null pointer as the empty string.</li>
</ul>

<p>
The consensus was NAD.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add to the synopsis in 21.4 [basic.string]
</p>

<blockquote><pre><ins>basic_string( nullptr_t ) = delete;</ins>
</pre></blockquote>





<hr>
<h3><a name="470"></a>470. accessing containers from their elements' special functions</h3>
<p><b>Section:</b> 23 [containers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2004-06-28 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#containers">issues</a> in [containers].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The standard doesn't prohibit the destructors (or any other special
functions) of containers' elements invoked from a member function
of the container from "recursively" calling the same (or any other)
member function on the same container object, potentially while the
container is in an intermediate state, or even changing the state
of the container object while it is being modified. This may result
in some surprising (i.e., undefined) behavior.
</p>

<p>Read email thread starting with c++std-lib-13637 for more.</p>



<p><b>Proposed resolution:</b></p>

<p>Add to Container Requirements the following new paragraph:</p>

<pre>    Unless otherwise specified, the behavior of a program that
    invokes a container member function f from a member function
    g of the container's value_type on a container object c that
    called g from its mutating member function h, is undefined.
    I.e., if v is an element of c, directly or indirectly calling
    c.h() from v.g() called from c.f(), is undefined.
</pre>

<p><i>[Redmond: This is a real issue, but it's probably a clause 17
  issue, not clause 23.  We get the same issue, for example, if we
  try to destroy a stream from one of the stream's callback functions.]</i></p>

  


<p><b>Rationale:</b></p>
<p>
Recommend NAD.  We agree this is an issue, but not a defect.
We believe that there is no wording we can put in the standard
that will cover all cases without introducing unfortunate
corner cases.
</p>





<hr>
<h3><a name="472"></a>472. Missing "Returns" clause in std::equal_range</h3>
<p><b>Section:</b> 25.4.3.3 [equal.range] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Prateek R Karandikar <b>Opened:</b> 2004-06-30 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#equal.range">issues</a> in [equal.range].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#270">270</a></p>
<p><b>Discussion:</b></p>
<p>
There is no "Returns:" clause for std::equal_range, which returns non-void.
</p>


<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>Fixed as part of issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#270">270</a>.</p>






<hr>
<h3><a name="476"></a>476. Forward Iterator implied mutability</h3>
<p><b>Section:</b> 24.2.5 [forward.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Dave Abrahams <b>Opened:</b> 2004-07-09 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#forward.iterators">issues</a> in [forward.iterators].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>24.1/3 says:</p>
<blockquote><p>
  Forward iterators satisfy all the requirements of the input and
  output iterators and can be used whenever either kind is specified
</p></blockquote>

<p>
The problem is that satisfying the requirements of output iterator
means that you can always assign *something* into the result of
dereferencing it.  That makes almost all non-mutable forward
iterators non-conforming.  I think we need to sever the refinement
relationship between forward iterator and output iterator.
</p>

<p>Related issue: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#200">200</a>.  But this is not a dup.</p>



<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>Yes, 24.1/3 does say that. But it's introductory material. The
precise specification is in 24.1.3, and the requrements table there is
right.  We don't need to fine-tune introductory wording.  (Especially
since this wording is likely to be changed as part of the iterator
overhaul.)</p> 





<hr>
<h3><a name="477"></a>477. Operator-&gt; for const forward iterators</h3>
<p><b>Section:</b> 24.2.5 [forward.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Dave Abrahams <b>Opened:</b> 2004-07-11 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#forward.iterators">issues</a> in [forward.iterators].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#478">478</a></p>
<p><b>Discussion:</b></p>
<p>
The Forward Iterator requirements table contains the following:
</p>
<pre> expression  return type         operational  precondition
                                  semantics
  ==========  ==================  ===========  ==========================
  a-&gt;m        U&amp; if X is mutable, (*a).m       pre: (*a).m is well-defined.
              otherwise const U&amp;

  r-&gt;m        U&amp;                  (*r).m       pre: (*r).m is well-defined.
</pre>

<p>
The first line is exactly right.  The second line is wrong.  Basically
it implies that the const-ness of the iterator affects the const-ness
of referenced members.  But Paragraph 11 of [lib.iterator.requirements] says:
</p>

<blockquote><p>
   In the following sections, a and b denote values of type const X, n
   denotes a value of the difference type Distance, u, tmp, and m
   denote identifiers, r denotes a value of X&amp;, t denotes a value of
   value type T, o denotes a value of some type that is writable to
   the output iterator.
</p></blockquote>

<p>AFAICT if we need the second line at all, it should read the same
as the first line.</p>

<p>Related issue: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#478">478</a></p>


<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>The LWG agrees that this is a real problem.  Marked as a DUP
  because the LWG chose to adopt the solution proposed in
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#478">478</a>.
</p>





<hr>
<h3><a name="479"></a>479. Container requirements and placement new</h3>
<p><b>Section:</b> 23.2 [container.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Herb Sutter <b>Opened:</b> 2004-08-01 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#580">580</a></p>
<p><b>Discussion:</b></p>
<p>Nothing in the standard appears to make this program ill-formed:</p>

<pre>  struct C {
    void* operator new( size_t s ) { return ::operator new( s ); }
    // NOTE: this hides in-place and nothrow new
  };

  int main() {
    vector&lt;C&gt; v;
    v.push_back( C() );
  }
</pre>

<p>Is that intentional?  We should clarify whether or not we intended
  to require containers to support types that define their own special
  versions of <tt>operator new</tt>.</p>

<p><i>[
Lillehammer: A container will definitely never use this overridden
operator new, but whether it will fail to compile is unclear from the
standard.  Are containers supposed to use qualified or unqualified
placement new?  20.4.1.1 is somewhat relevant, but the standard
doesn't make it completely clear whether containers have to use
Allocator::construct(). If containers don't use it, the details of how
containers use placement new are unspecified. That is the real bug,
but it needs to be fixed as part of the allocator overhaul.  Weak
support that the eventual solution should make this code well formed.
]</i></p>




<p><b>Proposed resolution:</b></p>







<hr>
<h3><a name="480"></a>480. unary_function and binary_function should have protected nonvirtual destructors</h3>
<p><b>Section:</b> X [base] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Joe Gottman <b>Opened:</b> 2004-08-19 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#base">issues</a> in [base].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>The classes std::unary_function and std::binary_function are both
designed to be inherited from but contain no virtual functions.  This
makes it too easy for a novice programmer to write code like
binary_function&lt;int, int, int&gt; *p = new plus&lt;int&gt;; delete p;</p>

<p>There are two common ways to prevent this source of undefined
behavior: give the base class a public virtual destructor, or give it
a protected nonvirtual destructor.  Since unary_function and
binary_function have no other virtual functions, (note in particular
the absence of an operator()() ), it would cost too much to give them
public virtual destructors.  Therefore, they should be given protected
nonvirtual destructors.</p>


<p><b>Proposed resolution:</b></p>
<p>Change Paragraph 20.3.1 of the Standard from</p>
<pre>    template &lt;class Arg, class Result&gt;
    struct unary_function {
        typedef Arg argument_type;
        typedef Result result_type;
    };

    template &lt;class Arg1, class Arg2, class Result&gt;
    struct binary_function {
        typedef Arg1 first_argument_type;
        typedef Arg2 second_argument_type;
        typedef Result result_type;
    };
</pre>

<p>to</p>
<pre>    template &lt;class Arg, class Result&gt;
        struct unary_function {
        typedef Arg argument_type;
        typedef Result result_type;
    protected:
        ~unary_function() {}
    };

    template &lt;class Arg1, class Arg2, class Result&gt;
    struct binary_function {
        typedef Arg1 first_argument_type;
        typedef Arg2 second_argument_type;
        typedef Result result_type;
    protected:
        ~binary_function() {}
    };
</pre>


<p><b>Rationale:</b></p>
<p>The LWG doesn't believe the existing definition causes anybody any
  concrete harm.</p>





<hr>
<h3><a name="481"></a>481. unique's effects on the range [result, last)</h3>
<p><b>Section:</b> 25.3.9 [alg.unique] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Andrew Koenig <b>Opened:</b> 2004-08-30 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.unique">issues</a> in [alg.unique].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The standard says that unique(first, last) "eliminates all but the
first element from every consecutive group of equal elements" in
[first, last) and returns "the end of the resulting range".  So a
postcondition is that [first, result) is the same as the old [first,
last) except that duplicates have been eliminated.
</p>

<p>What postconditions are there on the range [result, last)?  One
  might argue that the standard says nothing about those values, so
  they can be anything.  One might also argue that the standard
  doesn't permit those values to be changed, so they must not be.
  Should the standard say something explicit one way or the other?</p>



<p><b>Proposed resolution:</b></p>
<p>
</p>


<p><b>Rationale:</b></p>
<p>We don't want to make many guarantees about what's in [result,
end). Maybe we aren't being quite explicit enough about not being
explicit, but it's hard to think that's a major problem.</p>





<hr>
<h3><a name="483"></a>483. Heterogeneous equality and EqualityComparable</h3>
<p><b>Section:</b> 25.2 [alg.nonmodifying], 25.3 [alg.modifying.operations] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2004-09-20 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#283">283</a></p>
<p><b>Discussion:</b></p>
<p>c++std-lib-14262</p>

<p>[lib.alg.find] requires T to be EqualityComparable:</p>

<pre>template &lt;class InputIterator, class T&gt;
   InputIterator find(InputIterator first, InputIterator last,
                      const T&amp; value);
</pre>

<p>
However the condition being tested, as specified in the Effects
clause, is actually *i == value, where i is an InputIterator.
</p>

<p>
The two clauses are in agreement only if the type of *i is T, but this
isn't necessarily the case. *i may have a heterogeneous comparison
operator that takes a T, or a T may be convertible to the type of *i.
</p>

<p>Further discussion (c++std-lib-14264): this problem affects a
  number of algorithsm in clause 25, not just <tt>find</tt>.  We
  should try to resolve this problem everywhere it appears.</p>


<p><b>Proposed resolution:</b></p>

<p>[lib.alg.find]:</p>
<blockquote><p>
   Remove [lib.alg.find]/1.
</p></blockquote>

<p>[lib.alg.count]:</p>
<blockquote><p>
   Remove [lib.alg.count]/1.
</p></blockquote>

<p>[lib.alg.search]:</p>
<blockquote><p>
   Remove "Type T is EqualityComparable (20.1.1), " from [lib.alg.search]/4.
</p></blockquote>

<p>[lib.alg.replace]:</p>

<blockquote>
   <p>
   Remove [lib.alg.replace]/1.
   Replace [lb.alg.replace]/2 with:
   </p>

       <blockquote><p>
       For every iterator i in the range [first, last) for which *i == value
       or pred(*i) holds perform *i = new_value.
       </p></blockquote>

   <p>
   Remove the first sentence of /4.
   Replace the beginning of /5 with:
   </p>

       <blockquote><p>
       For every iterator i in the range [result, result + (last -
       first)), assign to *i either...
       </p></blockquote>

   <p>(Note the defect here, current text says assign to i, not *i).</p>
</blockquote>

<p>[lib.alg.fill]:</p>

<blockquote>
   <p>
   Remove "Type T is Assignable (23.1), " from /1.
   Replace /2 with:
   </p>

       <blockquote><p>
       For every iterator i in the range [first, last) or [first, first + n),
       perform *i = value.
       </p></blockquote>
</blockquote>

<p>[lib.alg.remove]:</p>
<blockquote><p>
   Remove /1.
   Remove the first sentence of /6.
</p></blockquote>



<p><b>Rationale:</b></p>
<p>Duplicate of (a subset of) issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#283">283</a>.</p>






<hr>
<h3><a name="484"></a>484. Convertible to T</h3>
<p><b>Section:</b> 24.2.3 [input.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Future">NAD Future</a>
 <b>Submitter:</b> Chris Jefferson <b>Opened:</b> 2004-09-16 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#input.iterators">issues</a> in [input.iterators].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<p>From comp.std.c++:</p>

<p>
I note that given an input iterator a for type T, 
then *a only has to be "convertable to T", not actually of type T.
</p>

<p>Firstly, I can't seem to find an exact definition of "convertable to T". 
While I assume it is the obvious definition (an implicit conversion), I 
can't find an exact definition. Is there one?</p>

<p>Slightly more worryingly, there doesn't seem to be any restriction on 
the this type, other than it is "convertable to T". Consider two input 
iterators a and b. I would personally assume that most people would 
expect *a==*b would perform T(*a)==T(*b), however it doesn't seem that 
the standard requires that, and that whatever type *a is (call it U) 
could have == defined on it with totally different symantics and still 
be a valid inputer iterator.</p>

<p>Is this a correct reading? When using input iterators should I write 
T(*a) all over the place to be sure that the object i'm using is the 
class I expect?</p>

<p>This is especially a nuisance for operations that are defined to be
  "convertible to bool".  (This is probably allowed so that
  implementations could return say an int and avoid an unnessary
  conversion. However all implementations I have seen simply return a
  bool anyway.  Typical implemtations of STL algorithms just write
  things like <tt>while(a!=b &amp;&amp; *a!=0)</tt>.  But strictly
  speaking, there are lots of types that are convertible to T but
  that also overload the appropriate operators so this doesn't behave
  as expected.</p>

<p>If we want to make code like this legal (which most people seem to
  expect), then we'll need to tighten up what we mean by "convertible
  to T".</p>

<p><i>[Lillehammer: The first part is NAD, since "convertible" is
 well-defined in core. The second part is basically about pathological
 overloads. It's a minor problem but a real one. So leave open for
 now, hope we solve it as part of iterator redesign.]</i></p>


<p><i>[
2009-07-28 Reopened by Alisdair.  No longer solved by concepts.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Mark as NAD Future. We agree there's an issue, but there is no
proposed solution at this time and this will be solved by concepts in
the future.
</blockquote>



<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p><i>[
San Francisco:
]</i></p>


<blockquote>
Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2758.pdf">N2758</a>.
</blockquote>







<hr>
<h3><a name="485"></a>485. output iterator insufficiently constrained</h3>
<p><b>Section:</b> 24.2.4 [output.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Chris Jefferson <b>Opened:</b> 2004-10-13 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#output.iterators">issues</a> in [output.iterators].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The note on 24.1.2 Output iterators insufficiently limits what can be
performed on output iterators. While it requires that each iterator is
progressed through only once and that each iterator is written to only
once, it does not require the following things:</p>

<p>Note: Here it is assumed that x is an output iterator of type X which
has not yet been assigned to.</p>

<p>a) That each value of the output iterator is written to:
The standard allows:
++x; ++x; ++x;
</p>

<p>
b) That assignments to the output iterator are made in order
X a(x); ++a; *a=1; *x=2; is allowed
</p>

<p>
c) Chains of output iterators cannot be constructed:
X a(x); ++a; X b(a); ++b; X c(b); ++c; is allowed, and under the current
wording (I believe) x,a,b,c could be written to in any order.
</p>

<p>I do not believe this was the intension of the standard?</p>
<p><i>[Lillehammer: Real issue.  There are lots of constraints we
  intended but didn't specify.  Should be solved as part of iterator
  redesign.]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Bill provided wording according to consensus.
</blockquote>

<p><i>[
2009-07-21 Alisdair requests change from Review to Open.  See thread starting
with c++std-lib-24459 for discussion.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Modified wording.  Set to Review.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready after looking at again in a larger group in Santa Cruz.
</blockquote>

<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote>
Moved to NAD Editorial.  Rationale added below.
</blockquote>



<p><b>Rationale:</b></p>
<p>
Solved by N3066.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change Table 101  Output iterator requirements in 24.2.4 [output.iterators]:
</p>
<blockquote>
<table border="1">
<caption>Table 101  Output iterator requirements</caption>
<tbody><tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion/note pre-/post-condition</th>
</tr>

<tr>
<td>
<tt>X(a)</tt>
</td>
<td>
&nbsp;
</td>
<td>
&nbsp;
</td>
<td>
<tt>a = t</tt> is equivalent to <tt>X(a) = t</tt>. note: a destructor is assumed.
</td>
</tr>

<tr>
<td>
<tt>X u(a);</tt><br>
<tt>X u = a;</tt>
</td>
<td>
&nbsp;
</td>
<td>
&nbsp;
</td>
<td>
&nbsp;
</td>
</tr>

<tr>
<td>
<tt>*r = o</tt>
</td>
<td>
result is not used
</td>
<td>
&nbsp;
</td>
<td>
<ins>
Post: <tt>r</tt> is not required to be dereferenceable.  <tt>r</tt> is incrementable.
</ins>
</td>
</tr>

<tr>
<td>
<tt>++r</tt>
</td>
<td>
<tt>X&amp;</tt>
</td>
<td>
&nbsp;
</td>
<td>
<tt>&amp;r == &amp;++r</tt>
<ins>
Post: <tt>r</tt> is dereferenceable, unless otherwise specified.  <tt>r</tt> is not required to be incrementable.
</ins>
</td>
</tr>

<tr>
<td>
<tt>r++</tt>
</td>
<td>
convertible to <tt>const X&amp;</tt>
</td>
<td>
<tt>{X tmp = r;<br>++r;<br>return tmp;}</tt>
</td>
<td>
<ins>
Post: <tt>r</tt> is dereferenceable, unless otherwise specified. <tt>r</tt> is not required to be incrementable.
</ins>
</td>
</tr>

<tr>
<td>
<tt>*r++ = o;</tt>
</td>
<td>
result is not used
</td>
<td>
&nbsp;
</td>
<td>

</td>
</tr>

</tbody></table>
</blockquote>





<hr>
<h3><a name="486"></a>486. min/max CopyConstructible requirement is too strict</h3>
<p><b>Section:</b> 25.4.7 [alg.min.max] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Dave Abrahams <b>Opened:</b> 2004-10-13 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.min.max">issues</a> in [alg.min.max].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#281">281</a></p>
<p><b>Discussion:</b></p>
<p>A straightforward implementation of these algorithms does not need to
copy T.</p>


<p><b>Proposed resolution:</b></p>
<p>drop the the words "and CopyConstructible" from paragraphs 1 and 4</p>


<p><b>Rationale:</b></p>






<hr>
<h3><a name="487"></a>487. Allocator::construct is too limiting</h3>
<p><b>Section:</b> 20.2.5 [allocator.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Dhruv Matani <b>Opened:</b> 2004-10-17 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The standard's version of allocator::construct(pointer,
const_reference) severely limits what you can construct using this
function.  Say you can construct a socket from a file descriptor. Now,
using this syntax, I first have to manually construct a socket from
the fd, and then pass the constructed socket to the construct()
function so it will just to an uninitialized copy of the socket I
manually constructed. Now it may not always be possible to copy
construct a socket eh! So, I feel that the changes should go in the
allocator::construct(), making it:
</p>
<pre>    template&lt;typename T&gt;
    struct allocator{
      template&lt;typename T1&gt;
      void construct(pointer T1 const&amp; rt1);
    };
</pre>

<p>
Now, the ctor of the class T which matches the one that takes a T1 can
be called! Doesn't that sound great?
</p>


<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>NAD. STL uses copying all the time, and making it possible for
  allocators to construct noncopyable objects is useless in the
  absence of corresponding container changes. We might consider this
  as part of a larger redesign of STL.</p>





<hr>
<h3><a name="489"></a>489. std::remove / std::remove_if wrongly specified</h3>
<p><b>Section:</b> 25.3.8 [alg.remove] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Thomas Mang <b>Opened:</b> 2004-12-12 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.remove">issues</a> in [alg.remove].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>In Section 25.2.7 [lib.alg.remove], paragraphs 1 to 5 describe the
behavior of the mutating sequence operations std::remove and
std::remove_if. However, the wording does not reflect the intended
behavior [Note: See definition of intended behavior below] of these
algorithms, as it is known to the C++ community [1].
</p>



<p>1) Analysis of current wording:</p>


<p>25.2.7 [lib.alg.remove], paragraph 2:</p>

<p>Current wording says:
"Effects: Eliminates all the elements referred to by iterator i in the
range [first, last) for which the following corresponding conditions
hold: *i == value, pred(*i) != false."</p>

<p>
This sentences expresses specifically that all elements denoted by the
(original) range [first, last) for which the corresponding condition
hold will be eliminated. Since there is no formal definition of the term
"eliminate" provided, the meaning of "eliminate" in everyday language
implies that as postcondition, no element in the range denoted by
[first, last) will hold the corresponding condition on reiteration over
the range [first, last).
</p>

<p>
However, this is neither the intent [Note: See definition of intended
behavior below] nor a general possible approach. It can be easily proven
that if all elements of the original range[first, last) will hold the
condition, it is not possible to substitute them by an element for which
the condition will not hold.
</p>


<p>25.2.7 [lib.alg.remove], paragraph 3:</p>

<p>
Current wording says:
"Returns: The end of the resulting range."
</p>

<p>
The resulting range is not specified. In combination with 25.2.7
[lib.alg.remove], paragraph 2, the only reasonable interpretation of
this so-called resulting range is the range [first,last) - thus
returning always the ForwardIterator 'last' parameter.
</p>


<p>
25.2.7 [lib.alg.remove], paragraph 4:
</p>

<p>
Current wording says:
"Notes: Stable: the relative order of the elements that are not removed
is the same as their relative order in the original range"
</p>

<p>
This sentences makes use of the term "removed", which is neither
specified, nor used in a previous paragraph (which uses the term
"eliminate"), nor unamgiuously separated from the name of the algorithm.
</p>


<p>2) Description of intended behavior:</p>

<p>
For the rest of this Defect Report, it is assumed that the intended
behavior was that all elements of the range [first, last) which do not
hold the condition *i == value (std::remove) or  pred(*i) != false
(std::remove_if)], call them s-elements [Note: s...stay], will be placed
into a contiguous subrange of [first, last), denoted by the iterators
[first, return value). The number of elements in the resulting range
[first, return value) shall be equal to the number of s-elements in the
original range [first, last). The relative order of the elements in the
resulting subrange[first, return value) shall be the same as the
relative order of the corresponding elements in the original range. It
is undefined whether any elements in the resulting subrange [return
value, last) will hold the corresponding condition, or not.
</p>

<p>
All implementations known to the author of this Defect Report comply
with this intent. Since the intent  of the behavior (contrary to the
current wording) is also described in various utility references serving
the C++ community [1], it is not expected that fixing the paragraphs
will influence current code - unless the code relies on the behavior as
it is described by current wording and the implementation indeed
reflects the current wording, and not the intent.
</p>



<p>3) Proposed fixes:</p>


<p>Change 25.2.7 [lib.alg.remove], paragraph 2 to:</p>

<p>
"Effect: Places all the elements referred to by iterator i in the range
[first, last) for which the following corresponding conditions hold :
!(*i == value), pred(*i) == false into the subrange [first, k) of the
original range, where k shall denote a value of type ForwardIterator. It
is undefined whether any elements in the resulting subrange [k, last)
will hold the corresponding condition, or not."
</p>

<p>Comments to the new wording:</p>

<p>
a) "Places" has no special meaning, and the everyday language meaning
should fit.
b) The corresponding conditions were negated compared to the current
wording, becaue the new wording requires it.
c) The wording "of the original range" might be redundant, since any
subrange starting at 'first' and containing no more elements than the
original range is implicitly a subrange of the original range [first,
last).
d) The iterator k was introduced instead of "return value" in order to
avoid a cyclic dependency on 25.2.7/3. The wording ", where k shall
denote a value of type ForwardIterator" might be redundant, because it
follows implicitly by 25.2.7/3.
e) "Places" does, in the author's opinion, explicitly forbid duplicating
any element holding the corresponding condition in the original range
[first, last) within the resulting range [first, k). If there is doubt
this term might be not unambiguous regarding this, it is suggested that
k is specified more closely by the following wording: "k shall denote a
value of type ForwardIterator [Note: see d)] so that k - first is equal
to the number of elements in the original range [first, last) for which
the corresponding condition did hold". This could also be expressed as a
separate paragraph "Postcondition:"
f) The senctence "It is undefined whether any elements in the resulting
subrange [k, last) will hold the corresponding condition, or not." was
added consciously so the term "Places" does not imply if the original
range [first, last) contains n elements holding the corresponding
condition, the identical range[first, last) will also contain exactly n
elements holding the corresponding condition after application of the
algorithm.
</p>

<p>
Change 25.2.7 [lib.alg.remove], paragraph 3 to:

"Returns: The iterator k."
</p>

<p>
Change 25.2.7 [lib.alg.remove], paragraph 4 to:

"Notes: Stable: the relative order of the elements that are placed into
the subrange [first, return value) shall be the same as their relative
order was in the original range [first, last) prior to application of
the algorithm."
</p>

<p>
Comments to the new wording:
</p>

<p>
a) the wording "was ...  prior to application of the algorithm" is used
to explicitly distinguish the original range not only by means of
iterators, but also by a 'chronological' factor from the resulting range
[first, return value). It might be redundant.
</p>

<p>
[1]:
The wording of these references is not always unambiguous, and provided
examples partially contradict verbal description of the algorithms,
because the verbal description resembles the problematic wording of
ISO/IEC 14882:2003.
</p>


<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>The LWG believes that the standard is sufficiently clear, and that
  there is no evidence of any real-world confusion about this point.</p>





<hr>
<h3><a name="490"></a>490. std::unique wrongly specified</h3>
<p><b>Section:</b> 25.3.9 [alg.unique] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Thomas Mang <b>Opened:</b> 2004-12-12 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.unique">issues</a> in [alg.unique].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>In Section 25.2.8 [lib.alg.unique], paragraphs 1 to 3 describe the
behavior of the mutating sequence operation std::unique. However, the
wording does not reflect the intended behavior [Note: See definition of
intended behavior below] of these algorithms, as it is known to the C++
community [1].</p>



<p>1) Analysis of current wording:</p>


<p>25.2.8 [lib.alg.unique], paragraph 1:</p>

<p>
Current wording says:
"Effects: Eliminates all but the first element from every consecutive
group of equal elements referred to by the iterator i in the range
[first, last) for which the following corresponding conditions hold: *i
== *(i - 1) or pred(*i, *(i -1)) != false"
</p>

<p>
This sentences expresses specifically that all elements denoted by the
(original) range [first, last) which are not but the first element from
a consecutive group of equal elements (where equality is defined as *i
== *(i - 1) or pred(*i, *(i - 1)) ! = false) [Note: See DR 202], call
them r-elements [Note: r...remove], will be eliminated. Since there is
no formal definition of the term "eliminate" provided, it is undefined
how this "elimination" takes place. But the meaning of "eliminate" in
everyday language seems to disallow explicitly that after application of
the algorithm, any r-element will remain at any position of the range
[first, last) [2].
</p>

<p>
Another defect in the current wording concerns the iterators used to
compare two elements for equality: The current wording contains the
expression "(i - 1)", which is not covered by 25/9 [Note: See DR
submitted by Thomas Mang regarding invalid iterator arithmetic
expressions].
</p>


<p>
25.2.8 [lib.alg.unique], paragraph 2:
</p>
<p>Current wording says:
"Returns: The end of the resulting range."</p>

<p>
The resulting range is not specified. In combination with 25.2.8
[lib.alg.unique], paragraph 1, one reasonable interpretation (in the
author's opinion even the only possible interpretation) of this
so-called resulting range is the range [first, last) - thus returning
always the ForwardIterator 'last' parameter.
</p>

<p>2) Description of intended behavior:</p>

<p>
For the rest of this Defect Report, it is assumed that the intended
behavior was that all elements denoted by the original range [first,
last) which are the first element from a consecutive group of elements
for which the corresponding conditions: *(i-1) == *i (for the version of
unique without a predicate argument) or pred(*(i-1), *i) ! = false (for
the version of unique with a predicate argument) [Note: If such a group
of elements consists of only a single element, this is also considered
the first element] [Note: See resolutions of DR 202], call them
s-elements [Note: s...stay], will be placed into a contiguous subrange
of [first, last), denoted by the iterators [first, return value). The
number of elements in the resulting range [first, return value) shall be
equal to the number of s-elements in the original range [first, last).
Invalid iterator arithmetic expressions are expected to be resolved as
proposed in DR submitted by Thomas Mang regarding invalid iterator
arithmetic expressions. It is also assumed by the author that the
relative order of the elements in the resulting subrange [first, return
value) shall be the same as the relative order of the corresponding
elements (the s-elements) in the original range [Note: If this was not
intended behavior, the additional proposed paragraph about stable order
will certainly become obsolete].
Furthermore, the resolutions of DR 202 are partially considered.
</p>

<p>
All implementations known to the author of this Defect Report comply
with this intent [Note: Except possible effects of DR 202]. Since this
intent of the behavior (contrary to the current wording) is also
described in various utility references serving the C++ community [1],
it is not expected that fixing the paragraphs will influence current
code [Note: Except possible effects of DR 202] - unless the code relies
on the behavior as it is described by current wording and the
implementation indeed reflects the current wording, and not the intent.
</p>



<p>3) Proposed fixes:</p>

<p>
Change 25.2.8 [lib.alg.unique], paragraph 1 to:
</p>

<p>
"Effect: Places the first element from every consecutive group of
elements, referred to by the iterator i in the range [first, last), for
which the following conditions hold: *(i-1) == *i (for the version of
unique without a predicate argument) or pred(*(i -1), *i) != false (for
the version of unique with a predicate argument), into the subrange
[first, k) of the original range, where k shall denote a value of type
ForwardIterator."
</p>

<p>Comments to the new wording:</p>

<p>
a) The new wording was influenced by the resolutions of DR 202. If DR
202 is resolved in another way, the proposed wording need also
additional review.
b) "Places" has no special meaning, and the everyday language meaning
should fit.
c) The expression "(i - 1)" was left, but is expected that DR submitted
by Thomas Mang regarding invalid iterator arithmetic expressions will
take this into account.
d) The wording "(for the version of unique without a predicate
argument)" and "(for the version of unique with a predicate argument)"
was added consciously for clarity and is in resemblence with current
23.2.2.4 [lib.list.ops], paragraph 19. It might be considered redundant.
e) The wording "of the original range" might be redundant, since any
subrange starting at first and containing no more elements than the
original range is implicitly a subrange of the original range [first,
last).
f) The iterator k was introduced instead of "return value" in order to
avoid a cyclic dependency on 25.2.8 [lib.alg.unique], paragraph 2. The
wording ", where k shall denote a value of type ForwardIterator" might
be redundant, because it follows implicitly by 25.2.8 [lib.alg.unique],
paragraph 2.
g) "Places" does, in the author's opinion, explicitly forbid duplicating
any s-element in the original range [first, last) within the resulting
range [first, k). If there is doubt this term might be not unambiguous
regarding this, it is suggested that k is specified more closely by the
following wording: "k shall denote a value of type ForwardIterator
[Note: See f)] so that k - first is equal to the number of elements in
the original range [first, last) being the first element from every
consecutive group of elements for which the corresponding condition did
hold". This could also be expressed as a separate paragraph
"Postcondition:".
h) If it is considered that the wording is unclear whether it declares
the element of a group which consists of only a single element
implicitly to be the first element of this group [Note: Such an
interpretation could eventually arise especially in case last - first ==
1] , the following additional sentence is proposed: "If such a group of
elements consists of only a single element, this element is also
considered the first element."
</p>

<p>
Change 25.2.8 [lib.alg.unique], paragraph 2 to:
"Returns: The iterator k."
</p>

<p>
Add a separate paragraph "Notes:" as 25.2.8 [lib.alg.unique], paragraph
2a or 3a, or a separate paragraph "Postcondition:" before 25.2.8
[lib.alg.unique], paragraph 2 (wording inside {} shall be eliminated if
the preceding expressions are used, or the preceding expressions shall
be eliminated if wording inside {} is used):
</p>

<p>
"Notes:{Postcondition:} Stable: the relative order of the elements that
are placed into the subrange [first, return value {k}) shall be the same
as their relative order was in the original range [first, last) prior to
application of the algorithm."
</p>

<p>Comments to the new wording:</p>

<p>
a) It is assumed by the author that the algorithm was intended to be
stable.
In case this was not the intent, this paragraph becomes certainly
obsolete.
b) The wording "was ...  prior to application of the algorithm" is used
to explicitly distinguish the original range not only by means of
iterators, but also by a 'chronological' factor from the resulting range
[first, return value). It might be redundant.
</p>

<p>
25.2.8 [lib.alg.unique], paragraph 3:
</p>
<p>See DR 239.</p>

<p>
4) References to other DRs:
</p>

<p>
See DR 202, but which does not address any of the problems described in
this Defect Report [Note: This DR is supposed to complement DR 202].
See DR 239.
See DR submitted by Thomas Mang regarding invalid iterator arithmetic
expressions.
</p>

<p>
[1]:
The wording of these references is not always unambiguous, and provided
examples partially contradict verbal description of the algorithms,
because the verbal description resembles the problematic wording of
ISO/IEC 14882:2003.
</p>

<p>
[2]:
Illustration of conforming implementations according to current wording:
</p>

<p>
One way the author of this DR considers how this "elimination" could be
achieved by a conforming implementation according to current wording is
by substituting each r-element by _any_ s-element [Note: s...stay; any
non-r-element], since all r-elements are "eliminated".
</p>

<p>
In case of a sequence consisting of elements being all 'equal' [Note:
See DR 202], substituting each r-element by the single s-element is the
only possible solution according to current wording.
</p>


<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>The LWG believes the standard is sufficiently clear. No
implementers get it wrong, and changing it wouldn't cause any code to
change, so there is no real-world harm here.</p>





<hr>
<h3><a name="491"></a>491. std::list&lt;&gt;::unique incorrectly specified</h3>
<p><b>Section:</b> 23.3.4.4 [list.ops] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Thomas Mang <b>Opened:</b> 2004-12-12 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#list.ops">issues</a> in [list.ops].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>In Section 23.3.4.4 [list.ops], paragraphs 19 to 21 describe the
behavior of the std::list&lt;T, Allocator&gt;::unique operation. However, the
current wording is defective for various reasons.</p>



<p>
1) Analysis of current wording:
</p>

<p>23.3.4.4 [list.ops], paragraph 19:</p>

<p>
Current wording says:
"Effects:  Eliminates all but the first element from every consecutive
group of equal elements referred to by the iterator i in the range
[first + 1, last) for which *i == *(i - 1) (for the version of unique
with no argument) or pred(*i, *(i -1)) (for the version of unique with a
predicate argument) holds."</p>

<p>
This sentences makes use of the undefined term "Eliminates". Although it
is, to a certain degree, reasonable to consider the term "eliminate"
synonymous with "erase", using "Erase" in the first place, as the
wording of 23.3.4.4 [list.ops], paragraph 15 does, would be clearer.</p>

<p>
The range of the elements referred to by iterator i is "[first + 1,
last)". However, neither "first" nor "last" is defined.</p>

<p>
The sentence makes three times use of iterator arithmetic expressions (
"first + 1", "*i == *(i - 1)", "pred(*i, *(i -1))" ) which is not
defined for bidirectional iterator [see DR submitted by Thomas Mang
regarding invalid iterator arithmetic expressions].</p>

<p>
The same problems as pointed out in DR 202 (equivalence relation / order
of arguments for pred()) apply to this paragraph.</p>

<p>
23.3.4.4 [list.ops], paragraph 20:
</p>

<p>
Current wording says:
"Throws: Nothing unless an exception in thrown by *i == *(i-1) or
pred(*i, *(i - 1))"</p>

<p>
The sentence makes two times use of invalid iterator arithmetic
expressions ( "*i == *(i - 1)", "pred(*i, *(i -1))" ).
</p>
<p>
[Note: Minor typos: "in" / missing dot at end of sentence.]
</p>

<p>
23.3.4.4 [list.ops], paragraph 21:</p>

<p>
Current wording says:
"Complexity: If the range (last - first) is not empty, exactly (last -
first) - 1 applications of the corresponding predicate, otherwise no
application of the predicate.</p>

<p>
See DR 315 regarding "(last - first)" not yielding a range.</p>

<p>
Invalid iterator arithmetic expression "(last - first) - 1" left .</p>


<p>2) Description of intended behavior:</p>

<p>
For the rest of this Defect Report, it is assumed that "eliminate" is
supposed to be synonymous to "erase", that "first" is equivalent to an
iterator obtained by a call to begin(), "last" is equivalent to an
iterator obtained by a call to end(), and that all invalid iterator
arithmetic expressions are resolved as described in DR submitted by
Thomas Mang regarding invalid iterator arithmetic expressions.</p>

<p>
Furthermore, the resolutions of DR 202 are considered regarding
equivalence relation and order of arguments for a call to pred.</p>

<p>
All implementations known to the author of this Defect Report comply
with these assumptions, apart from the impact of the alternative
resolution of DR 202. Except for the changes implied by the resolutions
of DR 202, no impact on current code is expected.</p>

<p>
3) Proposed fixes:</p>

<p>
Change 23.3.4.4 [list.ops], paragraph 19 to:</p>

<p>
"Effect: Erases all but the first element from every consecutive group
of elements, referred to by the iterator i in the range [begin(),
end()), for which the following conditions hold: *(i-1) == *i (for the
version of unique with no argument) or pred(*(i-1), *i) != false (for
the version of unique with a predicate argument)."</p>

<p>
Comments to the new wording:</p>

<p>
a) The new wording was influenced by DR 202 and the resolutions
presented there. If DR 202 is resolved in another way, the proposed
wording need also additional review.
b) "Erases" refers in the author's opinion unambiguously to the member
function "erase". In case there is doubt this might not be unamgibuous,
a direct reference to the member function "erase" is suggested [Note:
This would also imply a change of 23.3.4.4 [list.ops], paragraph
15.].
c) The expression "(i - 1)" was left, but is expected that DR submitted
by Thomas Mang regarding invalid iterator arithmetic expressions will
take this into account.
d) The wording "(for the version of unique with no argument)" and "(for
the version of unique with a predicate argument)" was kept consciously
for clarity.
e) "begin()" substitutes "first", and "end()" substitutes "last". The
range need adjustment from "[first + 1, last)" to "[begin(), end())" to
ensure a valid range in case of an empty list.
f) If it is considered that the wording is unclear whether it declares
the element of a group which consists of only a single element
implicitly to be the first element of this group [Note: Such an
interpretation could eventually arise especially in case size() == 1] ,
the following additional sentence is proposed: "If such a group of
elements consists of only a single element, this element is also
considered the first element."</p>

<p>
Change 23.3.4.4 [list.ops], paragraph 20 to:</p>

<p>
"Throws: Nothing unless an exception is thrown by *(i-1) == *i or
pred(*(i-1), *i)."</p>

<p>
Comments to the new wording:</p>

<p>
a) The wording regarding the conditions is identical to proposed
23.3.4.4 [list.ops], paragraph 19. If 23.3.4.4 [list.ops],
paragraph 19 is resolved in another way, the proposed wording need also
additional review.
b) The expression "(i - 1)" was left, but is expected that DR submitted
by Thomas Mang regarding invalid iterator arithmetic expressions will
take this into account.
c) Typos fixed.</p>

<p>
Change 23.3.4.4 [list.ops], paragraph 21 to:</p>

<p>
"Complexity: If empty() == false, exactly size() - 1 applications of the
corresponding predicate, otherwise no applications of the corresponding
predicate."</p>

<p>
Comments to the new wording:</p>

<p>
a) The new wording is supposed to also replace the proposed resolution
of DR 315, which suffers from the problem of undefined "first" / "last".
</p>

<p>
5) References to other DRs:</p>

<p>See DR 202.
See DR 239.
See DR 315.
See DR submitted by Thomas Mang regarding invalid iterator arithmetic
expressions.</p>



<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>"All implementations known to the author of this Defect Report
comply with these assumption", and "no impact on current code is
expected", i.e. there is no evidence of real-world confusion or
harm.</p>





<hr>
<h3><a name="492"></a>492. Invalid iterator arithmetic expressions</h3>
<p><b>Section:</b> 17.5.1.4 [structure.specifications] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Thomas Mang <b>Opened:</b> 2004-12-12 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#structure.specifications">issues</a> in [structure.specifications].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>Various clauses other than clause 25 make use of iterator arithmetic not
supported by the iterator category in question.
Algorithms in clause 25 are exceptional because of 25 [lib.algorithms],
paragraph 9, but this paragraph does not provide semantics to the
expression "iterator - n", where n denotes a value of a distance type
between iterators.</p>

<p>1) Examples of current wording:</p>

<p>Current wording outside clause 25:</p>

<p>
23.2.2.4 [lib.list.ops], paragraphs 19-21: "first + 1", "(i - 1)",
"(last - first)"
23.3.1.1 [lib.map.cons], paragraph 4: "last - first"
23.3.2.1 [lib.multimap.cons], paragraph 4: "last - first"
23.3.3.1 [lib.set.cons], paragraph 4: "last - first"
23.3.4.1 [lib.multiset.cons], paragraph 4: "last - first"
24.4.1 [lib.reverse.iterators], paragraph 1: "(i - 1)"
</p>

<p>
[Important note: The list is not complete, just an illustration. The
same issue might well apply to other paragraphs not listed here.]</p>

<p>None of these expressions is valid for the corresponding iterator
category.</p>

<p>Current wording in clause 25:</p>

<p>
25.1.1 [lib.alg.foreach], paragraph 1: "last - 1"
25.1.3 [lib.alg.find.end], paragraph 2: "[first1, last1 -
(last2-first2))"
25.2.8 [lib.alg.unique], paragraph 1: "(i - 1)"
25.2.8 [lib.alg.unique], paragraph 5: "(i - 1)"
</p>

<p>
However, current wording of 25 [lib.algorithms], paragraph 9 covers
neither of these four cases:</p>

<p>Current wording of 25 [lib.algorithms], paragraph 9:</p>

<p>
"In the description of the algorithms operator + and - are used for some
of the iterator categories for which they do not have to be defined. In
these cases the semantics of a+n is the same as that of</p>
<pre>{X tmp = a;
advance(tmp, n);
return tmp;
}
</pre>
<p>and that of b-a is the same as of return distance(a, b)"</p>

<p>
This paragrpah does not take the expression "iterator - n" into account,
where n denotes a value of a distance type between two iterators [Note:
According to current wording, the expression "iterator - n" would be
resolved as equivalent to "return distance(n, iterator)"]. Even if the
expression "iterator - n" were to be reinterpreted as equivalent to
"iterator + -n" [Note: This would imply that "a" and "b" were
interpreted implicitly as values of iterator types, and "n" as value of
a distance type], then 24.3.4/2 interfers because it says: "Requires: n
may be negative only for random access and bidirectional iterators.",
and none of the paragraphs quoted above requires the iterators on which
the algorithms operate to be of random access or bidirectional category.
</p>

<p>2) Description of intended behavior:</p>

<p>
For the rest of this Defect Report, it is assumed that the expression
"iterator1 + n" and "iterator1 - iterator2" has the semantics as
described in current 25 [lib.algorithms], paragraph 9, but applying to
all clauses. The expression "iterator1 - n" is equivalent to an
result-iterator for which the expression "result-iterator + n" yields an
iterator denoting the same position as iterator1 does. The terms
"iterator1", "iterator2" and "result-iterator" shall denote the value of
an iterator type, and the term "n" shall denote a value of a distance
type between two iterators.</p>

<p>
All implementations known to the author of this Defect Report comply
with these assumptions.
No impact on current code is expected.</p>

<p>3) Proposed fixes:</p>


<p>Change 25 [lib.algorithms], paragraph 9 to:</p>

<p>
"In the description of the algorithms operator + and - are used for some
of the iterator categories for which they do not have to be defined. In
this paragraph, a and b denote values of an iterator type, and n denotes
a value of a distance type between two iterators. In these cases the
semantics of a+n is the same as that of</p>
<pre>{X tmp = a;
advance(tmp, n);
return tmp;
}
</pre>
<p>,the semantics of a-n denotes the value of an iterator i for which the
following condition holds:
advance(i, n) == a,
and that of b-a is the same as of
return distance(a, b)".
</p>

<p>Comments to the new wording:</p>

<p>
a) The wording " In this paragraph, a and b denote values of an iterator
type, and n denotes a value of a distance type between two iterators."
was added so the expressions "b-a" and "a-n" are distinguished regarding
the types of the values on which they operate.
b) The wording ",the semantics of a-n denotes the value of an iterator i
for which the following condition holds: advance(i, n) == a" was added
to cover the expression 'iterator - n'. The wording "advance(i, n) == a"
was used to avoid a dependency on the semantics of a+n, as the wording
"i + n == a" would have implied. However, such a dependency might well
be deserved.
c) DR 225 is not considered in the new wording.
</p>

<p>
Proposed fixes regarding invalid iterator arithmetic expressions outside
clause 25:</p>

<p>
Either
a) Move modified 25 [lib.algorithms], paragraph 9 (as proposed above)
before any current invalid iterator arithmetic expression. In that case,
the first sentence of 25 [lib.algorithms], paragraph 9, need also to be
modified and could read: "For the rest of this International Standard,
...." / "In the description of the following clauses including this
...." / "In the description of the text below ..." etc. - anyways
substituting the wording "algorithms", which is a straight reference to
clause 25.
In that case, 25 [lib.algorithms] paragraph 9 will certainly become
obsolete.
Alternatively,
b) Add an appropiate paragraph similar to resolved 25 [lib.algorithms],
paragraph 9, to the beginning of each clause containing invalid iterator
arithmetic expressions.
Alternatively,
c) Fix each paragraph (both current wording and possible resolutions of
DRs) containing invalid iterator arithmetic expressions separately.
</p>

<p>5) References to other DRs:</p>

<p>
See DR 225.
See DR 237. The resolution could then also read "Linear in last -
first".
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
Keep open and ask Bill to provide wording.
</blockquote>

<p><i>[
2009-05-09 Alisdair adds:
]</i></p>


<blockquote>
This issue is related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#997">997</a>.
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
Hinnant: this isn't going to change any user's code or any vendor's implementation.
</p>
<p>
No objection to "NAD without prejudice." If anyone proposes a
resolution, the LWG will consider it.
</p>
<p>
Move to NAD.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>

<p><i>[Lillehammer: Minor issue, but real. We have a blanket statement
about this in 25/11. But (a) it should be in 17, not 25; and (b) it's
not quite broad enough, because there are some arithmetic expressions
it doesn't cover. Bill will provide wording.]</i></p>







<hr>
<h3><a name="493"></a>493. Undefined Expression in Input Iterator Note Title</h3>
<p><b>Section:</b> 24.2.3 [input.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Chris Jefferson <b>Opened:</b> 2004-12-13 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#input.iterators">issues</a> in [input.iterators].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>1) In 24.1.1/3, the following text is currently present.</p>

<p>"Note: For input iterators, a==b does not imply ++a=++b (Equality does
not guarantee the substitution property or referential transparency)."</p>

<p>However, when in Table 72, part of the definition of ++r is given as:</p>

<p>"pre: r is dereferenceable.
post: any copies of the previous value of r are no longer required
either to be dereferenceable ..."</p>

<p>While a==b does not imply that b is a copy of a, this statement should
perhaps still be made more clear.</p>

<p>2) There are no changes to intended behaviour</p>

<p>
3) This Note should be altered to say "Note: For input iterators a==b,
when its behaviour is defined ++a==++b may still be false (Equality does
not guarantee the substitution property or referential transparency).</p>



<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>This is descriptive text, not normative, and the meaning is clear.</p>





<hr>
<h3><a name="494"></a>494. Wrong runtime complexity for associative container's insert and delete</h3>
<p><b>Section:</b> 23.2.4 [associative.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Hans B os <b>Opened:</b> 2004-12-19 <b>Last modified:</b> 2010-10-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>According to [lib.associative.reqmts] table 69, the runtime comlexity
of insert(p, t) and erase(q) can be done in amortized constant time.</p>

<p>It was my understanding that an associative container could be
implemented as a balanced binary tree.</p>

<p>For inser(p, t), you 'll have to iterate to p's next node to see if t
can be placed next to p.  Furthermore, the insertion usually takes
place at leaf nodes. An insert next to the root node will be done at
the left of the root next node</p>

<p>So when p is the root node you 'll have to iterate from the root to
its next node, which  takes O(log(size)) time in a balanced tree.</p>

<p>If you insert all values with insert(root, t) (where root is the
root of the tree before insertion) then each insert takes O(log(size))
time.  The amortized complexity per insertion will be O(log(size))
also.</p>

<p>For erase(q), the normal algorithm for deleting a node that has no
empty left or right subtree, is to iterate to the next (or previous),
which is a leaf node. Then exchange the node with the next and delete
the leaf node.  Furthermore according to DR 130, erase should return
the next node of the node erased.  Thus erasing the root node,
requires iterating to the next node.</p>

<p>Now if you empty a map by deleting the root node until the map is
empty, each operation will take O(log(size)), and the amortized
complexity is still O(log(size)).</p>

<p>The operations can be done in amortized constant time if iterating
to the next node can be done in (non amortized) constant time.  This
can be done by putting all nodes in a double linked list.  This
requires two extra links per node.  To me this is a bit overkill since
you can already efficiently insert or erase ranges with erase(first,
last) and insert(first, last).</p>



<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>Only "amortized constant" in special circumstances, and we believe
  that's implementable. That is: doing this N times will be O(N), not
  O(log N).</p>





<hr>
<h3><a name="499"></a>499. Std. doesn't seem to require stable_sort() to be stable!</h3>
<p><b>Section:</b> 25.4.1.2 [stable.sort] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Prateek Karandikar <b>Opened:</b> 2005-04-12 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<blockquote><p>
17.3.1.1 Summary</p>

<p>
1 The Summary provides a synopsis of the category, and introduces the 
first-level subclauses. Each subclause also provides a summary, listing 
the headers specified in the subclause and the library entities 
provided in each header. 
</p>
<p>
2 Paragraphs labelled "Note(s):" or "Example(s):" are informative, 
other paragraphs are normative.
</p></blockquote> 

<p>So this means that a "Notes" paragraph wouldn't be normative. </p>

<blockquote><p>
25.3.1.2 stable_sort
</p>
<pre>template&lt;class RandomAccessIterator&gt; 
void stable_sort(RandomAccessIterat or first, RandomAccessIterator last); 

template&lt;class RandomAccessIterator, class Compare&gt; 
void stable_sort(RandomAccessIterat or first, RandomAccessIterator last, Compare comp);
</pre>
<p>
1 Effects: Sorts the elements in the range [first, last).
</p>
<p>
2 Complexity: It does at most N(log N)^2 (where N == last - first) 
comparisons; if enough extra memory is available, it is N log N.
</p>
<p>
3 Notes: Stable: the relative order of the equivalent elements is 
preserved. 
</p></blockquote> 

<p>
The Notes para is informative, and nowhere else is stability mentioned above. 
</p>

<p>
Also, I just searched for the word "stable" in my copy of the Standard. 
and the phrase "Notes: Stable: the relative order of the elements..." 
is repeated several times in the Standard library clauses for 
describing various functions. How is it that stability is talked about 
in the informative paragraph? Or am I missing something obvious? 
</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>


<p><b>Rationale:</b></p>
<p>
This change has already been made.
</p>





<hr>
<h3><a name="500"></a>500. do_length cannot be implemented correctly</h3>
<p><b>Section:</b> 22.4.1.5 [locale.codecvt.byname] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Krzysztof &#379;elechowski <b>Opened:</b> 2005-05-24 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.codecvt.byname">issues</a> in [locale.codecvt.byname].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<ol>
<li>codecvt::do_length is of type int;</li>
<li>it is assumed to be sort-of returning from_next - from of type ptrdiff_t;</li>
<li>ptrdiff_t cannot be cast to an int without data loss.</li>
</ol>
<p>
Contradiction.
</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="501"></a>501. Proposal: strengthen guarantees of lib.comparisons</h3>
<p><b>Section:</b> X [base] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Me &lt;anti_spam_email2003@yahoo.com&gt; <b>Opened:</b> 2005-06-07 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#base">issues</a> in [base].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<blockquote><p>
"For templates greater, less, greater_equal, and less_equal,
the specializations for any pointer type yield a total order, even if
the built-in operators &lt;, &gt;, &lt;=, &gt;= do not."
</p></blockquote>

<p>
The standard should do much better than guarantee that these provide a
total order, it should guarantee that it can be used to test if memory
overlaps, i.e. write a portable memmove. You can imagine a platform
where the built-in operators use a uint32_t comparison (this tests for
overlap on this platform) but the less&lt;T*&gt; functor is allowed to be
defined to use a int32_t comparison. On this platform, if you use
std::less with the intent of making a portable memmove, comparison on
an array that straddles the 0x7FFFFFFF/0x8000000 boundary can give
incorrect results.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add a footnote to 20.5.3/8 saying:
</p>

<blockquote><p>
Given a p1 and p2 such that p1 points to N objects of type T and p2
points to M objects of type T. If [p1,p1+N) does not overlap [p2,p2+M),
less returns the same value when comparing all pointers in [p1,p1+N) to
all pointers in [p2,p2+M). Otherwise, there is a value Q and a value R
such that less returns the same value when comparing all pointers in
[p1,p1+Q) to all pointers in [p2,p2+R) and an opposite value when
comparing all pointers in [p1+Q,p1+N) to all pointers in [p2+R,p2+M).
For the sake of completeness, the null pointer value (4.10) for T is
considered to be an array of 1 object that doesn't overlap with any
non-null pointer to T. less_equal, greater, greater_equal, equal_to,
and not_equal_to give the expected results based on the total ordering
semantics of less. For T of void, treat it as having similar semantics
as T of char i.e. less&lt;cv T*&gt;(a, b) gives the same results as less&lt;cv
void*&gt;(a, b) which gives the same results as less&lt;cv char*&gt;((cv
char*)(cv void*)a, (cv char*)(cv void*)b).
</p></blockquote>

<p>
I'm also thinking there should be a footnote to 20.5.3/1 saying that if
A and B are similar types (4.4/4), comp&lt;A&gt;(a,b) returns the same value
as comp&lt;B&gt;(a,b) (where comp is less, less_equal, etc.). But this might
be problematic if there is some really funky operator overloading going
on that does different things based on cv (that should be undefined
behavior if somebody does that though). This at least should be
guaranteed for all POD types (especially pointers) that use the
built-in comparison operators.
</p>



<p><b>Rationale:</b></p>
<p>
less is already required to provide a strict weak ordering which is good enough
to detect overlapping memory situations.
</p>





<hr>
<h3><a name="502"></a>502. Proposition: Clarification of the interaction between a facet and an iterator</h3>
<p><b>Section:</b> 22.3.1.1.1 [locale.category] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Christopher Conrade Zseleghovski <b>Opened:</b> 2005-06-07 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.category">issues</a> in [locale.category].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Motivation:
</p>

<p>
This requirement seems obvious to me, it is the essence of code modularity. 
I have complained to Mr. Plauger that the Dinkumware library does not 
observe this principle but he objected that this behaviour is not covered in 
the standard.
</p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
No objection to NAD, Fixed.
</p>
<p>
Move to NAD.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Append the following point to 22.1.1.1.1:
</p>

<p>
6. The implementation of a facet of Table 52 parametrized with an 
InputIterator/OutputIterator should use that iterator only as character 
source/sink respectively.
For a *_get facet, it means that the value received depends only on the 
sequence of input characters and not on how they are accessed.
For a *_put facet, it means that the sequence of characters output depends 
only on the value to be formatted and not of how the characters are stored.
</p>

<p><i>[
Berlin:  Moved to Open, Need to clean up this area to make it clear
locales don't have to contain open ended sets of facets. Jack, Howard,
Bill.
]</i></p>







<hr>
<h3><a name="503"></a>503. more on locales</h3>
<p><b>Section:</b> 22.4 [locale.categories] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2005-06-20 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.categories">issues</a> in [locale.categories].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
a) In 22.2.1.1 para. 2 we refer to "the instantiations required in Table
51" to refer to the facet *objects* associated with a locale. And we
almost certainly mean just those associated with the default or "C"
locale. Otherwise, you can't switch to a locale that enforces a different
mapping between narrow and wide characters, or that defines additional
uppercase characters.
</p>

<p>
b) 22.2.1.5 para. 3 (codecvt) has the same issues.
</p>

<p>
c) 22.2.1.5.2 (do_unshift) is even worse. It *forbids* the generation of
a homing sequence for the basic character set, which might very well need
one.
</p>

<p>
d) 22.2.1.5.2 (do_length) likewise dictates that the default mapping
between wide and narrow characters be taken as one-for-one.
</p>

<p>
e) 22.2.2 para. 2 (num_get/put) is both muddled and vacuous, as far as
I can tell. The muddle is, as before, calling Table 51 a list of
instantiations. But the constraint it applies seems to me to cover
*all* defined uses of num_get/put, so why bother to say so?
</p>

<p>
f) 22.2.3.1.2 para. 1(do_decimal_point) says "The required instantiations
return '.' or L'.'.) Presumably this means "as appropriate for the
character type. But given the vague definition of "required" earlier,
this overrules *any* change of decimal point for non "C" locales.
Surely we don't want to do that.
</p>

<p>
g) 22.2.3.1.2 para. 2 (do_thousands_sep) says "The required instantiations
return ',' or L','.) As above, this probably means "as appropriate for the
character type. But this overrules the "C" locale, which requires *no*
character ('\0') for the thousands separator. Even if we agree that we
don't mean to block changes in decimal point or thousands separator,
we should also eliminate this clear incompatibility with C.
</p>

<p>
h) 22.2.3.1.2 para. 2 (do_grouping) says "The required instantiations
return the empty string, indicating no grouping." Same considerations
as for do_decimal_point.
</p>

<p>
i) 22.2.4.1 para. 1 (collate) refers to "instantiations required in Table
51". Same bad jargon.
</p>

<p>
j) 22.2.4.1.2 para. 1 (do_compare) refers to "instantiations required
in Table 51". Same bad jargon.
</p>

<p>
k) 22.2.5 para. 1 (time_get/put) uses the same muddled and vacuous
as num_get/put.
</p>

<p>
l) 22.2.6 para. 2 (money_get/put) uses the same muddled and vacuous
as num_get/put.
</p>

<p>
m) 22.2.6.3.2 (do_pos/neg_format) says "The instantiations required
in Table 51 ... return an object of type pattern initialized to
{symbol, sign, none, value}." This once again *overrides* the "C"
locale, as well as any other locale."
</p>

<p>
3) We constrain the use_facet calls that can be made by num_get/put,
so why don't we do the same for money_get/put? Or for any of the
other facets, for that matter?
</p>

<p>
4) As an almost aside, we spell out when a facet needs to use the ctype
facet, but several also need to use a codecvt facet and we don't say so.
</p>
<p><i>[
Berlin: Bill to provide wording.
]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
No objection to NAD.
</p>
<p>
Move to NAD.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="504"></a>504. Integer types in pseudo-random number engine requirements</h3>
<p><b>Section:</b> 26.5.1 [rand.req], TR1 5.1.1 [tr.rand.req] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Walter Brown <b>Opened:</b> 2005-07-03 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.req">issues</a> in [rand.req].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In [tr.rand.req], Paragraph 2 states that "... s is a value of integral type,
g is an ... object returning values of unsigned integral type ..."
</p>


<p><b>Proposed resolution:</b></p>
<p>
In 5.1.1 [tr.rand.req], Paragraph 2 replace
</p>

<blockquote><p>
... s is a value of integral type, g is an lvalue of a type other than X that
defines a zero-argument function object returning values of <del>unsigned integral</del> type
<ins><tt>unsigned long int</tt></ins>,
...
</p></blockquote>

<p>
In 5.1.1 [tr.rand.seq], Table 16, replace in the line for X(s)
</p>

<blockquote><p>
creates an engine with the initial internal state
determined by <ins><tt>static_cast&lt;unsigned long&gt;(</tt></ins><tt><i>s</i></tt><ins><tt>)</tt></ins>
</p></blockquote>

<p><i>[
Mont Tremblant:  Both s and g should be unsigned long.
This should refer to the constructor signatures. Jens  provided wording post Mont Tremblant.
]</i></p>


<p><i>[
Berlin:  N1932 adopts the proposed resolution:  see 26.3.1.3/1e and Table 3 row 2. Moved
to Ready.
]</i></p>




<p><b>Rationale:</b></p>
<p>
Jens:  Just requiring X(unsigned long) still makes it possible
for an evil library writer to also supply a X(int) that does something
unexpected.  The wording above requires that X(s) always performs
as if X(unsigned long) would have been called.  I believe that is
sufficient and implements our intentions from Mont Tremblant.  I
see no additional use in actually requiring a X(unsigned long)
signature.  u.seed(s) is covered by its reference to X(s), same
arguments.
</p>


<p><i>[
Portland:  Subsumed by N2111.
]</i></p>





<hr>
<h3><a name="506"></a>506. Requirements of Distribution parameter for variate_generator</h3>
<p><b>Section:</b> 26.5 [rand], TR1 5.1.3 [tr.rand.var] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Walter Brown <b>Opened:</b> 2005-07-03 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand">issues</a> in [rand].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Paragraph 3 requires that template argument U (which corresponds to template
parameter Engine) satisfy all uniform random number generator requirements.
However, there is no  analogous requirement regarding the template argument
that corresponds to template parameter Distribution.  We believe there should
be, and that it should require that this template argument satisfy all random
distribution requirements.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Consequence 1: Remove the precondition clauses [tr.rand.var]/16 and /18.
</p>
<p>
Consequence 2: Add max() and min() functions to those distributions that
do not already have them.
</p>

<p><i>[
Mont Tremblant: Jens reccommends NAD, min/max not needed everywhere.
Marc supports having min and max to satisfy generic programming interface.
]</i></p>




<p><b>Rationale:</b></p>
<p>Berlin:  N1932 makes this moot: variate_generator has been eliminated.</p>





<hr>
<h3><a name="509"></a>509. Uniform_int template parameters</h3>
<p><b>Section:</b> 26.5.8.1 [rand.dist.uni], TR1 5.1.7.1 [tr.rand.dist.iunif] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Walter Brown <b>Opened:</b> 2005-07-03 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.dist.uni">issues</a> in [rand.dist.uni].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In [tr.rand.dist.iunif] the uniform_int distribution currently has a single
template parameter, IntType, used as the input_type and as the result_type
of the distribution.  We believe there is no reason to conflate these types
in this way.
</p>


<p><b>Proposed resolution:</b></p>
<p>
We recommend that there be a second template  parameter to
reflect the distribution's input_type, and that the existing first template
parameter continue to reflect (solely) the result_type:
</p>
<blockquote><pre>template&lt; class IntType = int, UIntType = unsigned int &gt;
class uniform_int
{
public:
  // types
  typedef  UIntType  input_type;
  typedef  IntType   result_type;
</pre></blockquote>

<p><i>[
Berlin: Moved to NAD.  N1932 makes this moot: the input_type template parameter has been
eliminated.
]</i></p>







<hr>
<h3><a name="510"></a>510. Input_type for bernoulli_distribution</h3>
<p><b>Section:</b> 26.5.8.2 [rand.dist.bern], TR1 5.1.7.2 [tr.rand.dist.bern] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Walter Brown <b>Opened:</b> 2005-07-03 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In [tr.rand.dist.bern] the distribution currently requires;
</p>
<blockquote><pre>typedef  int  input_type;
</pre></blockquote>


<p><b>Proposed resolution:</b></p>
<p>
We believe this is an unfortunate choice, and recommend instead:
</p>
<blockquote><pre>typedef  unsigned int  input_type;
</pre></blockquote>

<p><i>[
Berlin:  Moved to NAD. N1932 makes this moot: the input_type template parameter has been
eliminated.
]</i></p>







<hr>
<h3><a name="511"></a>511. Input_type for binomial_distribution</h3>
<p><b>Section:</b> 26.5.8 [rand.dist], TR1 5.1.7.5 [tr.rand.dist.bin] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Walter Brown <b>Opened:</b> 2005-07-03 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.dist">issues</a> in [rand.dist].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Unlike all other distributions in TR1, this binomial_distribution has an
implementation-defined  input_type.  We believe this is an unfortunate choice,
because it hinders users from writing portable code.  It also hinders the
writing of compliance tests.  We recommend instead:
</p>
<blockquote><pre>typedef  RealType  input_type;
</pre></blockquote>
<p>
While this choice is somewhat arbitrary (as it was for some of the other
distributions), we make  this particular choice because (unlike all other
distributions) otherwise this template would not publish its RealType
argument and so users could not write generic code that accessed this
second template parameter.  In this respect, the choice is consistent with
the other distributions in  TR1. 
</p>
<p>
We have two reasons for recommending that a real type be specified instead.
One reason is  based specifically on characteristics of binomial distribution
implementations, while the other is based on mathematical characteristics of
probability distribution functions in general.
</p>
<p>
Implementations of binomial distributions commonly use Stirling approximations
for values in certain ranges.  It is far more natural to use real values to
represent these approximations than it would be to use integral values to do
so.  In other ranges, implementations reply on the Bernoulli  distribution to
obtain values.  While TR1's bernoulli_distribution::input_type is specified as
int, we believe this would be better specified as double.
</p>
<p>
This brings us to our main point:  The notion of a random distribution rests
on the notion of a cumulative distribution function, which in turn mathematically
depends on a continuous dependent variable.  Indeed, such a distribution function
would be meaningless if it depended on  discrete values such as integers - and this
remains true even if the distribution function were to take discrete steps.
</p>
<p>
Although this note is specifically about binomial_distribution::input_type,
we intend to recommend that all of the random distributions input_types be
specified as a real type (either a RealType template parameter, or double,
as appropriate).
</p>
<p>
Of the nine distributions in TR1, four already have this characteristic
(uniform_real, exponential_distribution, normal_distribution, and
gamma_distribution).  We have already argued the case for the binomial the
remaining four distributions.
</p>
<p>
In the case of uniform_int, we believe that the calculations to produce an
integer result in a  specified range from an integer in a different specified
range is best done using real arithmetic.  This is because it involves a
product, one of whose terms is the ratio of the extents of the two ranges.
Without real arithmetic, the results become less uniform: some numbers become
more  (or less) probable that they should be.  This is, of course, undesireable
behavior in a uniform distribution.
</p>
<p>
Finally, we believe that in the case of the bernoulli_distribution (briefly
mentioned earlier), as well as the cases of the geometric_distribution and the
poisson_distribution, it would be far more natural to have a real input_type.
This is because the most natural computation involves the  random number
delivered and the distribution's parameter p (in the case of bernoulli_distribution,
for example, the computation is a comparison against p), and p is already specified
in each case as having some real type.
</p>


<p><b>Proposed resolution:</b></p>
<blockquote><pre>typedef  RealType  input_type;
</pre></blockquote>

<p><i>[
Berlin:  Moved to NAD.  N1932 makes this moot: the input_type template parameter has been
eliminated.
]</i></p>






<hr>
<h3><a name="512"></a>512. Seeding subtract_with_carry_01 from a single unsigned long</h3>
<p><b>Section:</b> 26.5.3 [rand.eng], TR1 5.1.4.4 [tr.rand.eng.sub1] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Walter Brown <b>Opened:</b> 2005-07-03 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.eng">issues</a> in [rand.eng].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Paragraph 8 specifies the algorithm by which a subtract_with_carry_01  engine
is to be seeded given a single unsigned long.  This algorithm is seriously
flawed in the case where the engine parameter w (also known as word_size)
exceeds 31 [bits].  The key part of the paragraph reads:
</p>
<blockquote><p>
sets x(-r) ... x(-1) to (lcg(1)*2**(-w)) mod 1
</p></blockquote>
<p>
and so forth. 
</p>
<p>
Since the specified linear congruential engine, lcg, delivers numbers with
a maximum of 2147483563 (just a shade under 31 bits), then when w is, for
example, 48, each of the x(i) will be less than 2**-17.  The consequence
is that roughly the first 400 numbers delivered will be  conspicuously
close to either zero or one.
</p>
<p>
Unfortunately, this is not an innocuous flaw:  One of the predefined engines
in [tr.rand.predef],  namely ranlux64_base_01, has w = 48 and would exhibit
this poor behavior, while the original N1378 proposal states that these
pre-defined engines are intended to be of "known good properties."
</p>


<p><b>Proposed resolution:</b></p>
<p>
In 5.1.4.4 [tr.rand.eng.sub1], replace the "effects" clause for
void seed(unsigned long value = 19780503) by
</p>

<blockquote><p>
<i>Effects:</i> If <tt>value == 0</tt>, sets value to <tt>19780503</tt>. In any
case, <del>with a linear congruential generator <tt>lcg</tt>(i) having parameters
<tt><i>m<sub>lcg</sub></i> = 2147483563</tt>, <tt><i>a<sub>lcg</sub></i> = 40014</tt>,
<tt><i>c<sub>lcg</sub></i> = 0</tt>, and <tt><i>lcg</i>(0) = value</tt>,</del>
sets <ins>carry<tt>(-1)</tt> and</ins> <tt>x(-r)  x(-1)</tt>
<ins>as if executing</ins></p>

<blockquote><pre><ins>
linear_congruential&lt;unsigned long, 40014, 0, 2147483563&gt; lcg(value);
seed(lcg);
</ins></pre></blockquote>

<p>
<del>to <tt>(<i>lcg</i>(1)  2<sup>-<i>w</i></sup>) mod 1
 (<i>lcg</i>(<i>r</i>)  2<sup>-<i>w</i></sup>) mod 1</tt>,
respectively. If <tt><i>x</i>(-1) == 0</tt>, sets carry<tt>(-1) = 2<sup>-<i>w</i></sup></tt>,
else sets carry<tt>(-1) = 0</tt>.</del></p>
</blockquote>

<p><i>[
Jens provided revised wording post Mont Tremblant.
]</i></p>


<p><i>[
Berlin: N1932 adopts the originally-proposed resolution of the issue.
Jens's supplied wording is a clearer description of what is
intended.  Moved to Ready.
]</i></p>




<p><b>Rationale:</b></p>
<p>
Jens: I'm using an explicit type here, because fixing the
prose would probably not qualify for the (with issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#504">504</a> even
stricter) requirements we have for seed(Gen&amp;).
</p>

<p><i>[
Portland:  Subsumed by N2111.
]</i></p>






<hr>
<h3><a name="513"></a>513. Size of state for subtract_with_carry_01</h3>
<p><b>Section:</b> 26.5.3 [rand.eng], TR1 5.1.4.4 [tr.rand.eng.sub1] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Walter Brown <b>Opened:</b> 2005-07-03 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.eng">issues</a> in [rand.eng].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Paragraph 3 begins:
</p>
<blockquote><p>
The size of the state is r.
</p></blockquote>
<p>
However, this is not quite consistent with the remainder of the paragraph
which specifies a total  of nr+1 items in the textual representation of
the state.  We recommend the sentence be corrected to match:
</p>
<blockquote><p>
The size of the state is nr+1.
</p></blockquote>
<p>
To give meaning to the coefficient n, it may be also desirable to move
n's definition from later in the paragraph.  Either of the following
seem reasonable formulations:
</p>
<blockquote><p>
With n=..., the size of the state is nr+1.
</p></blockquote>
<blockquote><p>
The size of the state is nr+1, where n=... .
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p><i>[
Jens:  I plead for "NAD" on the grounds that "size of state" is only
used as an argument for big-O complexity notation, thus
constant factors and additions don't count.
]</i></p>


<p><i>[
Berlin: N1932 adopts the proposed NAD.
]</i></p>







<hr>
<h3><a name="514"></a>514. Size of state for subtract_with_carry</h3>
<p><b>Section:</b> 26.5.3.3 [rand.eng.sub], TR1 5.1.4.3 [tr.rand.eng.sub] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Walter Brown <b>Opened:</b> 2005-07-03 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Paragraph 2 begins:
</p>
<blockquote><p>
The size of the state is r.
</p></blockquote>
<p>
However, the next sentence specifies a total of r+1 items in the textual
representation of the state,  r specific x's as well as a specific carry.
This makes a total of r+1 items that constitute the size of the state,
rather than r.
</p>


<p><b>Proposed resolution:</b></p>
<p>
We recommend the sentence be corrected to match:
</p>
<blockquote><p>
 The size of the state is r+1.
</p></blockquote>

<p><i>[
Jens:  I plead for "NAD" on the grounds that "size of state" is only
used as an argument for big-O complexity notation, thus
constant factors and additions don't count.
]</i></p>


<p><i>[
Berlin: N1932 adopts the proposed NAD.
]</i></p>







<hr>
<h3><a name="515"></a>515. Random number engine traits</h3>
<p><b>Section:</b> 26.5.2 [rand.synopsis], TR1 5.1.2 [tr.rand.synopsis] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Walter Brown <b>Opened:</b> 2005-07-03 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.synopsis">issues</a> in [rand.synopsis].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
To accompany the concept of a pseudo-random number engine as defined in Table 17,
we propose and recommend an adjunct template, engine_traits, to be declared in
[tr.rand.synopsis] as:
</p>
<blockquote><pre>template&lt; class PSRE &gt;
class engine_traits;
</pre></blockquote>
<p>
This template's primary purpose would be as an aid to generic programming involving
pseudo-random number engines.  Given only the facilities described in tr1, it would
be very difficult to produce any algorithms involving the notion of a generic engine.
The intent of this proposal is to  provide, via engine_traits&lt;&gt;, sufficient
descriptive information to allow an algorithm to employ a pseudo-random number engine
without regard to its exact type, i.e., as a template parameter.
</p>
<p>
For example, today it is not possible to write an efficient generic function that
requires any specific number of random bits.  More specifically, consider a
cryptographic application that internally needs 256 bits of randomness per call:
</p>
<blockquote><pre>template&lt; class Eng, class InIter, class OutIter &gt;
void crypto( Eng&amp; e, InIter in, OutIter out );
</pre></blockquote>
<p>
Without knowning the number of bits of randomness produced per call to a provided
engine, the algorithm has no means of determining how many times to call the engine.
</p>
<p>
In a new section [tr.rand.eng.traits], we proposed to define the engine_traits
template as: 
</p>
<blockquote><pre>template&lt; class PSRE &gt;
class engine_traits
{
  static  std::size_t  bits_of_randomness = 0u;
  static  std::string  name()  { return "unknown_engine"; }
  // TODO: other traits here
};
</pre></blockquote>
<p>
Further, each engine described in [tr.rand.engine] would be accompanied by a
complete specialization of this new engine_traits template.
</p>



<p><b>Proposed resolution:</b></p>
<p><i>[
Berlin:  Walter: While useful for implementation per TR1, N1932 has no need for this
feature.  Recommend close as NAD.
]</i></p>



<p><b>Rationale:</b></p>
<p>
Recommend NAD,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1932.pdf">N1932</a>,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2111.pdf">N2111</a>
covers this.  Already in WP.
</p>





<hr>
<h3><a name="516"></a>516. Seeding subtract_with_carry_01 using a generator</h3>
<p><b>Section:</b> 26.5.3 [rand.eng], TR1 5.1.4.4 [tr.rand.eng.sub1] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Walter Brown <b>Opened:</b> 2005-07-03 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.eng">issues</a> in [rand.eng].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Paragraph 6 says:
</p>
<blockquote><p>
... obtained by successive invocations of g, ... 
</p></blockquote>
<p>
We recommend instead:
</p>
<blockquote><p>
... obtained by taking successive invocations of g mod 2**32, ...
</p></blockquote>
<p>
as the context seems to require only 32-bit quantities be used here.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Berlin: N1932 adopts the proposed resultion: see 26.3.3.4/7.  Moved to Ready.
</p>

<p><i>[
Portland:  Subsumed by N2111.
]</i></p>






<hr>
<h3><a name="517"></a>517. Should include name in external representation</h3>
<p><b>Section:</b> 26.5.1 [rand.req], TR1 5.1.1 [tr.rand.req] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Walter Brown <b>Opened:</b> 2005-07-03 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.req">issues</a> in [rand.req].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The last two rows of Table 16 deal with the i/o requirements of an engine,
specifying that the textual representation of an engine's state,
appropriately formatted, constitute the engine's  external representation.
</p>
<p>
This seems adequate when an engine's type is known.  However, it seems
inadequate in the  context of generic code, where it becomes useful and
perhaps even necessary to determine an engine's type via input.
</p>
<p>
</p>


<p><b>Proposed resolution:</b></p>
<p>
We therefore recommend that, in each of these two rows of Table 16, the
text "textual representation" be expanded so as to read "engine name
followed by the textual representation."
</p>

<p><i>[
Berlin: N1932 considers this NAD. This is a QOI issue.
]</i></p>







<hr>
<h3><a name="523"></a>523. regex case-insensitive character ranges are unimplementable as specified</h3>
<p><b>Section:</b> 28 [re] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Future">NAD Future</a>
 <b>Submitter:</b> Eric Niebler <b>Opened:</b> 2005-07-01 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#re">issues</a> in [re].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<p>
A problem with TR1 regex is currently being discussed on the Boost 
developers list. It involves the handling of case-insensitive matching 
of character ranges such as [Z-a]. The proper behavior (according to the 
ECMAScript standard) is unimplementable given the current specification 
of the TR1 regex_traits&lt;&gt; class template. John Maddock, the author of 
the TR1 regex proposal, agrees there is a problem. The full discussion 
can be found at http://lists.boost.org/boost/2005/06/28850.php (first 
message copied below). We don't have any recommendations as yet.
</p>
<p>
-- Begin original message --
</p>
<p>
The situation of interest is described in the ECMAScript specification
(ECMA-262), section 15.10.2.15:
</p>
<p>
"Even if the pattern ignores case, the case of the two ends of a range
is significant in determining which characters belong to the range.
Thus, for example, the pattern /[E-F]/i matches only the letters E, F,
e, and f, while the pattern /[E-f]/i matches all upper and lower-case
ASCII letters as well as the symbols [, \, ], ^, _, and `."
</p>
<p>
A more interesting case is what should happen when doing a
case-insentitive match on a range such as [Z-a]. It should match z, Z,
a, A and the symbols [, \, ], ^, _, and `. This is not what happens with
Boost.Regex (it throws an exception from the regex constructor).
</p>
<p>
The tough pill to swallow is that, given the specification in TR1, I
don't think there is any effective way to handle this situation.
According to the spec, case-insensitivity is handled with
regex_traits&lt;&gt;::translate_nocase(CharT) -- two characters are equivalent
if they compare equal after both are sent through the translate_nocase
function. But I don't see any way of using this translation function to
make character ranges case-insensitive. Consider the difficulty of
detecting whether "z" is in the range [Z-a]. Applying the transformation
to "z" has no effect (it is essentially std::tolower). And we're not
allowed to apply the transformation to the ends of the range, because as
ECMA-262 says, "the case of the two ends of a range is significant."
</p>
<p>
So AFAICT, TR1 regex is just broken, as is Boost.Regex. One possible fix
is to redefine translate_nocase to return a string_type containing all
the characters that should compare equal to the specified character. But
this function is hard to implement for Unicode, and it doesn't play nice
with the existing ctype facet. What a mess!
</p>
<p>
-- End original message --
</p>

<p><i>[
John Maddock adds:
]</i></p>


<p>
One small correction, I have since found that ICU's regex package does 
implement this correctly, using a similar mechanism to the current 
TR1.Regex.
</p>
<p>
Given an expression [c1-c2] that is compiled as case insensitive it:
</p>
<p>
Enumerates every character in the range c1 to c2 and converts it to it's 
case folded equivalent.  That case folded character is then used a key to a 
table of equivalence classes, and each member of the class is added to the 
list of possible matches supported by the character-class.  This second step 
isn't possible with our current traits class design, but isn't necessary if 
the input text is also converted to a case-folded equivalent on the fly.
</p>
<p>
ICU applies similar brute force mechanisms to character classes such as 
[[:lower:]] and [[:word:]], however these are at least cached, so the impact 
is less noticeable in this case.
</p>
<p>
Quick and dirty performance comparisons show that expressions such as 
"[X-\\x{fff0}]+" are indeed very slow to compile with ICU (about 200 times 
slower than a "normal" expression).  For an application that uses a lot of 
regexes this could have a noticeable performance impact.  ICU also has an 
advantage in that it knows the range of valid characters codes: code points 
outside that range are assumed not to require enumeration, as they can not 
be part of any equivalence class.  I presume that if we want the TR1.Regex 
to work with arbitrarily large character sets enumeration really does become 
impractical.
</p>
<p>
Finally note that Unicode has:
</p>
<p>
Three cases (upper, lower and title).
One to many, and many to one case transformations.
Character that have context sensitive case translations - for example an 
uppercase sigma has two different lowercase forms  - the form chosen depends 
on context(is it end of a word or not), a caseless match for an upper case 
sigma should match either of the lower case forms, which is why case folding 
is often approximated by tolower(toupper(c)).
</p>
<p>
Probably we need some way to enumerate character equivalence classes, 
including digraphs (either as a result or an input), and some way to tell 
whether the next character pair is a valid digraph in the current locale.
</p>
<p>
Hoping this doesn't make this even more complex that it was already,
</p>

<p><i>[
Portland:  Alisdair: Detect as invalid, throw an exception.
Pete: Possible general problem with case insensitive ranges.
]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
We agree that this is a problem, but we do not know the answer.
</p>
<p>
We are going to declare this NAD until existing practice leads us in some direction.
</p>
<p>
No objection to NAD Future.
</p>
<p>
Move to NAD Future.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="526"></a>526. Is it undefined if a function in the standard changes in parameters?</h3>
<p><b>Section:</b> 23.2.3 [sequence.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Chris Jefferson <b>Opened:</b> 2005-09-14 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#sequence.reqmts">issues</a> in [sequence.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Problem: There are a number of places in the C++ standard library where
it is possible to write what appear to be sensible ways of calling
functions, but which can cause problems in some (or all)
implementations, as they cause the values given to the function to be
changed in a way not specified in standard (and therefore not coded to
correctly work). These fall into two similar categories.
</p>

<p>
1) Parameters taken by const reference can be changed during execution
of the function
</p>

<p>
Examples:
</p>

<p>
Given std::vector&lt;int&gt; v:
</p>
<p>
v.insert(v.begin(), v[2]);
</p>
<p>
v[2] can be changed by moving elements of vector
</p>


<p>
Given std::list&lt;int&gt; l:
</p>
<p>
l.remove(*l.begin());
</p>
<p>
Will delete the first element, and then continue trying to access it.
This is particularily vicious, as it will appear to work in almost all
cases.
</p>

<p>
2) A range is given which changes during the execution of the function:
Similarly,
</p>

<p>
v.insert(v.begin(), v.begin()+4, v.begin()+6);
</p>

<p>
This kind of problem has been partly covered in some cases. For example
std::copy(first, last, result) states that result cannot be in the range
[first, last). However, does this cover the case where result is a
reverse_iterator built from some iterator in the range [first, last)?
Also, std::copy would still break if result was reverse_iterator(last +
1), yet this is not forbidden by the standard
</p>

<p>
Solution:
</p>

<p>
One option would be to try to more carefully limit the requirements of
each function. There are many functions which would have to be checked.
However as has been shown in the std::copy case, this may be difficult.
A simpler, more global option would be to somewhere insert text similar to:
</p>

<p>
If the execution of any function would change either any values passed
by reference or any value in any range passed to a function in a way not
defined in the definition of that function, the result is undefined.
</p>

<p>
Such code would have to at least cover chapters 23 and 25 (the sections
I read through carefully). I can see no harm on applying it to much of
the rest of the standard.
</p>

<p>
Some existing parts of the standard could be improved to fit with this,
for example the requires for 25.2.1 (Copy) could be adjusted to:
</p>

<p>
Requires: For each non-negative integer n &lt; (last - first), assigning to
*(result + n) must not alter any value in the range [first + n, last).
</p>

<p>
However, this may add excessive complication.
</p>

<p>
One other benefit of clearly introducing this text is that it would
allow a number of small optimisations, such as caching values passed
by const reference.
</p>

<p>
Matt Austern adds that this issue also exists for the <tt>insert</tt> and
<tt>erase</tt> members of the ordered and unordered associative containers.
</p>

<p><i>[
Berlin: Lots of controversey over how this should be solved. Lots of confusion
as to whether we're talking about self referencing iterators or references.
Needs a good survey as to the cases where this matters, for which
implementations, and how expensive it is to fix each case.
]</i></p>




<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>
Recommend NAD.
</p>
<ul>
<li><tt>vector::insert(iter, value)</tt> is required to work because the standard
doesn't give permission for it not to work.</li>
<li><tt>list::remove(value)</tt> is required to work because the standard
doesn't give permission for it not to work.</li>
<li><tt>vector::insert(iter, iter, iter)</tt> is not required to work because
23.2.3 [sequence.reqmts], p4 says so.</li>
<li><tt>copy</tt> has to work, except where 25.3.1 [alg.copy] says
it doesn't have to work.  While a language lawyer can tear this wording apart,
it is felt that the wording is not prone to accidental interpretation.</li>
<li>The current working draft provide exceptions for the unordered associative
containers similar to the containers requirements which exempt the member
template insert functions from self referencing.</li>
</ul>





<hr>
<h3><a name="528"></a>528. <tt>const_iterator</tt> <tt>iterator</tt> issue when they are the same type</h3>
<p><b>Section:</b> 23.7 [unord], TR1 6.3.4 [tr.unord.unord] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Paolo Carlini <b>Opened:</b> 2005-10-12 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unord">issues</a> in [unord].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
while implementing the resolution of issue 6.19 I'm noticing the
following: according to 6.3.4.3/2 (and 6.3.4.5/2), for unordered_set and
unordered_multiset:
</p>

<blockquote><p>
    "The iterator and const_iterator types are both const types. It is
unspecified whether they are the same type"
</p></blockquote>

<p>
Now, according to the resolution of 6.19, we have overloads of insert
with hint and erase (single and range) both for iterator and
const_iterator, which, AFAICS, can be meaningful at the same time *only*
if iterator and const_iterator *are* in fact different types.
</p>
<p>
Then, iterator and const_iterator are *required* to be different types?
Or that is an unintended consequence? Maybe the overloads for plain
iterators should be added only to unordered_map and unordered_multimap?
Or, of course, I'm missing something?
</p>



<p><b>Proposed resolution:</b></p>
<p>
Add to 6.3.4.3p2 (and 6.3.4.5p2):
</p>
<p>
2  ... The iterator and const_iterator types are both <del>const</del>
<ins>constant</ins> iterator types.
It is unspecified whether they are the same type. 
</p>

<p>
Add a new subsection to 17.4.4 [lib.conforming]:
</p>

<blockquote>
<p>
An implementation shall not supply an overloaded function
       signature specified in any library clause if such a signature
       would be inherently ambiguous during overload resolution
       due to two library types referring to the same type.
</p>
<p>
       [Note: For example, this occurs when a container's iterator
       and const_iterator types are the same. -- end note]
</p>
</blockquote>

<p><i>[
Post-Berlin: Beman supplied wording.
]</i></p>




<p><b>Rationale:</b></p>
Toronto:  The first issue has been fixed by N2350 (the insert and erase members
are collapsed into one signature).  Alisdair to open a separate issue on the
chapter 17 wording.





<hr>
<h3><a name="529"></a>529. The standard encourages redundant and confusing preconditions</h3>
<p><b>Section:</b> 17.6.3.11 [res.on.required] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> David Abrahams <b>Opened:</b> 2005-10-25 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
17.4.3.8/1 says:
</p>

<blockquote><p>
Violation of the preconditions specified in a function's 
Required behavior: paragraph results in undefined behavior unless the 
function's Throws: paragraph specifies throwing an exception when the 
precondition is violated.
</p></blockquote>

<p>
This implies that a precondition violation can lead to defined
behavior.  That conflicts with the only reasonable definition of
precondition: that a violation leads to undefined behavior.  Any other
definition muddies the waters when it comes to analyzing program
correctness, because precondition violations may be routinely done in
correct code (e.g. you can use std::vector::at with the full
expectation that you'll get an exception when your index is out of
range, catch the exception, and continue).  Not only is it a bad
example to set, but it encourages needless complication and redundancy
in the standard.  For example:
</p>

<blockquote><pre>  21 Strings library 
  21.3.3 basic_string capacity

  void resize(size_type n, charT c);

  5 Requires: n &lt;= max_size()
  6 Throws: length_error if n &gt; max_size().
  7 Effects: Alters the length of the string designated by *this as follows:
</pre></blockquote>

<p>
The Requires clause is entirely redundant and can be dropped.  We
could make that simplifying change (and many others like it) even
without changing 17.4.3.8/1; the wording there just seems to encourage
the redundant and error-prone Requires: clause.
</p>

<p><i>[
Batavia:  Alan and Pete to work.
]</i></p>


<p><i>[
Bellevue:  NAD Editorial, this group likes 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2121.html">N2121</a>,
Pete agrees, accepting it is Pete's business.
General agreement that precondition violations are synonymous with UB.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
1. Change 17.4.3.8/1 to read:
</p>

<blockquote><p>
Violation of the preconditions specified in a function's
<i>Required behavior:</i> paragraph results in undefined behavior
<del>unless the function's <i>Throws:</i> paragraph specifies throwing
an exception when the precondition is violated</del>.
</p></blockquote>

<p>
2. Go through and remove redundant Requires: clauses.  Specifics to be
   provided by Dave A.
</p>

<p><i>[
Berlin: The LWG requests a detailed survey of part 2 of the proposed resolution.
]</i></p>


<p><i>[
Alan provided the survey
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2121.html">N2121</a>.
]</i></p>







<hr>
<h3><a name="532"></a>532. Tuple comparison</h3>
<p><b>Section:</b> 20.4.2.7 [tuple.rel], TR1 6.1.3.5 [tr.tuple.rel] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Future">NAD Future</a>
 <b>Submitter:</b> David Abrahams <b>Opened:</b> 2005-11-29 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#tuple.rel">issues</a> in [tuple.rel].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Future">NAD Future</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#348">348</a></p>
<p><b>Discussion:</b></p>
<p>
Where possible, tuple comparison operators &lt;,&lt;=,=&gt;, and &gt; ought to be
defined in terms of std::less rather than operator&lt;, in order to
support comparison of tuples of pointers.  
</p>

<p><i>[
2009-07-28 Reopened by Alisdair.  No longer solved by concepts.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
<p>
If we solve this for <tt>tuple</tt> we would have to solve it for <tt>pair</tt>
algorithms, etc.  It is too late to do that at this time.  Move to NAD Future.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
change 6.1.3.5/5 from:
</p>

<blockquote><p>
  Returns: The result of a lexicographical comparison between t and
  u. The result is defined as: (bool)(get&lt;0&gt;(t) &lt; get&lt;0&gt;(u)) ||
  (!(bool)(get&lt;0&gt;(u) &lt; get&lt;0&gt;(t)) &amp;&amp; ttail &lt; utail), where rtail for
  some tuple r is a tuple containing all but the first element of
  r. For any two zero-length tuples e and f, e &lt; f returns false.
</p></blockquote>

<p>
to:
</p>

<blockquote>
<p>
  Returns: The result of a lexicographical comparison between t and
  u. For any two zero-length tuples e and f, e &lt; f returns false.
  Otherwise, the result is defined as: cmp( get&lt;0&gt;(t), get&lt;0&gt;(u)) ||
  (!cmp(get&lt;0&gt;(u), get&lt;0&gt;(t)) &amp;&amp; ttail &lt; utail), where rtail for some
  tuple r is a tuple containing all but the first element of r, and
  cmp(x,y) is an unspecified function template defined as follows.
</p>
<p>
  Where T is the type of x and U is the type of y:
</p>

<p>
     if T and U are pointer types and T is convertible to U, returns
     less&lt;U&gt;()(x,y)
</p>

<p>
     otherwise, if T and U are pointer types, returns less&lt;T&gt;()(x,y)
</p>

<p>
     otherwise, returns (bool)(x &lt; y)
</p>
</blockquote>

<p><i>[
Berlin: This issue is much bigger than just tuple (pair, containers,
algorithms). Dietmar will survey and work up proposed wording.
]</i></p>




<p><b>Rationale:</b></p>
<p>
Recommend NAD.  This will be fixed with the next revision of concepts.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2770.pdf">N2770</a>.
</blockquote>





<hr>
<h3><a name="536"></a>536. Container iterator constructor and explicit convertibility</h3>
<p><b>Section:</b> 23.2 [container.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Joaqun M Lpez Muoz <b>Opened:</b> 2005-12-17 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#589">589</a></p>
<p><b>Discussion:</b></p>
<p>
The iterator constructor X(i,j) for containers as defined in 23.1.1 and
23.2.2 does only require that i and j be input iterators but
nothing is said about their associated value_type. There are three
sensible
options:
</p>
<ol>
<li>iterator's value_type is exactly X::value_type (modulo cv).</li>
<li>iterator's value_type is *implicitly* convertible to X::value_type.</li>
<li>iterator's value_type is *explicitly* convertible to X::value_type.</li>
</ol>
<p>
The issue has practical implications, and stdlib vendors have
taken divergent approaches to it: Dinkumware follows 2,
libstdc++ follows 3.
</p>
<p>
The same problem applies to the definition of insert(p,i,j) for
sequences and insert(i,j) for associative contianers, as well as
assign.
</p>

<p><i>[
The following added by Howard and the example code was originally written by
Dietmar.
]</i></p>

<p>
Valid code below?
</p>

<blockquote><pre>#include &lt;vector&gt; 
#include &lt;iterator&gt; 
#include &lt;iostream&gt; 

struct foo 
{ 
    explicit foo(int) {} 
}; 

int main() 
{ 
    std::vector&lt;int&gt; v_int; 
    std::vector&lt;foo&gt; v_foo1(v_int.begin(), v_int.end()); 
    std::vector&lt;foo&gt; v_foo2((std::istream_iterator&lt;int&gt;(std::cin)), 
                             std::istream_iterator&lt;int&gt;()); 
} 
</pre></blockquote>
<p><i>[
Berlin: Some support, not universal, for respecting the explicit qualifier.
]</i></p>




<p><b>Proposed resolution:</b></p>






<hr>
<h3><a name="544"></a>544. minor NULL problems in C.2</h3>
<p><b>Section:</b> C.2 [diff.library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2005-11-25 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#diff.library">issues</a> in [diff.library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
According to C.2.2.3, p1, "the macro NULL, defined in any of &lt;clocale&gt;,
&lt;cstddef&gt;, &lt;cstdio&gt;, &lt;cstdlib&gt;, &lt;cstring&gt;, &lt;ctime&gt;,
or &lt;cwchar&gt;." This is consistent with the C standard.
</p>
<p>
However, Table 95 in C.2 fails to mention &lt;clocale&gt; and &lt;cstdlib&gt;.
</p>
<p>
In addition, C.2, p2 claims that "The C++ Standard library provides
54 standard macros from the C library, as shown in Table 95." While
table 95 does have 54 entries, since a couple of them (including the
NULL macro) are listed more than once, the actual number of macros
defined by the C++ Standard Library may not be 54.
</p>


<p><b>Proposed resolution:</b></p>
<p>
I propose we add &lt;clocale&gt; and &lt;cstdlib&gt; to Table 96 and remove the
number of macros from C.2, p2 and reword the sentence as follows:
</p>
<blockquote><p>
The C++ Standard library <del>provides 54 standard macros from</del>
<ins>defines a number macros corresponding to those defined by</ins> the C 
<ins>Standard</ins> library, as shown in Table 96.
</p></blockquote>

<p><i>[
Portland:  Resolution is considered editorial.  It will be incorporated into the WD.
]</i></p>







<hr>
<h3><a name="546"></a>546. _Longlong and _ULonglong are integer types</h3>
<p><b>Section:</b> TR1 5.1.1 [tr.rand.req] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2006-01-10 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The TR sneaks in two new integer types, _Longlong and _Ulonglong, in [tr.c99].
The rest of the TR should use that type.  I believe this affects two places.
First, the random number requirements, 5.1.1/10-11, lists all of the types with
which template parameters named IntType and UIntType may be instantiated.
_Longlong (or "long long", assuming it is added to C++0x) should be added to the
IntType list, and UIntType (again, or "unsigned long long") should be added to
the UIntType list.  Second, 6.3.2 lists the types for which hash&lt;&gt; is
required to be instantiable. _Longlong and _Ulonglong should be added to that
list, so that people may use long long as a hash key.
</p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
We are not going to fix TR1.
</p>
<p>
The paper "long long goes to the library" addresses the integration of
long long into the C++0x library.
</p>
<p>
Move to NAD.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="547"></a>547. division should be floating-point, not integer</h3>
<p><b>Section:</b> 26.5 [rand], TR1 5.1 [tr.rand] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2006-01-10 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand">issues</a> in [rand].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Paragraph 10 describes how a variate generator uses numbers produced by an
engine to pass to a generator. The sentence that concerns me is: "Otherwise, if
the value for engine_value_type::result_type is true and the value for
Distribution::input_type is false [i.e. if the engine produces integers and the
engine wants floating-point values], then the numbers in s_eng are divided by
engine().max() - engine().min() + 1 to obtain the numbers in s_e." Since the
engine is producing integers, both the numerator and the denominator are
integers and we'll be doing integer division, which I don't think is what we
want. Shouldn't we be performing a conversion to a floating-point type first?
</p>


<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>
Recommend NAD as the affected section is now gone and so the issue is moot.
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2111.pdf">N2111</a>.
</p>





<hr>
<h3><a name="548"></a>548. May random_device block?</h3>
<p><b>Section:</b> 26.5.6 [rand.device], TR1 5.1.6 [tr.rand.device] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2006-01-10 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.device">issues</a> in [rand.device].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Class random_device "produces non-deterministic random numbers", using some
external source of entropy. In most real-world systems, the amount of available
entropy is limited. Suppose that entropy has been exhausted. What is an
implementation permitted to do? In particular, is it permitted to block
indefinitely until more random bits are available, or is the implementation
required to detect failure immediately? This is not an academic question. On
Linux a straightforward implementation would read from /dev/random, and "When
the entropy pool is empty, reads to /dev/random will block until additional
environmental noise is gathered." Programmers need to know whether random_device
is permitted to (or possibly even required to?) behave the same way.
</p>

<p><i>[
Berlin: Walter: N1932 considers this NAD. Does the standard specify whether std::cin
may block?
]</i></p>


<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2391.pdf">N2391</a> and
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2423.pdf">N2423</a>
for some further discussion.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Adopt the proposed resolution in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2423.pdf">N2423</a> (NAD).
</p>





<hr>
<h3><a name="549"></a>549. Undefined variable in binomial_distribution</h3>
<p><b>Section:</b> 26.5.8 [rand.dist], TR1 5.1.7.5 [tr.rand.dist.bin] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2006-01-10 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.dist">issues</a> in [rand.dist].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Paragraph 1 says that "A binomial distributon random distribution produces
integer values i&gt;0 with p(i) = (n choose i) * p*i * (1-p)^(t-i), where t and
p are the parameters of the distribution. OK, that tells us what t, p, and i
are. What's n?
</p>


<p><b>Proposed resolution:</b></p>
<p>
Berlin: Typo: "n" replaced by "t" in N1932: see 26.3.7.2.2/1.
</p>

<p><i>[
Portland:  Subsumed by N2111.
]</i></p>






<hr>
<h3><a name="553"></a>553. very minor editorial change intptr_t / uintptr_t</h3>
<p><b>Section:</b> 18.4.1 [cstdint.syn], TR1 8.22.1 [tr.c99.cstdint.syn] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Paolo Carlini <b>Opened:</b> 2006-01-30 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#cstdint.syn">issues</a> in [cstdint.syn].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In the synopsis, some types are identified as optional: int8_t, int16_t,
and so on, consistently with C99, indeed.
</p>
<p>
On the other hand, intptr_t and uintptr_t, are not marked as such and
probably should, consistently with C99, 7.18.1.4.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 18.4.1 [cstdint.syn]:
</p>

<blockquote><pre>...
typedef <i>signed integer type</i> intptr_t;    <ins><i>// optional</i></ins>
...
typedef <i>unsigned integer type</i> uintptr_t;    <ins><i>// optional</i></ins>
...
</pre></blockquote>



<p><b>Rationale:</b></p>
Recommend NAD and fix as editorial with the proposed resolution.





<hr>
<h3><a name="554"></a>554. Problem with lwg DR 184 numeric_limits&lt;bool&gt;</h3>
<p><b>Section:</b> 18.3.1.5 [numeric.special] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2006-01-29 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#numeric.special">issues</a> in [numeric.special].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I believe we have a bug in the resolution of:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#184">lwg 184</a>
(WP status).
</p>

<p>
The resolution spells out each member of <tt>numeric_limits&lt;bool&gt;</tt>.
The part I'm having a little trouble with is:
</p>
<blockquote><pre>static const bool traps = false;
</pre></blockquote>

<p>
Should this not be implementation defined?  Given:
</p>

<blockquote><pre>int main()
{
     bool b1 = true;
     bool b2 = false;
     bool b3 = b1/b2;
}
</pre></blockquote>

<p>
If this causes a trap, shouldn't <tt>numeric_limits&lt;bool&gt;::traps</tt> be
<tt>true</tt>?
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 18.2.1.5p3:
</p>

<blockquote><p>
-3- The specialization for <tt>bool</tt> shall be provided as follows: </p>
<blockquote><pre>namespace std { 
   template &lt;&gt; class numeric_limits&lt;bool&gt; {
      ...
      static const bool traps = <del>false</del> <ins><i>implementation-defined</i></ins>;
      ...
   };
}
</pre></blockquote>
</blockquote>

<p><i>[
Redmond:  NAD because traps refers to values, not operations.  There is no bool
value that will trap.
]</i></p>







<hr>
<h3><a name="555"></a>555. TR1, 8.21/1: typo</h3>
<p><b>Section:</b> TR1 8.21 [tr.c99.boolh] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Paolo Carlini <b>Opened:</b> 2006-02-02 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This one, if nobody noticed it yet, seems really editorial:
s/cstbool/cstdbool/
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 8.21p1:
</p>
<blockquote><p>
-1- The header behaves as if it defines the additional macro defined in
<tt>&lt;cst<ins>d</ins>bool&gt;</tt> by including the header <tt>&lt;cstdbool&gt;</tt>.
</p></blockquote>

<p><i>[
Redmond:  Editorial.
]</i></p>







<hr>
<h3><a name="557"></a>557. TR1: div(_Longlong, _Longlong) vs div(intmax_t, intmax_t)</h3>
<p><b>Section:</b> 18.4 [cstdint], TR1 8.22 [tr.c99.cstdint] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Paolo Carlini <b>Opened:</b> 2006-02-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#cstdint">issues</a> in [cstdint].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I'm seeing a problem with such overloads: when, _Longlong == intmax_t ==
long long we end up, essentially, with the same arguments and different
return types (lldiv_t and imaxdiv_t, respectively). Similar issue with
abs(_Longlong) and abs(intmax_t), of course.
</p>
<p>
Comparing sections 8.25 and 8.11, I see an important difference,
however: 8.25.3 and 8.25.4 carefully describe div and abs for _Longlong
types (rightfully, because not moved over directly from C99), whereas
there is no equivalent in 8.11: the abs and div overloads for intmax_t
types appear only in the synopsis and are not described anywhere, in
particular no mention in 8.11.2 (at variance with 8.25.2).
</p>
<p>
I'm wondering whether we really, really, want div and abs for intmax_t...
</p>



<p><b>Proposed resolution:</b></p>



<p><i>[
Portland: no consensus.
]</i></p>


<p><b>Rationale:</b></p>
<p><i>[
Batavia, Bill: The <tt>&lt;cstdint&gt;</tt> synopsis in TR1 8.11.1 [tr.c99.cinttypes.syn] contains:
]</i></p>

<blockquote><pre>intmax_t imaxabs(intmax_t i);
intmax_t abs(intmax_t i);

imaxdiv_t imaxdiv(intmax_t numer, intmax_t denom);
imaxdiv_t div(intmax_t numer, intmax_t denom);
</pre></blockquote>

<p><i>[
and in TR1 8.11.2 [tr.c99.cinttypes.def]:
]</i></p>


<blockquote><p>
The header defines all functions, types, and macros the same as C99
subclause 7.8.
</p></blockquote>

<p><i>[
This is as much definition as we give for most other C99 functions,
so nothing need change. We might, however, choose to add the footnote:
]</i></p>


<blockquote><p>
[<i>Note:</i> These overloads for <tt>abs</tt> and <tt>div</tt> may well be equivalent to
those that take <tt>long long</tt> arguments. If so, the implementation is
responsible for avoiding conflicting declarations. -- <i>end note</i>]
</p></blockquote>

<p><i>[
Bellevue: NAD Editorial. Pete must add a footnote, as described below.
]</i></p>


<blockquote>
<p><i>[
Looks like a real problem. Dietmar suggests div() return a template
type. Matt: looks like imaxdiv_t is loosly defined. Can it be a typedef
for lldiv_t when _Longlong == intmax_t? PJP seems to agree. We would
need a non-normative note declaring that the types lldiv_t and imaxdiv_t
may not be unique if intmax_t==_longlong.
]</i></p>

</blockquote>






<hr>
<h3><a name="558"></a>558. lib.input.iterators Defect</h3>
<p><b>Section:</b> 24.2.3 [input.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> David Abrahams <b>Opened:</b> 2006-02-09 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#input.iterators">issues</a> in [input.iterators].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<blockquote>
<p>
  24.1.1 Input iterators [lib.input.iterators]
</p>
<p>
  1 A class or a built-in type X satisfies the requirements of an
  input iterator for the value type T if the following expressions are
  valid, where U is the type of any specified member of type T, as
  shown in Table 73.
</p>
</blockquote>
<p>
There is no capital U used in table 73.  There is a lowercase u, but
that is clearly not meant to denote a member of type T.  Also, there's
no description in 24.1.1 of what lowercase a means.  IMO the above
should have been...Hah, a and b are already covered in 24.1/11, so maybe it
should have just been:
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 24.1.1p1:
</p>
<blockquote><p>
-1- A class or a built-in type <tt>X</tt> satisfies the requirements of an
input iterator for the value type <tt>T</tt> if the following expressions 
are valid<del>, where <tt>U</tt> is the type of any specified member of type
<tt>T</tt>,</del> as shown in Table 73.
</p></blockquote>

<p><i>[
Portland: Editorial.
]</i></p>







<hr>
<h3><a name="560"></a>560. User-defined allocators without default constructor</h3>
<p><b>Section:</b> 20.2.5 [allocator.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Sergey P. Derevyago <b>Opened:</b> 2006-02-17 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<h4>1. The essence of the problem.</h4>
<p>
User-defined allocators without default constructor are not explicitly
supported by the standard but they can be supported just like std::vector
supports elements without default constructor.
</p>
<p>
As a result, there exist implementations that work well with such allocators
and implementations that don't.
</p>

<h4>2. The cause of the problem.</h4>
<p>
1) The standard doesn't explicitly state this intent but it should. In
particular, 20.1.5p5 explicitly state the intent w.r.t. the allocator
instances that compare non-equal. So it can similarly state the intent w.r.t.
the user-defined allocators without default constructor.
</p>
<p>
2) Some container operations are obviously underspecified. In particular,
21.3.7.1p2 tells:
</p>
<blockquote><pre>template&lt;class charT, class traits, class Allocator&gt;
  basic_string&lt;charT,traits,Allocator&gt; operator+(
    const charT* lhs,
    const basic_string&lt;charT,traits,Allocator&gt;&amp; rhs
  );
</pre>
<p>
Returns: <tt>basic_string&lt;charT,traits,Allocator&gt;(lhs) + rhs</tt>.
</p>
</blockquote>
<p>
That leads to the basic_string&lt;charT,traits,Allocator&gt;(lhs, Allocator()) call.
Obviously, the right requirement is:
</p>
<blockquote><p>
Returns: <tt>basic_string&lt;charT,traits,Allocator&gt;(lhs, rhs.get_allocator()) + rhs</tt>.
</p></blockquote>
<p>
It seems like a lot of DRs can be submitted on this "Absent call to
get_allocator()" topic.
</p>

<h4>3. Proposed actions.</h4>
<p>
1) Explicitly state the intent to allow for user-defined allocators without
default constructor in 20.1.5 Allocator requirements.
</p>
<p>
2) Correct all the places, where a correct allocator object is available
through the get_allocator() call but default Allocator() gets passed instead.
</p>
<h4>4. Code sample.</h4>
<p>
Let's suppose that the following memory pool is available:
</p>
<blockquote><pre>class mem_pool {
      // ...
      void* allocate(size_t size);
      void deallocate(void* ptr, size_t size);
};
</pre></blockquote>
<p>
So the following allocator can be implemented via this pool:
</p>
<blockquote><pre>class stl_allocator {
      mem_pool&amp; pool;

 public:
      explicit stl_allocator(mem_pool&amp; mp) : pool(mp) {}
      stl_allocator(const stl_allocator&amp; sa) : pool(sa.pool) {}
      template &lt;class U&gt;
      stl_allocator(const stl_allocator&lt;U&gt;&amp; sa)  : pool(sa.get_pool()) {}
      ~stl_allocator() {}

      pointer allocate(size_type n, std::allocator&lt;void&gt;::const_pointer = 0)
      {
       return (n!=0) ? static_cast&lt;pointer&gt;(pool.allocate(n*sizeof(T))) : 0;
      }

      void deallocate(pointer p, size_type n)
      {
       if (n!=0) pool.deallocate(p, n*sizeof(T));
      }

      // ...
};
</pre></blockquote>
<p>
Then the following code works well on some implementations and doesn't work on
another:
</p>
<blockquote><pre>typedef basic_string&lt;char, char_traits&lt;char&gt;, stl_allocator&lt;char&gt; &gt; 
  tl_string;
mem_pool mp;
tl_string s1("abc", stl_allocator&lt;int&gt;(mp));
printf("(%s)\n", ("def"+s1).c_str());
</pre></blockquote>
<p>
In particular, on some implementations the code can't be compiled without
default stl_allocator() constructor.
</p>
<p>
The obvious way to solve the compile-time problems is to intentionally define
a NULL pointer dereferencing default constructor
</p>
<blockquote><pre>stl_allocator() : pool(*static_cast&lt;mem_pool*&gt;(0)) {}
</pre></blockquote>
<p>
in a hope that it will not be called. The problem is that it really gets
called by operator+(const char*, const string&amp;) under the current 21.3.7.1p2
wording.
</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>


<p><b>Rationale:</b></p>
<p>
Recommend NAD.  <tt>operator+()</tt> with <tt>string</tt> already requires the desired
semantics of copying the allocator from one of the strings (<i>lhs</i> when there is a choice).
</p>





<hr>
<h3><a name="568"></a>568. log2 overloads missing</h3>
<p><b>Section:</b> TR1 8.16.4 [tr.c99.cmath.over] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Paolo Carlini <b>Opened:</b> 2006-03-07 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>log2</tt> is missing from the list of "additional overloads" in TR1 8.16.4 [tr.c99.cmath.over] p1.
</p>

<p>
Hinnant:  This is a TR1 issue only.  It is fixed in the current (N2135) WD.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree this has been fixed in the Working Draft.
Move to NAD.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Add <tt>log2</tt> to the list of functions in TR1 8.16.4 [tr.c99.cmath.over] p1.
</p>





<hr>
<h3><a name="569"></a>569. Postcondition for basic_ios::clear(iostate) incorrectly stated</h3>
<p><b>Section:</b> 27.5.4.3 [iostate.flags] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Seungbeom Kim <b>Opened:</b> 2006-03-10 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iostate.flags">issues</a> in [iostate.flags].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#272">272</a></p>
<p><b>Discussion:</b></p>
<p>
Section: 27.4.4.3 [lib.iostate.flags]
</p>
<p>
Paragraph 4 says:
</p>
<blockquote>
<blockquote><pre>void clear(iostate <i>state</i> = goodbit);
</pre></blockquote>
<p>
<i>Postcondition:</i> If <tt>rdbuf()!=0</tt> then <tt><i>state</i> == rdstate();</tt>
otherwise <tt>rdstate()==<i>state</i>|ios_base::badbit</tt>.
</p>
</blockquote>

<p>
The postcondition "rdstate()==state|ios_base::badbit" is parsed as
"(rdstate()==state)|ios_base::badbit", which is probably what the
committee meant.
</p>




<p><b>Rationale:</b></p>






<hr>
<h3><a name="570"></a>570. Request adding additional explicit specializations of char_traits</h3>
<p><b>Section:</b> 21.2 [char.traits] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Jack Reeves <b>Opened:</b> 2006-04-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#char.traits">issues</a> in [char.traits].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, the Standard Library specifies only a declaration for template class
char_traits&lt;&gt; and requires the implementation provide two explicit
specializations: char_traits&lt;char&gt; and char_traits&lt;wchar_t&gt;. I feel the Standard
should require explicit specializations for all built-in character types, i.e.
char, wchar_t, unsigned char, and signed char.
</p>
<p>
I have put together a paper
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1985.htm">N1985</a>)
that describes this in more detail and
includes all the necessary wording.
</p>
<p><i>[
Portland: Jack will rewrite
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1985.htm">N1985</a>
to propose a primary template that will work with other integral types.
]</i></p>

<p><i>[
Toronto: issue has grown with addition of <tt>char16_t</tt> and <tt>char32_t</tt>.
]</i></p>


<p><i>[
post Bellevue:
]</i></p>


<blockquote>
<p>
We suggest that Jack be asked about the status of his paper, and if it
is not forthcoming, the work-item be assigned to someone else. If no one
steps forward to do the paper before the next meeting, we propose to
make this NAD without further discussion. We leave this Open for now,
but our recommendation is NAD.
</p>
<p>
Note: the issue statement should be updated, as the Toronto comment has
already been resolved. E.g., char_traits specializations for char16_t
and char32_t are now in the working paper.
</p>
</blockquote>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
Nobody has submitted the requested paper, so we move to NAD, as suggested by the decision at the last meeting.
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="571"></a>571. Update C90 references to C99?</h3>
<p><b>Section:</b> 1.2 [intro.refs] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2006-04-08 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#intro.refs">issues</a> in [intro.refs].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
1.2 Normative references [intro.refs] of the WP currently refers to ISO/IEC
9899:1990, Programming languages - C. Should that be changed to ISO/IEC
9899:1999?
</p>
<p>
What impact does this have on the library?
</p>


<p><b>Proposed resolution:</b></p>
<p>
In 1.2/1 [intro.refs] of the WP, change:
</p>
<blockquote>
<ul>
<li>ISO/IEC 9899:<del>1990</del><ins>1999 + TC1 + TC2</ins>, <i>Programming languages - C</i></li>
</ul>
</blockquote>



<p><b>Rationale:</b></p>
Recommend NAD, fixed editorially.





<hr>
<h3><a name="572"></a>572. Oops, we gave 507 WP status</h3>
<p><b>Section:</b> 26.5 [rand], TR1 5.1 [tr.rand] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2006-04-11 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand">issues</a> in [rand].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In Berlin, as a working group, we voted in favor of N1932 which makes issue 507 moot:
variate_generator has been eliminated.  Then in full committee we voted to give
this issue WP status (mistakenly).
</p>


<p><b>Proposed resolution:</b></p>
<p>
Strike the proposed resolution of issue 507.
</p>
<p><i>[
post-Portland:  Walter and Howard recommend NAD.  The proposed resolution of 507 no longer
exists in the current WD.
]</i></p>



<p><b>Rationale:</b></p>
<p>
NAD.  Will be moot once
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2135.pdf">N2135</a>
is adopted.
</p>





<hr>
<h3><a name="573"></a>573. C++0x file positioning should handle modern file sizes</h3>
<p><b>Section:</b> 27.5.3 [fpos] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2006-04-12 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#fpos">issues</a> in [fpos].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There are two deficiencies related to file sizes:
</p>
<ol>
<li>It doesn't appear that the Standard Library is specified in
      a way that handles modern file sizes, which are often too
      large to be represented by an unsigned long.</li>

<li>The std::fpos class does not currently have the ability to
      set/get file positions.</li>
</ol>
<p>
The Dinkumware implementation of the Standard Library as shipped with the Microsoft compiler copes with these issues by:
</p>
<ol type="A">
<li>Defining fpos_t be long long, which is large enough to
      represent any file position likely in the foreseeable future.</li>

<li>Adding member functions to class fpos. For example,
<blockquote><pre>fpos_t seekpos() const;
</pre></blockquote>
</li>
</ol>
<p>
Because there are so many types relating to file positions and offsets (fpos_t,
fpos, pos_type, off_type, streamoff, streamsize, streampos, wstreampos, and
perhaps more), it is difficult to know if the Dinkumware extensions are
sufficient. But they seem a useful starting place for discussions, and they do
represent existing practice.
</p>

<p><i>[
Kona (2007): We need a paper. It would be nice if someone proposed
clarifications to the definitions of <tt>pos_type</tt> and <tt>off_type</tt>. Currently
these definitions are horrible. Proposed Disposition: Open
]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
This is the subject of paper N2926.
</p>
<p>
If we choose to take any action, we will move the paper, so the issue can be closed.
</p>
<p>
Move to NAD.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="579"></a>579. erase(iterator) for unordered containers should not return an iterator</h3>
<p><b>Section:</b> 23.2.5 [unord.req] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Joaqun M Lpez Muoz <b>Opened:</b> 2006-06-13 <b>Last modified:</b> 2010-11-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#unord.req">active issues</a> in [unord.req].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unord.req">issues</a> in [unord.req].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
See
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2023.pdf">N2023</a>
for full discussion.
</p>

<p><i>[
2009-12-11 Paolo opens:
]</i></p>


<blockquote>
I'm asking for DR 579 to be re-opened, basing on recent discussions on the
library reflector, see Message c++std-lib-26040 and replies.
</blockquote>

<p><i>[
2010-02-07 Paolo updates wording.
]</i></p>


<blockquote>
As pointed out by Chris in c++std-lib-26040, that an
<tt>erase(unordered_container, iterator)</tt> returning an <tt>iterator</tt> can
easily implemented in user code, if needed; that actually returning an
<tt>iterator</tt> costs nothing for the overload taking two <tt>iterator</tt>s,
thus that proposed change is only for consistency; that
<tt>forward_list::erase_after</tt> also returns <tt>void</tt> (for different
reasons, granted, but isn't that any "<tt>erase</tt>" function in the containers
uniformly returns an <tt>iterator</tt>); that, also in thread started by Chris'
message, Alberto pointed out that the proxy idea isn't a good one; that users
both of the GNU and Boost implementations are reporting serious performance
problems with the current version returning an <tt>iterator</tt>.
</blockquote>

<p><i>[
2010-02-07 Original wording saved here:
]</i></p>


<blockquote class="note">
<p>
Option 1:
</p>

<p>
The problem can be eliminated by omitting the requirement that <tt>a.erase(q)</tt> return an 
iterator. This is, however, in contrast with the equivalent requirements for other 
standard containers.
</p>

<p>
Option 2:
</p>

<p>
<tt>a.erase(q)</tt> can be made to compute the next iterator only when explicitly requested: 
the technique consists in returning a proxy object implicitly convertible to <tt>iterator</tt>, so 
that
</p>

<blockquote><pre>iterator q1=a.erase(q);
</pre></blockquote>

<p>
works as expected, while
</p>

<blockquote><pre>a.erase(q);
</pre></blockquote>

<p>
does not ever invoke the conversion-to-iterator operator, thus avoiding the associated 
computation. To allow this technique, some sections of TR1 along the line "return value 
is an iterator..." should be changed to "return value is an unspecified object implicitly 
convertible to an iterator..." Although this trick is expected to work transparently, it can 
have some collateral effects when the expression <tt>a.erase(q)</tt> is used inside generic 
code.
</p>

</blockquote>

<p><i>[
2010-03-27 Joaqun adds:
]</i></p>


<blockquote>
<p>
Signature of <tt>iterator erase(const_iterator)</tt> should be changed to <tt>void
erase(const_iterator)</tt>. If this is not viable an acceptable tradeoff
could be to make the return type of <tt>erase(const_iterator)</tt>
<i>implementation defined</i>.
</p>

<p>
The standard should allow implementations of unordered associative
containers using either singly or doubly linked lists.
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2023.pdf">N2023</a>
proves that singly-linked lists implementations cannot provide the required
complexity for <tt>iterator erase(const_iterator)</tt>. Thus, some action is
needed to allow both implementations.
</p>

<p> 
Option 1: Changing the required complexity from O(1) to O(log n). This option
merely masks a design flaw. Users are forcefully penalized for what they don't
use (the returned iterator). Besides, they would have to learn about the
pathological (yet very real) situations where using <tt>erase</tt> can lead to
quadratic performance. Two out of these three objections remain even if some
alternative member function like <tt>void quick_erase(const_iterator)</tt> is
thrown in to the interface.
</p>

<p> 
Some objections have been expressed to changing return type of <tt>erase</tt> to
<tt>void</tt>, arguing that it would break current existing practice with
standard library implementations based on doubly-linked lists, where the problem
does not occur. However implementations based on drafts should not block the
resolution of a serious design issue, more so when the issue will hurt future
users of C++, as it's happening already.
</p>

<p> 
Option 2: Make <tt>erase</tt> return type <i>implementation defined</i>. There's
a possible tradeoff with the objectors above consisting in changing the
signature to <i>implementation defined</i> <tt>erase(iterator)</tt>, so that
returning an iterator is indeed a valid extension. To this it can be argued that
this would make implementantions returning an iterator look as somehow promoting
proprietary extensions: this in my opinion is not a valid argument since those
implementations are <em>already</em> extending the required interface by
providing bidirectional iterators (just forward iterators are required).
</p>
</blockquote>

<p><i>[
2010 Rapperswil:
]</i></p>


<blockquote>
<p>
The issue was lengthy discussed and implementation experience was demonstrated that a non-void return
type is implementable for both single-linked and double-linked lists without loss of efficiency.
</p>

<p>
By a 12-1-1-0 poll voted to keep the return type of erase as <tt>iterator</tt> instead of 
<tt>void</tt> and a second 0-0-3-10 poll rejected the additional proposal to add a 
<tt>quick_erase</tt> returning <tt>void</tt>, thus LWG decided for NAD.
</p>
</blockquote>


<p><b>Rationale:</b></p>

<p>
No consensus for a change.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="580"></a>580. unused allocator members</h3>
<p><b>Section:</b> 23.2.1 [container.requirements.general] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2006-06-14 <b>Last modified:</b> 2010-10-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#container.requirements.general">active issues</a> in [container.requirements.general].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#container.requirements.general">issues</a> in [container.requirements.general].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#479">479</a></p>
<p><b>Discussion:</b></p>
        <p>

C++ Standard Library  templates that take an allocator  as an argument
are    required    to    call    the    <code>allocate()</code>    and
<code>deallocate()</code>  members of the  allocator object  to obtain
storage.  However, they do not appear to be required to call any other
allocator      members      such     as      <code>construct()</code>,
<code>destroy()</code>,           <code>address()</code>,          and
<code>max_size()</code>.  This makes these allocator members less than
useful in portable programs.

        </p>
        <p>

It's unclear to me whether the absence of the requirement to use these
allocator  members  is  an  unintentional  omission  or  a  deliberate
choice. However,  since the functions exist in  the standard allocator
and  since  they are  required  to  be  provided by  any  user-defined
allocator I  believe the standard  ought to be clarified  to explictly
specify  whether programs  should or  should not  be able  to  rely on
standard containers calling the functions.

        </p>
        <p>

I  propose  that all  containers  be required  to  make  use of  these
functions.

        </p>
<p><i>[
Batavia:  We support this resolution.  Martin to provide wording.
]</i></p>

<p><i>[
pre-Oxford:  Martin provided wording.
]</i></p>


<p><i>[
2009-04-28 Pablo adds:
]</i></p>


<blockquote>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2554.pdf">N2554</a>
(scoped allocators),
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2768.pdf">N2768</a>
(allocator concepts), and
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2810.pdf">N2810</a>
(allocator defects), address all of these points EXCEPT <tt>max_size()</tt>.
So, I would add a note to that affect and re-class the defect as belonging
to section 23.2.1 [container.requirements.general].
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
The comment in the description of this issue that this "would be"
rendered editorial by the adoption of N2257 is confusing. It appears
that N2257 was never adopted.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Addressed by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2982.pdf">N2982</a>.
</blockquote>



    <p><b>Proposed resolution:</b></p>
       <p>

Specifically, I propose to change 23.2 [container.requirements],
p9 as follows:

       </p>
           <blockquote>
<p>
-9- Copy constructors  for all container types defined  in this clause
<ins>that   are  parametrized  on   <code>Allocator</code></ins>  copy
<del>an</del><ins>the</ins>  allocator argument from  their respective
first parameters.

All other  constructors for  these container types  take a<del>n</del>
<ins>const</ins>  <code>Allocator&amp;</code>  argument  (20.1.6),  an
allocator whose <code>value_type</code> is the same as the container's
<code>value_type</code>.

A copy of this  argument <del>is</del><ins>shall be</ins> used for any
memory  allocation <ins> and  deallocation</ins> performed<del>,</del>
by these  constructors and by all  member functions<del>,</del> during
the  lifetime  of each  container  object.   <ins>Allocation shall  be
performed  "as  if"  by  calling  the  <code>allocate()</code>  member
function on  a copy  of the allocator  object of the  appropriate type
<sup>New  Footnote)</sup>,   and  deallocation  "as   if"  by  calling
<code>deallocate()</code> on  a copy of  the same allocator  object of
the corresponding type.</ins>

<ins>A  copy of  this argument  shall also  be used  to  construct and
destroy objects whose lifetime  is managed by the container, including
but not  limited to those of  the container's <code>value_type</code>,
and  to  obtain  their  address.   All  objects  residing  in  storage
allocated by a  container's allocator shall be constructed  "as if" by
calling the <code>construct()</code> member  function on a copy of the
allocator object of  the appropriate type.  The same  objects shall be
destroyed "as if"  by calling <code>destroy()</code> on a  copy of the
same allocator object  of the same type.  The  address of such objects
shall be obtained "as if" by calling the <code>address()</code> member
function  on  a  copy  of  the allocator  object  of  the  appropriate
type.</ins>

<ins>Finally, a copy  of this argument shall be  used by its container
object to determine  the maximum number of objects  of the container's
<code>value_type</code> the container may  store at the same time. The
container  member function <code>max_size()</code> obtains  this number
from      the      value      returned      by     a      call      to
<code>get_allocator().max_size()</code>.</ins>

In   all  container   types  defined   in  this   clause <ins>that  are
parametrized     on    <code>Allocator</code></ins>,     the    member
<code>get_allocator()</code>     returns     a     copy     of     the
<code>Allocator</code>     object     used     to    construct     the
container.<sup>258)</sup>
</p>
<p>
New Footnote: This type  may be different from <code>Allocator</code>:
it     may    be     derived    from     <code>Allocator</code>    via
<code>Allocator::rebind&lt;U&gt;::other</code>   for  the  appropriate
type <code>U</code>.
</p>
           </blockquote>
       <p>

The proposed wording seems cumbersome but I couldn't think of a better
way   to  describe   the   requirement  that   containers  use   their
<code>Allocator</code>  to manage  only objects  (regardless  of their
type)  that  persist  over  their  lifetimes  and  not,  for  example,
temporaries  created on the  stack. That  is, containers  shouldn't be
required  to  call  <code>Allocator::construct(Allocator::allocate(1),
elem)</code>  just to  construct a  temporary copy  of an  element, or
<code>Allocator::destroy(Allocator::address(temp),     1)</code>    to
destroy temporaries.

       </p>


<p><i>[
Howard: This same paragraph will need some work to accommodate <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#431">431</a>.
]</i></p>


<p><i>[
post Oxford:  This would be rendered NAD Editorial by acceptance of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2257.html">N2257</a>.
]</i></p>





<hr>
<h3><a name="582"></a>582. specialized algorithms and volatile storage</h3>
<p><b>Section:</b> 20.9.8.2 [uninitialized.copy] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2006-06-14 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#uninitialized.copy">issues</a> in [uninitialized.copy].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>Related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1029">1029</a></p>
        <p>

The specialized  algorithms [lib.specialized.algorithms] are specified
as having the general effect of invoking the following expression:

        </p>
            <pre>
new (static_cast&lt;void*&gt;(&amp;*i))
    typename iterator_traits&lt;ForwardIterator&gt;::value_type (x)

            </pre>
        <p>

This  expression is  ill-formed  when the  type  of the  subexpression
<code>&amp;*i</code> is some volatile-qualified <code>T</code>.

        </p>

<p><i>[
Batavia:  Lack of support for proposed resolution but agree there is a
defect.  Howard to look at wording.  Concern that move semantics
properly expressed if iterator returns rvalue.
]</i></p>



<p><i>[
2009-06-17 Pablo adds:
]</i></p>


<blockquote>

<p>Propose that Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#582">582</a> be closed NAD.</p>
<p>
Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#582">582</a> asks that <tt>uninitialized_copy</tt>,
<tt>uninitialized_fill</tt>, and <tt>uninitialized_fill_n</tt> should be
well-formed if the result type is volatile.  My feeling is that the
standard does not, and should not, guarantee any useful behavior when
constructors are invoked on volatile storage, so making it syntactically
legal to call <tt>uninitialized_copy</tt> on volatile storage is not useful. A
possible editorial change would be to put my previous sentence into a
non-normative note.
</p>
<p>
Note that the three sections starting with 20.9.8.2 [uninitialized.copy] do not
yet have concepts.  Here's a first crack at the first one:
</p>
<blockquote><pre>template &lt;InputIterator InIter, OutputIterator OutIter&gt;
requires ExplicitConvertible&lt;HasDereference&lt;OutIter::reference&gt;::result,
                             OutIter::value_type&amp;&gt;
      &amp;&amp; Convertible&lt;OutIter::value_type*, void*&gt;
      &amp;&amp; ExplicitConvertible&lt;OutIter::value_type, InIter::reference&gt;
  OutIter uninitialized_copy(InIter first, InIter last, OutIter result);
</pre>
<blockquote>
<p>
Effects:
</p>
<blockquote><pre>while (first != last) {
  typedef OutIter::value_type value_type;
  value_type&amp; outRef = static_cast&lt;value_type&amp;&gt;(*result++);
  ::new (static_cast&lt;void*&gt;(addressof(outRef))) value_type(*first++);
}
</pre></blockquote>
</blockquote>

</blockquote>

<p>
Notes:
</p>
<ol>
<li>This definition is actually LESS constrained than in C++03 because
there is no requirement that the result be a forward iterator.
</li>
<li>
If
OutIter returns a proxy type with an overloaded operator&amp;, this
definition probably won't compile.  Lifting this limitation while
allowing value_type to have an overloaded operator&amp; would be hard, but
is probably possible with careful overloading.  I'm not sure it's worth
it.
</li>
<li>
This definition retains the prohibition on the use of volatile types for the result.
</li>
</ol>

</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
We don't deal with volatile in the library.
</p>
<p>
Jim: should we state that explicitly somewhere?
</p>
<p>
Beman: you might argue that clause 17 should say something about
volatile. However, if you want to raise we argument, we should open it
as a separate issue and consult with experts on concurrency.
</p>
<p>
Hinnant: actually, some library components do handle volatile, so we'd
need to be very careful about what we say in clause 17.
</p>
<p>
No objection to NAD.
</p>
<p>
Move to NAD.
</p>
</blockquote>

    

    <p><b>Proposed resolution:</b></p>
        <p>

In order  to allow these algorithms  to operate on  volatile storage I
propose to change the expression so as to make it well-formed even for
pointers  to volatile  types.  Specifically,  I propose  the following
changes to clauses 20 and 24. Change 20.6.4.1, p1 to read:

        </p>
            <pre>
<i>Effects</i>:

typedef typename iterator_traits&lt;ForwardIterator&gt;::pointer    pointer;
typedef typename iterator_traits&lt;ForwardIterator&gt;::value_type value_type;

for (; first != last; ++result, ++first)
    new (static_cast&lt;void*&gt;(const_cast&lt;pointer&gt;(&amp;*result))
        value_type (*first);

            </pre>
        <p>

change 20.6.4.2, p1 to read

        </p>
            <pre>
<i>Effects</i>:

typedef typename iterator_traits&lt;ForwardIterator&gt;::pointer    pointer;
typedef typename iterator_traits&lt;ForwardIterator&gt;::value_type value_type;

for (; first != last; ++result, ++first)
    new (static_cast&lt;void*&gt;(const_cast&lt;pointer&gt;(&amp;*first))
        value_type (*x);

            </pre>
        <p>

and change 20.6.4.3, p1 to read

        </p>
            <pre>
<i>Effects</i>:

typedef typename iterator_traits&lt;ForwardIterator&gt;::pointer    pointer;
typedef typename iterator_traits&lt;ForwardIterator&gt;::value_type value_type;

for (; n--; ++first)
    new (static_cast&lt;void*&gt;(const_cast&lt;pointer&gt;(&amp;*first))
        value_type (*x);

            </pre>
        <p>

In   addition,  since   there   is  no   partial  specialization   for
<code>iterator_traits&lt;volatile T*&gt;</code>  I propose to  add one
to parallel such specialization  for &lt;const T*&gt;. Specifically, I
propose to add the following text to the end of 24.3.1, p3:

        </p>
        <p>

and for pointers to volatile as 

        </p>
            <pre>
namespace std {
template&lt;class T&gt; struct iterator_traits&lt;volatile T*&gt; {
typedef ptrdiff_t difference_type;
typedef T value_type;
typedef volatile T* pointer;
typedef volatile T&amp; reference;
typedef random_access_iterator_tag iterator_category;
};
}

            </pre>
        <p>

Note that  the change to  <code>iterator_traits</code> isn't necessary
in order to implement the  specialized algorithms in a way that allows
them to operate on volatile  strorage. It is only necesassary in order
to specify  their effects in terms  of <code>iterator_traits</code> as
is  done here.   Implementations can  (and some  do) achieve  the same
effect by means of function template overloading.

        </p>
    



<hr>
<h3><a name="583"></a>583. div() for unsigned integral types</h3>
<p><b>Section:</b> 26.8 [c.math] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2006-06-15 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#c.math">issues</a> in [c.math].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There is no div() function for unsigned integer types.
</p>
<p>
There are several possible resolutions.  The simplest one is noted below.  Other
possibilities include a templated solution.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add to 26.7 [lib.c.math] paragraph 8:
</p>

<blockquote><pre>struct udiv_t div(unsigned, unsigned);
struct uldiv_t div(unsigned long, unsigned long);
struct ulldiv_t div(unsigned long long, unsigned long long);
</pre></blockquote>



<p><b>Rationale:</b></p>
Toronto:  C99 does not have these unsigned versions because
the signed version exist just to define the implementation-defined behavior
of signed integer division.  Unsigned integer division has no implementation-defined
behavior and thus does not need this treatment.





<hr>
<h3><a name="584"></a>584. missing int pow(int,int) functionality</h3>
<p><b>Section:</b> 26.8 [c.math] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2006-06-15 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#c.math">issues</a> in [c.math].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There is no pow() function for any integral type.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add something like:
</p>

<blockquote><pre>template&lt; typename T&gt;
T power( T x, int n );
// requires: n &gt;=0
</pre></blockquote>


<p><b>Rationale:</b></p>
Toronto:  We already have double pow(integral, integral) from 26.8 [c.math] p11.





<hr>
<h3><a name="585"></a>585. facet error reporting</h3>
<p><b>Section:</b> 22.4 [locale.categories] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor, Paolo Carlini <b>Opened:</b> 2006-06-22 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.categories">issues</a> in [locale.categories].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
        <p>

Section  22.2, paragraph 2  requires facet  <code>get()</code> members
that    take    an    <code>ios_base::iostate&amp;</code>    argument,
<code><i>err</i></code>,  to   ignore  the  (initial)   value  of  the
argument, but to set it to <code>ios_base::failbit</code> in case of a
parse error.

        </p>
        <p>

We  believe  there  are  a   few  minor  problems  with  this  blanket
requirement  in   conjunction  with   the  wording  specific   to  each
<code>get()</code> member function.

        </p>
        <p>

First,  besides <code>get()</code>  there are  other  member functions
with     a      slightly     different     name      (for     example,
<code>get_date()</code>). It's not completely clear that the intent of
the  paragraph  is  to  include  those  as  well,  and  at  least  one
implementation has interpreted the requirement literally.

        </p>
        <p>

Second,    the     requirement    to    "set     the    argument    to
<code>ios_base::failbit</code>  suggests that  the  functions are  not
permitted    to   set    it   to    any   other    value    (such   as
<code>ios_base::eofbit</code>,   or   even  <code>ios_base::eofbit   |
ios_base::failbit</code>).

        </p>
        <p>

However, 22.2.2.1.2, p5 (Stage  3 of <code>num_get</code> parsing) and
p6 (<code>bool</code> parsing)  specifies that the <code>do_get</code>
functions  perform <code><i>err</i> |=  ios_base::eofbit</code>, which
contradicts  the earlier  requirement to  ignore  <i>err</i>'s initial
value.

        </p>
        <p>

22.2.6.1.2,  p1  (the  Effects  clause of  the  <code>money_get</code>
facet's  <code>do_get</code>  member  functions) also  specifies  that
<code><i>err</i></code>'s initial  value be used to  compute the final
value  by  ORing  it  with  either  <code>ios_base::failbit</code>  or
with<code>ios_base::eofbit | ios_base::failbit</code>.

        </p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Move to NAD.
</blockquote>

    

    <p><b>Proposed resolution:</b></p>
        <p>

We believe the  intent is for all facet member  functions that take an
<code>ios_base::iostate&amp;</code> argument to:

        </p>
            <ul>
                <li>

ignore the initial value of the <code><i>err</i></code> argument,

                </li>
                <li>

reset <code><i>err</i></code>  to <code>ios_base::goodbit</code> prior
to any further processing,

                </li>
                <li>

and       set      either       <code>ios_base::eofbit</code>,      or
<code>ios_base::failbit</code>, or both in <code><i>err</i></code>, as
appropriate,  in response  to  reaching the  end-of-file  or on  parse
error, or both.

                </li>
            </ul>
        <p>

To that effect we propose to change 22.2, p2 as follows:

        </p>
        <p>

The  <i>put</i><del>()</del>  members  make  no  provision  for  error
reporting.   (Any  failures of  the  OutputIterator  argument must  be
extracted   from  the   returned  iterator.)    <ins>Unless  otherwise
specified, </ins>the <i>get</i><del>()</del>  members  <ins>that</ins>
take an  <code>ios_base::iostate&amp;</code> argument <del>whose value
they  ignore,  but  set  to  ios_base::failbit  in  case  of  a  parse
error.</del><ins>,   <code><i>err</i></code>,   start  by   evaluating
<code>err  =   ios_base::goodbit</code>,  and  may   subsequently  set
<i>err</i>     to     either     <code>ios_base::eofbit</code>,     or
<code>ios_base::failbit</code>,     or     <code>ios_base::eofbit    |
ios_base::failbit</code> in response to reaching the end-of-file or in
case of a parse error, or both, respectively.</ins>

        </p>
    
    
<p><i>[
Kona (2007): We need to change the proposed wording to clarify that the
phrase "the get members" actually denotes <tt>get()</tt>, <tt>get_date()</tt>, etc.
Proposed Disposition: Open
]</i></p>




<hr>
<h3><a name="587"></a>587. iststream ctor missing description</h3>
<p><b>Section:</b> D.9.2.1 [depr.istrstream.cons] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2006-06-22 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
        <p>

The  <code>iststream(char*, streamsize)</code>  ctor is  in  the class
synopsis  in D.7.2  but its  signature is  missing in  the description
below (in D.7.2.1).

        </p>
    

    <p><b>Proposed resolution:</b></p>
        <p>

This seems like a simple editorial issue and the missing signature can
be added to the one for <code>const char*</code> in paragraph 2.

        </p>

<p><i>[
post Oxford: Noted that it is already fixed in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2284.pdf">N2284</a>
]</i></p>


    



<hr>
<h3><a name="588"></a>588. requirements on zero sized tr1::arrays and other details</h3>
<p><b>Section:</b> 23.3.1 [array] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Gennaro Prota <b>Opened:</b> 2006-07-18 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#array">issues</a> in [array].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The wording used for section 23.2.1 [lib.array] seems to be subtly
ambiguous about zero sized arrays (N==0). Specifically:
</p>
<p>
* "An instance of array&lt;T, N&gt; stores N elements of type T, so that
[...]"
</p>
<p>
Does this imply that a zero sized array object stores 0 elements, i.e.
that it cannot store any element of type T? The next point clarifies
the rationale behind this question, basically how to implement begin()
and end():
</p>
<p>
* 23.2.1.5 [lib.array.zero], p2: "In the case that N == 0, begin() ==
end() == unique value."
</p>
<p>
What does "unique" mean in this context? Let's consider the following
possible implementations, all relying on a partial specialization:
</p>
<blockquote><pre>a)
    template&lt; typename T &gt;
    class array&lt; T, 0 &gt; {
    
        ....

        iterator begin()
        { return iterator( reinterpret_cast&lt; T * &gt;( this ) ); }
        ....

    };
</pre></blockquote>
<p>
This has been used in boost, probably intending that the return value
had to be unique to the specific array object and that array couldn't
store any T. Note that, besides relying on a reinterpret_cast, has
(more than potential) alignment problems.
</p>
<blockquote><pre>b)
    template&lt; typename T &gt;
    class array&lt; T, 0 &gt; {
    
        T t;

        iterator begin()
        { return iterator( &amp;t ); }
        ....

    };
</pre></blockquote>
<p>
This provides a value which is unique to the object and to the type of
the array, but requires storing a T. Also, it would allow the user to
mistakenly provide an initializer list with one element.
</p>
<p>
A slight variant could be returning *the* null pointer of type T
</p>
<blockquote><pre>    return static_cast&lt;T*&gt;(0);
</pre></blockquote>
<p>
In this case the value would be unique to the type array&lt;T, 0&gt; but not
to the objects (all objects of type array&lt;T, 0&gt; with the same value
for T would yield the same pointer value).
</p>
<p>
Furthermore this is inconsistent with what the standard requires from
allocation functions (see library issue 9).
</p>
<p>
c) same as above but with t being a static data member; again, the
value would be unique to the type, not to the object.
</p>
<p>
d) to avoid storing a T *directly* while disallowing the possibility
to use a one-element initializer list a non-aggregate nested class
could be defined
</p>
<blockquote><pre>    struct holder { holder() {} T t; } h;
</pre></blockquote>
<p>
and then begin be defined as
</p>
<blockquote><pre> iterator begin() { return &amp;h.t; }
</pre></blockquote>
<p>
But then, it's arguable whether the array stores a T or not.
Indirectly it does.
</p>
<p>
-----------------------------------------------------
</p>
<p>
Now, on different issues:
</p>
<p>
* what's the effect of calling assign(T&amp;) on a zero-sized array? There
seems to be only mention of front() and back(), in 23.2.1 [lib.array]
p4 (I would also suggest to move that bullet to section 23.2.1.5
[lib.array.zero], for locality of reference)
</p>
<p>
* (minor) the opening paragraph of 23.2.1 [lib.array] wording is a bit
inconsistent with that of other sequences: that's not a problem in
itself, but compare it for instance with "A vector is a kind of
sequence that supports random access iterators"; though the intent is
obvious one might argue that the wording used for arrays doesn't tell
what an array is, and relies on the reader to infer that it is what
the &lt;array&gt; header defines.
</p>
<p>
* it would be desiderable to have a static const data member of type
std::size_t, with value N, for usage as integral constant expression
</p>
<p>
* section 23.1 [lib.container.requirements] seem not to consider
fixed-size containers at all, as it says: "[containers] control
allocation and deallocation of these objects [the contained objects]
through constructors, destructors, *insert and erase* operations"
</p>
<p>
* max_size() isn't specified: the result is obvious but, technically,
it relies on table 80: "size() of the largest possible container"
which, again, doesn't seem to consider fixed size containers
</p>

<p><i>[
2009-05-29 Daniel adds:
]</i></p>


<blockquote>
<ol type="a">
<li>
<p>
star bullet 1 ("what's the effect of calling <tt>assign(T&amp;)</tt> on a
zero-sized array?[..]");
</p>
<blockquote>
<tt>assign</tt> has been renamed to <tt>fill</tt> and the semantic of <tt>fill</tt> is now
defined in terms of
the free algorithm <tt>fill_n</tt>, which is well-defined for this situation.
</blockquote>
</li>
<li>
<p>
star bullet 3 ("it would be desiderable to have a static const data
member..."):
</p>
<blockquote>
It seems that <tt>tuple_size&lt;array&lt;T, N&gt; &gt;::value</tt> as of 23.3.1.8 [array.tuple] does
provide this functionality now.
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
Alisdair to address by the next meeting, or declare NAD.
</p>
<p>
Moved to Tentatively NAD.
</p>
</blockquote>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
Moved to NAD.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>


<p><i>[
Kona (2007): requirements on zero sized <tt>tr1::array</tt>s and other details
Issue 617: <tt>std::array</tt> is a sequence that doesn't satisfy the sequence
requirements? Alisdair will prepare a paper. Proposed Disposition: Open
]</i></p>





<hr>
<h3><a name="590"></a>590. Type traits implementation latitude should be removed for C++0x</h3>
<p><b>Section:</b> 20.7 [meta], TR1 4.9 [tr.meta.req] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2006-08-10 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta">issues</a> in [meta].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.4.9 [lib.meta.req], Implementation requirements, provides latitude for type
traits implementers that is not needed in C++0x. It includes the wording:
</p>

<blockquote><p>
[<i>Note:</i> the latitude granted to implementers in this clause is temporary,
and is expected to be removed in future revisions of this document. -- <i>end note</i>]
</p></blockquote>

<p>
Note:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2157.html">N2157: Minor Modifications to the type traits Wording</a>
also has the intent of removing this wording from the WP.
</p>



<p><b>Proposed resolution:</b></p>
<p>
Remove 20.4.9 [lib.meta.req] in its entirety from the WP.
</p>

<p><i>[
post-Oxford: Recommend NAD Editorial.  This resolution is now in the
current working draft.
]</i></p>







<hr>
<h3><a name="591"></a>591. Misleading "built-in</h3>
<p><b>Section:</b> 18.3.1.2 [numeric.limits.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> whyglinux <b>Opened:</b> 2006-08-08 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#numeric.limits.members">issues</a> in [numeric.limits.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
18.2.1.2 numeric_limits members [lib.numeric.limits.members]
Paragraph 7:
</p>
<blockquote><p>
"For built-in integer types, the number of non-sign bits in the
representation."
</p></blockquote>

<p>
26.1 Numeric type requirements [lib.numeric.requirements]
Footnote:
</p>

<blockquote><p>
"In other words, value types. These include built-in arithmetic types,
pointers, the library class complex, and instantiations of valarray for
value types."
</p></blockquote>

<p>
Integer types (which are bool, char, wchar_t, and the signed and
unsigned integer types) and arithmetic types (which are integer and
floating types) are all built-in types and thus there are no
non-built-in (that is, user-defined) integer or arithmetic types. Since
the redundant "built-in" in the above 2 sentences can mislead that
there may be built-in or user-defined integer and arithmetic types
(which is not correct), the "built-in" should be removed.
</p>


<p><b>Proposed resolution:</b></p>
<p>
18.2.1.2 numeric_limits members [lib.numeric.limits.members]
Paragraph 7:
</p>
<blockquote><p>
"For <del>built-in</del> integer types, the number of non-sign bits in the
representation."
</p></blockquote>

<p>
26.1 Numeric type requirements [lib.numeric.requirements]
Footnote:
</p>

<blockquote><p>
"In other words, value types. These include <del>built-in</del> arithmetic types,
pointers, the library class complex, and instantiations of valarray for
value types."
</p></blockquote>


<p><b>Rationale:</b></p>
<p>
Recommend NAD / Editorial.  The proposed resolution is accepted as editorial.
</p>





<hr>
<h3><a name="592"></a>592. Incorrect treatment of rdbuf()-&gt;close() return type</h3>
<p><b>Section:</b> 27.9.1.9 [ifstream.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Christopher Kohlhoff <b>Opened:</b> 2006-08-17 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ifstream.members">issues</a> in [ifstream.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I just spotted a minor problem in 27.8.1.7
[lib.ifstream.members] para 4 and also 27.8.1.13
[lib.fstream.members] para 4. In both places it says:
</p>
<blockquote>
<pre>void close();
</pre>
<p>
Effects: Calls rdbuf()-&gt;close() and, if that function returns false, ...
</p>
</blockquote>
<p>
However, basic_filebuf::close() (27.8.1.2) returns a pointer to the
filebuf on success, null on failure, so I think it is meant to
say "if that function returns a null pointer". Oddly, it is
correct for basic_ofstream.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 27.9.1.9 [ifstream.members], p5:
</p>

<blockquote><p>
<i>Effects:</i> Calls <tt>rdbuf()-&gt;close()</tt> and, if that function
<ins>fails (</ins>returns <del><tt>false</tt></del> <ins>a null pointer)</ins>,
calls <tt>setstate(failbit)</tt> (which may throw <tt>ios_base::failure</tt>
(27.4.4.3)).
</p></blockquote>

<p>
Change 27.9.1.17 [fstream.members], p5:
</p>

<blockquote><p>
<i>Effects:</i> Calls <tt>rdbuf()-&gt;close()</tt> and, if that function
<ins>fails (</ins>returns <del><tt>false</tt></del> <ins>a null pointer)</ins>,
calls <tt>setstate(failbit)</tt> (which may throw <tt>ios_base::failure</tt>
(27.4.4.3)).
</p></blockquote>



<p><i>[
Kona (2007): Proposed Disposition: NAD, Editorial
]</i></p>





<hr>
<h3><a name="597"></a>597. Decimal: The notion of 'promotion' cannot be emulated by user-defined types.</h3>
<p><b>Section:</b> TRDecimal 3.2 [trdec.types.types] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Daveed Vandevoorde <b>Opened:</b> 2006-04-05 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#trdec.types.types">issues</a> in [trdec.types.types].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In a private email, Daveed writes:
</p>
<blockquote>
<p>
I am not familiar with the C TR, but my guess is that the
class type approach still won't match a built-in type
approach because the notion of "promotion" cannot be
emulated by user-defined types.
</p>
<p>
Here is an example:
</p>
</blockquote>
<pre>
         struct S {
           S(_Decimal32 const&amp;);  // Converting constructor
         };
         void f(S);

         void f(_Decimal64);

         void g(_Decimal32 d) {
           f(d);
         }
</pre>

<blockquote>
<p>
If _Decimal32 is a built-in type, the call f(d) will likely
resolve to f(_Decimal64) because that requires only a
promotion, whereas f(S) requires a user-defined conversion.
</p>
<p>
If _Decimal32 is a class type, I think the call f(d) will be
ambiguous because both the conversion to _Decimal64 and the
conversion to S will be user-defined conversions with neither
better than the other.
</p>
</blockquote>
<p>
Robert comments:
</p>
<p>
In general, a library of arithmetic types cannot exactly emulate the behavior of the intrinsic numeric types.  There are several ways to tell whether an implementation of the decimal types uses compiler intrinisics or a library.  For example:
</p>
<pre>                 _Decimal32 d1;
                 d1.operator+=(5);  // If d1 is a builtin type, this won't compile.
</pre>
<p>
In preparing the decimal TR, we have three options:
</p>
<ol>
<li>require that the decimal types be class types</li>
<li>require that the decimal types be builtin types, like float and double</li>
<li>specify a library of class types, but allow enough implementor latitude that a conforming implementation could instead provide builtin types</li>
</ol>
<p>
We decided as a group to pursue option #3, but that approach implies that implementations may not agree on the semantics of certain use cases (first example, above), or on whether certain other cases are well-formed (second example).  Another potentially important problem is that, under the present definition of POD, the decimal classes are not POD types, but builtins will be.
</p>
<p>
Note that neither example above implies any problems with respect to C-to-C++ compatibility, since neither example can be expressed in C.
</p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
Decimal numeric types may either be builtin types or library types. We
only intend to specify the common subset of behaviors of the two
implementation approaches. The front matter of the Decimal TR says this
explicitly.
</p>
<p>
Move to NAD.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="606"></a>606. Decimal: allow narrowing conversions</h3>
<p><b>Section:</b> TRDecimal 3.2 [trdec.types.types] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2006-06-15 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#trdec.types.types">issues</a> in [trdec.types.types].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In c++std-lib-17205, Martin writes:
</p>
<blockquote><p>
...was it a deliberate design choice to make narrowing assignments ill-formed while permitting narrowing compound assignments?  For instance:
</p></blockquote>
<pre>      decimal32 d32;
      decimal64 d64;

      d32 = 64;     // error
      d32 += 64;    // okay
</pre>
<p>
In c++std-lib-17229, Robert responds:
</p>
<blockquote><p>
It is a vestige of an old idea that I forgot to remove from the paper.  Narrowing assignments should be permitted.  The bug is that the converting constructors that cause narrowing should not be explicit.  Thanks for pointing this out.
</p></blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
The current state of the Decimal TR is the result of a deliberate design
decision that has been examined many times.
</p>
<p>
Move to NAD.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
1.  In "3.2.2 Class <code>decimal32</code>" synopsis, remove the <code>explicit</code> specifier from the narrowing conversions:
</p>
<pre>                // <i>3.2.2.2 conversion from floating-point type:</i>
                <del>explicit</del> decimal32(decimal64 <i>d64</i>);
                <del>explicit</del> decimal32(decimal128 <i>d128</i>);
</pre>
<p>
2.  Do the same thing in "3.2.2.2. Conversion from floating-point type."
</p>
<p>
3.  In "3.2.3 Class <code>decimal64</code>" synopsis, remove the <code>explicit</code> specifier from the narrowing conversion:
</p>
<pre>                // <i>3.2.3.2 conversion from floating-point type:</i>
                <del>explicit</del> decimal64(decimal128 <i>d128</i>);
</pre>
<p>
4.  Do the same thing in "3.2.3.2. Conversion from floating-point type."
</p>

<p><i>[
Redmond: We prefer explicit conversions for narrowing and implicit for widening.
]</i></p>






<hr>
<h3><a name="614"></a>614. std::string allocator requirements still inconsistent</h3>
<p><b>Section:</b> 21.4 [basic.string] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Bo Persson <b>Opened:</b> 2006-12-05 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#basic.string">issues</a> in [basic.string].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This is based on N2134, where 21.3.1/2 states:
"... The Allocator object used shall be a copy of the Allocator object 
passed to the basic_string object's constructor or, if the constructor does 
not take an Allocator argument, a copy of a default-constructed Allocator 
object."
</p>
<p>
Section 21.3.2/1 lists two constructors:
</p>
<blockquote><pre>basic_string(const basic_string&lt;charT,traits,Allocator&gt;&amp; str );

basic_string(const basic_string&lt;charT,traits,Allocator&gt;&amp; str ,
             size_type pos , size_type n = npos,
             const Allocator&amp; a = Allocator());
</pre></blockquote>
<p>
and then says "In the first form, the Allocator value used is copied from 
str.get_allocator().", which isn't an option according to 21.3.1.
</p>
<p><i>[
Batavia:  We need blanket statement to the effect of:
]</i></p>


<ol>
<li>If an allocator is passed in, use it, or,</li>
<li>If a string is passed in, use its allocator.</li>
</ol>
<p><i>[
Review constructors and functions that return a string; make sure we follow these
rules (substr, operator+, etc.).  Howard to supply wording.
]</i></p>


<p><i>[
Bo adds:  The new container constructor which takes only a <tt>size_type</tt> is not
consistent with 23.2 [container.requirements], p9 which says in part:

</i></p><blockquote><i>
All other constructors for these container types take an
<tt>Allocator&amp;</tt> argument (20.1.2), an allocator whose value type
is the same as the container's value type. A copy of this argument is
used for any memory allocation performed, by these constructors and by
all member functions, during the lifetime of each container object.
</i></blockquote><i>
]</i><p></p>


<p><i>[
post Bellevue: We re-confirm that the issue is real. Pablo will provide wording.
]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Move to NAD.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="615"></a>615. Inconsistencies in Section 21.4</h3>
<p><b>Section:</b> 21.7 [c.strings] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Bo Persson <b>Opened:</b> 2006-12-11 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#c.strings">issues</a> in [c.strings].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In the current draft N2134, 21.4/1 says
</p>
<p>
"Tables 59,228) 60, 61, 62,and 63 229) 230) describe headers &lt;cctype&gt;, 
&lt;cwctype&gt;, &lt;cstring&gt;, &lt;cwchar&gt;, and &lt;cstdlib&gt; (character conversions), 
respectively."
</p>
<p>
Here footnote 229 applies to table 62, not table 63.
</p>
<p>
Also, footnote 230 lists the new functions in table 63, "atoll, strtoll, 
strtoull, strtof, and strtold added by TR1". However, strtof is not present 
in table 63.
</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>


<p><b>Rationale:</b></p>
<p>
Recommend NAD, editorial.  Send to Pete.
</p>





<hr>
<h3><a name="617"></a>617. std::array is a sequence that doesn't satisfy the sequence requirements?</h3>
<p><b>Section:</b> 23.3.1 [array] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Bo Persson <b>Opened:</b> 2006-12-30 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#array">issues</a> in [array].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>&lt;array&gt;</tt> header is given under 23.3 [sequences].
23.3.1 [array]/paragraph 3 says:
</p>
<blockquote><p>
"Unless otherwise specified, all array operations are as described in
23.2 [container.requirements]".
</p></blockquote>
<p>
However, array isn't mentioned at all in section 23.2 [container.requirements].
In particular, Table 82 "Sequence requirements" lists several operations (insert, erase, clear) 
that std::array does not have in 23.3.1 [array].
</p>
<p>
Also, Table 83 "Optional sequence operations" lists several operations that 
std::array does have, but array isn't mentioned.
</p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
The real issue seems to be different than what is described here.
Non-normative text says that std::array is a sequence container, but
there is disagreement about what that really means. There are two
possible interpretations:
</p>
<ol>
<li>
a sequence container is one that satisfies all sequence container requirements
</li>
<li>
a sequence container is one that satisfies some of the sequence
container requirements. Any operation that the container supports is
specified by one or more sequence container requirements, unless that
operation is specifically singled out and defined alongside the
description of the container itself.
</li>
</ol>
<p>
Move to Tentatively NAD.
</p>
</blockquote>

<p><i>[
2009-07-15 Loc Joly adds:
]</i></p>


<blockquote>
<p>
The section 23.2.3 [sequence.reqmts]/1 states that array is a sequence. 23.2.3 [sequence.reqmts]/3
introduces table 83, named Sequence container requirements. This seems
to me to be defining the requirements for all sequences. However, array
does not follow all of this requirements (this can be read in the array
specific section, for the standard is currently inconsistent).
</p>

<p>
Proposed resolution 1 (minimal change): 
</p>
<blockquote>
<p>
Say that array is a container, that in addition follows only some of the
sequence requirements, as described in the array section:
</p>

<blockquote>
The library provides <del>five</del> <ins>three</ins> basic kinds of sequence containers: <del><tt>array</tt></del>,
<tt>vector</tt>, 
<del><tt>forward_list</tt></del>, <tt>list</tt>, and <tt>deque</tt>. <ins>In addition, <tt>array</tt>
and <tt>forward_list</tt> follows some of the requirements 
of sequences, as described in their respective sections.</ins>
</blockquote>

</blockquote>

<p>
Proposed resolution 2 (most descriptive description, no full wording provided): 
</p>
<blockquote>
Introduce the notion of a Fixed Size Sequence, with it requirement table
that would be a subset of the current Sequence container. array would be
the only Fixed Size Sequence (but dynarray is in the queue for TR2).
Sequence requirements would now be requirements in addition to Fixed
Size Sequence requirements (it is currently in addition to container).
</blockquote>
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
Move to NAD Editorial
</blockquote>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
This will require a lot of reorganization. Editor doesn't think this is really
an issue, since the description of array can be considered as overriding
what's specified about sequences. Move to NAD.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="626"></a>626. new <i>Remark</i> clauses not documented</h3>
<p><b>Section:</b> 17.5.1.4 [structure.specifications] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2007-01-20 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#structure.specifications">issues</a> in [structure.specifications].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
        <p>

The <i>Remark</i> clauses newly  introduced into the Working Paper 
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2134.pdf">N2134</a>)
are  not mentioned  in  17.5.1.4 [structure.specifications] where  we list  the
meaning  of <i>Effects</i>, <i>Requires</i>,  and other  clauses (with
the exception  of <i>Notes</i> which are documented  as informative in
17.5.1.2 [structure.summary], p2, and which they replace in many cases).

        </p>
        <p>

Propose add a bullet for <i>Remarks</i> along with a brief description.

        </p>
<p><i>[
Batavia:  Alan and Pete to work.
]</i></p>


<p><i>[
Bellevue: Already resolved in current working paper.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="627"></a>627. Low memory and exceptions</h3>
<p><b>Section:</b> 18.6.1.1 [new.delete.single] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2007-01-23 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#new.delete.single">issues</a> in [new.delete.single].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I recognize the need for nothrow guarantees in the exception reporting
mechanism, but I strongly believe that implementors also need an escape hatch
when memory gets really low. (Like, there's not enough heap to construct and
copy exception objects, or not enough stack to process the throw.) I'd like to
think we can put this escape hatch in 18.6.1.1 [new.delete.single],
<tt>operator new</tt>, but I'm not sure how to do it. We need more than a
footnote, but the wording has to be a bit vague. The idea is that if
<tt>new</tt> can't allocate something sufficiently small, it has the right to
<tt>abort</tt>/call <tt>terminate</tt>/call <tt>unexpected</tt>.
</p>

<p><i>[
Bellevue: NAD.  1.4p2 specifies a program must behave correctly "within
its resource limits", so no further escape hatch is necessary.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="631"></a>631. conflicting requirements for <tt>BinaryPredicate</tt></h3>
<p><b>Section:</b> 25 [algorithms] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> James Kanze <b>Opened:</b> 2007-01-31 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#algorithms">issues</a> in [algorithms].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The general requirements for <tt><tt>BinaryPredicate</tt></tt> (in 25 [algorithms]/8) contradict the implied specific requirements for
some functions. In particular, it says that:
</p>

<blockquote><p>
[...] if an algorithm takes <tt>BinaryPredicate <i>binary_pred</i></tt>
as its argument and <tt><i>first1</i></tt> and <i>first2</i> as its
iterator arguments, it should work correctly in the construct <tt>if
(binary_pred (*<i>first1</i> , *<i>first2</i> )){...}</tt>.
<tt>BinaryPredicate</tt> always takes the first iterator type as its
first argument, that is, in those cases when <tt>T <i>value</i></tt> is
part of the signature, it should work correctly in the context of <tt>if
(binary_pred (*<i>first1</i> , <i>value</i>)){...}</tt>.
</p></blockquote>

<p>
In the description of <tt>upper_bound</tt> (25.4.3.2 [upper.bound]/2), however, the use is described as
"<tt>!comp(<i>value</i>, <i>e</i>)</tt>", where <tt><i>e</i></tt> is an
element of the sequence (a result of dereferencing
<tt>*<i>first</i></tt>).
</p>

<p>
In the description of <tt>lexicographical_compare</tt>, we have both
"<tt>*<i>first1</i> &lt; *<i>first2</i></tt>" and "<tt>*<i>first2</i>
&lt; *<i>first1</i></tt>" (which presumably implies "<tt>comp(
*<i>first1</i>, *<i>first2</i> )</tt>" and "<tt>comp( *<i>first2</i>,
*<i>first1</i> )</tt>".
</p>

<p>
Logically, the <tt>BinaryPredicate</tt> is used as an ordering
relationship, with the semantics of "less than".  Depending on the
function, it may be used to determine equality, or any of the inequality
relationships; doing this requires being able to use it with either
parameter first.  I would thus suggest that the requirement be:
</p>

<p>
Alternatively, one could specify an order for each function. IMHO, this
would be more work for the committee, more work for the implementors,
and of no real advantage for the user: some functions, such as
<tt>lexicographical_compare</tt> or <tt>equal_range</tt>, will still require both
functions, and it seems like a much easier rule to teach that both
functions are always required, rather than to have a complicated list of
when you only need one, and which one.
</p>

<p><i>[
Toronto:  Moved to Open.  ConceptGCC seems to get <tt>lower_bound</tt>
and <tt>upper_bound</tt> to work withoutt these changes.
]</i></p>


<p><i>[
2009-07-28 Reopened by Alisdair.  No longer solved by concepts.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Review. The small problem with the "iterator type"
will be fixed. The cited functions (<tt>lower_bound</tt>, <tt>uppwer_bound</tt>,
<tt>equal_range</tt>) don't actually use <tt>BinaryPredicate</tt> , and where it is used,
it is consistent with  [algorithm]/8, so the main complaint of the issue
is moot.
</blockquote>

<p><i>[
2010-01-16 Beman clarified wording.
]</i></p>


<p><i>[
2010-01-31: Moved to Tentatively NAD after 5 positive votes on c++std-lib. 
Rationale added below.
]</i></p>




<p><b>Rationale:</b></p>
<p><i>[
post San Francisco:
]</i></p>


<blockquote>
<p>
Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2759.pdf">N2759</a>.
</p>
</blockquote>

<p>
2010-01-31: The draft standard is well specified as is, and this specification
is desired.  Issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#556">556</a> and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#870">870</a> solve the remaining
unclearness regarding the meaning of BinaryPredicate.
</p>



<p><b>Proposed resolution:</b></p>
<p><i>Change 25 [algorithms] paragraph 8 as indicated:</i></p>

<blockquote>

<p>
8 The <tt>BinaryPredicate</tt> parameter is used whenever an algorithm expects a
function object that when applied to the result of dereferencing two
corresponding iterators or to dereferencing an iterator and type <tt>T</tt> when
<tt>T</tt> is part of the signature returns a value testable as true. <ins>
<tt>BinaryPredicate</tt> always takes the first iterator <tt>value_type</tt> as
one of its arguments; which argument is unspecified.</ins> <del>In other words,
if</del> <ins> If</ins> an algorithm takes <tt>BinaryPredicate binary_pred</tt>
as its argument and <tt>first1</tt> and <tt>first2</tt> as its iterator
arguments, it should work correctly <ins>both</ins> in the construct <tt>if
(binary_pred(*first1, *first2)){...}</tt> <ins>and <tt>if (binary_pred (*first2,
*first1)){...}</tt></ins>. <del><tt>BinaryPredicate</tt> always takes the first
iterator type as its first argument, that is, in</del> <ins>In</ins> those cases
when <tt>T value</tt> is part of the signature, it should work correctly in the
context of <tt> if (binary_pred(*first1, value)){...}</tt> <ins>and of <tt>if
(binary_pred (value, *first1)){...}</tt></ins>. <del> <tt>binary_pred</tt> shall
not apply any non-constant function through the dereferenced iterators.</del>
<ins>[<i>Note:</i> if the two types are not identical, and neither is
convertable to the other, this may require that the <tt>BinaryPredicate</tt> be
a functional object with two overloaded <tt>operator()()</tt> functions.
 <i>end note</i>]</ins>
</p>

</blockquote>






<hr>
<h3><a name="632"></a>632. Time complexity of size() for std::set</h3>
<p><b>Section:</b> 23.2 [container.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Lionel B <b>Opened:</b> 2007-02-01 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
A recent news group discussion:
</p>
<blockquote>
<p>
Anyone know if the Standard has anything to say about the time complexity
of size() for std::set?   I need to access a set's size (/not/ to know if it is empty!) heavily
during an algorithm and was thus wondering whether I'd be better off
tracking the size "manually" or whether that'd be pointless.
</p>
<p>
That would be pointless. size() is O(1).
</p>
<p>
Nit: the standard says "should" have constant time. Implementations may take
license to do worse. I know that some do this for <tt>std::list&lt;&gt;</tt> as a part of
some trade-off with other operation.
</p>

<p>
I was aware of that, hence my reluctance to use size() for std::set.
</p>
<p>
However, this reason would not apply to <tt>std::set&lt;&gt;</tt> as far as I can see.
</p>
<p>
Ok, I guess the only option is to try it and see...
</p>
</blockquote>

<p>
If I have any recommendation to the C++ Standards Committee it is that
implementations must (not "should"!) document clearly[1], where known, the
time complexity of *all* container access operations.
</p>
<p>
[1] In my case (gcc 4.1.1) I can't swear that the time complexity of size()
for std::set is not documented... but if it is it's certainly well hidden
away.
</p>

<p><i>[
Kona (2007): This issue affects all the containers. We'd love to see a
paper dealing with the broad issue. We think that the complexity of the
<tt>size()</tt> member of every container -- except possibly <tt>list</tt> -- should be
O(1). Alan has volunteered to provide wording.
]</i></p>


<p><i>[
Bellevue:
]</i></p>


<blockquote>
Mandating O(1) size will not fly, too many implementations would be
invalidated. Alan to provide wording that toughens wording, but that
does not absolutely mandate O(1).
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We observed that the wording "should" (in note a) has no effect.
Howard prefers that O(1) size be mandated.
It is not clear that this issue can be resolved to everyone's satisfaction,
but Alan will provide wording nonetheless.
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Fixed by paper N2923.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="633"></a>633. Return clause mentions undefined "type()"</h3>
<p><b>Section:</b> 20.8.14.2.5 [func.wrap.func.targ] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2007-02-03 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.8.14.2.5 [func.wrap.func.targ], p4 says:
</p>
<blockquote><p>
<i>Returns:</i> If <tt>type() == typeid(T)</tt>, a pointer to the stored
function target; otherwise a null pointer.
</p></blockquote>

<ol>
<li>
There exists neither a type, a typedef <tt>type</tt>, nor member
function <tt>type()</tt> in class template function nor in the global or
<tt>std</tt> namespace.
</li>
<li>
Assuming that <tt>type</tt> should have been <tt>target_type()</tt>,
this description would lead to false results, if <tt>T = <i>cv</i>
void</tt> due to returns clause 20.8.14.2.5 [func.wrap.func.targ], p1.
</li>
</ol>



<p><b>Proposed resolution:</b></p>
<p>
Change 20.8.14.2.5 [func.wrap.func.targ], p4:
</p>

<blockquote><p>
<i>Returns:</i> If <tt><del>type()</del> <ins>target_type()</ins> == typeid(T) <ins>&amp;&amp; typeid(T) !=
typeid(void)</ins></tt>, a pointer to the stored function target;
otherwise a null pointer.
</p></blockquote>

<p><i>[
Pete: Agreed. It's editorial, so I'll fix it.
]</i></p>







<hr>
<h3><a name="636"></a>636. 26.5.2.3 valarray::operator[]</h3>
<p><b>Section:</b> 26.6.2.3 [valarray.access] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Bo Persson <b>Opened:</b> 2007-02-11 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#valarray.access">issues</a> in [valarray.access].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The signature of the const operator[] has been changed to return a const 
reference.
</p>
<p>
The description in paragraph 1 still says that the operator returns by 
value.
</p>
<p><i>[
Pete recommends editorial fix.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="637"></a>637. [c.math]/10 inconsistent return values</h3>
<p><b>Section:</b> 26.8 [c.math] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Bo Persson <b>Opened:</b> 2007-02-13 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#c.math">issues</a> in [c.math].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
26.8 [c.math], paragraph 10 has long lists of added signatures for float and long double 
functions. All the signatures have float/long double return values, which is 
inconsistent with some of the double functions they are supposed to 
overload.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 26.8 [c.math], paragraph 10,
</p>

<blockquote><pre><del>float</del> <ins>int</ins> ilogb(float);
<del>float</del> <ins>long</ins> lrint(float);
<del>float</del> <ins>long</ins> lround(float);
<del>float</del> <ins>long long</ins> llrint(float);
<del>float</del> <ins>long long</ins> llround(float);

<del>long double</del> <ins>int</ins> ilogb(long double);
<del>long double</del> <ins>long</ins> lrint(long double);
<del>long double</del> <ins>long</ins> lround(long double);
<del>long double</del> <ins>long long</ins> llrint(long double);
<del>long double</del> <ins>long long</ins> llround(long double);
</pre></blockquote>





<hr>
<h3><a name="639"></a>639. Still problems with exceptions during streambuf IO</h3>
<p><b>Section:</b> 27.7.1.2.3 [istream::extractors], 27.7.2.6.3 [ostream.inserters] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2007-02-17 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream::extractors">issues</a> in [istream::extractors].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There already exist two active DR's for the wording of 27.7.1.2.3 [istream::extractors]/13
from 14882:2003(E), namely <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#64">64</a> and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#413">413</a>.
</p>

<p>
Even with these proposed corrections, already maintained in N2134,
I have the feeling, that the current wording does still not properly
handle the "exceptional" situation. The combination of para 14
</p>

<blockquote><p>
"[..] Characters are extracted and inserted until
any of the following occurs:
</p>
<p>
[..]
</p>
<p>
- an exception occurs (in which case the exception is caught)."
</p></blockquote>

<p>
and 15
</p>

<blockquote><p>
"If the function inserts no characters, it calls setstate(failbit),
which
may throw ios_base::failure (27.4.4.3). If it inserted no characters
because it caught an exception thrown while extracting characters
from *this and failbit is on in exceptions() (27.4.4.3), then the
caught
exception is rethrown."
</p></blockquote>

<p>
both in N2134 seems to imply that any exception, which occurs
*after* at least one character has been inserted is caught and lost
for
ever. It seems that even if failbit is on in exceptions() rethrow is
not
allowed due to the wording "If it inserted no characters because it
caught an exception thrown while extracting".
</p>

<p>
Is this behaviour by design?
</p>

<p>
I would like to add that its output counterpart in 27.7.2.6.3 [ostream.inserters]/7-9
(also
N2134) does not demonstrate such an exception-loss-behaviour.
On the other side, I wonder concerning several subtle differences
compared to input::
</p>
<p>
1) Paragraph 8 says at its end:
</p>

<blockquote><p>
"- an exception occurs while getting a character from sb."
</p></blockquote>

<p>
Note that there is nothing mentioned which would imply that such
an exception will be caught compared to 27.7.1.2.3 [istream::extractors]/14.
</p>

<p>
2) Paragraph 9 says:
</p>

<blockquote><p>
"If the function inserts no characters, it calls setstate(failbit)
(which
may throw ios_base::failure (27.4.4.3)). If an exception was thrown
while extracting a character, the function sets failbit in error
state,
and if failbit is on in exceptions() the caught exception is
rethrown."
</p></blockquote>

<p>
The sentence starting with "If an exception was thrown" seems to
imply that such an exception *should* be caught before.
</p>


<p><b>Proposed resolution:</b></p>
<p>
(a) In 27.7.1.2.3 [istream::extractors]/15 (N2134) change the sentence
</p>

<blockquote><p>
If the function inserts no characters, it calls
<tt>setstate(failbit)</tt>, which may throw <tt>ios_base::failure</tt>
(27.4.4.3). If <del>it inserted no characters because it caught an
exception thrown while extracting characters from <tt>*this</tt></del>
<ins>an exception was thrown while extracting a character from
<tt>*this</tt>, the function sets <tt>failbit</tt> in error state,</ins>
and <tt>failbit</tt> is on in <tt>exceptions()</tt> (27.4.4.3), then the
caught exception is rethrown.
</p></blockquote>

<p>
(b) In 27.7.2.6.3 [ostream.inserters]/8 (N2134) change the sentence:
</p>

<blockquote>
<p>
Gets characters from <tt>sb</tt> and inserts them in <tt>*this</tt>.
Characters are read from <tt>sb</tt> and inserted until any of the
following occurs:
</p>
<ul>
<li>end-of-file occurs on the input sequence;</li>
<li>inserting in the output sequence fails (in which case the character to be inserted is not extracted);</li>
<li>an exception occurs while getting a character from <tt>sb</tt> <ins>(in which
case the exception is caught)</ins>.</li>
</ul>
</blockquote>



<p><b>Rationale:</b></p>
This extractor is described as a formatted input function so the
exception behavior is already specified. There is additional behavior
described in this section that applies to the case in which failbit is
set. This doesn't contradict the usual exception behavior for formatted
input functions because that applies to the case in which badbit is set.





<hr>
<h3><a name="641"></a>641. Editorial fix for 27.6.4 (N2134)</h3>
<p><b>Section:</b> 27.7.4 [ext.manip] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2007-02-18 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ext.manip">issues</a> in [ext.manip].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The function <tt>f</tt> in para 4 (27.7.4 [ext.manip]) references an unknown <tt>strm</tt>
in the following line:
</p>

<blockquote><pre>mg.get(Iter(str.rdbuf()), Iter(), intl, strm, err, mon);
</pre></blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 27.7.4 [ext.manip], p4:
</p>

<blockquote><pre>mg.get(Iter(str.rdbuf()), Iter(), intl, str<del>m</del>, err, mon);
</pre></blockquote>

<p><i>[
Oxford:  Editorial.
]</i></p>







<hr>
<h3><a name="642"></a>642. Invalidated fstream footnotes in N2134</h3>
<p><b>Section:</b> 27.9.1.9 [ifstream.members], 27.9.1.13 [ofstream.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2007-02-20 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ifstream.members">issues</a> in [ifstream.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The standard wording of N2134 has extended the 14882:2003(E)
wording for the ifstream/ofstream/fstream open function to fix
a long standing problem, see <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#409">409</a>.
</p>

<p>
Now it's properly written as
</p>

<blockquote><p>
"If that function does not return a null pointer calls clear(),
otherwise
calls setstate(failbit)[..]"
</p></blockquote>

<p>
instead of the previous
</p>

<blockquote><p>
"If that function returns a null pointer, calls setstate(failbit)[..]
</p></blockquote>

<p>
While the old footnotes saying
</p>

<blockquote><p>
"A successful open does not change the error state."
</p></blockquote>

<p>
where correct and important, they are invalid now for ifstream and
ofstream (because clear *does* indeed modify the error state) and
should be removed (Interestingly fstream itself never had these,
although
they where needed for that time).
</p>


<p><b>Proposed resolution:</b></p>
<p>
In 27.9.1.9 [ifstream.members], remove footnote:
</p>

<blockquote><p>
<del><sup>334)</sup> A successful open does not change the error state.</del>
</p></blockquote>

<p>
In 27.9.1.13 [ofstream.members], remove footnote:
</p>

<blockquote><p>
<del><sup>335)</sup> A successful open does not change the error state.</del>
</p></blockquote>






<hr>
<h3><a name="644"></a>644. Possible typos in 'function' description</h3>
<p><b>Section:</b> 20.8.14.2 [func.wrap.func] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Bo Persson <b>Opened:</b> 2007-02-25 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#func.wrap.func">issues</a> in [func.wrap.func].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.8.14.2 [func.wrap.func]
</p>
<p>
The note in paragraph 2 refers to 'undefined void operators', while the
section declares a pair of operators returning bool.
</p>

<p><i>[
Post-Sophia Antipolis:
]</i></p>


<blockquote>
Changed from Pending WP to Open.  This issue was voted to WP at the same time the operators were
changed from private to deleted.  The two issues stepped on each other.  What do we want the return
type of these deleted functions to be?
</blockquote>

<p><i>[
2009-05-02 Daniel adds:
]</i></p>


<blockquote>
<p>
I suggest harmonizing this issue with similar classes. E.g. in
20.9.10.3 [util.smartptr.weak] <tt>bool</tt> return values for
</p>
<blockquote><pre>template &lt;class Y&gt; bool operator&lt;(weak_ptr&lt;Y&gt; const&amp;) const = delete;
template &lt;class Y&gt; bool operator&lt;=(weak_ptr&lt;Y&gt; const&amp;) const = delete;
template &lt;class Y&gt; bool operator&gt;(weak_ptr&lt;Y&gt; const&amp;) const = delete;
template &lt;class Y&gt; bool operator&gt;=(weak_ptr&lt;Y&gt; const&amp;) const = delete;
</pre></blockquote>

<p>
are used and basically all <em>newer</em> provided deleted copy assignment operators
of type <tt>X</tt> use the canonical return type <tt>X&amp;</tt> instead of <tt>void</tt>. Since the note
mentioned in the issue description has now already been changed to
</p>
<blockquote>
deleted overloads close possible hole in the type system
</blockquote>
<p>
it seems to be of even lesser need to perform the change. Therefore
I recommend declaring the issue as NAD.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with Daniel's recommendation.
</p>
<p>
Move to NAD.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 20.8.14.2 [func.wrap.func]
</p>

<blockquote><pre>...
private:
   // 20.8.14.2 [func.wrap.func], undefined operators:
   template&lt;class Function2&gt; <del>bool</del> <ins>void</ins> operator==(const function&lt;Function2&gt;&amp;);
   template&lt;class Function2&gt; <del>bool</del> <ins>void</ins> operator!=(const function&lt;Function2&gt;&amp;);
};
</pre></blockquote>

<p>
Change 20.8.14.2 [func.wrap.func]
</p>

<blockquote><pre>template&lt;class Function2&gt; <del>bool</del> <ins>void</ins> operator==(const function&lt;Function2&gt;&amp;);
template&lt;class Function2&gt; <del>bool</del> <ins>void</ins> operator!=(const function&lt;Function2&gt;&amp;);
</pre></blockquote>





<hr>
<h3><a name="645"></a>645. Missing members in match_results</h3>
<p><b>Section:</b> 28.10 [re.results] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2007-02-26 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#re.results">issues</a> in [re.results].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
According to the description given in 28.10 [re.results]/2 the class template
match_results "shall satisfy the requirements of a Sequence, [..],
except that only operations defined for const-qualified Sequences
are supported".
Comparing the provided operations from 28.10 [re.results]/3 with the
sequence/container tables 80 and 81 one recognizes the following
missing operations:
</p>

<p>
1) The members
</p>

<blockquote><pre>const_iterator rbegin() const;
const_iterator rend() const;
</pre></blockquote>

<p>
should exists because 23.1/10 demands these for containers
(all sequences are containers) which support bidirectional
iterators. Aren't these supported by match_result? This is not
explicitely expressed, but it's somewhat implied by two arguments:
</p>
<p>
(a) Several typedefs delegate to
<tt>iterator_traits&lt;BidirectionalIterator&gt;</tt>.
</p>
<p>
(b) The existence of <tt>const_reference operator[](size_type n) const</tt>
implies even random-access iteration.
I also suggest, that <tt>match_result</tt> should explicitly mention,
which minimum iterator category is supported and if this does
not include random-access the existence of <tt>operator[]</tt> is
somewhat questionable.
</p>
<p>
2) The new "convenience" members
</p>
<blockquote><pre>const_iterator cbegin() const;
const_iterator cend() const;
const_iterator crbegin() const;
const_iterator crend() const;
</pre></blockquote>
<p>
should be added according to tables 80/81.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add the following members to the <tt>match_results</tt> synopsis after <tt>end()</tt> in 28.10 [re.results]
para 3:
</p>

<blockquote><pre>const_iterator cbegin() const; 
const_iterator cend() const;
</pre></blockquote>

<p>
In section 28.10.4 [re.results.acc] change:
</p>

<blockquote>
<pre>const_iterator begin() const;
<ins>const_iterator cbegin() const;</ins>
</pre>
<blockquote>
<p>
-7- <i>Returns:</i> A starting iterator that enumerates over all the sub-expressions stored in <tt>*this</tt>.
</p>
</blockquote>

<pre>const_iterator end() const;
<ins>const_iterator cend() const;</ins>
</pre>
<blockquote>
<p>
-8- <i>Returns:</i> A terminating iterator that enumerates over all the sub-expressions stored in <tt>*this</tt>.
</p>
</blockquote>
</blockquote>



<p><i>[
Kona (2007): Voted to adopt proposed wording in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2409.pdf">N2409</a>
except removing the entry in the table container requirements.  Moved to Review.
]</i></p>


<p><i>[
Bellevue:  Proposed wording now in the WP.
]</i></p>





<hr>
<h3><a name="647"></a>647. Inconsistent regex_search params</h3>
<p><b>Section:</b> 28.11.3 [re.alg.search] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2007-02-26 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
28.11.3 [re.alg.search]/5 declares
</p>

<blockquote><pre>template &lt;class iterator, class charT, class traits&gt;
bool regex_search(iterator first, iterator last,
                  const basic_regex&lt;charT, traits&gt;&amp; e,
                  regex_constants::match_flag_type flags =
                      regex_constants::match_default);
</pre></blockquote>

<p>
where it's not explained, which iterator category
the parameter iterator belongs to. This is inconsistent
to the preceding declaration in the synopsis section
28.4 [re.syn], which says:
</p>

<blockquote><pre>template &lt;class BidirectionalIterator, class charT, class traits&gt;
bool regex_search(BidirectionalIterator first, BidirectionalIterator last,
                  const basic_regex&lt;charT, traits&gt;&amp; e,
                  regex_constants::match_flag_type flags =
                      regex_constants::match_default);
</pre></blockquote>


<p><b>Proposed resolution:</b></p>
<p>
In 28.11.3 [re.alg.search]/5 replace all three occurences of param "iterator" with
"BidirectionalIterator"
</p>

<blockquote><pre>template &lt;class <del>iterator</del> <ins>BidirectionalIterator</ins>, class charT, class traits&gt;
  bool regex_search(<del>iterator</del> <ins>BidirectionalIterator</ins> first, <del>iterator</del> <ins>BidirectionalIterator</ins> last, 
                    const basic_regex&lt;charT, traits&gt;&amp; e, 
                    regex_constants::match_flag_type flags = 
                      regex_constants::match_default);
</pre>
<p>
-6- <i>Effects:</i> Behaves "as if" by constructing an object what of
type <tt>match_results&lt;<del>iterator</del>
<ins>BidirectionalIterator</ins>&gt;</tt> and then returning the result
of <tt>regex_search(first, last, what, e, flags)</tt>.
</p>
</blockquote>


<p><b>Rationale:</b></p>
Applied to working paper while issue was still in New status.





<hr>
<h3><a name="648"></a>648. regex_iterator c'tor needs clarification/editorial fix</h3>
<p><b>Section:</b> 28.12.1.1 [re.regiter.cnstr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2007-03-03 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 28.12.1.1 [re.regiter.cnstr]/2 the effects paragraph starts with:
</p>

<blockquote>
<p>
<i>Effects:</i> Initializes begin and end to point to the beginning and the
end of the target sequence, sets pregex to &amp;re, sets flags to f,[..]
</p></blockquote>

<p>
There are two issues with this description:
</p>

<ol>
<li>
The meaning of very first part of this quote is unclear, because
there is no target sequence provided, instead there are given two
parameters a and b, both of type BidirectionalIterator. The mentioned
part does not explain what a and b represent.
</li>
<li>
There does not exist any parameter f, but instead a parameter
m in the constructor declaration, so this is actually an editorial
fix.
</li>
</ol>


<p><b>Proposed resolution:</b></p>
<p>
In 28.12.1.1 [re.regiter.cnstr]/2 change the above quoted part by
</p>

<blockquote><p>
<i>Effects:</i> Initializes <tt>begin</tt> and <tt>end</tt> to point to
the beginning and the end of the target sequence <ins>designated by the
iterator range <tt>[a, b)</tt></ins>, sets <tt>pregex</tt> to
<tt>&amp;re</tt>, sets <tt>flags</tt> to <tt><del>f</del>
<ins>m</ins></tt>, then calls <tt>regex_search(begin, end, match,
*pregex, flags)</tt>. If this call returns <tt>false</tt> the
constructor sets <tt>*this</tt> to the end-of-sequence iterator.
</p></blockquote>





<hr>
<h3><a name="649"></a>649. Several typos in regex_token_iterator constructors</h3>
<p><b>Section:</b> 28.12.2.1 [re.tokiter.cnstr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2007-03-03 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#re.tokiter.cnstr">issues</a> in [re.tokiter.cnstr].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 28.12.2.1 [re.tokiter.cnstr]/1+2 both the constructor declaration
and the following text shows some obvious typos:
</p>
<p>
1) The third constructor form is written as
</p>
<blockquote><pre>template &lt;std::size_t N&gt;
  regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b, 
                       const regex_type&amp; re, 
                       const int (&amp;submatches)[R], 
                       regex_constants::match_flag_type m = 
                         regex_constants::match_default);
</pre></blockquote>

<p>
where the dimensions of submatches are specified by an
unknown value R, which should be N.
</p>
<p>
2) Paragraph 2 of the same section says in its last sentence:
</p>

<blockquote><p>
The third constructor initializes the member <tt>subs</tt> to hold a
copy of the sequence of integer values pointed to by the iterator range
<tt>[&amp;submatches, &amp;submatches + R)</tt>.
</p></blockquote>

<p>
where again R must be replaced by N.
</p>

<p>
3) Paragraph 3 of the same section says in its first sentence:
</p>

<blockquote><p>
Each constructor then sets <tt>N</tt> to <tt>0</tt>, and
<tt>position</tt> to <tt>position_iterator(a, b, re, f)</tt>.
</p></blockquote>

<p>
where a non-existing parameter "f" is mentioned, which must be
replaced
by the parameter "m".
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 28.12.2.1 [re.tokiter.cnstr]/1:
</p>
<blockquote><pre>template &lt;std::size_t N&gt;
  regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b, 
                       const regex_type&amp; re, 
                       const int (&amp;submatches)[<del>R</del> <ins>N</ins>], 
                       regex_constants::match_flag_type m = 
                         regex_constants::match_default);
</pre></blockquote>

<p>
Change 28.12.2.1 [re.tokiter.cnstr]/2:
</p>

<blockquote><p>
<i>Effects:</i> The first constructor initializes the member
<tt>subs</tt> to hold the single value <tt>submatch</tt>. The second
constructor initializes the member <tt>subs</tt> to hold a copy of the
argument <tt>submatches</tt>. The third constructor initializes the
member <tt>subs</tt> to hold a copy of the sequence of integer values
pointed to by the iterator range <tt>[&amp;submatches, &amp;submatches +
<del>R</del> <ins>N</ins>)</tt>.
</p></blockquote>

<p>
Change 28.12.2.1 [re.tokiter.cnstr]/3:
</p>

<blockquote><p>
Each constructor then sets <tt>N</tt> to <tt>0</tt>, and
<tt>position</tt> to <tt>position_iterator(a, b, re, <del>f</del>
<ins>m</ins>)</tt>. If <tt>position</tt> is not an end-of-sequence
iterator the constructor sets <tt>result</tt> to the address of the
current match. Otherwise if any of the values stored in <tt>subs</tt> is
equal to <tt>-1</tt> the constructor sets <tt>*this</tt> to a suffix
iterator that points to the range <tt>[a, b)</tt>, otherwise the
constructor sets <tt>*this</tt> to an end-of-sequence iterator.
</p></blockquote>






<hr>
<h3><a name="653"></a>653. Library reserved names</h3>
<p><b>Section:</b> 1.2 [intro.refs] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2007-03-08 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#intro.refs">issues</a> in [intro.refs].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
</p>
<blockquote>
<p>
1.2 [intro.refs] Normative references
</p>

<p>
The following standards contain provisions which, through reference in
this text, constitute provisions of this Interna- tional Standard. At
the time of publication, the editions indicated were valid. All
standards are subject to revision, and parties to agreements based on
this International Standard are encouraged to investigate the
possibility of applying the most recent editions of the standards
indicated below. Members of IEC and ISO maintain registers of currently
valid International Standards.
</p>

<ul>
<li>Ecma International, ECMAScript Language Specification, Standard
Ecma-262, third edition, 1999.</li>
<li>ISO/IEC 2382 (all parts), Information technology - Vocabulary</li>
<li>ISO/IEC 9899:1990, Programming languages - C</li>
<li>ISO/IEC 9899/Amd.1:1995, Programming languages - C, AMENDMENT 1: C
Integrity</li>
<li>ISO/IEC 9899:1999, Programming languages - C</li>
<li>ISO/IEC 9899:1999/Cor.1:2001 Programming languages - C</li>
<li>ISO/IEC 9899:1999/Cor.2:2004 Programming languages - C</li>
<li>ISO/IEC 9945:2003, Information Technology-Portable Operating System
Interface (POSIX)</li>
<li>ISO/IEC 10646-1:1993 Information technology - Universal Multiple-Octet
Coded Character Set (UCS) - Part 1: Architecture and Basic Multilingual
Plane</li>
</ul>
</blockquote>

<p>
I'm not sure how many of those reserve naming patterns that might affect
us, but I am equally sure I don't own a copy of any of these to check!
</p>
<p>
The point is to list the reserved naming patterns, rather than the
individual names themselves - although we may want to list C keywords
that are valid identifiers in C++ but likely to cause trouble in shared
headers (e.g. restrict)
</p>

<p><i>[
Kona (2007): Recommend NAD.  No one has identified a specific defect, just the possibility of one.
]</i></p>


<p><i>[
Post-Kona: Alisdair request Open. A good example of the problem was a
discussion of the system error proposal, where it was pointed out an all-caps
identifier starting with a capital E conflicted with reserved macro names for
both Posix and C.  I had absolutely no idea of this rule, and suspect I was
not the only one in the room.<br>
<br>
Resolution will require someone with access to all the listed documents to
research their respective name reservation rules, or people with access to
specific documents add their rules to this issue until the list is complete.
]</i></p>


<p><i>[
Bellevue: Wording is aleady present in various standards, and no-one has come forward with wording.
Suggest a formal paper rather than a defect report is the correct way to proceed.
]</i></p>




<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="656"></a>656. Typo in subtract_with_carry_engine declaration</h3>
<p><b>Section:</b> 26.5.2 [rand.synopsis] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2007-03-08 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.synopsis">issues</a> in [rand.synopsis].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
26.5.2 [rand.synopsis] the header <tt>&lt;random&gt;</tt> synopsis
contains an unreasonable closing curly brace inside the
<tt>subtract_with_carry_engine</tt> declaration.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change the current declaration in 26.5.2 [rand.synopsis]
</p>

<blockquote><pre>template &lt;class UIntType, size_t w<del>}</del>, size_t s, size_t r&gt;
class subtract_with_carry_engine;
</pre></blockquote>


<p><i>[
Pete: Recommends editorial.
]</i></p>





<hr>
<h3><a name="657"></a>657. unclear requirement about header inclusion</h3>
<p><b>Section:</b> 17.6.2.2 [using.headers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Gennaro Prota <b>Opened:</b> 2007-03-14 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
17.6.2.2 [using.headers] states:
</p>

<blockquote><p>
A translation unit shall include a header only outside of any
external declaration or definition, [...]
</p></blockquote>

<p>
I see three problems with this requirement:
</p>

<ol type="a">
<li><p>The C++ standard doesn't define what an "external declaration" or
an "external definition" are (incidentally the C99 standard does, and
has a sentence very similar to the above regarding header inclusion).
</p><p>
I think the intent is that the #include directive shall lexically
appear outside *any* declaration; instead, when the issue was pointed
out on comp.std.c++ at least one poster interpreted "external
declaration" as "declaration of an identifier with external linkage".
If this were the correct interpretation, then the two inclusions below
would be legal:
</p>
<blockquote><pre>  // at global scope
  static void f()
  {
# include &lt;cstddef&gt;
  }

  static void g()
  {
# include &lt;stddef.h&gt;
  }
</pre></blockquote>
<p>
(note that while the first example is unlikely to compile correctly,
the second one may well do)
</p></li>

<li><p>as the sentence stands, violations will require a diagnostic; is
this the intent? It was pointed out on comp.std.c++ (by several
posters) that at least one way to ensure a diagnostic exists:
</p>
<blockquote><p>
   [If there is an actual file for each header,] one simple way
   to implement this would be to insert a reserved identifier
   such as __begin_header  at the start of each standard header.
   This reserved identifier would be ignored for all other
   purposes, except that, at the appropriate point in phase 7, if
   it is found inside an external definition, a diagnostic is
   generated. There's many other similar ways to achieve the same
   effect.
   </p>
<p>                                 --James Kuyper, on comp.std.c++
</p></blockquote></li>

<li><p>is the term "header" meant to be limited to standard headers?
Clause 17 is all about the library, but still the general question is
interesting and affects one of the points in the explicit namespaces
proposal (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1691.html">n1691</a>):
</p>
<blockquote><p>
    Those seeking to conveniently enable argument-dependent
    lookups for all operators within an explicit namespace
    could easily create a header file that does so:
</p><pre>    namespace mymath::
    {
        #include "using_ops.hpp"
    }
</pre></blockquote>
</li>
</ol>


<p><b>Proposed resolution:</b></p>
<p>
</p>


<p><b>Rationale:</b></p>
We believe that the existing language does not cause any real confusion
and any new formulation of the rules that we could come up with are
unlikely to be better than what's already in the standard.





<hr>
<h3><a name="662"></a>662. Inconsistent handling of incorrectly-placed thousands separators</h3>
<p><b>Section:</b> 22.4.2.1.2 [facet.num.get.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Cosmin Truta <b>Opened:</b> 2007-04-05 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#facet.num.get.virtuals">issues</a> in [facet.num.get.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
From Section 22.4.2.1.2 [facet.num.get.virtuals], paragraphs 11 and 12, it is implied
that the value read from a stream must be stored
even if the placement of thousands separators does not conform to the
<code>grouping()</code> specification from the <code>numpunct</code> facet.
Since incorrectly-placed thousands separators are flagged as an extraction
failure (by the means of <code>failbit</code>), we believe it is better not
to store the value. A consistent strategy, in which any kind of extraction
failure leaves the input item intact, is conceptually cleaner, is able to avoid
corner-case traps, and is also more understandable from the programmer's point
of view.
</p>
<p>
Here is a quote from <i>"The C++ Programming Language (Special Edition)"</i>
by B.&nbsp;Stroustrup (Section&nbsp;D.4.2.3, pg.&nbsp;897):
</p>
<blockquote><p>
<i>"If a value of the desired type could not be read, failbit is set in r.
[...] An input operator will use r to determine how to set the state of its
stream. If no error was encountered, the value read is assigned through v;
otherwise, v is left unchanged."</i>
</p></blockquote>
<p>
This statement implies that <code>rdstate()</code> alone is sufficient to
determine whether an extracted value is to be assigned to the input item
<i>val</i> passed to <code>do_get</code>. However, this is in disagreement
with the current C++ Standard. The above-mentioned assumption is true in all
cases, except when there are mismatches in digit grouping. In the latter case,
the parsed value is assigned to <i>val</i>, and, at the same time, <i>err</i>
is assigned to <code>ios_base::failbit</code> (essentially "lying" about the
success of the operation). Is this intentional? The current behavior raises
both consistency and usability concerns.
</p>
<p>
Although digit grouping is outside the scope of <code>scanf</code> (on which
the virtual methods of <code>num_get</code> are based), handling of grouping
should be consistent with the overall behavior of scanf. The specification of
<code>scanf</code> makes a distinction between input failures and matching
failures, and yet both kinds of failures have no effect on the input items
passed to <code>scanf</code>. A mismatch in digit grouping logically falls in
the category of matching failures, and it would be more consistent, and less
surprising to the user, to leave the input item intact whenever a failure is
being signaled.
</p>
<p>
The extraction of <code>bool</code> is another example outside the scope of
<code>scanf</code>, and yet consistent, even in the event of a successful
extraction of a <code>long</code> but a failed conversion from
<code>long</code> to <code>bool</code>.
</p>
<p>
Inconsistency is further aggravated by the fact that, when failbit is set,
subsequent extraction operations are no-ops until <code>failbit</code> is
explicitly cleared. Assuming that there is no explicit handling of
<code>rdstate()</code> (as in <code>cin&gt;&gt;i&gt;&gt;j</code>) it is
counter-intuitive to be able to extract an integer with mismatched digit
grouping, but to be unable to extract another, properly-formatted integer
that immediately follows.
</p>
<p>
Moreover, setting <code>failbit</code>, and selectively assigning a value to
the input item, raises usability problems. Either the strategy of
<code>scanf</code> (when there is no extracted value in case of failure), or
the strategy of the <code>strtol</code> family (when there is always an
extracted value, and there are well-defined defaults in case of a failure) are
easy to understand and easy to use. On the other hand, if <code>failbit</code>
alone cannot consistently make a difference between a failed extraction, and a
successful but not-quite-correct extraction whose output happens to be the same
as the previous value, the programmer must resort to implementation tricks.
Consider the following example:
</p>
<pre>    int i = old_i;
    cin &gt;&gt; i;
    if (cin.fail())
        // can the value of i be trusted?
        // what does it mean if i == old_i?
        // ...
</pre>
<p>
Last but not least, the current behvaior is not only confusing to the casual
reader, but it has also been confusing to some book authors. Besides
Stroustrup's book, other books (e.g. "Standard C++ IOStreams and Locales" by
Langer and Kreft) are describing the same mistaken assumption. Although books
are not to be used instead of the standard reference, the readers of these
books, as well as the people who are generally familiar to <code>scanf</code>,
are even more likely to misinterpret the standard, and expect the input items
to remain intact when a failure occurs.
</p>


<p><b>Proposed resolution:</b></p>

<p>
Change 22.4.2.1.2 [facet.num.get.virtuals]:
</p>

<blockquote>
<p>
<b>Stage 3:</b> The result of stage 2 processing can be one of
</p>
<ul>
<li>A sequence of <code>chars</code> has been accumulated in stage 2 that is converted (according to the rules of <code>scanf</code>) to a value of the type of <code><i>val</i></code>.  <del>This value is stored in <code><i>val</i></code> and <code>ios_base::goodbit</code> is stored in <code><i>err</i></code>.</del></li>

<li>The sequence of <code>chars</code> accumulated in stage 2 would have caused <code>scanf</code> to report an input failure. <code>ios_base::failbit</code> is assigned to <code><i>err</i></code>.</li>
</ul>
<p>
<ins>In the first case,</ins> <del>D</del><ins>d</ins>igit grouping is checked.  That is, the positions of discarded separators is examined for consistency with <code>use_facet&lt;numpunct&lt;charT&gt; &gt;(<i>loc</i>).grouping()</code>.  If they are not consistent then <code>ios_base::failbit</code> is assigned to <code><i>err</i></code>.  <ins>Otherwise, the value that was converted in stage 2 is stored in <code><i>val</i></code> and <code>ios_base::goodbit</code> is stored in <code><i>err</i></code>.</ins>
</p>
</blockquote>


<p><b>Rationale:</b></p>
post-Toronto: Changed from New to NAD at the request of the author.  The preferred solution of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2327.pdf">N2327</a>
makes this resolution obsolete.





<hr>
<h3><a name="663"></a>663. Complexity Requirements</h3>
<p><b>Section:</b> 17.5.1.4 [structure.specifications] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Thomas Plum <b>Opened:</b> 2007-04-16 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#structure.specifications">issues</a> in [structure.specifications].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
17.5.1.4 [structure.specifications] para 5 says
</p>

<blockquote><p>
-5- Complexity requirements specified in the library
clauses are upper bounds, and implementations that provide better
complexity guarantees satisfy the requirements.
</p></blockquote>

<p>
The following
objection has been raised:
</p>

<blockquote><p>
The library clauses suggest general
guidelines regarding complexity, but we have been unable to discover
any absolute hard-and-fast formulae for these requirements. Unless
or until the Library group standardizes specific hard-and-fast
formulae, we regard all the complexity requirements as subject to a
"fudge factor" without any intrinsic upper bound.
</p></blockquote>

<p>
[Plum ref
_23213Y31 etc]
</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>


<p><b>Rationale:</b></p>
Kona (2007): No specific instances of underspecification have been
identified, and big-O notation always involves constant factors.





<hr>
<h3><a name="667"></a>667. <tt>money_get</tt>'s widened minus sign</h3>
<p><b>Section:</b> 22.4.6.1.2 [locale.money.get.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Thomas Plum <b>Opened:</b> 2007-04-16 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.money.get.virtuals">issues</a> in [locale.money.get.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
22.4.6.1.2 [locale.money.get.virtuals], para 1 says:
</p>

<blockquote><p>
The result is returned as an integral value
stored in <tt>units</tt> or as a sequence of digits possibly preceded by a
minus sign (as produced by <tt>ct.widen(c)</tt> where <tt>c</tt> is '-' or in the range
from '0' through '9', inclusive) stored in <tt>digits</tt>.
</p></blockquote>

<p>
The following
objection has been raised:
</p>

<blockquote><p>
Some implementations interpret this to mean that a facet derived from
<tt>ctype&lt;wchar_t&gt;</tt> can provide its own member <tt>do_widen(char)</tt>
which produces e.g. <tt>L'@'</tt> for the "widened" minus sign, and that the
<tt>'@'</tt> symbol will appear in the resulting sequence of digits.  Other
implementations have assumed that one or more places in the standard permit the
implementation to "hard-wire" <tt>L'-'</tt> as the "widened" minus sign.  Are
both interpretations permissible, or only  one?
</p></blockquote>

<p>
[Plum ref _222612Y14]
</p>

<p>
Furthermore: if <tt>ct.widen('9')</tt> produces <tt>L'X'</tt> (a non-digit), does a
parse fail if a <tt>'9'</tt> appears in the subject string? [Plum ref _22263Y33]
</p>

<p><i>[
Kona (2007): Bill and Dietmar to provide proposed wording.
]</i></p>


<p><i>[
post Bellevue: Bill adds:
]</i></p>


<blockquote>
The Standard is clear that the minus sign stored in <tt>digits</tt> is <tt>ct.widen('-')</tt>.
The subject string must contain characters <tt>c</tt> in the set <tt>[-0123456789]</tt>
which are translated by <tt>ct.widen(c)</tt> calls before being stored in <tt>digits</tt>;
the widened characters are not relevant to the parsing of the subject string.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with Bill's comment above,
in line with the first of the interpretations offered in the issue.
Move to NAD.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="668"></a>668. <tt>money_get</tt>'s empty minus sign</h3>
<p><b>Section:</b> 22.4.6.1.2 [locale.money.get.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Thomas Plum <b>Opened:</b> 2007-04-16 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.money.get.virtuals">issues</a> in [locale.money.get.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
22.4.6.1.2 [locale.money.get.virtuals], para 3 says:
</p>

<blockquote><p>
If <tt>pos</tt> or <tt>neg</tt> is empty, the sign component is
optional, and if no sign is detected, the result is given the sign
that corresponds to the source of the empty string.
</p></blockquote>

<p>
The following objection has been raised:
</p>

<blockquote><p>
A <tt>negative_sign</tt> of "" means "there is no
way to write a negative sign" not "any null sequence is a negative
sign, so it's always there when you look for it".
</p></blockquote>

<p>
[Plum ref _222612Y32]
</p>

<p><i>[
Kona (2007): Bill to provide proposed wording and interpretation of existing wording.
]</i></p>


<p>
Related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#669">669</a>.
</p>

<p><i>[
2009-05-17 Howard adds:
]</i></p>


<blockquote>
<p>
I disagree that a <tt>negative_sign</tt> of "" means "there is no way to
write a negative sign".  The meaning requires the sentences of 22.4.6.1.2 [locale.money.get.virtuals] p3 following that quoted above to be
taken into account:
</p>

<blockquote>
-3- ... If <tt>pos</tt> or <tt>neg</tt> is empty, the sign component is
optional, and if no sign is detected, the result is given the sign that
corresponds to the source of the empty string. Otherwise, the character
in the indicated position must match the first character of <tt>pos</tt>
or <tt>neg</tt>, and the result is given the corresponding sign. If the
first character of <tt>pos</tt> is equal to the first character of
<tt>neg</tt>, or if both strings are empty, the result is given a
positive sign.
</blockquote>

<p>
So a <tt>negative_sign</tt> of "" means "there is no way to write a
negative sign" only when <tt>positive_sign</tt> is also "".  However
when <tt>negative_sign</tt> is "" and <tt>postive_sign.size() &gt;
0</tt>, then one writes a negative value by not writing the
<tt>postive_sign</tt> in the position indicated by
<tt>money_base::sign</tt>.
For example:
</p>

<blockquote><pre>pattern = {symbol, sign, value, none}
positive_sign = "+"
negative_sign = ""
$123   // a negative value, using optional sign
$+123  // a positive value
$-123  // a parse error
</pre></blockquote>

<p>
And:
</p>

<blockquote><pre>pattern = {symbol, sign, value, none}
positive_sign = ""
negative_sign = ""
$123   // a positive value, no sign possible
$+123  // a parse error
$-123  // a parse error
</pre></blockquote>


<p>
And (regarding <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#669">669</a>):
</p>

<blockquote><pre>pattern = {symbol, sign, value, none}
positive_sign = "-"
negative_sign = "-"
$123   // a parse error, sign is mandatory
$+123  // a parse error
$-123  // a positive value
</pre></blockquote>


<p>
The text seems both unambiguous and clear to me.  I recommend NAD for
both this issue and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#669">669</a>.  However I would have no
objection to adding examples such as those above.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
This discussion applies equally to issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#669">669</a> (q.v.).
Howard has added examples above,
and recommends either NAD or a resolution that adds his (or similar) examples
to the Working Paper.
</p>
<p>
Alan would like to rewrite paragraph 3.
</p>
<p>
We recommend moving to NAD.
Anyone who feels strongly about adding the examples
is invited to submit corresponding wording.
We further recommend issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#669">669</a> be handled identically.
</p>
</blockquote>

<p><i>[
2009-07-14 Alan reopens with improved wording.
]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
No consensus for closing as NAD.  Leave in Review.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD.  Agreed that the original assessment as NAD was correct.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 22.4.6.1.2 [locale.money.get.virtuals] p3:
</p>

<blockquote>
-3- <del>If the first character (if any) in the string pos returned by
<tt>mp.positive_sign()</tt> or the string <tt>neg</tt> returned by
<tt>mp.negative_sign()</tt> is recognized in the position indicated by
sign in the format pattern, it is consumed and any remaining characters
in the string are required after all the other format components.
[<i>Example:</i> If <tt>showbase</tt> is off, then for a <tt>neg</tt>
value of "()" and a currency symbol of "L", in "(100 L)" the "L" is
consumed; but if <tt>neg</tt> is "-", the "L" in "-100 L" is not
consumed. -- <i>end example</i>] If <tt>pos</tt> or <tt>neg</tt> is
empty, the sign component is optional, and if no sign is detected, the
result is given the sign that corresponds to the source of the empty
string. Otherwise, the character in the indicated position must match
the first character of <tt>pos</tt> or <tt>neg</tt>, and the result is
given the corresponding sign. If the first character of <tt>pos</tt> is
equal to the first character of <tt>neg</tt>, or if both strings are
empty, the result is given a positive sign.</del>

<ins>The sign pattern strings <tt>pos</tt> and <tt>neg</tt> are returned by
<tt>mp.positive_sign()</tt> and <tt>mp.negative_sign()</tt> respectively. A sign pattern
is matched if its first character is recognized in <tt>s</tt> in the position
indicated by <tt>sign</tt> in the format pattern, or if the pattern is empty and
there is no sign recognized in <tt>s</tt>. A match is required to occur. If both
patterns are matched, the result is given a positive sign, otherwise the
result is given the sign corresponding to the matched pattern. 
If the pattern contains more than one character, the characters after the first 
must be matched in <tt>s</tt> after all other format components. 
If any sign
characters are matched, <tt>s</tt> is consumed up to and including those characters.
[<i>Example:</i> If <tt>showbase</tt> is off, then for a <tt>neg</tt>
value of "<tt>()</tt>" and a currency symbol of "<tt>L</tt>", in
"<tt>(100 L)</tt>" the entire string is consumed; but for a <tt>neg</tt>
value of "<tt>-</tt>", in "<tt>-100 L</tt>", the string is consumed
through the second "<tt>0</tt>" (the space and "<tt>L</tt>" are not consumed).  <i>end
example</i>] </ins>
</blockquote>





<hr>
<h3><a name="669"></a>669. Equivalent postive and negative signs in <tt>money_get</tt></h3>
<p><b>Section:</b> 22.4.6.1.2 [locale.money.get.virtuals] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Thomas Plum <b>Opened:</b> 2007-04-16 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#locale.money.get.virtuals">issues</a> in [locale.money.get.virtuals].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
22.4.6.1.2 [locale.money.get.virtuals], para 3 sentence 4 says:
</p>

<blockquote><p>
If the first character of <tt>pos</tt> is equal to the first character of <tt>neg</tt>, 
or if both strings are empty, the result is given a positive sign.
</p></blockquote>

<p>
One interpretation is that an input sequence must match either the
positive pattern or the negative pattern, and then in either event it
is interpreted as positive.  The following objections has been raised:
</p>

<blockquote><p>
The input can successfully match only a positive sign, so the negative
pattern is an unsuccessful match.
</p></blockquote>

<p>
[Plum ref _222612Y34, 222612Y51b]
</p>

<p><i>[
Bill to provide proposed wording and interpretation of existing wording.
]</i></p>


<p><i>[
2009-05-17 See Howard's comments in related issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#668">668</a>.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
This discussion applies equally to issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#668">668</a> (q.v.).
Howard has added examples there,
and recommends either NAD or a resolution that adds his (or similar) examples
to the Working Paper.
</p>
<p>
We recommend moving to NAD.
Anyone who feels strongly about adding the examples
is invited to submit corresponding wording.
We further recommend issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#668">668</a> be handled identically.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="670"></a>670. <tt>money_base::pattern</tt> and <tt>space</tt></h3>
<p><b>Section:</b> 22.4.6.3 [locale.moneypunct] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Thomas Plum <b>Opened:</b> 2007-04-16 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#836">836</a></p>
<p><b>Discussion:</b></p>
<p>
22.4.6.3 [locale.moneypunct], para 2 says:
</p>

<blockquote><p>
The value <tt>space</tt> indicates that at least one space is required at 
that position.
</p></blockquote>

<p>
The following objection has been raised:
</p>

<blockquote><p>
Whitespace is optional when matching space. (See 22.4.6.1.2 [locale.money.get.virtuals], para 2.)
</p></blockquote>

<p>
[Plum ref _22263Y22]
</p>

<p><i>[
Kona (2007): Bill to provide proposed wording. We agree that C++03 is
ambiguous, and that we want C++0X to say "space" means 0 or more
whitespace characters on input.
]</i></p>




<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="683"></a>683. regex_token_iterator summary error</h3>
<p><b>Section:</b> 28.12.2 [re.tokiter] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Eric Niebler <b>Opened:</b> 2007-06-02 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#re.tokiter">issues</a> in [re.tokiter].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
28.12.2 [re.tokiter], p3 says:
</p>
<blockquote>
<p>
After it is constructed, the iterator finds and stores a value
<tt>match_results&lt;BidirectionalIterator&gt;</tt> position and sets the
internal count <tt>N</tt> to zero.
</p>
</blockquote>

<p>
Should read:
</p>

<blockquote>
<p>
After it is constructed, the iterator finds and stores a value
<tt><del>match_results</del><ins>regex_iterator</ins>&lt;BidirectionalIterator<ins>, charT, traits</ins>&gt;</tt>
position and sets the internal count <tt>N</tt> to zero.
</p>
</blockquote>

<p><i>[
John adds:
]</i></p>


<blockquote><p>
Yep, looks like a typo/administrative fix to me.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="684"></a>684. Unclear which members of match_results should be used in comparison</h3>
<p><b>Section:</b> 28.10 [re.results] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Nozomu Katoo <b>Opened:</b> 2007-05-27 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#re.results">issues</a> in [re.results].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 28.4 [re.syn] of N2284, two template functions 
are declared here: 
</p>
<blockquote><pre>// 28.10, class template match_results: 
  &lt;<i>snip</i>&gt;
// match_results comparisons 
  template &lt;class BidirectionalIterator, class Allocator&gt; 
    bool operator== (const match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m1, 
                     const match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m2); 
  template &lt;class BidirectionalIterator, class Allocator&gt; 
    bool operator!= (const match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m1, 
                     const match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m2); 

// 28.10.6, match_results swap:
</pre></blockquote>

<p>
But the details of these two bool operator functions (i.e., which members of
<tt>match_results</tt> should be used in comparison) are not described in any
following sections.
</p>

<p><i>[
John adds:
]</i></p>


<blockquote><p>
That looks like a bug: <tt>operator==</tt> should return <tt>true</tt> only if
the two objects refer to the same match - ie if one object was constructed as a
copy of the other.
</p></blockquote>

<p><i>[
Kona (2007): Bill and Pete to add minor wording to that proposed in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2409.pdf">N2409</a>.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
Add a new section after 28.10.7 [re.results.swap], which reads:
</p>
<p>
28.10.7 match_results non-member functions.
</p>

<blockquote>
<pre>template&lt;class BidirectionalIterator, class Allocator&gt; 
  bool operator==(const match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m1, 
                  const match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m2);
</pre>
<blockquote>
<p>
<i>Returns:</i> <tt>true</tt> only if the two objects refer to the same match.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>template&lt;class BidirectionalIterator, class Allocator&gt; 
  bool operator!=(const match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m1, 
                  const match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m2);
</pre>
<blockquote>
<p>
<i>Returns:</i> <tt>!(m1 == m2)</tt>.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>template&lt;class BidirectionalIterator, class Allocator&gt; 
  void swap(match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m1, 
            match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m2);
</pre>
<blockquote>
<p>
<i>Returns:</i> <tt>m1.swap(m2)</tt>.
</p>
</blockquote>
</blockquote>


<p><i>[
Bellevue:  Proposed wording now in WP.
]</i></p>





<hr>
<h3><a name="686"></a>686. Unique_ptr and shared_ptr fail to specify non-convertibility to int for unspecified-bool-type</h3>
<p><b>Section:</b> 20.9.9.2.4 [unique.ptr.single.observers], 20.9.10.2.5 [util.smartptr.shared.obs] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2007-06-14 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The standard library uses the <tt>operator <i>unspecified-bool-type</i>() const</tt> idiom in
five places. In three of those places (20.8.14.2.3 [func.wrap.func.cap], function capacity 
for example) the returned value is constrained to disallow
unintended conversions to int. The standardese is
</p>
<blockquote><p>
The return type shall not be convertible to <tt>int</tt>.
</p></blockquote>
<p>
This constraint is omitted for <tt>unique_ptr</tt> and <tt>shared_ptr</tt>. It should be added for those.
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
Close as NAD. Accepting paper
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2435.htm">N2435</a>
makes it irrelevant.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
To the <i>Returns</i> paragraph for <tt>operator <i>unspecified-bool-type</i>()
const</tt> of 20.9.9.2.4 [unique.ptr.single.observers] paragraph 11 and 20.9.10.2.5 [util.smartptr.shared.obs] paragraph 16, add the sentence:
</p>
<blockquote><p>
The return type shall not be convertible to <tt>int</tt>.
</p></blockquote>


<p><i>[
Kona (2007): Uncertain if <tt>nullptr</tt> will address this issue.
]</i></p>





<hr>
<h3><a name="690"></a>690. abs(long long) should return long long</h3>
<p><b>Section:</b> 26.8 [c.math] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Niels Dekker <b>Opened:</b> 2007-06-10 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#c.math">issues</a> in [c.math].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Quoting the latest draft (n2135), 26.8 [c.math]: 
</p>

<blockquote>
<p>
The added signatures are:
</p>
<blockquote><pre>long abs(long); // labs()
long abs(long long); // llabs()
</pre></blockquote>
</blockquote>
<p>
Shouldn't <tt>abs(long long)</tt> have <tt>long long</tt> as return type?
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 26.8 [c.math]: 
</p>
<blockquote><pre><ins>long </ins>long abs(long long); // llabs()
</pre></blockquote>


<p><b>Rationale:</b></p>
Had already been fixed in the WP by the time the LWG reviewed this.





<hr>
<h3><a name="701"></a>701. assoc laguerre poly's</h3>
<p><b>Section:</b> TR1 5.2.1.1 [tr.num.sf.Lnm] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Christopher Crawford <b>Opened:</b> 2007-06-30 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I see that the definition the associated Laguerre
polynomials TR1 5.2.1.1 [tr.num.sf.Lnm] has been corrected since
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1687.pdf">N1687</a>.
However, the draft standard only specifies ranks of integer value <tt>m</tt>,
while the associated Laguerre polynomials are actually valid for real
values of <tt>m &gt; -1</tt>.  In the case of non-integer values of <tt>m</tt>, the
definition  <tt><i>L</i><sub>n</sub><sup>(m)</sup> = (1/n!)e<sup>x</sup>x<sup>-m</sup> (d/dx)<sup>n</sup> (e<sup>-x</sup>x<sup>m+n</sup>)</tt>
must be used, which also holds for integer values of <tt>m</tt>.  See
Abramowitz &amp; Stegun, 22.11.6 for the general case, and 22.5.16-17 for
the integer case.  In fact fractional values are most commonly used in
physics, for example to <tt>m = +/- 1/2</tt> to describe the harmonic
oscillator in 1 dimension, and <tt>1/2, 3/2, 5/2, ...</tt> in 3
dimensions.
</p>
<p>
If I am correct, the calculation of the more general case is no
more difficult, and is in fact the function implemented in the GNU
Scientific Library.  I would urge you to consider upgrading the 
standard, either adding extra functions for real <tt>m</tt> or switching the
current ones to <tt>double</tt>.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We understand the issue, and have opted not to extend as recommended.
</p>
<p>
Move to NAD.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="702"></a>702. Restriction in associated Legendre functions</h3>
<p><b>Section:</b> TR1 5.2.1.2 [tr.num.sf.Plm] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Christopher Crawford <b>Opened:</b> 2007-06-30 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
One other small thing, in TR1 5.2.1.2 [tr.num.sf.Plm], the restriction should  be
<tt>|x| &lt;= 1</tt>, not <tt>x &gt;= 0</tt>.</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
The error has been corrected in the pending IS.
</p>
<p>
Move to NAD.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="707"></a>707. null pointer constant for <tt>exception_ptr</tt></h3>
<p><b>Section:</b> 18.8.5 [propagation] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Jens Maurer <b>Opened:</b> 2007-07-20 <b>Last modified:</b> 2010-10-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#propagation">active issues</a> in [propagation].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#propagation">issues</a> in [propagation].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
From the Toronto Core wiki:
</p>

<p>
What do you mean by "null pointer constant"? How do you guarantee that
<tt>exception_ptr() == 1</tt> doesn't work?  Do you even want to prevent that?
What's the semantics?  What about <tt>void *p = 0; exception_ptr() == p</tt>?
Maybe disallow those in the interface, but how do you do that with
portable C++? Could specify just "make it work".
</p>

<p>
Peter's response:
</p>

<p>
null pointer constant as defined in 4.10 [conv.ptr]. Intent is "just make it
work", can be implemented as assignment operator taking a unique pointer
to member, as in the unspecified bool type idiom.
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
Original implementation was possible using the "unspecified-null-pointer" idiom, similar to unspecified-bool.
</p>
<p>
Even simpler now with nullptr_t.
</p>
<p>
NAD Rationale : null pointer constant is a perfectly defined term, and
while API is clearly implementable there is no need to spell out
implementation details.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="708"></a>708. Locales need to be per thread and updated for POSIX changes</h3>
<p><b>Section:</b> 22 [localization] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Future">NAD Future</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2007-07-28 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#localization">issues</a> in [localization].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The POSIX "Extended API Set Part 4,"
</p>
<blockquote><p>
<a href="http://www.opengroup.org/sib/details.tpl?id=C065">http://www.opengroup.org/sib/details.tpl?id=C065</a>
</p></blockquote>
<p>
introduces extensions to the C locale mechanism that
allow multiple concurrent locales to be used in the same application
by introducing a type <tt>locale_t</tt> that is very similar to
<tt>std::locale</tt>, and a number of <tt>_l</tt> functions that make use of it.
</p>
<p>
The global locale (set by setlocale) is now specified to be per-
process. If a thread does not call <tt>uselocale</tt>, the global locale is
in effect for that thread. It can install a per-thread locale by
using <tt>uselocale</tt>.
</p>
<p>
There is also a nice <tt>querylocale</tt> mechanism by which one can obtain
the name (such as "de_DE") for a specific <tt>facet</tt>, even for combined
locales, with no <tt>std::locale</tt> equivalent.
</p>
<p>
<tt>std::locale</tt> should be harmonized with the new POSIX <tt>locale_t</tt>
mechanism and provide equivalents for <tt>uselocale</tt> and <tt>querylocale</tt>.
</p>

<p><i>[
Kona (2007): Bill and Nick to provide wording.
]</i></p>


<p><i>[
San Francisco: Bill and Nick still intend to provide wording, but this
is a part of the task to be addressed by the group that will look into
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#860">860</a>.
]</i></p>


<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
<p>
It's our intention to stay in sync with WG14. If WG14 makes a decision
that requires a change in WG21 the issue will be reopened.
</p>
<p>
Move to NAD Future.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="717"></a>717. Incomplete <tt>valarray::operator[]</tt> specification in [valarray.access]</h3>
<p><b>Section:</b> 26.6.2.3 [valarray.access] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2007-08-27 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#valarray.access">issues</a> in [valarray.access].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Since the return type of <tt>valarray</tt>'s <tt>operator[] const</tt> overload has been
changed to <tt>const T&amp;</tt> as described in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#389">389</a> several paragraphs of
the section 26.6.2.3 [valarray.access] are now
incompletely
specified, because many requirements and guarantees should now also
apply to the const overload. Most notably, the address and reference
guarantees should be extended to the const overload case.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 26.6.2.3 [valarray.access]:
</p>

<blockquote>
<p>
-1- <del>When applied to a constant array, the subscript operator returns a
reference to the corresponding element of the array. When applied to a
non-constant array, t</del><ins>T</ins>he subscript operator returns a
reference to the corresponding element of the array.
</p>

<p>
-3- The expression <tt>&amp;a[i+j] == &amp;a[i] + j</tt> evaluates as <tt>true</tt> for all <tt>size_t i</tt>
and <tt>size_t j</tt> such that <tt>i+j</tt> is less 
than the length of the <del>non-constant</del> array <tt>a</tt>.
</p>

<p>
-4- Likewise, the expression <tt>&amp;a[i] != &amp;b[j]</tt> evaluates
as <tt>true</tt> for any two <del>non-constant</del> arrays <tt>a</tt> and
<tt>b</tt> and for any <tt>size_t i</tt> and <tt>size_t j</tt> such that
<tt>i</tt> is less than the length of <tt>a</tt> and <tt>j</tt> is less
than the length of <tt>b</tt>. This property indicates an absence of
aliasing and may be used to advantage by optimizing
compilers.<sup>281)</sup>
</p>

<p>
-5- The reference returned by the subscript operator for a<ins>n</ins> <del>non-constant</del> array is guaranteed to be valid until
the member function <tt>resize(size_t, T)</tt> (26.5.2.7) is called for that array or until the lifetime 
of that array ends, whichever happens first.
</p>

</blockquote>






<hr>
<h3><a name="718"></a>718. <tt>basic_string</tt> is not a sequence</h3>
<p><b>Section:</b> 21.4 [basic.string] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Bo Persson <b>Opened:</b> 2007-08-18 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#basic.string">issues</a> in [basic.string].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Paragraph 21.4 [basic.string]/3 states:
</p>

<blockquote>
<p>
The class template <tt>basic_string</tt> conforms to the requirements for a 
Sequence (23.1.1) and for a Reversible Container (23.1).
</p>
</blockquote>

<p>
First of all, 23.2.3 [sequence.reqmts] is no longer "Sequence" but "Sequence container". 
Secondly, after the resent changes to containers (<tt>emplace</tt>, <tt>push_back</tt>, 
<tt>const_iterator</tt> parameters to <tt>insert</tt> and <tt>erase</tt>), <tt>basic_string</tt> is not 
even close to conform to the current requirements.
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
<ul>
<li>emplace, for example, may not make sense for strings. Is also likely suboptimal</li>
<li>with concepts do we need to maintain string as sequence container?</li>
<li>One approach might be to say something like: string is a sequence except it doesn't have these functions</li>
</ul>
<ul>
<li>basic_string already has push_back</li>
<li>const_iterator parameters to insert and erase should be added to basic_string</li>
<li>this leaves emplace to handle -- we have the following options:
<ul>
<li>option 1: add it to string even though it's optional</li>
<li>option 2: make emplace optional to sequences (move from table 89 to 90)</li>
<li>option 3: say string not sequence (the proposal),</li>
<li>option 4: add an exception to basic string wording.</li>
</ul>
</li>
</ul>
General consensus is to suggest option 2.
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
Move to NAD Editorial
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Remove this sentence, in recognition of the fact that <tt>basic_string</tt> is 
not just a <tt>vector</tt>-light for literal types, but something quite 
different, a string abstraction in its own right.
</p>





<hr>
<h3><a name="721"></a>721. <tt>wstring_convert</tt> inconsistensies</h3>
<p><b>Section:</b> 22.3.3.2.2 [conversions.string] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Bo Persson <b>Opened:</b> 2007-08-27 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#conversions.string">issues</a> in [conversions.string].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Paragraph 3 says that the <tt>Codecvt</tt> template parameter shall meet the 
requirements of <tt>std::codecvt</tt>, even though <tt>std::codecvt</tt> itself cannot 
be used (because of a protected destructor).
</p>

<p>
How are we going to explain this code to beginning programmers?
</p>

<blockquote><pre>template&lt;class I, class E, class S&gt;
struct codecvt : std::codecvt&lt;I, E, S&gt;
{
    ~codecvt()
    { }
};

void main()
{
    std::wstring_convert&lt;codecvt&lt;wchar_t, char, std::mbstate_t&gt; &gt; compiles_ok;
    
    std::wstring_convert&lt;std::codecvt&lt;wchar_t, char, std::mbstate_t&gt; &gt;   not_ok;
}
</pre></blockquote>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
Bill will propose a resolution.
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
<p>
codecvt isn't intended for beginning programmers. This is a regrettable
consequence of the original design of the facet.
</p>
<p>
Move to NAD.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="725"></a>725. Optional sequence container requirements column label</h3>
<p><b>Section:</b> 23.2.3 [sequence.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> David Abrahams <b>Opened:</b> 2007-09-16 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#sequence.reqmts">issues</a> in [sequence.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Table 90: (Optional sequence container operations) states the
"assertion note pre/post-condition" of <tt>operator[]</tt> to be
</p>

<blockquote><pre>*(a.begin() + n)
</pre></blockquote>

<p>
Surely that's meant to be "operational semantics?"
</p>



<p><b>Proposed resolution:</b></p>
<blockquote>
<table border="1">
<caption>Table 90: Optional sequence container operations</caption>
<tbody><tr>
<th>expression</th> <th>return type</th> <th><del>assertion/note<br>pre/post-condition</del><br> <ins>operational semantics</ins></th> <th>container</th>
</tr>
</tbody></table>
</blockquote>






<hr>
<h3><a name="726"></a>726. Missing <tt>regex_replace()</tt> overloads</h3>
<p><b>Section:</b> 28.11.4 [re.alg.replace] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2007-09-22 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#re.alg.replace">issues</a> in [re.alg.replace].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Two overloads of <tt>regex_replace()</tt> are currently provided:
</p>

<blockquote><pre>template &lt;class OutputIterator, class BidirectionalIterator, 
    class traits, class charT&gt; 
  OutputIterator 
  regex_replace(OutputIterator out, 
                BidirectionalIterator first, BidirectionalIterator last, 
                const basic_regex&lt;charT, traits&gt;&amp; e, 
                const basic_string&lt;charT&gt;&amp; fmt, 
                regex_constants::match_flag_type flags = 
                  regex_constants::match_default);
 
template &lt;class traits, class charT&gt; 
  basic_string&lt;charT&gt; 
  regex_replace(const basic_string&lt;charT&gt;&amp; s, 
                const basic_regex&lt;charT, traits&gt;&amp; e, 
                const basic_string&lt;charT&gt;&amp; fmt, 
                regex_constants::match_flag_type flags = 
                  regex_constants::match_default);
</pre></blockquote>

<ol>
<li>Overloads taking <tt>const charT *</tt> are provided for <tt>regex_match()</tt> and
<tt>regex_search()</tt>, but not <tt>regex_replace()</tt>.  This is inconsistent.</li>
<li>
<p>The absence of <tt>const charT *</tt> overloads prevents ordinary-looking code from compiling, such as:</p>

<blockquote><pre>const string s("kitten");
const regex r("en");
cout &lt;&lt; regex_replace(s, r, "y") &lt;&lt; endl;
</pre></blockquote>

<p>
The compiler error message will be something like "could not deduce
template argument for 'const std::basic_string&lt;_Elem&gt; &amp;' from 'const
char[1]'".
</p>

<p>
Users expect that anything taking a <tt>basic_string&lt;charT&gt;</tt> can also take a
<tt>const charT *</tt>.  In their own code, when they write a function taking
<tt>std::string</tt> (or <tt>std::wstring</tt>), they can pass a <tt>const char *</tt> (or <tt>const
wchar_t *</tt>), thanks to <tt>basic_string</tt>'s implicit constructor.  Because the
regex algorithms are templated on <tt>charT</tt>, they can't rely on
<tt>basic_string</tt>'s implicit constructor (as the compiler error message
indicates, template argument deduction fails first).
</p>

<p>
If a user figures out what the compiler error message means, workarounds
are available - but they are all verbose.  Explicit template arguments
could be given to <tt>regex_replace()</tt>, allowing <tt>basic_string</tt>'s implicit
constructor to be invoked - but <tt>charT</tt> is the last template argument, not
the first, so this would be extremely verbose.  Therefore, constructing
a <tt>basic_string</tt> from each C string is the simplest workaround.
</p>
</li>

<li>
There is an efficiency consideration: constructing <tt>basic_string</tt>s can
impose performance costs that could be avoided by a library
implementation taking C strings and dealing with them directly. 
(Currently, for replacement sources, C strings can be converted into
iterator pairs at the cost of verbosity, but for format strings, there
is no way to avoid constructing a <tt>basic_string</tt>.)
</li>
</ol>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
We note that Boost already has these overloads. However, the proposed
wording is provided only for 28.11.4 [re.alg.replace]; wording is needed for the synopsis
as well. We also note that this has impact on <tt>match_results::format</tt>,
which may require further overloads.
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
Daniel to tweak for us.
</blockquote>

<p><i>[
2009-07-25 Daniel tweaks both this issue and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#727">727</a>.
]</i></p>


<blockquote>
<p>
This is solved by the proposed resolution of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#727">727</a>.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Leave Open. Though we believe this is solved by the proposed resolution
to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#727">727</a>.
</blockquote>

<p><i>[
2010-01-27 Moved to Tentatively NAD after 5 positive votes on c++std-lib. 
Rationale added below.
]</i></p>



<p><b>Rationale:</b></p>
<p>
Solved by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#727">727</a>.
</p>


<p><b>Proposed resolution:</b></p>

<p>
Provide additional overloads for <tt>regex_replace()</tt>: one additional
overload of the iterator-based form (taking <tt>const charT* fmt</tt>), and three
additional overloads of the convenience form (one taking <tt>const charT*
str</tt>, another taking <tt>const charT* fmt</tt>, and the third taking both <tt>const
charT* str</tt> and <tt>const charT* fmt</tt>).  28.11.4 [re.alg.replace]:
</p>

<blockquote>
<pre>template &lt;class OutputIterator, class BidirectionalIterator, 
    class traits, class charT&gt; 
  OutputIterator 
  regex_replace(OutputIterator out, 
                BidirectionalIterator first, BidirectionalIterator last, 
                const basic_regex&lt;charT, traits&gt;&amp; e, 
                const basic_string&lt;charT&gt;&amp; fmt, 
                regex_constants::match_flag_type flags = 
                  regex_constants::match_default);

<ins>template &lt;class OutputIterator, class BidirectionalIterator, 
    class traits, class charT&gt; 
  OutputIterator 
  regex_replace(OutputIterator out, 
                BidirectionalIterator first, BidirectionalIterator last, 
                const basic_regex&lt;charT, traits&gt;&amp; e, 
                const charT* fmt, 
                regex_constants::match_flag_type flags = 
                  regex_constants::match_default);</ins>
</pre>
<p>...</p>
<pre>template &lt;class traits, class charT&gt; 
  basic_string&lt;charT&gt; 
  regex_replace(const basic_string&lt;charT&gt;&amp; s, 
                const basic_regex&lt;charT, traits&gt;&amp; e, 
                const basic_string&lt;charT&gt;&amp; fmt, 
                regex_constants::match_flag_type flags = 
                  regex_constants::match_default);

<ins>template &lt;class traits, class charT&gt; 
  basic_string&lt;charT&gt; 
  regex_replace(const basic_string&lt;charT&gt;&amp; s, 
                const basic_regex&lt;charT, traits&gt;&amp; e, 
                const charT* fmt, 
                regex_constants::match_flag_type flags = 
                  regex_constants::match_default);</ins>

<ins>template &lt;class traits, class charT&gt; 
  basic_string&lt;charT&gt; 
  regex_replace(const charT* s, 
                const basic_regex&lt;charT, traits&gt;&amp; e, 
                const basic_string&lt;charT&gt;&amp; fmt, 
                regex_constants::match_flag_type flags = 
                  regex_constants::match_default);</ins>

<ins>template &lt;class traits, class charT&gt; 
  basic_string&lt;charT&gt; 
  regex_replace(const charT* s, 
                const basic_regex&lt;charT, traits&gt;&amp; e, 
                const charT* fmt, 
                regex_constants::match_flag_type flags = 
                  regex_constants::match_default);</ins>
</pre>
</blockquote>






<hr>
<h3><a name="729"></a>729. Problem in [rand.req.eng]/3</h3>
<p><b>Section:</b> 26.5.1.4 [rand.req.eng] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Stephan Tolksdorf <b>Opened:</b> 2007-09-21 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.req.eng">issues</a> in [rand.req.eng].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The 3rd table row in 26.5.1.4 [rand.req.eng]/3 requires random number engines to accept any 
arithmetic type as a seed, which is then casted to the engine's <tt>result_type</tt> and subsequently 
used for seeding the state of the engine. The requirement stated as "Creates an engine with 
initial state determined by <tt>static_cast&lt;X::result_type&gt;(s)</tt>" forces random number engines 
to either use a seeding method that completely depends on the <tt>result_type</tt> (see the discussion 
of seeding for the <tt>mersenne_twister_engine</tt> in point T2 above) or at least to throw away "bits 
of randomness" in the seed value if the <tt>result_type</tt> is smaller than the seed type. This seems 
to be inappropriate for many modern random number generators, in particular F2-linear or 
cryptographic ones, which operate on an internal bit array that in principle is independent of the 
type of numbers returned.
</p>

<p>
<b>Posible resolution:</b> I propose to change the wording to a version similar to "Creates an 
engine with initial state determined by <tt>static_cast&lt;UintType&gt;(s)</tt>, where <tt>UintType</tt> is an 
implementation specific unsigned integer type."
</p>

<p>
Additionally, the definition of s in 26.5.1.4 [rand.req.eng]/1 c) could be restricted to unsigned integer types.
</p>

<p>
Similarly, the type of the seed in 26.5.1.5 [rand.req.adapt]/3 e) could be left unspecified.
</p>

<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2424.pdf">N2424</a>
for further discussion.
</p>

<p><i>[
Stephan Tolksdorf adds pre-Bellevue:
]</i></p>


<blockquote>
<p>
In reply to the discussion in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2424.pdf">N2424</a>
regarding this issue:
</p>
<p>
The descriptions of all engines and engine adaptors given in sections
26.5.3 [rand.eng] and 26.5.4 [rand.adapt] already specify the concrete
types of the integer arguments for seeding. Hence, relaxing the general
requirement in 26.5.1.4 [rand.req.eng] would not affect portability and
reproducibility of the standard library. Furthermore, it is not clear to
me what exactly the guarantee "with initial state determined by
<tt>static_cast&lt;X::result_type&gt;(s)</tt>" is useful for. On the other hand,
relaxing the requirement would allow developers to implement  other
random number engines that do not have to cast all arithmetic seed
arguments to their result_types.
</p>
</blockquote>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
Propose close NAD for the reasons given in N2424.
</blockquote>




<p><b>Proposed resolution:</b></p>
<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2424.pdf">N2424</a>
for further discussion.
</p>

<p><i>[
Stephan Tolksdorf adds pre-Bellevue:
]</i></p>


<blockquote>
<p>
Change row 3 of table 105 "Random number engine requirements" in 26.5.1.4 [rand.req.eng]/3
</p>

<blockquote>
Creates an engine with initial state determined by
<tt><del>static_cast&lt;X::result_type&gt;(</del>s<del>)</del></tt>
</blockquote>

<p>
Similarly, change 26.5.1.5 [rand.req.adapt]/3 e)
</p>

<blockquote>
When <tt>X::X</tt> is invoked with <del>an <tt>X::result_type</tt></del> value <tt>s</tt>
<ins>of arithmetic type (3.9.1)</ins>, ...
</blockquote>

</blockquote>






<hr>
<h3><a name="730"></a>730. Comment on [rand.req.adapt]/3 e)</h3>
<p><b>Section:</b> 26.5.1.5 [rand.req.adapt] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Stephan Tolksdorf <b>Opened:</b> 2007-09-21 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
If an engine adaptor is invoked with an argument of type <tt>seed_seq</tt>, then all base 
engines are specified to be seeded with this <tt>seed_seq</tt>. As <tt>seed_seq</tt>'s randomization method is 
qualified as constant, this procedure will ef fectively initialize all base engines with the same seed 
(though the resulting state might still dif fer to a certain degree if the engines are of different types). 
It is not clear whether this mode of operation is in general appropriate, hence -- as far as the 
stated requirements are of general nature and not just specific to the engine adaptors provided by 
the library -- it might be better to leave the behaviour unspecified, since the current definition of 
<tt>seed_seq</tt> does not allow for a generally satisfying specification.
</p>

<p>
<b>Posssible resolution:</b> [As above]
</p>

<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2424.pdf">N2424</a>
for further discussion.
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
Close NAD for the reasons given in N2424.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2424.pdf">N2424</a>
for the proposed resolution.
</p>





<hr>
<h3><a name="731"></a>731. proposal for a customizable <tt>seed_seq</tt></h3>
<p><b>Section:</b> 26.5.7.1 [rand.util.seedseq] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Stephan Tolksdorf <b>Opened:</b> 2007-09-21 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.util.seedseq">issues</a> in [rand.util.seedseq].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The proper way to seed random number engines seems to be the most frequently 
discussed issue of the 26.5 [rand] proposal. While the new <tt>seed_seq</tt> approach is already rather 
general and probably sufficient for most situations, it is unlikely to be optimal in every case (one 
problem was pointed out in point T5 above). In some situations it might, for instance, be better to 
seed the state with a cryptographic generator. 
</p>
<p>
In my opinion this is a pretty strong argument for extending the standard with a simple facility to 
customize the seeding procedure. This could, for example, be done with the following minimal 
changes:
</p>

<p>
<b>Possible resolution:</b>
</p>

<ol type="a">
<li>
Turn the interface specification of 26.5.7.1 [rand.util.seedseq]/2 into a "SeedSeq" requirement, where the 
exact behaviour of the constructors and the randomize method are left unspecified and where the
const qualification for randomize is removed. Classes implementing this interface are additionally 
required to specialize the traits class in c).
</li>
<li>
Provide the class <tt>seed_seq</tt> as a default implementation of the SeedSeq interface.
</li>
<li>
<p>
Supplement the <tt>seed_seq</tt> with a traits class
</p>
<blockquote><pre>template &lt;typename T&gt; 
struct is_seed_seq { static const bool value = false; }
</pre></blockquote>
<p>and the specialization</p>
<blockquote><pre>template &lt;&gt; 
struct is_seed_seq&lt;seed_seq&gt; { static const bool value = true; }
</pre></blockquote>
<p>which users can supplement with further specializations.</p>
</li>
<li>
Change 26.5.1.4 [rand.req.eng]/1 d) to "q is an lvalue of a type that fulfils the SeedSeq requirements", and 
modify the constructors and seed methods in 26.5.3 [rand.eng] appropriately (the actual implementation 
could be done using the SFINAE technique).
</li>
</ol>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
See N2424. Close NAD but note that "conceptizing" the library may cause
this problem to be solved by that route.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2424.pdf">N2424</a>
for the proposed resolution.
</p>





<hr>
<h3><a name="732"></a>732. Defect in [rand.dist.samp.genpdf]</h3>
<p><b>Section:</b> X [rand.dist.samp.genpdf] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Stephan Tolksdorf <b>Opened:</b> 2007-09-21 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.dist.samp.genpdf">issues</a> in [rand.dist.samp.genpdf].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#795">795</a></p>
<p><b>Discussion:</b></p>
<p>
X [rand.dist.samp.genpdf] describes the interface for a distribution template that is 
meant to simulate random numbers from any general distribution given only the density and the 
support of the distribution. I'm not aware of any general purpose algorithm that would be capable 
of correctly and efficiently implementing the described functionality. From what I know, this is 
essentially an unsolved research problem. Existing algorithms either require more knowledge 
about the distribution and the problem domain or work only under very limited circumstances. 
Even the state of the art special purpose library UNU.RAN does not solve the problem in full 
generality, and in any case, testing and customer support for such a library feature would be a 
nightmare.
</p>

<p>
<b>Possible resolution:</b> For these reasons, I propose to delete section X [rand.dist.samp.genpdf].
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
Disagreement persists.
</p>
<p>
Objection to this issue is that this function takes a general functor.
The general approach would be to normalize this function, integrate it,
and take the inverse of the integral, which is not possible in general.
An example function is sin(1+n*x) -- for any spatial frequency that the
implementor chooses, there is a value of n that renders that choice
arbitrarily erroneous.
</p>
<p>
Correction: The formula above should instead read 1+sin(n*x).
</p>
<p>
Objector proposes the following possible compromise positions:
</p>
<ul>
<li>
rand.dist.samp.genpdf takes an number of points so that implementor need not guess.
</li>
<li>
replace rand.disk.samp.genpdf with an extension to either or both of the discrete functions to take arguments that take a functor and number of points in place of the list of probabilities. Reference issues 793 and 794.
</li>
</ul>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2813.pdf">N2813</a>
for the proposed resolution.
</p>


<p><b>Rationale:</b></p>
Addressed by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2836.pdf">N2836</a> "Wording Tweaks for Concept-enabled Random Number Generation in C++0X".





<hr>
<h3><a name="733"></a>733. Comment on [rand.req.dist]/9</h3>
<p><b>Section:</b> 26.5.1.6 [rand.req.dist] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Stephan Tolksdorf <b>Opened:</b> 2007-09-21 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The requirement "P shall have a declaration of the form <tt>typedef X distribution_- 
type</tt>" effectively makes the use of inheritance for implementing distributions very inconvenient, 
because the child of a distribution class in general will not satisfy this requirement. In my opinion 
the benefits of having a typedef in the parameter class pointing back to the distribution class are 
not worth the hassle this requirement causes. [In my code base I never made use of the nested 
typedef but on several occasions could have profited from being able to use simple inheritance for 
the implementation of a distribution class.]
</p>

<p>
<b>Proposed resolution:</b> I propose to drop this requirement.
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
Close NAD for the reasons given in N2424. In practice it is not inconvenient to meet these requirements.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2424.pdf">N2424</a>
for the proposed resolution.
</p>





<hr>
<h3><a name="735"></a>735. Unfortunate naming</h3>
<p><b>Section:</b> 26.5.8.2.2 [rand.dist.bern.bin], 26.5.8.2.4 [rand.dist.bern.negbin] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Stephan Tolksdorf <b>Opened:</b> 2007-09-21 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In my opinion the choice of name for the <tt>t</tt> parameter of the <tt>binomial_distribution</tt>
is very unfortunate. In virtually every internet reference, book and software implementation 
this parameter is called <tt>n</tt> instead, see for example Wikipedia, Mathworld, Evans et al. (1993) 
Statistical Distributions, 2nd E., Wiley, p. 38, the R statistical computing language, p. 926, 
Mathematica and Matlab.
</p>

<p>
Similarly, the choice of <tt>k</tt> for the parameter of the negative binomial distributions is rather unusual. 
The most common choice for the negative binomial distribution seems to be <tt>r</tt> instead.
</p>

<p>
Choosing unusual names for the parameters causes confusion among users and makes the 
interface unnecessarily inconvenient to use.
</p>

<p>
<b>Possible resolution:</b> For these reasons, I propose to change the name of the respective parameters
to <tt>n</tt> and <tt>r</tt>.
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
In N2424. NAD It has been around for a while. It is hardly universal,
there is prior art, and this would confuse people.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2424.pdf">N2424</a>
for the proposed resolution.
</p>





<hr>
<h3><a name="736"></a>736. Comment on [rand.dist.samp.discrete]</h3>
<p><b>Section:</b> 26.5.8.5.1 [rand.dist.samp.discrete] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Stephan Tolksdorf <b>Opened:</b> 2007-09-21 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.dist.samp.discrete">issues</a> in [rand.dist.samp.discrete].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<ol type="a">
<li>
The specification for <tt>discrete_distribution</tt> requires the member <tt>probabilities()</tt>
to return a vector of <i>standardized</i> probabilities, which forces the implementation every time to 
divide each probability by the sum of all probabilities, as the sum will in practice almost never be 
exactly 1.0. This is unnecessarily inef ficient as the implementation would otherwise not need to 
compute the standardized probabilities at all and could instead work with the non-standardized 
probabilities and the sum. If there was no standardization the user would just get back the 
probabilities that were previously supplied to the distribution object, which to me seems to be the 
more obvious solution.
</li>
<li>
The behaviour of <tt>discrete_distribution</tt> is not specified in case the number of given
probabilities is larger than the maximum number representable by the IntType.
</li>
</ol>

<p>
<b>Possible resolution:</b> I propose to change the specification such that the non-standardized 
probabilities need to be returned and that an additional requirement is included for the number 
of probabilities to be smaller than the maximum of IntType.
</p>

<p><i>[
Stephan Tolksdorf adds pre-Bellevue:
]</i></p>


<blockquote>
<p>
In reply to the discussion in 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2424.pdf">N2424</a>
of this issue:
</p>
<p>
Rescaled floating-point parameter vectors can not be expected to compare
equal because of the limited precision of floating-point numbers.
My proposal would at least guarantee that a parameter
vector (of type double) passed into the distribution would compare equal
with the one returned by the <tt>probabilities()</tt> method. Furthermore, I do
not understand why "the changed requirement would lead to a significant
increase in the amount of state in the distribution object". A typical
implementation's state would increase by exactly one number: the sum of
all probabilities. The textual representation for serialization would
not need to grow at all. Finally, the proposed replacement "<tt>0 &lt; n &lt;=
numeric_limits&lt;IntType&gt;::max() + 1</tt>" makes the implementation
unnecessarily complicated, "<tt>0 &lt; n &lt;= numeric_limits&lt;IntType&gt;::max()</tt>"
would be better.
</p>
</blockquote>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
In N2424. We agree with the observation and the proposed resolution to
part b). We recommend the wording n &gt; 0 be replaced with 0 &lt; n
numeric_limits::max() + 1. However, we disagree with part a), as it
would interfere with the definition of parameters' equality. Further,
the changed requirement would lead to a significant increase in the
amount of state of the distribution object.
</p>

<p>
As it stands now, it is convenient, and the changes proposed make it
much less so.
</p>

<p>
NAD. Part a the current behavior is desirable. Part b, any constructor
can fail, but the rules under which it can fail do not need to be listed
here.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2424.pdf">N2424</a>
for the proposed resolution.
</p>

<p><i>[
Stephan Tolksdorf adds pre-Bellevue:
]</i></p>


<blockquote>
<p>
In 26.5.8.5.1 [rand.dist.samp.discrete]:
</p>

<p>
Proposed wording a):
</p>

<blockquote>
<p>
Changae in para. 2
</p>

<blockquote>
Constructs a <tt>discrete_distribution</tt> object with <tt>n=1</tt> and <tt>p<sub>0</sub> <ins>= w<sub>0</sub></ins> = 1</tt>
</blockquote>

<p>
and change in para. 5
</p>

<blockquote>
<i>Returns:</i> A <tt>vector&lt;double&gt;</tt> whose <tt>size</tt> member returns <tt>n</tt> and whose
<tt>operator[]</tt> member returns <del><tt>p<sub>k</sub></tt></del>
<ins>the weight <tt>w<sub>k</sub></tt> as a double value</ins>
when invoked with argument <tt>k</tt> for <tt>k = 0,
..., n-1</tt>
</blockquote>

</blockquote>

<p>
Proposed wording b):
</p>

<blockquote>
<p>
Change in para. 3:
</p>

<blockquote>
If <tt>firstW == lastW</tt>, let the sequence <tt>w</tt> have length <tt>n = 1</tt> and consist
of the single value <tt>w<sub>0</sub> = 1</tt>. Otherwise, <tt>[firstW,lastW)</tt> shall form a
sequence <tt>w</tt> of length <tt>n <del>&gt; 0</del></tt> 
<ins>such that <tt>0 &lt; n &lt;= numeric_limits&lt;IntType&gt;::max()</tt>,</ins>
and <tt>*firstW</tt> shall yield a value <tt>w<sub>0</sub></tt>
convertible to <tt>double</tt>. [<i>Note:</i> The values <tt>w<sub>k</sub></tt> are commonly known
as the weights . <i>-- end note</i>]
</blockquote>

</blockquote>

</blockquote>





<hr>
<h3><a name="737"></a>737. Comment on [rand.dist.samp.pconst]</h3>
<p><b>Section:</b> 26.5.8.5.2 [rand.dist.samp.pconst] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Stephan Tolksdorf <b>Opened:</b> 2007-09-21 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.dist.samp.pconst">issues</a> in [rand.dist.samp.pconst].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<ol type="a">
<li>
The discussion in point T11 above regarding <tt>probabilities()</tt> similarly applies 
to the method <tt>densities()</tt> of <tt>piecewise_constant_distribution</tt>.
</li>
<li>
<p>
The design of the constructor
</p>
<blockquote><pre>template &lt;class InputIteratorB, class InputIteratorW&gt; 
piecewise_constant_distribution( InputIteratorB firstB, InputIteratorB lastB, 
                                 InputIteratorW firstW);
</pre></blockquote>
<p>
is unnecessarily unsafe, as there is no separate end-iterator given for the weights. I can't see 
any performance or convenience reasons that would justify the risks inherent in such a function 
interface, in particular the risk that input error might go unnoticed.
</p>
</li>
</ol>

<p>
<b>Possible resolution:</b> I propose to add an <tt>InputIteratorW lastW</tt> argument to the interface.
</p>

<p><i>[
Stephan Tolksdorf adds pre-Bellevue:
]</i></p>

<blockquote>
In reply to the discussion in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2424.pdf">N2424</a>
I'd like to make the same comments as for <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#736">736</a>.
</blockquote>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
In N2424. There is already precedent elsewhere in the library. Follows existing convention. NAD.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2424.pdf">N2424</a>
for the proposed resolution.
</p>

<p><i>[
Stephan Tolksdorf adds pre-Bellevue:
]</i></p>


<blockquote>
<p>
In 26.5.8.5.2 [rand.dist.samp.pconst]:
</p>

<p>
Proposed wording a)
</p>

<blockquote>
<p>
Change in para. 2
</p>
<blockquote>
Constructs a <tt>piecewise_constant_distribution</tt> object with <tt>n = 1</tt>, <tt>p<sub>0</sub> <ins>= w<sub>0</sub></ins> = 1</tt>,
<tt>b<sub>0</sub> = 0</tt>, and <tt>b<sub>1</sub> = 1</tt>
</blockquote>

<p>
and change in para. 5
</p>

<blockquote>
A <tt>vector&lt;result_type&gt;</tt> whose <tt>size</tt> member returns <tt>n</tt> and whose <tt>operator[]</tt>
member returns <del><tt>p<sub>k</sub></tt></del>
<ins>the weight <tt>w<sub>k</sub></tt> as a double value</ins>
when invoked with argument <tt>k</tt> for <tt>k = 0, ..., n-1</tt>
</blockquote>

</blockquote>

<p>
Proposed wording b)
</p>

<blockquote>
<p>
Change both occurrences of
</p>

<blockquote>
"piecewise_constant_distribution(InputIteratorB firstB, InputIteratorB lastB,
                                 InputIteratorW firstW<ins>, InputIteratorW lastW</ins>)
</blockquote>

<p>
and change in para. 3
</p>

<blockquote>
<del>the length of the sequence <tt>w</tt> starting from <tt>firstW</tt> shall be at least <tt>n</tt>,
<tt>*firstW</tt> shall return a value <tt>w<sub>0</sub></tt> that is convertible to <tt>double</tt>, and any
<tt>w<sub>k</sub></tt> for <tt>k &gt;= n</tt> shall be ignored by the distribution</del>
<ins><tt>[firstW, lastW)</tt> shall form a sequence <tt>w</tt> of length <tt>n</tt> whose leading element
<tt>w<sub>0</sub></tt> shall be convertible to <tt>double</tt></ins>
</blockquote>

</blockquote>


</blockquote>






<hr>
<h3><a name="738"></a>738. Editorial issue in [rand.adapt.disc]/3</h3>
<p><b>Section:</b> 26.5.4.1 [rand.adapt.disc] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Stephan Tolksdorf <b>Opened:</b> 2007-09-21 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.adapt.disc">issues</a> in [rand.adapt.disc].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Since the template parameter <tt>p</tt> and <tt>r</tt> are of type <tt>size_t</tt>, the member <tt>n</tt> in the class 
exposition should have type <tt>size_t</tt>, too.
</p>


<p><b>Proposed resolution:</b></p>
<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2424.pdf">N2424</a>
for the proposed resolution.
</p>





<hr>
<h3><a name="739"></a>739. Defect in [rand.util.canonical]/3</h3>
<p><b>Section:</b> 26.5.7.2 [rand.util.canonical] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Stephan Tolksdorf <b>Opened:</b> 2007-09-21 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.util.canonical">issues</a> in [rand.util.canonical].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The complexity of <tt>generate_canonical</tt> is specified to be "exactly k=max(1, ceil(b/log2 
R)) invocations of g". This terms involves a logarithm that is not rounded and hence can not (in 
general) be computed at compile time. As this function template is performance critical, I propose 
to replace ceil(b/log2 R) with ceil(b/floor(log2 R)).
</p>

<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2424.pdf">N2424</a>
for further discussion.
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
In N2424. Close NAD as described there.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2424.pdf">N2424</a>
for the proposed resolution.
</p>





<hr>
<h3><a name="741"></a>741. Const-incorrect <tt>get_deleter</tt> function for <tt>shared_ptr</tt></h3>
<p><b>Section:</b> 20.9.10.2.11 [util.smartptr.getdeleter] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2007-09-27 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#util.smartptr.getdeleter">issues</a> in [util.smartptr.getdeleter].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The following issue was raised by Alf P. Steinbach in c.l.c++.mod:
</p>

<p>
According to the recent draft N2369, both the header memory synopsis
of 20.9 [memory] and 20.9.10.2.11 [util.smartptr.getdeleter] declare:
</p>

<blockquote><pre>template&lt;class D, class T&gt; D* get_deleter(shared_ptr&lt;T&gt; const&amp; p);
</pre></blockquote>

<p>
This allows to retrieve the pointer to a mutable deleter of a <tt>const
shared_ptr</tt> (if that owns one) and therefore contradicts the usual
philosophy that associated functors are either read-only (e.g.
<tt>key_comp</tt> or <tt>value_comp</tt> of <tt>std::map</tt>) or do at least reflect
the mutability of the owner (as seen for the both overloads of
<tt>unique_ptr::get_deleter</tt>).
Even the next similar counter-part of <tt>get_deleter</tt> - the two
overloads of <tt>function::target</tt> in the class template function
synopsis 20.8.14.2 [func.wrap.func] or in 20.8.14.2.5 [func.wrap.func.targ] - do
properly mirror the const-state of the owner.
</p>

<b>Possible proposed resolutions:</b>

<p>
Replace the declarations of <tt>get_deleter</tt> in the header <tt>&lt;memory&gt;</tt>
synopsis of 20.9 [memory] and in 20.9.10.2.11 [util.smartptr.getdeleter] by one of the
following alternatives (A) or (B):
</p>

<ol type="A">
<li>
Provide <b>only</b> the immutable variant. This would reflect the
current praxis of <tt>container::get_allocator()</tt>, <tt>map::key_comp()</tt>, or
<tt>map::value_comp</tt>.

<blockquote><pre>template&lt;class D, class T&gt; const D* get_deleter(shared_ptr&lt;T&gt; const&amp; p);
</pre></blockquote>
</li>
<li>
Just remove the function.
</li>
</ol>

<p>
Alberto Ganesh Barbati adds:
</p>

<ol type="A" start="3">
<li>
<p>
Replace it with two functions:
</p>
<blockquote><pre>template &lt;class D, class T&gt; D get_deleter(shared_ptr&lt;T&gt; const&amp;);
template &lt;class D, class T&gt; bool has_deleter(shared_ptr&lt;T&gt; const&amp;);
</pre></blockquote>

<p>
The first one would throw if <tt>D</tt> is the wrong type, while the latter would
never throw. This approach would reflect the current praxis of
<tt>use_facet/has_facet</tt>, with the twist of returning the deleter by value as
<tt>container::get_allocator()</tt> do.
</p>
</li>
</ol>

<p>
Peter Dimov adds:
</p>

<blockquote>
<p>
My favorite option is "not a defect". A, B and C break useful code.
</p>
</blockquote>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
Concern this is similar to confusing "pointer to const" with "a constant pointer".
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="745"></a>745. copy_exception API slices.</h3>
<p><b>Section:</b> 18.8.5 [propagation] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2007-10-10 <b>Last modified:</b> 2010-10-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#propagation">active issues</a> in [propagation].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#propagation">issues</a> in [propagation].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It could be I did not understand the design rationale, but I thought
copy_exception would produce an exception_ptr to the most-derived (dynamic)
type of the passed exception.  Instead it slices, which appears to be less
useful, and a likely source of FAQ questions in the future.
</p>
<p>
(Peter Dimov suggests NAD)
</p>

<p><i>[
Bellevue: 
]</i></p>


<blockquote>
<p>
How could this be implemented in a way that the dynamic type is cloned?
</p>
<p>
The feature is designed to create an exception_ptr from an object whose
static type is identical to the dynamic type and thus there is no
slicing involved.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="747"></a>747. We have 3 separate type traits to identify classes supporting no-throw operations</h3>
<p><b>Section:</b> 20.7.4.3 [meta.unary.prop] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2007-10-10 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
We have 3 separate type traits to identify classes supporting no-throw
operations, which are very useful when trying to provide exception safety
guarantees.  However, I'm not entirely clear on what the current wording
requires of a conforming implementation.  To quote from
<tt>has_nothrow_default_constructor</tt>:
</p>
<blockquote><p>
or <tt>T</tt> is a class type with a default constructor that is known not to throw
any exceptions
</p></blockquote>
<p>
What level of magic do we expect to deduce if this is known?
</p>
<p>
E.g.
</p>

<blockquote><pre>struct test{
 int x;
 test() : x() {}
};
</pre></blockquote>
<p>
Should I expect a conforming compiler to 
 <tt>assert( has_nothrow_constructor&lt;test&gt;::value )</tt>
</p>
<p>
Is this a QoI issue?
</p>
<p>
Should I expect to 'know' only if-and-only-if there is an inline definition
available?
</p>
<p>
Should I never expect that to be true, and insist that the user supplies an
empty throw spec if they want to assert the no-throw guarantee?
</p>
<p>
It would be helpful to maybe have a footnote explaining what is required,
but right now I don't know what to suggest putting in the footnote.
</p>
<p>
(agreement since is that trivial ops and explicit no-throws are required.
Open if QoI should be allowed to detect further)
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
This looks like a QoI issue.
In the case of trivial and nothrow it is known. Static analysis of the program is definitely into QoI.
Move to OPEN. Need to talk to Core about this.
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
<p>
This is QoI.
</p>
<p>
Move to NAD.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="748"></a>748. The is_abstract type trait is defined by reference to 10.4.</h3>
<p><b>Section:</b> 20.7.4.3 [meta.unary.prop] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2007-10-10 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I am trying to decide is a pure virtual function is a <i>necessary</i> as well as
sufficient requirement to be classified as abstract?
</p>
<p>
For instance, is the following (non-polymorphic) type considered abstract?
</p>
<blockquote><pre>struct abstract {
protected:
 abstract(){}
 abstract( abstract const &amp; ) {}
 ~abstract() {}
};
</pre></blockquote>
<p>
(Suggested that this may be NAD, with an editorial fix-up from Pete on the
core wording to make clear that abstract requires a pure virtual function)
</p>


<p><b>Proposed resolution:</b></p>
<p>
Core has clarified that the definition abstract is adequate. Issue withdrawn by submitter. NAD.
</p>





<hr>
<h3><a name="750"></a>750. The current definition for <tt>is_convertible</tt> requires that the type be
implicitly convertible, so explicit constructors are ignored.</h3>
<p><b>Section:</b> 20.7.6 [meta.rel] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2007-10-10 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta.rel">issues</a> in [meta.rel].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#719">719</a></p>
<p><b>Discussion:</b></p>
<p>
With the pending arrival of explicit conversion functions though, I'm
wondering if we want an additional trait, <tt>is_explictly_convertible</tt>?
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
Alisdair is considering preparing a paper listing a number of missing
type traits, and feels that it might be useful to handle them all
together rather than piecemeal. This would affect issue 719 and 750.
These two issues should move to OPEN pending AM paper on type traits.
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
Duplicate of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#719">719</a> (for our purposes).
</blockquote>

<p><i>[
Addressed in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2947.html">N2947</a>.
]</i></p>




<p><b>Proposed resolution:</b></p>






<hr>
<h3><a name="751"></a>751. change pass-by-reference members of <tt>vector&lt;bool&gt;</tt> to pass-by-value?</h3>
<p><b>Section:</b> 23.4.2 [vector.bool] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2007-10-10 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#vector.bool">issues</a> in [vector.bool].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
A number of vector&lt;bool&gt; members take const bool&amp; as arguments.
Is there any chance we could change them to pass-by-value or would I 
be wasting everyone's time if wrote up an issue?
</p>

<p><i>[
post Bellevue:
]</i></p>


<blockquote>
<p>
As we understand it, the original requester (Martin Sebor) would like
for implementations to be permitted to pass-by-value. Alisdair suggests
that if this is to be resolved, it should be resolved more generally,
e.g. in other containers as well.
</p>
<p>
We note that this would break ABI. However, we also suspect that this
might be covered under the "as-if" rule in section 1.9.
</p>
<p>
Many in the group feel that for vector&lt;bool&gt;, this is a "don't care",
and that at this point in the process it's not worth the bandwidth.
</p>
<p>
Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#679">679</a> -- which was in ready status pre-Bellevue and is
now in the working paper -- is related to this, though not a duplicate.
</p>
<p>
Moving to Open with a task for Alisdair to craft a informative note to
be put whereever appropriate in the WP. This note would clarify places
where pass-by-const-ref can be transformed to pass-by-value under the
as-if rule.
</p>
</blockquote>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
This is really a clause 17 issue, rather than something specific to vector&lt;bool&gt;.
</p>
<p>
Move to Open. Alisdair to provide a resolution. Alternately, Howard can
close this as NAD and then open a new issue to handle the general issue
(rather than the vector&lt;bool&gt; one).
</p>
<p>
Howard:  Haven't yet opened new issue.  Lacking wording for it.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
NAD.  Insufficient motivation to make any changes.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="754"></a>754. Ambiguous return clause for <tt>std::uninitialized_copy</tt></h3>
<p><b>Section:</b> 20.9.8.2 [uninitialized.copy] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2007-10-15 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#uninitialized.copy">issues</a> in [uninitialized.copy].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
14882-2003, [lib.uninitialized.copy] is currently written as follows:
</p>

<blockquote>
<pre>template &lt;class InputIterator, class ForwardIterator&gt;
  ForwardIterator uninitialized_copy(InputIterator <i>first</i>, InputIterator <i>last</i>,
                                     ForwardIterator <i>result</i>);
</pre>
<blockquote>
<p>
-1- <i>Effects:</i>
</p>
<blockquote><pre>for (; first != last; ++result, ++first)
  new (static_cast&lt;void*&gt;(&amp;*result))
    typename iterator_traits&lt;ForwardIterator&gt;::value_type(*first);
</pre></blockquote>
<p>
-2- <i>Returns:</i> <tt><i>result</i></tt>
</p>
</blockquote>
</blockquote>

<p>
similarily for N2369, and its corresponding section
20.9.8.2 [uninitialized.copy].
</p>

<p>
It's not clear to me what the return clause is supposed to mean, I see
two
possible interpretations:
</p>

<ol type="a">
<li>
The notion of <tt><i>result</i></tt> is supposed to mean the value given by the
function parameter <tt><i>result</i></tt> [Note to the issue editor: Please use italics for
<tt><i>result</i></tt>].
This seems somewhat implied by recognizing that both the function
parameter
and the name used in the clause do have the same italic font.
</li>
<li>
The notion of "result" is supposed to mean the value of <tt><i>result</i></tt>
after the
preceding effects clause. This is in fact what all implementations I
checked
do (and which is probably it's intend, because it matches the
specification of <tt>std::copy</tt>).
</li>
</ol>

<p>
The problem is: I see nothing in the standard which grants that this
interpretation
is correct, specifically [lib.structure.specifications] or
17.5.1.4 [structure.specifications]
resp. do not clarify which "look-up" rules apply for names found in
the elements
of the detailed specifications - Do they relate to the corresponding
synopsis or
to the effects clause (or possibly other elements)? Fortunately most
detailed
descriptions are unambigious in this regard, e.g. this problem does
not apply
for <tt>std::copy</tt>.
</p>



<p><b>Proposed resolution:</b></p>
<p>
Change the wording of the return clause to say (20.9.8.2 [uninitialized.copy]):
</p>

<blockquote>
<p>
-2- <i>Returns:</i> <ins>The value of</ins> <tt><i>result</i></tt> <ins>after effects have taken place.</ins>
</p>
</blockquote>


<p><i>[
Bellevue:
]</i></p>


<blockquote>
Resolution: NAD editorial -- project editor to decide if change is
worthwhile. Concern is that there are many other places this might
occur.
</blockquote>




<hr>
<h3><a name="756"></a>756. Container adaptors push</h3>
<p><b>Section:</b> 23.5 [container.adaptors] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Paolo Carlini <b>Opened:</b> 2007-10-31 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#container.adaptors">issues</a> in [container.adaptors].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
After n2369 we have a single <tt>push_back</tt> overload in the sequence containers,
of the "emplace" type. At variance with that, still in n2461, we have
two separate overloads, the C++03 one + one taking an rvalue reference
in the container adaptors. Therefore, simply from a consistency point of
view, I was wondering whether the container adaptors should be aligned
with the specifications of the sequence container themselves: thus have
a single <tt>push</tt> along the lines:
</p>

<blockquote><pre>template&lt;typename... _Args&gt;
void
push(_Args&amp;&amp;... __args)
  { c.push_back(std::forward&lt;_Args&gt;(__args)...); }
</pre></blockquote>

<p><i>[
Related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#767">767</a>
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
Change 23.5.1.1 [queue.defn]:
</p>

<blockquote><pre><del>void push(const value_type&amp; x) { c.push_back(x); }</del>
<del>void push(value_type&amp;&amp; x) { c.push_back(std::move(x)); }</del>
<ins>template&lt;class... Args&gt; void push(Args&amp;&amp;... args) { c.push_back(std::forward&lt;Args&gt;(args)...); }</ins>
</pre></blockquote>

<p>
Change 23.5.2 [priority.queue]:
</p>

<blockquote><pre><del>void push(const value_type&amp; x) { c.push_back(x); }</del>
<del>void push(value_type&amp;&amp; x) { c.push_back(std::move(x)); }</del>
<ins>template&lt;class... Args&gt; void push(Args&amp;&amp;... args) { c.push_back(std::forward&lt;Args&gt;(args)...); }</ins>
</pre></blockquote>

<p>
Change 23.5.2.3 [priqueue.members]:
</p>

<blockquote>
<pre><del>void push(const value_type&amp; x);</del>
</pre>
<blockquote>
<p>
<del><i>Effects:</i></del>
</p>
<blockquote><pre><del>c.push_back(x);</del>
<del>push_heap(c.begin(), c.end(), comp);</del>
</pre></blockquote>
</blockquote>

<pre><ins>template&lt;class... Args&gt;</ins> void push(<del>value_type</del> <ins>Args</ins>&amp;&amp;<ins>...</ins> <del>x</del> <ins>args</ins>);
</pre>
<blockquote>
<p>
<i>Effects:</i>
</p>
<blockquote><pre>c.push_back(std::<del>move</del><ins>forward&lt;Args&gt;</ins>(<del>x</del> <ins>args</ins>)<ins>...</ins>);
push_heap(c.begin(), c.end(), comp);
</pre></blockquote>
</blockquote>
</blockquote>

<p>
Change 23.5.3.1 [stack.defn]:
</p>

<blockquote><pre><del>void push(const value_type&amp; x) { c.push_back(x); }</del>
<del>void push(value_type&amp;&amp; x) { c.push_back(std::move(x)); }</del>
<ins>template&lt;class... Args&gt; void push(Args&amp;&amp;... args) { c.push_back(std::forward&lt;Args&gt;(args)...); }</ins>
</pre></blockquote>



<p><b>Rationale:</b></p>
<p>
Addressed by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2680.pdf">N2680 Proposed Wording for Placement Insert (Revision 1)</a>.
</p>





<hr>
<h3><a name="757"></a>757. Typo in the synopsis of vector</h3>
<p><b>Section:</b> 23.4.1 [vector] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Paolo Carlini <b>Opened:</b> 2007-11-04 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#vector">issues</a> in [vector].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In the synopsis 23.4.1 [vector], there is the signature:
</p>

<blockquote><pre>void insert(const_iterator position, size_type n, T&amp;&amp; x);
</pre></blockquote>

<p>
instead of:
</p>

<blockquote><pre>iterator insert(const_iterator position, T&amp;&amp; x);
</pre></blockquote>

<p>
23.4.1.4 [vector.modifiers] is fine.
</p>



<p><b>Proposed resolution:</b></p>
<p>
Change the synopsis in 23.4.1 [vector]:
</p>

<blockquote><pre>iterator insert(const_iterator position, const T&amp; x); 
<ins>iterator insert(const_iterator position, T&amp;&amp; x);</ins>
void     insert(const_iterator position, size_type n, const T&amp; x); 
<del>void     insert(const_iterator position, size_type n, T&amp;&amp; x);</del>
</pre></blockquote>





<hr>
<h3><a name="760"></a>760. The emplace issue</h3>
<p><b>Section:</b> 23.2 [container.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Future">NAD Future</a>
 <b>Submitter:</b> Paolo Carlini <b>Opened:</b> 2007-11-11 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In an emplace member function the function parameter pack may be bound
to a priori unlimited number of objects: some or all of them can be
elements of the container itself. Apparently, in order to conform to the
blanket statement 23.2 [container.requirements]/11, the
implementation must check all of them for that possibility. A possible
solution can involve extending the exception in 23.2 [container.requirements]/12 also to the emplace member. As a
side note, the <tt>push_back</tt> and <tt>push_front</tt> member
functions are luckily not affected by this problem, can be efficiently
implemented anyway
</p>

<p><i>[
Related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#767">767</a>
]</i></p>


<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
The proposed addition (13) is partially redundant with the existing
paragraph 12. Why was the qualifier "rvalues" added to paragraph 12? Why
does it not cover subelements and pointers?
</p>
<p>
Resolution: Alan Talbot to rework language, then set state to Review.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
The problem is broader than emplace. The LWG doesn't
feel that it knows how to write wording that prohibits all of the
problematic use cases at this time.
</p>
<p>
NAD Future.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add after 23.2 [container.requirements]/12:
</p>

<blockquote>
<p>
-12- Objects passed to member functions of a container as rvalue
references shall not be elements of that container. No diagnostic
required.
</p>
<p>
<ins>
-13- Objects bound to the function parameter pack of the
<tt>emplace</tt> member function shall not be elements or sub-objects of
elements of the container. No diagnostic required.
</ins>
</p>

</blockquote>






<hr>
<h3><a name="763"></a>763. Renaming <tt>emplace()</tt> overloads</h3>
<p><b>Section:</b> 23.2.4 [associative.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Sylvain Pion <b>Opened:</b> 2007-12-04 <b>Last modified:</b> 2010-10-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The associative containers provide 2 overloads of <tt>emplace()</tt>:
</p>

<blockquote><pre>template &lt;class... Args&gt; pair&lt;iterator, bool&gt; emplace(Args&amp;&amp;... args);
template &lt;class... Args&gt; iterator emplace(const_iterator position, Args&amp;&amp;... args);
</pre></blockquote>

<p>
This is a problem if you mean the first overload while passing
a <tt>const_iterator</tt> as first argument.
</p>

<p><i>[
Related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#767">767</a>
]</i></p>


<p><i>[
Bellevue:
]</i></p>


<blockquote>
</blockquote>
<p>
This can be disambiguated by passing "begin" as the first argument in
the case when the non-default choice is desired. We believe that desire
will be rare.
</p>
<p>
Resolution: Change state to NAD.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Rename one of the two overloads.
For example to <tt>emplace_here</tt>, <tt>hint_emplace</tt>...
</p>





<hr>
<h3><a name="764"></a>764. <tt>equal_range</tt> on unordered containers should return a <tt>pair</tt> of <tt>local_iterators</tt></h3>
<p><b>Section:</b> 23.2.5 [unord.req] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Joe Gottman <b>Opened:</b> 2007-11-29 <b>Last modified:</b> 2010-10-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#unord.req">active issues</a> in [unord.req].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unord.req">issues</a> in [unord.req].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
    A major attribute of the unordered containers is that iterating 
though them inside a bucket is very fast while iterating between buckets 
can be much slower.  If an unordered container has a low load factor, 
iterating between the last iterator in one bucket and the next iterator, 
which is in another bucket, is <tt>O(bucket_count())</tt> which may be much 
larger than <tt>O(size())</tt>.
</p>
<p>
    If <tt>b</tt> is an non-const unordered container of type <tt>B</tt> and <tt>k</tt> is an 
object of it's <tt>key_type</tt>, then <tt>b.equal_range(k)</tt> currently returns 
<tt>pair&lt;B::iterator, B::iterator&gt;</tt>. Consider the following code:
</p>

<blockquote><pre>B::iterator lb, ub;
tie(lb, ub) = b.equal_range(k);
for (B::iterator it = lb; it != ub; ++it) {
        // Do something with *it
}
</pre></blockquote>

<p>
If <tt>b.equal_range(k)</tt> returns a non-empty range (i.e. <tt>b</tt> contains at least 
on element whose key is equivalent to <tt>k</tt>), then every iterator in the 
half-open range <tt>[lb, ub)</tt> will be in the same bucket, but <tt>ub</tt> will likely 
either be in a different bucket or be equal to <tt>b.end()</tt>.  In either case, 
iterating between <tt>ub - 1</tt> and <tt>ub</tt> could take a much longer time than 
iterating through the rest of the range.
</p>
<p>
If instead of returning <tt>pair&lt;iterator, iterator&gt;</tt>, <tt>equal_range</tt> were to 
return <tt>pair&lt;local_iterator, local_iterator&gt;</tt>, then <tt>ub</tt> (which, like <tt>lb</tt>, 
would now be a <tt>local_iterator</tt>) could be guaranteed to always be in the 
same bucket as <tt>lb</tt>. In the cases where currently <tt>ub</tt> is equal to <tt>b.end()</tt>
or is in a different bucket, <tt>ub</tt> would be equal to <tt>b.end(b.bucket(key))</tt>. 
  This would make iterating between <tt>lb</tt> and <tt>ub</tt> much faster, as every 
iteration would be constant time.
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
The proposed resolution breaks consistency with other container types
for dubious benefit, and iterators are already constant time.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change the entry for <tt>equal_range</tt> in Table 93 (23.2.5 [unord.req]) as follows:
</p>
<table border="1">
<tbody><tr>
<th>expression</th> <th>return type</th> <th>assertion/note pre/post-condition</th> <th>complexity</th>
</tr>

<tr>
<td><tt>b.equal_range(k)</tt></td>
<td><tt>pair&lt;<ins>local_</ins>iterator,<ins>local_</ins>iterator&gt;; pair&lt;const_<ins>local_</ins>iterator,const_<ins>local_</ins>iterator&gt;</tt> for <tt>const b</tt>.</td>
<td>Returns a range containing all elements with keys equivalent to <tt>k</tt>. Returns <tt>make_pair(b.end(<ins>b.bucket(key)</ins>),b.end(<ins>b.bucket(key)</ins>))</tt> if no such elements exist.</td>
<td>Average case &#920;<tt>(b.count(k))</tt>. Worst case &#920;<tt>(b.size())</tt>. </td>
</tr>
</tbody></table>





<hr>
<h3><a name="767"></a>767. Forwarding and backward compatibility</h3>
<p><b>Section:</b> 23 [containers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Sylvain Pion <b>Opened:</b> 2007-12-28 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#containers">issues</a> in [containers].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Playing with g++'s C++0X mode, I noticed that the following
code, which used to compile:
</p>

<blockquote><pre>#include &lt;vector&gt;

int main()
{
    std::vector&lt;char *&gt; v;
    v.push_back(0);
}
</pre></blockquote>

<p>
now fails with the following error message:
</p>

<blockquote>
.../include/c++/4.3.0/ext/new_allocator.h: In member function 'void __gnu_cxx::new_allocator&lt;_Tp&gt;::construct(_Tp*, _Args&amp;&amp; ...) [with _Args = int, _Tp = char*]':
.../include/c++/4.3.0/bits/stl_vector.h:707:   instantiated from 'void std::vector&lt;_Tp, _Alloc&gt;::push_back(_Args&amp;&amp; ...) [with _Args = int, _Tp = char*, _Alloc = std::allocator&lt;char*&gt;]'
test.cpp:6:   instantiated from here
.../include/c++/4.3.0/ext/new_allocator.h:114: error: invalid conversion from 'int' to 'char*'
</blockquote>

<p>
As far as I know, g++ follows the current draft here.
</p>
<p>
Does the committee really intend to break compatibility for such cases?
</p>

<p><i>[
Sylvain adds: 
]</i></p>


<blockquote>
<p>
I just noticed that <tt>std::pair</tt> has the same issue.
The following now fails with GCC's -std=c++0x mode:
</p>

<blockquote><pre>#include &lt;utility&gt;

int main()
{
   std::pair&lt;char *, char *&gt; p (0,0);
}
</pre></blockquote>

<p>
I have not made any general audit for such problems elsewhere.
</p>
</blockquote>

<p><i>[
Related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#756">756</a>
]</i></p>


<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
Motivation is to handle the old-style int-zero-valued NULL pointers.
Problem: this solution requires concepts in some cases, which some users
will be slow to adopt. Some discussion of alternatives involving
prohibiting variadic forms and additional library-implementation
complexity.
</p>
<p>
Discussion of "perfect world" solutions, the only such solution put
forward being to retroactively prohibit use of the integer zero for a
NULL pointer. This approach was deemed unacceptable given the large
bodies of pre-existing code that do use integer zero for a NULL pointer.
</p>
<p>
Another approach is to change the member names. Yet another approach is
to forbid the extension in absence of concepts.
</p>
<p>
Resolution: These issues (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#756">756</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#767">767</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#760">760</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#763">763</a>) will be subsumed into a
paper to be produced by Alan Talbot in time for review at the 2008
meeting in France. Once this paper is produced, these issues will be
moved to NAD.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add the following rows to Table 90 "Optional sequence container operations", 23.2.3 [sequence.reqmts]:
</p>

<blockquote>
<table border="1">
<tbody><tr>
<th>expression</th> <th>return type</th> <th>assertion/note<br>pre-/post-condition</th> <th>container</th>
</tr>

<tr>
<td>
<tt>a.push_front(t)</tt>
</td>
<td>
<tt>void</tt>
</td>
<td>
<tt>a.insert(a.begin(), t)</tt><br>
<i>Requires:</i> <tt>T</tt> shall be <tt>CopyConstructible</tt>.
</td>
<td>
<tt>list, deque</tt>
</td>
</tr>

<tr>
<td>
<tt>a.push_front(rv)</tt>
</td>
<td>
<tt>void</tt>
</td>
<td>
<tt>a.insert(a.begin(), rv)</tt><br>
<i>Requires:</i> <tt>T</tt> shall be <tt>MoveConstructible</tt>.
</td>
<td>
<tt>list, deque</tt>
</td>
</tr>

<tr>
<td>
<tt>a.push_back(t)</tt>
</td>
<td>
<tt>void</tt>
</td>
<td>
<tt>a.insert(a.end(), t)</tt><br>
<i>Requires:</i> <tt>T</tt> shall be <tt>CopyConstructible</tt>.
</td>
<td>
<tt>list, deque, vector, basic_string</tt>
</td>
</tr>

<tr>
<td>
<tt>a.push_back(rv)</tt>
</td>
<td>
<tt>void</tt>
</td>
<td>
<tt>a.insert(a.end(), rv)</tt><br>
<i>Requires:</i> <tt>T</tt> shall be <tt>MoveConstructible</tt>.
</td>
<td>
<tt>list, deque, vector, basic_string</tt>
</td>
</tr>

</tbody></table>
</blockquote>

<p>
Change the synopsis in 23.3.2 [deque]:
</p>

<blockquote><pre><ins>void push_front(const T&amp; x);</ins>
<ins>void push_front(T&amp;&amp; x);</ins>
<ins>void push_back(const T&amp; x);</ins>
<ins>void push_back(T&amp;&amp; x);</ins>
template &lt;class... Args&gt; <ins>requires Constructible&lt;T, Args&amp;&amp;...&gt;</ins> void push_front(Args&amp;&amp;... args);
template &lt;class... Args&gt; <ins>requires Constructible&lt;T, Args&amp;&amp;...&gt;</ins> void push_back(Args&amp;&amp;... args);
</pre></blockquote>

<p>
Change 23.3.2.3 [deque.modifiers]:
</p>

<blockquote><pre><ins>void push_front(const T&amp; x);</ins>
<ins>void push_front(T&amp;&amp; x);</ins>
<ins>void push_back(const T&amp; x);</ins>
<ins>void push_back(T&amp;&amp; x);</ins>
template &lt;class... Args&gt; <ins>requires Constructible&lt;T, Args&amp;&amp;...&gt;</ins> void push_front(Args&amp;&amp;... args);
template &lt;class... Args&gt; <ins>requires Constructible&lt;T, Args&amp;&amp;...&gt;</ins> void push_back(Args&amp;&amp;... args);
</pre></blockquote>

<p>
Change the synopsis in 23.3.4 [list]:
</p>

<blockquote><pre><ins>void push_front(const T&amp; x);</ins>
<ins>void push_front(T&amp;&amp; x);</ins>
<ins>void push_back(const T&amp; x);</ins>
<ins>void push_back(T&amp;&amp; x);</ins>
template &lt;class... Args&gt; <ins>requires Constructible&lt;T, Args&amp;&amp;...&gt;</ins> void push_front(Args&amp;&amp;... args);
template &lt;class... Args&gt; <ins>requires Constructible&lt;T, Args&amp;&amp;...&gt;</ins> void push_back(Args&amp;&amp;... args);
</pre></blockquote>

<p>
Change 23.3.4.3 [list.modifiers]:
</p>

<blockquote><pre><ins>void push_front(const T&amp; x);</ins>
<ins>void push_front(T&amp;&amp; x);</ins>
<ins>void push_back(const T&amp; x);</ins>
<ins>void push_back(T&amp;&amp; x);</ins>
template &lt;class... Args&gt; <ins>requires Constructible&lt;T, Args&amp;&amp;...&gt;</ins> void push_front(Args&amp;&amp;... args);
template &lt;class... Args&gt; <ins>requires Constructible&lt;T, Args&amp;&amp;...&gt;</ins> void push_back(Args&amp;&amp;... args);
</pre></blockquote>

<p>
Change the synopsis in 23.4.1 [vector]:
</p>

<blockquote><pre><ins>void push_back(const T&amp; x);</ins>
<ins>void push_back(T&amp;&amp; x);</ins>
template &lt;class... Args&gt; <ins>requires Constructible&lt;T, Args&amp;&amp;...&gt;</ins> void push_back(Args&amp;&amp;... args);
</pre></blockquote>

<p>
Change 23.4.1.4 [vector.modifiers]:
</p>

<blockquote><pre><ins>void push_back(const T&amp; x);</ins>
<ins>void push_back(T&amp;&amp; x);</ins>
template &lt;class... Args&gt; <ins>requires Constructible&lt;T, Args&amp;&amp;...&gt;</ins> void push_back(Args&amp;&amp;... args);
</pre></blockquote>




<p><b>Rationale:</b></p>
<p>
Addressed by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2680.pdf">N2680 Proposed Wording for Placement Insert (Revision 1)</a>.
</p>

<p>
If there is still an issue with pair, Howard should submit another issue.
</p>





<hr>
<h3><a name="773"></a>773. issues with random</h3>
<p><b>Section:</b> 26.5.8.1 [rand.dist.uni] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2008-01-14 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.dist.uni">issues</a> in [rand.dist.uni].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<ol>
<li>
26.5.8.1.1 [rand.dist.uni.int] <tt>uniform_int</tt> constructor has changed the default
max constructor parameter from 9 (in TR1) to <tt>max()</tt>. The value
is arbitrary at best and shouldn't be lightly changed because
it breaks backward compatibility.
</li>

<li>
26.5.8.1.1 [rand.dist.uni.int] <tt>uniform_int</tt> has a parameter <tt>param</tt> that you can
provide on construction or <tt>operator()</tt>, set, and get. But there
is not even a hint of what this might be for.
</li>

<li>
26.5.8.1.2 [rand.dist.uni.real] <tt>uniform_real</tt>. Same issue as #2.
</li>
</ol>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
NAD. Withdrawn.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="784"></a>784. unique_lock::release</h3>
<p><b>Section:</b> 30.4.2.2.3 [thread.lock.unique.mod] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Constantine Sapuntzakis <b>Opened:</b> 2008-02-02 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>unique_lock::release</tt> will probably lead to many mistakes where people
call <tt>release</tt> instead of <tt>unlock</tt>. I just coded such a mistake using the
boost pre-1.35 threads library last week.
</p>

<p>
In many threading libraries, a call with <tt>release</tt> in it unlocks the
lock (e.g. ReleaseMutex in Win32, java.util.concurrent.Semaphore).
</p>

<p>
I don't call <tt>unique_lock::lock</tt> much at all, so I don't get to see the
symmetry between <tt>::lock</tt> and <tt>::unlock</tt>. I usually use the constructor to
lock the mutex. So I'm left to remember whether to call <tt>release</tt> or
<tt>unlock</tt> during the few times I need to release the mutex before the scope
ends. If I get it wrong, the compiler doesn't warn me.
</p>

<p>
An alternative name for release may be <tt>disown</tt>.
</p>

<p>
This might be a rare case where usability is hurt by consistency with
the rest of the C++ standard (e.g. <tt>std::auto_ptr::release</tt>).
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
Change a name from release to disown. However prior art uses the release
name. Compatibility with prior art is more important that any possible
benefit such a change might make. We do not see the benefit for
changing. NAD
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change the synopsis in 30.4.2.2 [thread.lock.unique]:
</p>

<blockquote><pre>template &lt;class Mutex&gt; 
class unique_lock 
{ 
public:
   ...
   mutex_type* <del>release</del> <ins>disown</ins>();
   ...
};
</pre></blockquote>

<p>
Change 30.4.2.2.3 [thread.lock.unique.mod]:
</p>

<blockquote><pre>mutex_type *<del>release</del> <ins>disown</ins>();
</pre></blockquote>





<hr>
<h3><a name="785"></a>785. Random Number Requirements in TR1</h3>
<p><b>Section:</b> TR1 5.1.4.5 [tr.rand.eng.disc], TR1 5.1.4.6 [tr.rand.eng.xor] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> John Maddock <b>Opened:</b> 2008-01-15 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Table 16 of TR1 requires that all Pseudo Random Number generators have a
</p>

<blockquote><pre>seed(integer-type s)
</pre></blockquote>

<p>
member function that is equivalent to:
</p>

<blockquote><pre>mygen = Generator(s)
</pre></blockquote>

<p>
But the generators <tt>xor_combine</tt> and <tt>discard_block</tt> have no such seed member, only the
</p>

<blockquote><pre>template &lt;class Gen&gt;
seed(Gen&amp;);
</pre></blockquote>

<p>
member, which will not accept an integer literal as an argument: something that appears to violate the intent of Table 16.
</p>

<p>
So... is this a bug in TR1?
</p>

<p>
This is a real issue BTW, since the Boost implementation does adhere to the requirements of Table 16, while at least one commercial implementation does not and follows a strict adherence to sections 5.1.4.5 and 5.1.4.6 instead.
</p>

<p><i>[
Jens adds:
]</i></p>


<blockquote>
Both engines do have the necessary
constructor, therefore the omission of the <tt>seed()</tt> member
functions appears to be an oversight.
</blockquote>

<p><i>[
Post Summit Daniel adds:
]</i></p>


<blockquote>
Recommend NAD: <tt>xor_combine</tt> does no longer exist and <tt>discard_block[_engine]</tt>
has now the required seed overload accepting a <tt>result_type</tt>, which shall be an
unsigned integral type.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to NAD as recommended.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
NAD Recommended.
</p>





<hr>
<h3><a name="790"></a>790. <tt>xor_combine::seed</tt> not specified</h3>
<p><b>Section:</b> X [rand.adapt.xor] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2008-02-09 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.adapt.xor">issues</a> in [rand.adapt.xor].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>xor_combine::seed(result_type)</tt> and <tt>seed(seed_seq&amp;)</tt> don't say what
happens to each of the sub-engine seeds. (Should probably do the same
to both, unlike TR1.)
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
Overcome by the previous proposal. NAD mooted by resolution of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#789">789</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="791"></a>791. <tt>piecewise_constant_distribution::densities</tt> has wrong name</h3>
<p><b>Section:</b> 26.5.8.5.2 [rand.dist.samp.pconst] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2008-02-09 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.dist.samp.pconst">issues</a> in [rand.dist.samp.pconst].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>piecewise_constant_distribution::densities()</tt> should be <tt>probabilities()</tt>,
just like <tt>discrete_distribution</tt>. (There's no real use for weights divided
by areas.)
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
Fermilab does not agree with this summary. As defined in the equation in
26.4.8.5.2/4, the quantities are indeed probability densities not
probabilities. Because we view this distribution as a parameterization
of a *probability density function*, we prefer to work in terms of
probability densities.
</p>

<p>
We don't think this should be changed.
</p>

<p>
If there is a technical argument about why the implementation dealing
with these values can't be as efficient as one dealing with
probabilities, we might reconsider. We don't care about this one member
function being somewhat more or less efficient; we care about the size
of the distribution object and the speed of the calls to generate
variates.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>

<p>
Change synopsis in 26.5.8.5.2 [rand.dist.samp.pconst]:
</p>

<blockquote><pre>template &lt;class RealType = double&gt; 
class piecewise_constant_distribution 
{ 
public:
    ...
    vector&lt;double&gt; <del>densities</del> <ins>probabilities</ins>() const;
    ...
};
</pre></blockquote>

<p>
Change 26.5.8.5.2 [rand.dist.samp.pconst]/6:
</p>

<blockquote><pre>vector&lt;double&gt; <del>densities</del> <ins>probabilities</ins>() const;
</pre></blockquote>






<hr>
<h3><a name="793"></a>793. <tt>discrete_distribution</tt> missing constructor</h3>
<p><b>Section:</b> 26.5.8.5.1 [rand.dist.samp.discrete] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2008-02-09 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.dist.samp.discrete">issues</a> in [rand.dist.samp.discrete].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>discrete_distribution</tt> should have a constructor like:
</p>

<blockquote><pre>template&lt;class _Fn&gt;
  discrete_distribution(result_type _Count, double _Low, double _High,
                        _Fn&amp; _Func);
</pre></blockquote>

<p>
(Makes it easier to fill a histogram with function values over a range.)
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
How do you specify the function so that it does not return negative
values? If you do it is a bad construction. This requirement is already
there. Where in each bin does one evaluate the function? In the middle.
Need to revisit tomorrow.
</blockquote>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
<p>
Bill is not requesting this.
</p>
<p>
Marc Paterno: <tt>_Fn</tt> cannot return negative values at the points where the
function is sampled. It is sampled in the middle of each bin. <tt>_Fn</tt> cannot
return 0 everywhere it is sampled.
</p>
<p>
Jens: lambda expressions are rvalues
</p>
<p>
Add a library issue to provide an
<tt>initializer_list&lt;double&gt;</tt> constructor for
<tt>discrete_distribution</tt>.
</p>
<p>
Marc Paterno: dislikes reference for <tt>_Fn</tt> parameter. Make it pass-by-value (to use lambda),
use <tt>std::ref</tt> to wrap giant-state function objects.
</p>
<p>
Daniel: See <tt>random_shuffle</tt>, pass-by-rvalue-reference.
</p>
<p>
Daniel to draft wording.
</p>
</blockquote>

<p><i>[
Pre San Francisco, Daniel provided wording:
]</i></p>


<blockquote>
The here proposed changes of the WP refer to the current state of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2691.pdf">N2691</a>.
During the Sophia Antipolis meeting two different proposals came up
regarding the functor argument type, either by value or by rvalue-reference.
For consistence with existing conventions (state-free algorithms and the
<tt>general_pdf_distribution</tt> c'tor signature) the author decided to propose a
function argument that is provided by value. If severe concerns exists that
stateful functions would be of dominant relevance, it should be possible to
replace the two occurrences of <tt>Func</tt> by <tt>Func&amp;&amp;</tt> in this proposal as part
of an editorial process.
</blockquote>



<p><b>Proposed resolution:</b></p>

<p><b>Non-concept version of the proposed resolution</b></p>

<ol>
<li>
<p>
In 26.5.8.5.1 [rand.dist.samp.discrete]/1, class <tt>discrete_distribution</tt>, just
<em>before</em> the member declaration
</p>

<blockquote><pre>explicit discrete_distribution(const param_type&amp; parm);
</pre></blockquote>

<p>
insert:
</p>


<blockquote><pre>template&lt;typename Func&gt;
discrete_distribution(result_type nf, double xmin, double xmax, Func fw);
</pre></blockquote>
</li>

<li>
<p>
Between p.4 and p.5 insert a series of new paragraphs as part of the
new member description::
</p>
<blockquote><pre>template&lt;typename Func&gt;
discrete_distribution(result_type nf, double xmin, double xmax, Func fw);
</pre>

<p>
<i>Complexity:</i> Exactly nf invocations of fw.
</p>
<p>
<i>Requires:</i>
</p>
<ol type="a">
<li>
fw shall be callable with one argument of type double, and shall
return values of a type convertible to double;</li>

<li>If nf &gt; 0, the relation <tt><i>x</i><sub><i>min</i></sub></tt> &lt; <tt><i>x</i><sub><i>max</i></sub></tt> shall hold, and for all sample values
<tt><i>x</i><sub><i>k</i></sub></tt>, fw(<tt><i>x</i><sub><i>k</i></sub></tt>) shall return a weight value <tt><i>w</i><sub><i>k</i></sub></tt> that is non-negative, non-NaN,
and non-infinity;</li>

<li>The following relations shall hold: nf &#8805; 0, and 0 &lt; S = <tt><i>w</i><sub><i>0</i></sub></tt>+. . .+<tt><i>w<sub>n-1</sub></i></tt>.</li>

</ol>

<p>
<i>Effects:</i>
</p>
<ol type="a">
<li>If nf == 0, sets n = 1 and lets the sequence w have length n = 1 and
   consist of the single value <tt><i>w</i><sub><i>0</i></sub></tt> = 1.</li>

<li>
<p>Otherwise, sets n = nf, deltax = (<tt><i>x</i><sub><i>max</i></sub></tt> - <tt><i>x</i><sub><i>min</i></sub></tt>)/n and <tt><i>x</i><sub><i>cent</i></sub></tt> = <tt><i>x</i><sub><i>min</i></sub></tt> +
0.5 * deltax.</p>
<blockquote><pre>For each k = 0, . . . ,n-1, calculates:
  <tt><i>x</i><sub><i>k</i></sub></tt> = <tt><i>x</i><sub><i>cent</i></sub></tt> + k * deltax
  <tt><i>w</i><sub><i>k</i></sub></tt> = fw(<tt><i>x</i><sub><i>k</i></sub></tt>)
</pre></blockquote>
</li>
<li>
<p>Constructs a discrete_distribution object with probabilities:</p>
<blockquote><pre><tt><i>p</i><sub><i>k</i></sub></tt> = <tt><i>w</i><sub><i>k</i></sub></tt>/S  for k = 0, . . . , n-1.
</pre></blockquote>
</li>
</ol>
</blockquote>
</li>
</ol>

<p><b>Concept version of the proposed resolution</b></p>


<ol>
<li>
<p>
In 26.5.8.5.1 [rand.dist.samp.discrete]/1, class <tt>discrete_distribution</tt>, just
<em>before</em> the member declaration
</p>

<blockquote><pre>explicit discrete_distribution(const param_type&amp; parm);
</pre></blockquote>

<p>
insert:
</p>


<blockquote><pre>template&lt;Callable&lt;auto, double&gt; Func&gt;
 requires Convertible&lt;Func::result_type, double&gt;
discrete_distribution(result_type nf, double xmin, double xmax, Func fw);
</pre></blockquote>
</li>

<li>
<p>
Between p.4 and p.5 insert a series of new paragraphs as part of the
new member description::
</p>
<blockquote><pre>template&lt;Callable&lt;auto, double&gt; Func&gt;
 requires Convertible&lt;Func::result_type, double&gt;
discrete_distribution(result_type nf, double xmin, double xmax, Func fw);
</pre>

<p>
<i>Complexity:</i> Exactly nf invocations of fw.
</p>
<p>
<i>Requires:</i>
</p>
<ol type="a">
<li>If nf &gt; 0, the relation <tt><i>x</i><sub><i>min</i></sub></tt> &lt; <tt><i>x</i><sub><i>max</i></sub></tt> shall hold, and for all sample values
<tt><i>x</i><sub><i>k</i></sub></tt>, fw(<tt><i>x</i><sub><i>k</i></sub></tt>) shall return a weight value <tt><i>w</i><sub><i>k</i></sub></tt> that is non-negative, non-NaN,
and non-infinity;</li>

<li>The following relations shall hold: nf &#8805; 0, and 0 &lt; S = <tt><i>w</i><sub><i>0</i></sub></tt>+. . .+<tt><i>w<sub>n-1</sub></i></tt>.</li>

</ol>

<p>
<i>Effects:</i>
</p>
<ol type="a">
<li>If nf == 0, sets n = 1 and lets the sequence w have length n = 1 and
   consist of the single value <tt><i>w</i><sub><i>0</i></sub></tt> = 1.</li>

<li>
<p>Otherwise, sets n = nf, deltax = (<tt><i>x</i><sub><i>max</i></sub></tt> - <tt><i>x</i><sub><i>min</i></sub></tt>)/n and <tt><i>x</i><sub><i>cent</i></sub></tt> = <tt><i>x</i><sub><i>min</i></sub></tt> +
0.5 * deltax.</p>
<blockquote><pre>For each k = 0, . . . ,n-1, calculates:
  <tt><i>x</i><sub><i>k</i></sub></tt> = <tt><i>x</i><sub><i>cent</i></sub></tt> + k * deltax
  <tt><i>w</i><sub><i>k</i></sub></tt> = fw(<tt><i>x</i><sub><i>k</i></sub></tt>)
</pre></blockquote>
</li>
<li>
<p>Constructs a discrete_distribution object with probabilities:</p>
<blockquote><pre><tt><i>p</i><sub><i>k</i></sub></tt> = <tt><i>w</i><sub><i>k</i></sub></tt>/S  for k = 0, . . . , n-1.
</pre></blockquote>
</li>
</ol>
</blockquote>
</li>
</ol>



<p><b>Rationale:</b></p>
Addressed by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2836.pdf">N2836</a> "Wording Tweaks for Concept-enabled Random Number Generation in C++0X".





<hr>
<h3><a name="794"></a>794. <tt>piecewise_constant_distribution</tt> missing constructor</h3>
<p><b>Section:</b> 26.5.8.5.2 [rand.dist.samp.pconst] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2008-02-09 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.dist.samp.pconst">issues</a> in [rand.dist.samp.pconst].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>piecewise_constant_distribution</tt> should have a constructor like:
</p>

<blockquote><pre>template&lt;class _Fn&gt;
   piecewise_constant_distribution(size_t _Count,
            _Ty _Low, _Ty _High, _Fn&amp; _Func);
</pre></blockquote>

<p>
(Makes it easier to fill a histogram with function values over a range.
The two (reference <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#793">793</a>) make a sensible replacement for
<tt>general_pdf_distribution</tt>.)
</p>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
<p>
Marc: uses variable width of bins and weight for each bin. This is not
giving enough flexibility to control both variables.
</p>
<p>
Add a library issue to provide an constructor taking an
<tt>initializer_list&lt;double&gt;</tt> and <tt>_Fn</tt> for <tt>piecewise_constant_distribution</tt>.
</p>
<p>
Daniel to draft wording.
</p>
</blockquote>

<p><i>[
Pre San Francisco, Daniel provided wording.
]</i></p>


<blockquote>
The here proposed changes of the WP refer to the current state of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2691.pdf">N2691</a>.
For reasons explained in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#793">793</a>, the author decided to propose a function
argument that is provided by value. The issue proposes a c'tor signature,
that does not take advantage of the full flexibility of
<tt>piecewise_constant_distribution</tt>,
because it restricts on a constant bin width, but the use-case seems to
be popular enough to justify it's introduction.
</blockquote>



<p><b>Proposed resolution:</b></p>

<p><b>Non-concept version of the proposed resolution</b></p>

<ol>
<li>
<p>
In 26.5.8.5.2 [rand.dist.samp.pconst]/1, class <tt>piecewise_constant_distribution</tt>,
just <em>before</em> the member declaration
</p>

<blockquote><pre>explicit piecewise_constant_distribution(const param_type&amp; parm);
</pre></blockquote>
<p>
insert:
</p>
<blockquote><pre>template&lt;typename Func&gt;
piecewise_constant_distribution(size_t nf, RealType xmin, RealType xmax, Func fw);
</pre></blockquote>
</li>

<li>
<p>
Between p.4 and p.5 insert a new sequence of paragraphs nominated
below as [p5_1], [p5_2],
[p5_3], and [p5_4] as part of the new member description:
</p>

<blockquote><pre>template&lt;typename Func&gt;
piecewise_constant_distribution(size_t nf, RealType xmin, RealType xmax, Func fw);
</pre>
<blockquote>
<p>
[p5_1] <i>Complexity:</i> Exactly <tt>nf</tt> invocations of <tt>fw</tt>.
</p>
<p>
[p5_2] <i>Requires:</i>
</p>
<ol type="a">
<li><tt>fw</tt> shall be callable with one argument of type <tt>RealType</tt>, and shall
return values of a type convertible to double;
</li>
<li>
For all sample values <tt><i>x<sub>k</sub></i></tt> defined below, fw(<tt><i>x<sub>k</sub></i></tt>) shall return a weight
value <tt><i>w<sub>k</sub></i></tt> that is non-negative, non-NaN, and non-infinity;
</li>
<li>
The following relations shall hold: <tt><i>x<sub>min</sub></i></tt> &lt; <tt><i>x<sub>max</sub></i></tt>, and
0 &lt; S = <tt><i>w<sub>0</sub></i></tt>+. . .+<tt><i>w<sub>n-1</sub></i></tt>.
</li>
</ol>
<p>
[p5_3] <i>Effects:</i>
</p>
<ol type="a">
<li>
<p>If nf == 0,</p>
 <ol type="a">
 <li>
sets deltax = <tt><i>x<sub>max</sub></i></tt> - <tt><i>x<sub>min</sub></i></tt>, and</li>
<li> lets the sequence <tt>w</tt> have length <tt>n = 1</tt> and consist of the single
    value <tt><i>w<sub>0</sub></i></tt> = 1, and</li>
<li> lets the sequence <tt>b</tt> have length <tt>n+1</tt> with <tt><i>b<sub>0</sub></i></tt> = <tt><i>x<sub>min</sub></i></tt> and 
              <tt><i>b<sub>1</sub></i></tt> = <tt><i>x<sub>max</sub></i></tt>
</li>
</ol>
</li>
<li>
<p>Otherwise,</p>
<ol type="a">
<li> sets <tt>n = nf</tt>, <tt>deltax = </tt>(<tt><i>x<sub>max</sub></i></tt> - <tt><i>x<sub>min</sub></i></tt>)/n,
                 <tt><i>x<sub>cent</sub></i></tt> = <tt><i>x<sub>min</sub></i></tt> + 0.5 * deltax, and
</li>
<li><p>lets the sequences <tt>w</tt> and <tt>b</tt> have length <tt>n</tt> and <tt>n+1</tt>, resp. and</p>
<blockquote><pre>for each k = 0, . . . ,n-1, calculates:
  <tt><i>dx<sub>k</sub></i></tt> = k * deltax
  <tt><i>b<sub>k</sub></i></tt> = <tt><i>x<sub>min</sub></i></tt> + <tt><i>dx<sub>k</sub></i></tt>
  <tt><i>x<sub>k</sub></i></tt> = <tt><i>x<sub>cent</sub></i></tt> + <tt><i>dx<sub>k</sub></i></tt>
  <tt><i>w<sub>k</sub></i></tt> = fw(<tt><i>x<sub>k</sub></i></tt>),
</pre></blockquote> 
<p> and</p>
</li>
<li> sets <tt><i>b<sub>n</sub></i></tt> = <tt><i>x<sub>max</sub></i></tt></li>
</ol>
</li>
<li>
<p>
Constructs a <tt>piecewise_constant_distribution</tt> object with
the above computed sequence <tt>b</tt> as the interval boundaries
and with the probability densities:
</p>
<blockquote><pre><tt><i>&#961;<sub>k</sub></i></tt> = <tt><i>w<sub>k</sub></i></tt>/(S * deltax)  for k = 0, . . . , n-1.
</pre></blockquote> 
</li>
</ol>
<p>
[p5_4] [<i>Note:</i> In this context, the subintervals [<tt><i>b<sub>k</sub></i></tt>, <tt><i>b<sub>k+1</sub></i></tt>) are commonly
 known as the <i>bins</i> of a histogram. <i>-- end note</i>]
 </p>
</blockquote>
</blockquote>
</li>
</ol>

<p><b>Concept version of the proposed resolution</b></p>

<ol>
<li>
<p>
In 26.5.8.5.2 [rand.dist.samp.pconst]/1, class <tt>piecewise_constant_distribution</tt>,
just <em>before</em> the member declaration
</p>

<blockquote><pre>explicit piecewise_constant_distribution(const param_type&amp; parm);
</pre></blockquote>
<p>
insert:
</p>
<blockquote><pre>template&lt;Callable&lt;auto, RealType&gt; Func&gt;
 requires Convertible&lt;Func::result_type, double&gt;
piecewise_constant_distribution(size_t nf, RealType xmin, RealType xmax, Func fw);
</pre></blockquote>
</li>

<li>
<p>
Between p.4 and p.5 insert a new sequence of paragraphs nominated
below as [p5_1], [p5_2],
[p5_3], and [p5_4] as part of the new member description:
</p>

<blockquote><pre>template&lt;Callable&lt;auto, RealType&gt; Func&gt;
 requires Convertible&lt;Func::result_type, double&gt;
piecewise_constant_distribution(size_t nf, RealType xmin, RealType xmax, Func fw);
</pre>
<blockquote>
<p>
[p5_1] <i>Complexity:</i> Exactly <tt>nf</tt> invocations of <tt>fw</tt>.
</p>
<p>
[p5_2] <i>Requires:</i>
</p>
<ol type="a">
<li>
For all sample values <tt><i>x<sub>k</sub></i></tt> defined below, fw(<tt><i>x<sub>k</sub></i></tt>) shall return a weight
value <tt><i>w<sub>k</sub></i></tt> that is non-negative, non-NaN, and non-infinity;
</li>
<li>
The following relations shall hold: <tt><i>x<sub>min</sub></i></tt> &lt; <tt><i>x<sub>max</sub></i></tt>, and
0 &lt; S = <tt><i>w<sub>0</sub></i></tt>+. . .+<tt><i>w<sub>n-1</sub></i></tt>.
</li>
</ol>
<p>
[p5_3] <i>Effects:</i>
</p>
<ol type="a">
<li>
<p>If nf == 0,</p>
 <ol type="a">
 <li>
sets deltax = <tt><i>x<sub>max</sub></i></tt> - <tt><i>x<sub>min</sub></i></tt>, and</li>
<li> lets the sequence <tt>w</tt> have length <tt>n = 1</tt> and consist of the single
    value <tt><i>w<sub>0</sub></i></tt> = 1, and</li>
<li> lets the sequence <tt>b</tt> have length <tt>n+1</tt> with <tt><i>b<sub>0</sub></i></tt> = <tt><i>x<sub>min</sub></i></tt> and 
              <tt><i>b<sub>1</sub></i></tt> = <tt><i>x<sub>max</sub></i></tt>
</li>
</ol>
</li>
<li>
<p>Otherwise,</p>
<ol type="a">
<li> sets <tt>n = nf</tt>, <tt>deltax = </tt>(<tt><i>x<sub>max</sub></i></tt> - <tt><i>x<sub>min</sub></i></tt>)/n,
                 <tt><i>x<sub>cent</sub></i></tt> = <tt><i>x<sub>min</sub></i></tt> + 0.5 * deltax, and
</li>
<li><p>lets the sequences <tt>w</tt> and <tt>b</tt> have length <tt>n</tt> and <tt>n+1</tt>, resp. and</p>
<blockquote><pre>for each k = 0, . . . ,n-1, calculates:
  <tt><i>dx<sub>k</sub></i></tt> = k * deltax
  <tt><i>b<sub>k</sub></i></tt> = <tt><i>x<sub>min</sub></i></tt> + <tt><i>dx<sub>k</sub></i></tt>
  <tt><i>x<sub>k</sub></i></tt> = <tt><i>x<sub>cent</sub></i></tt> + <tt><i>dx<sub>k</sub></i></tt>
  <tt><i>w<sub>k</sub></i></tt> = fw(<tt><i>x<sub>k</sub></i></tt>),
</pre></blockquote> 
<p> and</p>
</li>
<li> sets <tt><i>b<sub>n</sub></i></tt> = <tt><i>x<sub>max</sub></i></tt></li>
</ol>
</li>
<li>
<p>
Constructs a <tt>piecewise_constant_distribution</tt> object with
the above computed sequence <tt>b</tt> as the interval boundaries
and with the probability densities:
</p>
<blockquote><pre><tt><i>&#961;<sub>k</sub></i></tt> = <tt><i>w<sub>k</sub></i></tt>/(S * deltax)  for k = 0, . . . , n-1.
</pre></blockquote> 
</li>
</ol>
<p>
[p5_4] [<i>Note:</i> In this context, the subintervals [<tt><i>b<sub>k</sub></i></tt>, <tt><i>b<sub>k+1</sub></i></tt>) are commonly
 known as the <i>bins</i> of a histogram. <i>-- end note</i>]
 </p>
</blockquote>
</blockquote>
</li>
</ol>



<p><b>Rationale:</b></p>
Addressed by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2836.pdf">N2836</a> "Wording Tweaks for Concept-enabled Random Number Generation in C++0X".





<hr>
<h3><a name="795"></a>795. <tt>general_pdf_distribution</tt> should be dropped</h3>
<p><b>Section:</b> X [rand.dist.samp.genpdf] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2008-02-09 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.dist.samp.genpdf">issues</a> in [rand.dist.samp.genpdf].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#732">732</a></p>
<p><b>Discussion:</b></p>
<p>
<tt>general_pdf_distribution</tt> should be dropped. (It's a research topic in
adaptive numerical integration.)
</p>

<p><i>[
Stephan Tolksdorf notes:
]</i></p>


<blockquote>
This appears to be a duplicate of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#732">732</a>.
</blockquote>


<p><b>Proposed resolution:</b></p>






<hr>
<h3><a name="796"></a>796. <tt>ranlux48_base</tt> returns wrong value</h3>
<p><b>Section:</b> 26.5.5 [rand.predef] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2008-02-09 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.predef">issues</a> in [rand.predef].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The 10,000<sup>th</sup> value returned by <tt>ranlux48_base</tt> is supposed to be
61839128582725. We get 192113843633948. (Note that the underlying
generator was changed in Kona.)
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
Submitter withdraws defect.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 26.5.5 [rand.predef]/p5:
</p>

<blockquote>
<pre>typedef subtract_with_carry_engine&lt;uint_fast64_t, 48, 5, 12&gt; 
        ranlux48_base; 
</pre>
<blockquote>
<i>Required behavior:</i> The 10000<sup>th</sup> consecutive invocation of a default-constructed
object of type <tt>ranlux48_base</tt> shall produce the value
<del>61839128582725</del> <ins>192113843633948</ins>.
</blockquote>
</blockquote>





<hr>
<h3><a name="797"></a>797. <tt>ranlux48</tt> returns wrong value</h3>
<p><b>Section:</b> 26.5.5 [rand.predef] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2008-02-09 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.predef">issues</a> in [rand.predef].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The 10,000<sup>th</sup> value returned by <tt>ranlux48</tt> is supposed to be
249142670248501. We get 88229545517833. (Note that this depends
on <tt>ranlux48_base</tt>.)
</p>
<p><i>[
Bellevue:
]</i></p>


<blockquote>
Submitter withdraws defect.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 26.5.5 [rand.predef]/p6:
</p>

<blockquote>
<pre>typedef discard_block_engine&lt;ranlux48_base, 389, 11&gt; 
        ranlux48
</pre>
<blockquote>
<i>Required behavior:</i> The 10000<sup>th</sup> consecutive invocation of a default-constructed
object of type <tt>ranlux48</tt> shall produce the value
<del>249142670248501</del> <ins>88229545517833</ins>.
</blockquote>
</blockquote>





<hr>
<h3><a name="799"></a>799. [tr.rand.eng.mers] and [rand.eng.mers]</h3>
<p><b>Section:</b> 26.5.3.2 [rand.eng.mers], TR1 5.1.4.2 [tr.rand.eng.mers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Stephan Tolksdorf <b>Opened:</b> 2008-02-18 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.eng.mers">issues</a> in [rand.eng.mers].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
TR1 5.1.4.2 [tr.rand.eng.mers](10) requires that <tt>operator==</tt> for the <tt>mersenne_twister</tt>
returns <tt>true</tt> if and only if the states of two <tt>mersenne_twisters</tt>,
consisting each of <tt>n</tt> integers between <tt>0</tt> and <tt>2<sup>w</sup> - 1</tt>, are completely
equal. This is a contradiction with TR1 5.1.1 [tr.rand.req](3) because the given
definition of the state also includes the lower <tt>r</tt> bits of <tt>x(i-n)</tt>, which
will never be used to generate a random number. If two <tt>mersenne_twister</tt>s
only differ in the lower bits of <tt>x(i-n)</tt> they will not compare equal,
although they will produce an identical sequence of random numbers.
</p>

<p>
26.5.3.2 [rand.eng.mers] in the latest C++ draft does not specify the behaviour
of <tt>operator==</tt> but uses a similar definition of the state and, just like
TR1 5.1.4.2 [tr.rand.eng.mers], requires the textual representation of a
<tt>mersenne_twister_engine</tt> to consist of <tt>X<sub>i-n</sub></tt> to <tt>X<sub>i-1</sub></tt>, including the
lower bits of <tt>X<sub>i-n</sub></tt>. This leads to two problems: First, the
unsuspecting implementer is likely to erroneously compare the lower <tt>r</tt>
bits of <tt>X<sub>i-n</sub></tt> in <tt>operator==</tt>. Second, if only the lower <tt>r</tt> bits differ,
two <tt>mersenne_twister_engine</tt>s will compare equal (if correctly
implemented) but have different textual representations, which
conceptually is a bit ugly.
</p>

<p>
I propose that a paragraph or footnote is added to 26.5.3.2 [rand.eng.mers] which
clarifies that the lower <tt>r</tt> bits of <tt>X<sub>i-n</sub></tt> are not to be compared in
<tt>operator==</tt> and <tt>operator!=</tt>. It would only be consequent if furthermore
the specification for the textual respresentation was changed to
<tt>X<sub>i-n</sub> bitand ((2<sup>w</sup> - 1) - (2<sup>r</sup> - 1)), X<sub>i-(n-1)</sub>, ...,  X<sub>i-1</sub></tt> or
something similar.
</p>

<p>
These changes would likely have no practical effect, but would allow an
implementation that does the right thing to be standard-conformant.
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
Fermi Lab has no objection to the proposed change. However it feels that
more time is needed to check the details, which would suggest a change
to REVIEW.
</p>
<p>
Bill feels that this is NAD, not enough practical importance to abandon
the simple definition of equality, and someone would have to do a lot
more study to ensure that all cases are covered for a very small
payback. The submitter admits that "These changes would likely have no
practical effect,", and according to Plum's razor this means that it is
not worth the effort!
</p>
<p>
Revisted: Agree that the fact that there is no practical difference means that no change can be justified.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
In 26.5.3.2 [rand.eng.mers]:
</p>

<blockquote>
<p>
Insert at the end of para 2.:
</p>

<blockquote>
[<i>Note:</i> The lower <tt>r</tt> bits of <tt>X<sub>i-n</sub></tt> do not influence
the state transition and hence should not be compared when comparing two
<tt>mersenne_twister_engine</tt> objects. <i>-- end note</i>]
</blockquote>

<p>
In para 5. change:
</p>

<blockquote>
The textual representation of <tt>x<sub>i</sub></tt> consists of the values of
<tt>X<sub>i-n</sub> <ins>bitand ((2<sup>w</sup> - 1) - (2<sup>r</sup> - 1)),  X<sub>i-(n-1)</sub></ins>,
..., X<sub>i-1</sub></tt>, in that order.
</blockquote>
</blockquote>





<hr>
<h3><a name="800"></a>800. Issues in 26.4.7.1 [rand.util.seedseq](6)</h3>
<p><b>Section:</b> 26.5.7.1 [rand.util.seedseq] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Stephan Tolksdorf <b>Opened:</b> 2008-02-18 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.util.seedseq">issues</a> in [rand.util.seedseq].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The for-loop in the algorithm specification has <tt>n</tt> iterations, where <tt>n</tt> is
defined to be <tt>end - begin</tt>, i.e. the number of supplied w-bit quantities.
Previous versions of this algorithm and the general logic behind it
suggest that this is an oversight and that in the context of the
for-loop <tt>n</tt> should be the number of full 32-bit quantities in <tt>b</tt> (rounded
upwards). If <tt>w</tt> is 64, the current algorithm throws away half of all bits
in <tt>b</tt>. If <tt>w</tt> is 16, the current algorithm sets half of all elements in <tt>v</tt>
to 0.
</p>

<p>
There are two more minor issues:
</p>

<ul>
<li>
Strictly speaking <tt>end - begin</tt> is not defined since
<tt>InputIterator</tt> is not required to be a random access iterator.
</li>
<li>
Currently all integral types are allowed as input to the <tt>seed_seq</tt>
constructor, including <tt>bool</tt>. IMHO allowing <tt>bool</tt>s unnecessarily
complicates the implementation without any real benefit to the user.
I'd suggest to exclude <tt>bool</tt>s as input.
</li>
</ul>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
Move to OPEN Bill will try to propose a resolution by the next meeting.
</blockquote>

<p><i>[
post Bellevue:  Bill provided wording.
]</i></p>


<p>
This issue is made moot if <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#803">803</a> is accepted.
</p>



<p><b>Proposed resolution:</b></p>
<p>
Replace 26.5.7.1 [rand.util.seedseq] paragraph 6 with:
</p>

<blockquote>
<p>
<i>Effects:</i> Constructs a <tt>seed_seq</tt> object by effectively concatenating the
low-order <tt>u</tt> bits of each of the elements of the supplied sequence <tt>[begin,
end)</tt>
in ascending order of significance to make a (possibly very large) unsigned
binary number <tt>b</tt> having a total of <tt>n</tt> bits, and then carrying out the
following
algorithm:
</p>

<blockquote><pre>for( v.clear(); n &gt; 0; n -= 32 )
   v.push_back(b mod 2<sup>32</sup>), b /= 2<sup>32</sup>;
</pre></blockquote>
</blockquote>


<p><b>Rationale:</b></p>
Addressed by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2836.pdf">N2836</a> "Wording Tweaks for Concept-enabled Random Number Generation in C++0X".





<hr>
<h3><a name="802"></a>802. <tt>knuth_b</tt> returns wrong value</h3>
<p><b>Section:</b> 26.5.5 [rand.predef] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2008-02-20 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.predef">issues</a> in [rand.predef].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The 10,000<sup>th</sup> value returned by <tt>knuth_b</tt> is supposed to be
1112339016. We get 2126698284.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 26.5.5 [rand.predef]/p8:
</p>

<blockquote>
<pre>typedef shuffle_order_engine&lt;minstd_rand0, 256&gt; 
        knuth_b; 
</pre>
<blockquote>
<i>Required behavior:</i> The 10000<sup>th</sup> consecutive invocation of a default-constructed
object of type <tt>knuth_b</tt> shall produce the value
<del>1112339016</del> <ins>2126698284</ins>.
</blockquote>
</blockquote>


<p><i>[
Bellevue: Submitter withdraws defect. "We got the wrong value for entirely the right reasons". NAD.
]</i></p>





<hr>
<h3><a name="803"></a>803. Simplification of <tt>seed_seq::seq_seq</tt></h3>
<p><b>Section:</b> 26.5.7.1 [rand.util.seedseq] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Charles Karney <b>Opened:</b> 2008-02-22 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.util.seedseq">issues</a> in [rand.util.seedseq].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>seed_seq(InputIterator begin, InputIterator end);</tt> constructs a <tt>seed_seq</tt>
object repacking the bits of supplied sequence <tt>[begin, end)</tt> into a
32-bit vector.
</p>
<p>
This repacking triggers several problems:
</p>
<ol>
<li>
Distinctness of the output of <tt>seed_seq::generate</tt> required the
introduction of the initial "<tt>if (w &lt; 32) v.push_back(n);</tt>"  (Otherwise
the unsigned short vectors [1, 0] and [1] generate the same sequence.)
</li>
<li>
Portability demanded the introduction of the template parameter <tt>u</tt>.
(Otherwise some sequences could not be obtained on computers where no
integer types are exactly 32-bits wide.)
</li>
<li>
The description and algorithm have become unduly complicated.
</li>
</ol>
<p>
I propose simplifying this <tt>seed_seq</tt> constructor to be "32-bit only".
Despite it's being simpler, there is NO loss of functionality (see
below).
</p>
<p>
Here's how the description would read
</p>
<blockquote>
<p>
26.5.7.1 [rand.util.seedseq] Class <tt>seed_seq</tt>
</p>

<blockquote>
<pre>template&lt;class InputIterator&gt;
  seed_seq(InputIterator begin, InputIterator end);
</pre>
<blockquote>
<p>
5 <i>Requires:</i> NO CHANGE
</p>
<p>
6 <i>Effects:</i> Constructs a <tt>seed_seq</tt> object by
</p>
<blockquote>
<pre>for (InputIterator s = begin; s != end; ++s)
   v.push_back((*s) mod 2^32);
</pre>
</blockquote>
</blockquote>
</blockquote>
</blockquote>

<p>
Discussion:
</p>
<p>
The chief virtues here are simplicity, portability, and generality.
</p>
<ul>
<li>
Simplicity -- compare the above specification with the
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2461.pdf">n2461</a> proposal.
</li>
<li>
Portability -- with <tt>iterator_traits&lt;InputIterator&gt;::value_type =
uint_least32_t</tt> the user is guaranteed to get the same behavior across
platforms.
</li>
<li>
Generality -- any behavior that the
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2461.pdf">n2461</a>
proposal can achieve can be
obtained with this simpler proposal (albeit with a shuffling of bits
in the input sequence).
</li>
</ul>
<p>
Arguments (and counter-arguments) against making this change (and
retaining the
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2461.pdf">n2461</a>
behavior) are:
</p>
<ul>
<li>
<p>
The user can pass an array of <tt>unsigned char</tt> and <tt>seed_seq</tt> will nicely
 repack it.
</p>
<p>
 Response: So what?  Consider the seed string "ABC".  The
 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2461.pdf">n2461</a>
 proposal results in
</p>
<blockquote><pre>v = { 0x3, 0x434241 };
</pre></blockquote>
<p>
while the simplified proposal yields
</p>
<blockquote><pre>v = { 0x41, 0x42, 0x43 };
</pre></blockquote>
<p>
The results produced by <tt>seed_seq::generate</tt> with the two inputs are
different but nevertheless equivalently "mixed up" and this remains
true even if the seed string is long.
</p>
</li>
<li>
<p>
With long strings (e.g., with bit-length comparable to the number of
 bits in the state), <tt>v</tt> is longer (by a factor of 4) with the simplified
 proposal and <tt>seed_seq::generate</tt> will be slower.
</p>
<p>
Response: It's unlikely that the efficiency of <tt>seed_seq::generate</tt> will
 be a big issue.  If it is, the user is free to repack the seed vector
 before constructing <tt>seed_seq</tt>.
</p>
</li>
<li>
<p>
A user can pass an array of 64-bit integers and all the bits will be
 used.
</p>
<p>
 Response: Indeed.  However, there are many instances in the 
 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2461.pdf">n2461</a>
 where integers are silently coerced to a narrower width and this
 should just be a case of the user needing to read the documentation.
 The user can of course get equivalent behavior by repacking his seed
 into 32-bit pieces.  Furthermore, the unportability of the 
 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2461.pdf">n2461</a>
 proposal with
</p>
<blockquote><pre>unsigned long s[] = {1, 2, 3, 4};
seed_seq q(s, s+4);
</pre></blockquote>
<p>
 which typically results in <tt>v = {1, 2, 3, 4}</tt> on 32-bit machines and in
<tt>v = {1, 0, 2, 0, 3, 0, 4, 0}</tt> on 64-bit machines is a major pitfall for
 unsuspecting users.
</p>
</li>
</ul>

<p>
Note: this proposal renders moot issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#782">782</a> and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#800">800</a>.
</p>

<p><i>[
Bellevue:
]</i></p>


<blockquote>
Walter needs to ask Fermilab for guidance. Defer till tomorrow. Bill likes the proposed resolution.
</blockquote>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
<p>
Marc Paterno wants portable behavior between 32bit and 64bit machines;
we've gone to significant trouble to support portability of engines and
their values.
</p>
<p>
Jens: the new algorithm looks perfectly portable
</p>
<p>
Marc Paterno to review off-line.
</p>
<p>
Modify the proposed resolution to read "Constructs a seed_seq object by the following algorithm ..."
</p>
<p>
Disposition: move to review; unanimous consent.
</p>
<p>
(moots <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#782">782</a> and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#800">800</a>)
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 26.5.7.1 [rand.util.seedseq]:
</p>

<blockquote>
<pre>template&lt;class InputIterator<del>, 
  size_t u = numeric_limits&lt;iterator_traits&lt;InputIterator&gt;::value_type&gt;::digits</del>&gt;
  seed_seq(InputIterator begin, InputIterator end);
</pre>
<blockquote>
<p>
-5- <i>Requires:</i> <tt>InputIterator</tt> shall satisfy the requirements of an input iterator (24.1.1)
such that <tt>iterator_traits&lt;InputIterator&gt;::value_type</tt> shall denote an integral type.
</p>
<p>
-6- Constructs a <tt>seed_seq</tt> object by <ins>the following algorithm</ins> <del>rearranging some or all of the bits of the supplied sequence
<tt>[begin,end)</tt> of w-bit quantities into 32-bit units, as if by the following: </del>
</p>
<p>
<del>First extract the rightmost <tt>u</tt> bits from each of the <tt>n = end
- begin</tt> elements of the supplied sequence and concatenate all the
extracted bits to initialize a single (possibly very large) unsigned
binary number, <tt>b = &#8721;<sup>n-1</sup><sub>i=0</sub> (begin[i] 
mod 2<sup>u</sup>)  2<sup>wi</sup></tt> (in which the bits of each <tt>begin[i]</tt>
are treated as denoting an unsigned quantity). Then carry out 
the following algorithm:</del>
</p>
<blockquote><pre><del>
v.clear(); 
if ($w$ &lt; 32) 
  v.push_back($n$); 
for( ; $n$ &gt; 0; --$n$) 
  v.push_back(b mod 2<sup>32</sup>), b /= 2<sup>32</sup>;
</del></pre></blockquote>
<blockquote>
<pre><ins>
for (InputIterator s = begin; s != end; ++s)
   v.push_back((*s) mod 2<sup>32</sup>);
</ins></pre>
</blockquote>
</blockquote>
</blockquote>


<p><b>Rationale:</b></p>
Addressed by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2836.pdf">N2836</a> "Wording Tweaks for Concept-enabled Random Number Generation in C++0X".





<hr>
<h3><a name="812"></a>812. unsolicited multithreading considered harmful?</h3>
<p><b>Section:</b> 25.4.1 [alg.sort] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Paul McKenney <b>Opened:</b> 2008-02-27 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Multi-threading is a good thing, but unsolicited multi-threading can
potentially be harmful.  For example, <tt>sort()</tt> performance might be
greatly increased via a multithreaded implementation.  However, such
a multithreaded implementation could result in concurrent invocations
of the user-supplied comparator.  This would in turn result in problems
given a caching comparator that might be written for complex sort keys.
Please note that this is not a theoretical issue, as multithreaded
implementations of <tt>sort()</tt> already exist.
</p>
<p>
Having a multithreaded <tt>sort()</tt> available is good, but it should not
be the default for programs that are not explicitly multithreaded.
Users should not be forced to deal with concurrency unless they have
asked for it.
</p>

<p><i>[
This may be covered by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2410.html">N2410</a>
Thread-Safety in the Standard Library (Rev 1).
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
</p>


<p><b>Rationale:</b></p>
This is already covered by 17.6.5.6/20 in N2723.





<hr>
<h3><a name="822"></a>822. Object with explicit copy constructor no longer <tt>CopyConstructible</tt></h3>
<p><b>Section:</b> 20.2.1 [utility.arg.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> James Kanze <b>Opened:</b> 2008-04-01 <b>Last modified:</b> 2010-11-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#utility.arg.requirements">issues</a> in [utility.arg.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I just noticed that the following program is legal in C++03, but
is forbidden in the current draft:
</p>

<blockquote><pre>#include &lt;vector&gt;
#include &lt;iostream&gt;

class Toto
{
public:
    Toto() {}
    explicit Toto( Toto const&amp; ) {}
} ;

int
main()
{
    std::vector&lt; Toto &gt; v( 10 ) ;
    return 0 ;
}
</pre></blockquote>

<p>
Is this change intentional?  (And if so, what is the
justification?  I wouldn't call such code good, but I don't see
any reason to break it unless we get something else in return.)
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
The subgroup that looked at this felt this was a good change, but it may
already be handled by incoming concepts (we're not sure).
</blockquote>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
<p>
Alisdair: Proposed resolution kinda funky as these tables no longer
exist. Move from direct init to copy init. Clarify with Doug, recommends
NAD.
</p>
<p>
Walter: Suggest NAD via introduction of concepts.
</p>
<p>
Recommend close as NAD.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
Need to look at again without concepts.
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
<p>
Move to Ready with original proposed resolution.
</p>
<p><i>[Howard:  Original proposed resolution restored.]</i></p>

</blockquote>

<p><i>[
2010-11 Batavia:
]</i></p>

<p>
This issue was re-reviewed in relation to [another issue, number to follow],
and the verdict was reversed.  Explicit copy and move constructors are rare
beasts, and the ripple effect of this fix was far more difficult to contain
than simply saying such types do not satisfy the <tt>MoveConstructible</tt>
and <tt>CopyConstructible</tt> requirements.
</p>

<blockquote>
<p>
In 20.2.1 [utility.arg.requirements] change Table 33: <tt>MoveConstructible</tt> requirements [moveconstructible]:
</p>

<blockquote>
<table border="1">
<tbody><tr>
<th>expression</th><th>post-condition</th>
</tr>
<tr>
<td><tt>T t<ins>(rv)</ins><del> = rv</del></tt></td><td><tt>t</tt> is equivalent to the value of <tt>rv</tt> before the construction</td>
</tr>
<tr>
<td colspan="2" align="center">...</td>
</tr>
</tbody></table>
</blockquote>

<p>
In 20.2.1 [utility.arg.requirements] change Table 34: <tt>CopyConstructible</tt> requirements [copyconstructible]:
</p>

<blockquote>
<table border="1">
<tbody><tr>
<th>expression</th><th>post-condition</th>
</tr>
<tr>
<td><tt>T t<ins>(u)</ins><del> = u</del></tt></td><td>the value of <tt>u</tt> is unchanged and is equivalent to <tt>t</tt></td>
</tr>
<tr>
<td colspan="2" align="center">...</td>
</tr>
</tbody></table>
</blockquote>

</blockquote>



<p><b>Proposed resolution:</b></p>
Resolved by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3215.html">n3215</a>.





<hr>
<h3><a name="825"></a>825. Missing rvalues reference stream insert/extract operators?</h3>
<p><b>Section:</b> 19.5.2.1 [syserr.errcode.overview], 20.9.10.2.8 [util.smartptr.shared.io], 22.4.8 [facets.examples], 20.5.4 [bitset.operators], 26.4.6 [complex.ops], 27.6 [stream.buffers], 28.9 [re.submatch] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2008-04-10 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses UK 220</b></p>

<p>
Should the following use rvalues references to stream in insert/extract
operators?
</p>

<ul>
<li>19.5.2.1 [syserr.errcode.overview]</li>
<li>20.9.10.2.8 [util.smartptr.shared.io]</li>
<li>22.4.8 [facets.examples]</li>
<li>20.5.4 [bitset.operators]</li>
<li>26.4.6 [complex.ops]</li>
<li>Doubled signatures in 27.6 [stream.buffers] for character inserters
(ref 27.7.2.6.4 [ostream.inserters.character])
+ definition 27.7.2.6.4 [ostream.inserters.character]</li>
<li>28.9 [re.submatch]</li>
</ul>

<p><i>[
Sophia Antipolis
]</i></p>


<blockquote>
Agree with the idea in the issue, Alisdair to provide wording.
</blockquote>

<p><i>[
Daniel adds 2009-02-14:
]</i></p>


<blockquote>
The proposal given in the paper
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2831.html">N2831</a>
apparently resolves this issue.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
The cited paper is an earlier version of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2844.html">N2844</a>,
which changed the rvalue reference binding rules.
That paper includes generic templates
<tt>operator&lt;&lt;</tt> and <tt>operator&gt;&gt;</tt>
that adapt rvalue streams.
</p>
<p>
We therefore agree with Daniel's observation.
Move to NAD Editorial.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="826"></a>826. Equivalent of <tt>%'d</tt>, or rather, lack thereof?</h3>
<p><b>Section:</b> 22.4.2.2 [locale.nm.put] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2008-04-07 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In the spirit of <tt>printf vs iostream</tt>...
</p>

<p>
POSIX <tt>printf</tt> says that <tt>%'d</tt> should insert grouping characters (and the
implication is that in the absence of <tt>'</tt> no grouping characters are
inserted). The <tt>num_put</tt> facet, on the other hand, seems to always insert
grouping characters. Can this be considered a defect worth fixing for
C++0x? Maybe <tt>ios_base</tt> needs an additional flag?
</p>

<p><i>[
Pablo Halpern:
]</i></p>


<blockquote>
I'm not sure it constitutes a defect, but I would be in favor of adding
another flag (and corresponding manipulator).
</blockquote>

<p><i>[
Martin Sebor:
]</i></p>


<blockquote>
I don't know if it qualifies as a defect but I agree that there
should be an easy way to control whether the thousands separator
should or shouldn't be inserted. A new flag would be in line with
the current design of iostreams (like <tt>boolalpha</tt>, <tt>showpos</tt>, or
<tt>showbase</tt>).
</blockquote>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
This is not a part of C99. LWG suggests submitting a paper may be appropriate.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="828"></a>828. Static initialization for <tt>std::mutex</tt>?</h3>
<p><b>Section:</b> 30.4.1.2.1 [thread.mutex.class] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2008-04-18 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.mutex.class">issues</a> in [thread.mutex.class].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
[Note: I'm assuming here that 3.6.2 [basic.start.init]/1 will be fixed.]
</p>
<p>
Currently <tt>std::mutex</tt> doesn't support static initialization. This is a
regression with respect to <tt>pthread_mutex_t</tt>, which does. I believe that
we should strive to eliminate such regressions in expressive power where
possible, both to ease migration and to not provide incentives to (or
force) people to forego the C++ primitives in favor of pthreads.
</p>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
<p>
We believe this is implementable on POSIX, because the initializer-list
feature and the constexpr feature make this work. Double-check core
language about static initialization for this case. Ask core for a core
issue about order of destruction of statically-initialized objects wrt.
dynamically-initialized objects (should come afterwards). Check
non-POSIX systems for implementability.
</p>
<p>
If ubiquitous implementability cannot be assured, plan B is to introduce
another constructor, make this constexpr, which is
conditionally-supported. To avoid ambiguities, this new constructor needs
to have an additional parameter.
</p>
</blockquote>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
<p>
Jens: constant initialization seems to be ok core-language wise
</p>
<p>
Consensus: Defer to threading experts, in particular a Microsoft platform expert.
</p>
<p>
Lawrence to send e-mail to Herb Sutter, Jonathan Caves, Anthony Wiliams,
Paul McKenney, Martin Tasker, Hans Boehm, Bill Plauger, Pete Becker,
Peter Dimov to alert them of this issue.
</p>
<p>
Lawrence: What about header file shared with C? The initialization
syntax is different in C and C++.
</p>
<p>
Recommend Keep in Review
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Keep in Review status pending feedback from members of the Concurrency subgroup.
</blockquote>

<p><i>[
See related comments from Alisdiar and Daniel in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#827">827</a>.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2994.html">N2994</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 30.4.1.2.1 [thread.mutex.class]:
</p>

<blockquote><pre>class mutex {
public:
  <ins>constexpr</ins> mutex();
  ...
</pre></blockquote>





<hr>
<h3><a name="830"></a>830. Incomplete list of char_traits specializations</h3>
<p><b>Section:</b> 21.2 [char.traits] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 2008-04-23 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#char.traits">issues</a> in [char.traits].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
  Paragraph 4 of 21.2 [char.traits] mentions that this
  section specifies two specializations (<code>char_traits&lt;char&gt;</code>
  and (<code>char_traits&lt;wchar_t&gt;</code>). However, there are actually
  four specializations provided, i.e. in addition to the two above also
  <code>char_traits&lt;char16_t&gt;</code> and <code>char_traits&lt;char32_t&gt;</code>).
  I guess this was just an oversight and there is nothing wrong with just
  fixing this.
</p>

<p><i>[
Alisdair adds:
]</i></p>

<blockquote>
<tt>char_traits&lt; char16/32_t &gt;</tt>
should also be added to <tt>&lt;ios_fwd&gt;</tt> in 27.3 [iostream.forward], and all the specializations
taking a <tt>char_traits</tt> parameter in that header.
</blockquote>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
<p>
Idea of the issue is ok.
</p>
<p>
Alisdair to provide wording, once that wording arrives, move to review.
</p>

</blockquote>

<p><i>[
2009-05-04 Alisdair adds:
]</i></p>


<blockquote>
<p>
The main point of the issue was resolved editorially in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a>,
so we are
close to NAD Editorial.
However, exploring the issue we found a second tweak was necessary for
<tt>&lt;iosfwd&gt;</tt> and that is still outstanding, so here are the words I am long
overdue delivering:
</p>

<p><i>[
Howard:  I've put Alisdair's words into the proposed wording section and
moved the issue to Review.
]</i></p>


</blockquote>

<p><i>[
Original proposed wording.
]</i></p>


<blockquote>

<p>
  Replace paragraph 4 of 21.2 [char.traits] by:
</p>
<blockquote>
<p>
  This subclause specifies a struct template, <code>char_traits&lt;charT&gt;</code>,
  and four explicit specializations of it, <code>char_traits&lt;char&gt;</code>,
  <code>char_traits&lt;char16_t&gt;</code>, <code>char_traits&lt;char32_t&gt;</code>, and
  <code>char_traits&lt;wchar_t&gt;</code>, all of which appear in the header
  &lt;string&gt; and satisfy the requirements below.
</p>
</blockquote>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree.  Move to NAD Editorial.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change Forward declarations 27.3 [iostream.forward]:
</p>

<blockquote>
<p>
<b>Header <tt>&lt;iosfwd&gt;</tt> synopsis</b>
</p>
<pre>namespace std {
   template&lt;class charT&gt; class char_traits;
   template&lt;&gt; class char_traits&lt;char&gt;;
   <ins>template&lt;&gt; class char_traits&lt;char16_t&gt;;</ins>
   <ins>template&lt;&gt; class char_traits&lt;char32_t&gt;;</ins>
   template&lt;&gt; class char_traits&lt;wchar_t&gt;;
...
}
</pre>
</blockquote>





<hr>
<h3><a name="831"></a>831. wrong type for not_eof()</h3>
<p><b>Section:</b> 21.2.3 [char.traits.specializations] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Dietmar Khl <b>Opened:</b> 2008-04-23 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#char.traits.specializations">issues</a> in [char.traits.specializations].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
  In Table 56 (Traits requirements) the <tt>not_eof()</tt> member function
  is using an argument of type <i>e</i> which denotes an object of
  type <code>X::int_type</code>. However, the specializations in
  21.2.3 [char.traits.specializations] all use <code>char_type</code>.
  This would effectively mean that the argument type actually can't
  represent EOF in the first place. I'm pretty sure that the type used
  to be <code>int_type</code> which is quite obviously the only sensible
  argument.
</p>
<p>
  This issue is close to being editorial. I suspect that the proposal
  changing this section to include the specializations for <code>char16_t</code>
  and <code>char32_t</code> accidentally used the wrong type.
</p>


<p><b>Proposed resolution:</b></p>
<p>
  In 21.2.3.1 [char.traits.specializations.char],
  21.2.3.2 [char.traits.specializations.char16_t],
  21.2.3.3 [char.traits.specializations.char32_t], and
   [char.traits.specializations.wchar_t] correct the
  argument type from <code>char_type</code> to <code>int_type</code>.
</p>


<p><b>Rationale:</b></p>
Already fixed in WP.





<hr>
<h3><a name="832"></a>832. Applying constexpr to System error support</h3>
<p><b>Section:</b> 19.5 [syserr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2008-05-14 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#syserr">issues</a> in [syserr].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Initialization of objects of class <tt>error_code</tt>
(19.5.2 [syserr.errcode]) and class
<tt>error_condition</tt> (19.5.3 [syserr.errcondition]) can be made simpler and more reliable by use of
the new <tt>constexpr</tt> feature 
[<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2349.pdf">N2349</a>]
of C++0x. Less code will need to be
generated for both library implementations and user programs when
manipulating constant objects of these types. 
</p>

<p>
This was not proposed originally because the constant expressions
proposal was moving into the standard at about the same time as the
Diagnostics Enhancements proposal 
[<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2241.html">N2241</a>],
and it wasn't desirable to
make the later depend on the former. There were also technical concerns
as to how <tt>constexpr</tt> would apply to references. Those concerns are now
resolved; <tt>constexpr</tt> can't be used for references, and that fact is
reflected in the proposed resolution.
</p>

<p>
Thanks to Jens Maurer, Gabriel Dos Reis, and Bjarne Stroustrup for clarification of <tt>constexpr</tt> requirements.
</p>

<p>
LWG issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#804">804</a> is related in that it raises the question of whether the
exposition only member <tt>cat_</tt> of class <tt>error_code</tt> (19.5.2 [syserr.errcode]) and class
<tt>error_condition</tt> (19.5.3 [syserr.errcondition]) should be presented as a reference or pointer.
While in the context of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#804">804</a> that is arguably an editorial question,
presenting it as a pointer becomes more or less required with this
proposal, given <tt>constexpr</tt> does not play well with references. The
proposed resolution thus changes the private member to a pointer, which
also brings it in sync with real implementations.
</p>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
On going question of extern pointer vs. inline functions for interface.
</blockquote>

<p><i>[
Pre-San Francisco:
]</i></p>


<blockquote>
<p>
Beman Dawes reports that this proposal is unimplementable, and thus NAD.
</p>
<p>
Implementation would require <tt>constexpr</tt> objects of classes derived
from class <tt>error_category</tt>, which has virtual functions, and that is
not allowed by the core language. This was determined when trying to
implement the proposal using a constexpr enabled compiler provided
by Gabriel Dos Reis, and subsequently verified in discussions with
Gabriel and Jens Maurer.
</p>

</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
The proposed wording assumes the LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#805">805</a> proposed wording has been
applied to the WP, resulting in the former <tt>posix_category</tt> being renamed
<tt>generic_category</tt>. If <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#805">805</a> has not been applied, the names in this
proposal must be adjusted accordingly.
</p>

<p>
Change 19.5.1.1 [syserr.errcat.overview] Class
<tt>error_category</tt> overview <tt>error_category</tt> synopsis  as
indicated:
</p>

<blockquote><pre><del>const error_category&amp; get_generic_category();</del>
<del>const error_category&amp; get_system_category();</del>

<del>static</del> <ins>extern</ins> const error_category<del>&amp;</del><ins>* const</ins> generic_category<del> = get_generic_category()</del>;
<del>static</del> <ins>extern</ins> const error_category<del>&amp;</del><ins>* const</ins> <del>native_category</del> system_category<del> = get_system_category()</del>;
</pre></blockquote>

<p>
Change 19.5.1.5 [syserr.errcat.objects] Error category objects as indicated:
</p>

<blockquote>
<pre><ins>extern</ins> const error_category<del>&amp;</del><ins>* const</ins> <del>get_</del>generic_category<del>()</del>;
</pre>
<p>
<del><i>Returns:</i> A reference</del> <ins><tt>generic_category</tt> shall point</ins>
to <del>an</del> <ins>a statically initialized</ins> object of a type derived from
class <tt>error_category</tt>.
</p>

<p>
<del><i>Remarks:</i></del> The object's <tt>default_error_condition</tt> and <tt>equivalent</tt> virtual
functions shall behave as specified for the class <tt>error_category</tt>. The
object's <tt>name</tt> virtual function shall return a pointer to the string
<tt>"GENERIC"</tt>.
</p>

<pre><ins>extern</ins> const error_category<del>&amp;</del><ins>* const</ins> <del>get_</del>system_category<del>()</del>;
</pre>

<p>
<del><i>Returns:</i> A reference</del> <ins><tt>system_category</tt> shall point</ins>
to <del>an</del> <ins>a statically
initialized</ins> object of a type derived from class <tt>error_category</tt>.
</p>

<p>
<del><i>Remarks:</i></del>  The object's <tt>equivalent</tt> virtual functions shall behave as
specified for class <tt>error_category</tt>. The object's <tt>name</tt> virtual function
shall return a pointer to the string <tt>"system"</tt>. The object's
<tt>default_error_condition</tt> virtual function shall behave as follows:
</p>

<p>
If the argument <tt>ev</tt> corresponds to a POSIX <tt>errno</tt> value <tt>posv</tt>, the function
shall return <tt>error_condition(posv, generic_category)</tt>. Otherwise, the
function shall return <tt>error_condition(ev, system_category)</tt>. What
constitutes correspondence for any given operating system is
unspecified. [<i>Note:</i> The number of potential system error codes is large
and unbounded, and some may not correspond to any POSIX <tt>errno</tt> value.
Thus implementations are given latitude in determining correspondence.
<i>-- end note</i>]
</p>
</blockquote>

<p>
Change 19.5.2.1 [syserr.errcode.overview] Class <tt>error_code</tt> overview as indicated:
</p>

<blockquote><pre>class error_code {
public:
  ...;
  <ins>constexpr</ins> error_code(int val, const error_category<del>&amp;</del><ins>*</ins> cat);
  ...
  void assign(int val, const error_category<del>&amp;</del><ins>*</ins> cat);
  ...
  const error_category<del>&amp;</del><ins>*</ins> category() const;
  ...
private:
  int val_;                    // exposition only
  const error_category<del>&amp;</del><ins>*</ins> cat_; // exposition only
</pre></blockquote>

<p>
Change 19.5.2.2 [syserr.errcode.constructors] Class <tt>error_code</tt> constructors as indicated:
</p>

<blockquote>
<pre><ins>constexpr</ins> error_code(int val, const error_category<del>&amp;</del><ins>*</ins> cat);
</pre>
<p>
<i>Effects:</i> Constructs an object of type <tt>error_code</tt>.
</p>
<p>
<i>Postconditions:</i> <tt>val_ == val</tt> and <tt>cat_ == cat</tt>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>

<p>
Change 19.5.2.3 [syserr.errcode.modifiers] Class <tt>error_code</tt> modifiers  as indicated:
</p>

<blockquote>
<pre>void assign(int val, const error_category<del>&amp;</del><ins>*</ins> cat);
</pre>
<p>
<i>Postconditions:</i> <tt>val_ == val</tt> and <tt>cat_ == cat</tt>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>

<p>
Change 19.5.2.4 [syserr.errcode.observers] Class <tt>error_code</tt> observers  as indicated:
</p>

<blockquote>
<pre>const error_category<del>&amp;</del><ins>*</ins> category() const;
</pre>

<p>
<i>Returns:</i> <tt>cat_</tt>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>

<p>
Change 19.5.3.1 [syserr.errcondition.overview] Class <tt>error_condition</tt> overview   as indicated:
</p>

<blockquote>
<pre>class error_condition {
public:
  ...;
  <ins>constexpr</ins> error_condition(int val, const error_category<del>&amp;</del><ins>*</ins> cat);
  ...
  void assign(int val, const error_category<del>&amp;</del><ins>*</ins> cat);
  ...
  const error_category<del>&amp;</del><ins>*</ins> category() const;
  ...
private:
  int val_;                    // exposition only
  const error_category<del>&amp;</del><ins>*</ins> cat_; // exposition only
</pre>
</blockquote>

<p>
Change 19.5.3.2 [syserr.errcondition.constructors] Class <tt>error_condition</tt> constructors as indicated:
</p>

<blockquote>
<pre><ins>constexpr</ins> error_condition(int val, const error_category<del>&amp;</del><ins>*</ins> cat);
</pre>
<p>
<i>Effects:</i> Constructs an object of type <tt>error_condition</tt>.
</p>
<p>
<i>Postconditions:</i> <tt>val_ == val</tt> and <tt>cat_ == cat</tt>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>

<p>
Change 19.5.3.3 [syserr.errcondition.modifiers] Class <tt>error_condition</tt> modifiers as indicated:
</p>

<blockquote>
<pre>void assign(int val, const error_category<del>&amp;</del><ins>*</ins> cat);
</pre>
<p>
<i>Postconditions:</i> <tt>val_ == val</tt> and <tt>cat_ == cat</tt>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>

<p>
Change 19.5.3.4 [syserr.errcondition.observers] Class <tt>error_condition</tt> observers as indicated:
</p>

<blockquote>
<pre>const error_category<del>&amp;</del><ins>*</ins> category() const;
</pre>
<p>
<i>Returns:</i> <tt>cat_</tt>.
</p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>

<p>
Throughout 19.5 [syserr] System error support, change "<tt>category().</tt>"  to "<tt>category()-&gt;</tt>".
Appears approximately six times.
</p>

<p>
<i>[Partially Editorial]</i> In 19.5.4 [syserr.compare] Comparison operators,
paragraphs 2 and 4, change "<tt>category.equivalent(</tt>"  to
"<tt>category()-&gt;equivalent(</tt>".
</p>

<p>
Change 19.5.6.1 [syserr.syserr.overview] Class system_error overview as indicated:
</p>

<blockquote><pre>public:
  system_error(error_code ec, const string&amp; what_arg);
  system_error(error_code ec);
  system_error(int ev, const error_category<del>&amp;</del><ins>*</ins> ecat,
      const string&amp; what_arg);
  system_error(int ev, const error_category<del>&amp;</del><ins>*</ins> ecat);
</pre></blockquote>

<p>
Change 19.5.6.2 [syserr.syserr.members] Class system_error members as indicated:
</p>

<blockquote>
<pre>system_error(int ev, const error_category<del>&amp;</del><ins>*</ins> ecat, const string&amp; what_arg);
</pre>
<blockquote>
<p>
<i>Effects:</i> Constructs an object of class <tt>system_error</tt>.
</p>
<p>
<i>Postconditions:</i> <tt>code() == error_code(ev, ecat)</tt> and
<tt>strcmp(runtime_error::what(), what_arg.c_str()) == 0</tt>.
</p>
</blockquote>

<pre>system_error(int ev, const error_category<del>&amp;</del><ins>*</ins> ecat);
</pre>
<blockquote>
<p>
<i>Effects:</i> Constructs an object of class <tt>system_error</tt>.
</p>
<p>
<i>Postconditions:</i> <tt>code() == error_code(ev, ecat)</tt> and
<tt>strcmp(runtime_error::what(), "") == 0</tt>.
</p>
</blockquote>
</blockquote>



<p><b>Rationale:</b></p>
<p><i>[
San Francisco:
]</i></p>


<blockquote>
NAD because Beman said so.
</blockquote>





<hr>
<h3><a name="833"></a>833. Freestanding implementations header list needs review for C++0x</h3>
<p><b>Section:</b> 17.6.1.3 [compliance] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2008-05-14 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#compliance">issues</a> in [compliance].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Once the C++0x standard library is feature complete, the LWG needs to
review 17.6.1.3 [compliance] Freestanding implementations header list to
ensure it reflects LWG consensus.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
This is a placeholder defect to remind us to review the table once we've
stopped adding headers to the library.
</p>
<p>
Three new headers that need to be added to the list:
</p>
<blockquote><pre>&lt;initializer_list&gt; &lt;concept&gt; &lt;iterator_concepts&gt;
</pre></blockquote>
<p>
<tt>&lt;iterator_concepts&gt;</tt>, in particular, has lots of stuff
that isn't needed, so maybe the stuff that is needed should be broken
out into a separate header.
</p>
<p>
Robert: What about <tt>reference_closure</tt>? It's currently in
<tt>&lt;functional&gt;</tt>.
</p>
</blockquote>

<p><i>[
Post Summit Daniel adds:
]</i></p>


<blockquote>
<ol>
<li>
The comment regarding <tt>reference_closure</tt> seems moot since it was just
recently decided to remove that.
</li>
<li>
A reference to proposal
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2814.pdf">N2814</a>
("Fixing freestanding") should be added. This
paper e.g. proposes to add only <tt>&lt;initializer_list&gt;</tt> to the include list
of freestanding.
</li>
</ol>
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
<p>
Addressed by paper
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2814.pdf">N2814</a>.
</p>
<p>
Move to NAD.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="837"></a>837. 
   <code>basic_ios::copyfmt()</code> overly loosely specified
 </h3>
<p><b>Section:</b> 27.5.4.2 [basic.ios.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2008-05-17 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#basic.ios.members">issues</a> in [basic.ios.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
   <p>

The <code>basic_ios::copyfmt()</code> member function is specified in 27.5.4.2 [basic.ios.members] to have the following effects:

   </p>
   <blockquote>

<i>Effects</i>: If <code>(this == &amp;rhs)</code> does
nothing. Otherwise assigns to the member objects of <code>*this</code>
the corresponding member objects of <code>rhs</code>, except that

     <ul>
       <li>

<code>rdstate()</code> and <code>rdbuf()</code> are left unchanged;

       </li>
       <li>

<code>exceptions()</code> is altered last by
calling <code>exceptions(rhs.except)</code>

       </li>
       <li>

the contents of arrays pointed at by <code>pword</code>
and <code>iword</code> are copied not the pointers themselves

       </li>
     </ul>
   </blockquote>
   <p>

Since the rest of the text doesn't specify what the member objects
of <code>basic_ios</code> are this seems a little too loose.

</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to NAD Editorial.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>

I propose to tighten things up by adding a <i>Postcondition</i> clause
to the function like so:

   </p>
   <blockquote>
     <i>Postconditions:</i>

     <table border="1">
       <thead>
         <tr>
           <th colspan="2"><code>copyfmt()</code> postconditions</th>
         </tr>
         <tr>
           <th>Element</th>
           <th>Value</th>
         </tr>
       </thead>
       <tbody>
         <tr>
           <td><code>rdbuf()</code></td>
           <td><i>unchanged</i></td>
         </tr>
         <tr> 
           <td><code>tie()</code></td>
           <td><code>rhs.tie()</code></td>
         </tr>
         <tr> 
           <td><code>rdstate()</code></td>
           <td><i>unchanged</i></td>
         </tr>
         <tr> 
           <td><code>exceptions()</code></td>
           <td><code>rhs.exceptions()</code></td>
         </tr>
         <tr> 
           <td><code>flags()</code></td>
           <td><code>rhs.flags()</code></td>
         </tr>
         <tr> 
           <td><code>width()</code></td>
           <td><code>rhs.width()</code></td>
         </tr>
         <tr> 
           <td><code>precision()</code></td>
           <td><code>rhs.precision()</code></td>
         </tr>
         <tr> 
           <td><code>fill()</code></td>
           <td><code>rhs.fill()</code></td>
         </tr>
         <tr> 
           <td><code>getloc()</code></td>
           <td><code>rhs.getloc()</code></td>
         </tr>
       </tbody>
     </table>
   </blockquote>
   <p>

The format of the table follows Table 117 (as
of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2588.pdf">N2588</a>): <code>basic_ios::init()</code>
effects.

   </p>
   <p>

The intent of the new table is not to impose any new requirements or
change existing ones, just to be more explicit about what I believe is
already there.

   </p>
 



<hr>
<h3><a name="839"></a>839. Maps and sets missing splice operation</h3>
<p><b>Section:</b> 23.6 [associative], 23.7 [unord] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Future">NAD Future</a>
 <b>Submitter:</b> Alan Talbot <b>Opened:</b> 2008-05-18 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#associative">issues</a> in [associative].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Splice is a very useful feature of <tt>list</tt>. This functionality is also very
useful for any other node based container, and I frequently wish it were
available for maps and sets. It seems like an omission that these
containers lack this capability. Although the complexity for a splice is
the same as for an insert, the actual time can be much less since the
objects need not be reallocated and copied. When the element objects are
heavy and the compare operations are fast (say a <tt>map&lt;int, huge_thingy&gt;</tt>)
this can be a big win.
</p>

<p>
<b>Suggested resolution:</b>
</p>

<p>
Add the following signatures to map, set, multimap, multiset, and the unordered associative containers:
</p>
<blockquote><pre> 
void splice(list&lt;T,Allocator&gt;&amp;&amp; x);
void splice(list&lt;T,Allocator&gt;&amp;&amp; x, const_iterator i);
void splice(list&lt;T,Allocator&gt;&amp;&amp; x, const_iterator first, const_iterator last);
</pre></blockquote>

<p>
Hint versions of these are also useful to the extent hint is useful.
(I'm looking for guidance about whether hints are in fact useful.)
</p>
 
<blockquote><pre> 
void splice(const_iterator position, list&lt;T,Allocator&gt;&amp;&amp; x);
void splice(const_iterator position, list&lt;T,Allocator&gt;&amp;&amp; x, const_iterator i);
void splice(const_iterator position, list&lt;T,Allocator&gt;&amp;&amp; x, const_iterator first, const_iterator last);
</pre></blockquote>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
<p>
Don't try to <tt>splice "list"</tt> into the other containers, it should be container-type.
</p>
<p>
<tt>forward_list</tt> already has <tt>splice_after</tt>.
</p>
<p>
Would "<tt>splice</tt>" make sense for an <tt>unordered_map</tt>?
</p>
<p>
Jens, Robert: "<tt>splice</tt>" is not the right term, it implies maintaining ordering in <tt>list</tt>s.
</p>
<p>
Howard: <tt>adopt</tt>?
</p>
<p>
Jens: <tt>absorb</tt>?
</p>
<p>
Alan: <tt>subsume</tt>?
</p>
<p>
Robert: <tt>recycle</tt>?
</p>
<p>
Howard: <tt>transfer</tt>? (but no direction)
</p>
<p>
Jens: <tt>transfer_from</tt>. No.
</p>
<p>
Alisdair: Can we give a nothrow guarantee? If your <tt>compare()</tt> and <tt>hash()</tt> doesn't throw, yes.
</p>
<p>
Daniel: For <tt>unordered_map</tt>, we can't guarantee nothrow.
</p>
</blockquote>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
Martin: this would possibly outlaw an implementation technique that is
currently in use; caching nodes in containers.
</p>
<p>
Alan: if you cache in the allocator, rather than the individual
container, this proposal doesn't interfere with that.
</p>
<p>
Martin: I'm not opposed to this, but I'd like to see an implementation
that demonstrates that it works.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
NAD Future.
</blockquote>

<p><i>[
2009-09-19 Howard adds:
]</i></p>


<blockquote>
<p>
I'm not disagreeing with the NAD Future resolution.  But when the future gets
here, here is a possibility worth exploring:
</p>

<blockquote>
<p>
Add to the "unique" associative containers:
</p>

<blockquote><pre>typedef <i>details</i>      node_ptr;

node_ptr             remove(const_iterator p);
pair&lt;iterator, bool&gt; insert(node_ptr&amp;&amp; nd);
iterator             insert(const_iterator p, node_ptr&amp;&amp; nd);
</pre></blockquote>

<p>
And add to the "multi" associative containers:
</p>

<blockquote><pre>typedef <i>details</i> node_ptr;

node_ptr remove(const_iterator p);
iterator insert(node_ptr&amp;&amp; nd);
iterator insert(const_iterator p, node_ptr&amp;&amp; nd);
</pre></blockquote>

<p>
<tt>Container::node_ptr</tt> is a smart pointer much like <tt>unique_ptr</tt>.
It owns a node obtained from the container it was removed from.  It maintains a
reference to the allocator in the container so that it can properly deallocate
the node if asked to, even if the allocator is stateful.  This being said, the
<tt>node_ptr</tt> can not outlive the container for this reason.
</p>

<p>
The <tt>node_ptr</tt> offers "<tt>const</tt>-free" access to the node's
<tt>value_type</tt>.
</p>

<p>
With this interface, clients have a great deal of flexibility:
</p>

<ul>
<li>
A client can remove a node from one container, and insert it into another
(without any heap allocation).  This is the splice functionality this issue
asks for.
</li>
<li>
A client can remove a node from a container, change its key or value, and insert
it back into the same container, or another container, all without the cost of
allocating a node.
</li>
<li>
If the Compare function is nothrow (which is very common), then this functionality
is nothrow unless modifying the value throws.  And if this does throw, it does
so outside of the containers involved.
</li>
<li>
If the Compare function does throw, the <tt>insert</tt> function will have the
argument <tt>nd</tt> retain ownership of the node.
</li>
<li>
The <tt>node_ptr</tt> should be independent of the <tt>Compare</tt> parameter
so that a node can be transferred from <tt>set&lt;T, C1, A&gt;</tt>
to <tt>set&lt;T, C2, A&gt;</tt> (for example).
</li>
</ul>

<p>
Here is how the customer might use this functionality:
</p>

<ul>
<li>
<p>
Splice a node from one container to another:
</p>
<blockquote><pre>m2.insert(m1.remove(i));
</pre></blockquote>
</li>

<li>
<p>
Change the "key" in a <tt>std::map</tt> without the cost of node reallocation:
</p>
<blockquote><pre>auto p = m.remove(i);
p-&gt;first = new_key;
m.insert(std::move(p));
</pre></blockquote>
</li>

<li>
<p>
Change the "value" in a <tt>std::set</tt> without the cost of node reallocation:
</p>
<blockquote><pre>auto p = s.remove(i);
*p = new_value;
s.insert(std::move(p));
</pre></blockquote>
</li>

<li>
<p>
Move a move-only or heavy object out of an associative container (as opposed to
the proposal in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1041">1041</a>):
</p>
<blockquote><pre>MoveOnly x = std::move(*s.remove(i));
</pre></blockquote>
<ol>
<li>
<tt>remove(i)</tt> transfers ownership of the node from the set to a temporary
<tt>node_ptr</tt>.
</li>
<li>
The <tt>node_ptr</tt> is dereferenced, and that non-const reference is sent to
<tt>move</tt> to cast it to an rvalue.
</li>
<li>
The rvalue <tt>MoveOnly</tt> is move constructed into <tt>x</tt> from
the <tt>node_ptr</tt>.
</li>
<li>
<tt>~node_ptr()</tt> destructs the moved-from <tt>MoveOnly</tt> and deallocates
the node.
</li>
</ol>

<p>
Contrast this with the <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1041">1041</a> solution:
</p>
<blockquote><pre>MoveOnly x = std::move(s.extract(i).first);
</pre></blockquote>

<p>
The former requires one move construction for <tt>x</tt> while the latter
requires two (one into the <tt>pair</tt> and then one into <tt>x</tt>).  Either
of these constructions can throw (say if there is only a copy constructor for
<tt>x</tt>).  With the former, the point of throw is outside of the container
<tt>s</tt>, after the element has been removed from the container.  With the latter,
one throwing construction takes place prior to the removal of the element, and
the second takes place after the element is removed.
</p>

</li>
</ul>

<p>
The "node insertion" API maintains the API associated with inserting <tt>value_type</tt>s
so the customer can use familiar techniques for getting an iterator to the 
inserted node, or finding out whether it was inserted or not for the "unique"
containers.
</p>

<p>
Lightly prototyped.  No implementation problems.  Appears to work great
for the client.
</p>

</blockquote>
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="840"></a>840. <tt>pair</tt> default template argument</h3>
<p><b>Section:</b> 20.3.5 [pairs] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Thorsten Ottosen <b>Opened:</b> 2008-05-23 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#pairs">issues</a> in [pairs].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I have one issue with <tt>std::pair</tt>. Well, it might just be a very annoying
historical accident, but why is there no default template argument for
the second template argument? This is so annoying when the type in
question is looong and hard to write (type deduction with <tt>auto</tt> won't
help those cases where we use it as a return or argument type).
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change the synopsis in 20.3 [utility] to read:
</p>

<blockquote><pre>template &lt;class T1, class T2 <ins>= T1</ins>&gt; struct pair;
</pre></blockquote>

<p>
Change 20.3.5 [pairs] to read:
</p>

<blockquote><pre>namespace std {
 template &lt;class T1, class T2 <ins>= T1</ins>&gt;
 struct pair {
   typedef T1 first_type;
   typedef T2 second_type;
   ...
</pre></blockquote>


<p><b>Rationale:</b></p>
<tt>std::pair</tt> is a heterogeneous container.





<hr>
<h3><a name="841"></a>841. cstdint.syn inconsistent with C99</h3>
<p><b>Section:</b> 18.4.1 [cstdint.syn] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2008-05-17 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#cstdint.syn">issues</a> in [cstdint.syn].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
   <p>

In specifying the names of macros and types defined in
header <code>&lt;stdint.h&gt;</code>, C99 makes use of the
symbol <code><i>N</i></code> to accommodate unusual platforms with
word sizes that aren't powers of two. C99
permits <code><i>N</i></code> to take on any positive integer value
(including, for example, 24).

   </p>
   <p>

In  cstdint.syn Header <code>&lt;cstdint&gt;</code>
synopsis, C++ on the other hand, fixes the value
of <code><i>N</i></code> to 8, 16, 32, and 64, and specifies only
types with these exact widths. 

   </p>
   <p>
   </p>

In addition, paragraph 1 of the same section makes use of a rather
informal shorthand notation to specify sets of macros. When
interpreted strictly, the notation specifies macros such
as <code>INT_8_MIN</code> that are not intended to be specified.

   <p>

Finally, the section is missing the usual table of symbols defined
in that header, making it inconsistent with the rest of the
specification.

   </p>
 
 <p><b>Proposed resolution:</b></p>
   <p>

I propose to use the same approach in the C++ spec as C99 uses, that
is, to specify the header synopsis in terms of "exposition only" types
that make use of the symbol <code><i>N</i></code> to denote one or
more of a theoretically unbounded set of widths.

   </p>
   <p>

Further, I propose to add a new table to section listing the symbols
defined in the header using a more formal notation that avoids
introducing inconsistencies.

   </p>
   <p>

To this effect, in  cstdint.syn
Header <code>&lt;cstdint&gt;</code> synopsis, replace both the
synopsis and paragraph 1 with the following text:

   </p>
   <blockquote>
     <p>
       </p><ol>
         <li>

In the names defined in the <code>&lt;cstdint&gt;</code> header, the
symbol <code><i>N</i></code> represents a positive decimal integer
with no leading zeros (e.g., 8 or 24, but not 0, 04, or 048). With the
exception of exact-width types, macros and types for values
of <code><i>N</i></code> in the set of 8, 16, 32, and 64 are
required. Exact-width types, and any macros and types for values
of <code><i>N</i></code> other than 8, 16, 32, and 64 are
optional. However, if an implementation provides integer types with
widths of 8, 16, 32, or 64 bits, the corresponding exact-width types
and macros are required.

         </li>
       </ol>
     <p></p>
     <pre>namespace std {

   // required types

   // Fastest minimum-width integer types
   typedef <i>signed integer type</i>   int_fast8_t;
   typedef <i>signed integer type</i>   int_fast16_t;
   typedef <i>signed integer type</i>   int_fast32_t;
   typedef <i>signed integer type</i>   int_fast64_t;

   typedef <i>unsigned integer type</i> uint_fast8_t;
   typedef <i>unsigned integer type</i> uint_fast16_t;
   typedef <i>unsigned integer type</i> uint_fast32_t;
   typedef <i>unsigned integer type</i> uint_fast64_t;

   // Minimum-width integer types
   typedef <i>signed integer type</i>   int_least8_t;
   typedef <i>signed integer type</i>   int_least16_t;
   typedef <i>signed integer type</i>   int_least32_t;
   typedef <i>signed integer type</i>   int_least64_t;

   typedef <i>unsigned integer type</i> uint_least8_t;
   typedef <i>unsigned integer type</i> uint_least16_t;
   typedef <i>unsigned integer type</i> uint_least32_t;
   typedef <i>unsigned integer type</i> uint_least64_t;

   // Greatest-width integer types
   typedef <i>signed integer type</i>   intmax_t;
   typedef <i>unsigned integer type</i> uintmax_t;

   // optionally defined types

   // Exact-width integer types
   typedef <i>signed integer type</i>   int<i>N</i>_t;
   typedef <i>unsigned integer type</i> uint<i>N</i>_t;

   // Fastest minimum-width integer types for values
   // of <i>N</i> other than 8, 16, 32, and 64
   typedef <i>signed integer type</i>   uint_fast<i>N</i>_t;
   typedef <i>unsigned integer type</i> uint_fast<i>N</i>_t;

   // Minimum-width integer types for values
   // of <i>N</i> other than 8, 16, 32, and 64
   typedef <i>signed integer type</i>   uint_least<i>N</i>_t;
   typedef <i>unsigned integer type</i> uint_least<i>N</i>_t;

   // Integer types capable of holding object pointers
   typedef <i>signed integer type</i>   intptr_t;
   typedef <i>signed integer type</i>   intptr_t;

}</pre>
   </blockquote>
   <p>

[Note to editor: Remove all of the existing paragraph 1 from  cstdint.syn.]

   </p>
   <blockquote>
     Table ??: Header <code>&lt;cstdint&gt;</code> synopsis
     <table border="1">
       <thead>
         <tr>
           <th>Type</th>
           <th colspan="3">Name(s)</th>
         </tr>
       </thead>
       <tbody>
         <tr>
           <td rowspan="11"><b>Macros:</b></td>
           <td><tt>INT<i>N</i>_MIN</tt></td>
           <td><tt>INT<i>N</i>_MAX</tt></td>
           <td><tt>UINT<i>N</i>_MAX</tt></td>
         </tr>
         <tr>
           <td><tt>INT_FAST<i>N</i>_MIN</tt></td>
           <td><tt>INT_FAST<i>N</i>_MAX</tt></td>
           <td><tt>UINT_FAST<i>N</i>_MAX</tt></td>
         </tr>
         <tr>
           <td><tt>INT_LEAST<i>N</i>_MIN</tt></td>
           <td><tt>INT_LEAST<i>N</i>_MAX</tt></td>
           <td><tt>UINT_LEAST<i>N</i>_MAX</tt></td>
         </tr>
         <tr>
           <td><tt>INTPTR_MIN</tt></td>
           <td><tt>INTPTR_MAX</tt></td>
           <td><tt>UINTPTR_MAX</tt></td>
         </tr>
         <tr>
           <td><tt>INTMAX_MIN</tt></td>
           <td><tt>INTMAX_MAX</tt></td>
           <td><tt>UINTMAX_MAX</tt></td>
         </tr>
         <tr>
           <td><tt>PTRDIFF_MIN</tt></td>
           <td><tt>PTRDIFF_MAX</tt></td>
           <td><tt>PTRDIFF_MAX</tt></td>
         </tr>
         <tr>
           <td><tt>SIG_ATOMIC_MIN</tt></td>
           <td><tt>SIG_ATOMIC_MAX</tt></td>
           <td><tt>SIZE_MAX</tt></td>
         </tr>
         <tr>
           <td><tt>WCHAR_MIN</tt></td>
           <td><tt>WCHAR_MAX</tt></td>
         <td></td>
         </tr>
         <tr>
           <td><tt>WINT_MIN</tt></td>
           <td><tt>WINT_MAX</tt></td>
           <td></td>
         </tr>
         <tr>
           <td><tt>INT<i>N</i>_C()</tt></td>
           <td><tt>UINT<i>N</i>_C()</tt></td>
           <td></td>
         </tr>
         <tr>
           <td><tt>INTMAX_C()</tt></td>
           <td><tt>UINTMAX_C()</tt></td>
           <td></td>
         </tr>
         <tr>
           <td rowspan="5"><b>Types:</b></td>
           <td><tt>int<i>N</i>_t</tt></td>
           <td><tt>uint<i>N</i>_t</tt></td>
           <td></td>
         </tr>
         <tr>
           <td><tt>int_fast<i>N</i>_t</tt></td>
           <td><tt>uint_fast<i>N</i>_t</tt></td>
           <td></td>
         </tr>
         <tr>
           <td><tt>int_least<i>N</i>_t</tt></td>
           <td><tt>uint_least<i>N</i>_t</tt></td>
           <td></td>
         </tr>
         <tr>
           <td><tt>intptr_t</tt></td>
           <td><tt>uintptr_t</tt></td>
           <td></td>
         </tr>
         <tr>
           <td><tt>intmax_t</tt></td>
           <td><tt>uintmax_t</tt></td>
           <td></td>
         </tr>
       </tbody>
     </table>
   </blockquote>
 




<hr>
<h3><a name="849"></a>849. missing type traits to compute root class and derived class of types in a class hierachy</h3>
<p><b>Section:</b> 20.7.7.6 [meta.trans.other] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Thorsten Ottosen <b>Opened:</b> 2008-06-05 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta.trans.other">issues</a> in [meta.trans.other].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The type traits library contains various traits to dealt with
polymorphic types, e.g. <tt>std::has_virtual_destructor</tt>, <tt>std::is_polymorphic</tt>
and <tt>std::is_base_of</tt>. However, there is no way to compute the unique
public base class of a type  if such  one exists.  Such a trait could be
very useful if one needs to instantiate a specialization made for the
root class whenever a derived class is passed as parameter. For example,
imagine that you wanted to specialize <tt>std::hash</tt> for a class
hierarchy---instead of specializing each class, you could specialize the
<tt>std::hash&lt;root_class&gt;</tt> and provide a partial specialization that worked
for all derived classes.
</p>

<p>
This ability---to specify operations in terms of their equivalent in the
root class---can be done with e.g. normal functions, but there is,
AFAIK, no way to do it for class templates. Being able to access
compile-time information about the type-hierachy can be very powerful,
and I therefore also suggest traits that computes the directly derived
class whenever that is possible.
</p>

<p>
If the computation can not be done, the traits should fall back on an
identity transformation. I expect this gives the best overall usability.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add the following to the synopsis in 20.7.2 [meta.type.synop] under "other transformations":
</p>

<blockquote><pre>template&lt; class T &gt; struct direct_base_class;
template&lt; class T &gt; struct direct_derived_class;
template&lt; class T &gt; struct root_base_class;
</pre></blockquote>

<p>
Add three new entries to table 51 (20.7.7.6 [meta.trans.other]) with the following content
</p>

<blockquote>
<table border="1">
<tbody><tr>
<th>Template</th><th>Condition</th><th>Comments</th>
</tr>
<tr>
<td><tt>template&lt; class T &gt; struct direct_base_class;</tt></td>
<td><tt>T</tt> shall be a complete type.</td>
<td>The member typedef <tt>type</tt> shall equal the accessible unambiguous direct base class of <tt>T</tt>.
If no such type exists, the member typedef <tt>type</tt> shall equal <tt>T</tt>.</td>
</tr>
<tr>
<td><tt>template&lt; class T &gt; struct direct_derived_class;</tt></td>
<td><tt>T</tt> shall be a complete type.</td>
<td>The member typedef <tt>type</tt> shall equal the unambiguous type which has <tt>T</tt>
as an accessible unambiguous direct base class. If no such type exists, the member typedef
<tt>type</tt> shall equal <tt>T</tt>.</td>
</tr>
<tr>
<td><tt>template&lt; class T &gt; struct root_base_class;</tt></td>
<td><tt>T</tt> shall be a complete type.</td>
<td>The member typedef <tt>type</tt> shall equal the accessible unambiguous most indirect base class of
<tt>T</tt>. If no such type exists, the member typedef type shall equal <tt>T</tt>.</td>
</tr>
</tbody></table>
</blockquote>



<p><b>Rationale:</b></p>
2008-9-16 San Francisco:  Issue pulled by author prior to being reviewed by the LWG.





<hr>
<h3><a name="851"></a>851. simplified array construction</h3>
<p><b>Section:</b> 23.3.1 [array] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Future">NAD Future</a>
 <b>Submitter:</b> Benjamin Kosnik <b>Opened:</b> 2008-06-05 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#array">issues</a> in [array].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This is an issue that came up on the libstdc++ list, where a
discrepancy between "C" arrays and C++0x's <tt>std::array</tt> was pointed
out.
</p>

<p>
In "C," this array usage is possible:
</p>

<blockquote><pre>int ar[] = {1, 4, 6};
</pre></blockquote>

<p>
But for C++, 
</p>

<blockquote><pre>std::array&lt;int&gt; a = { 1, 4, 6 }; // error
</pre></blockquote>

<p>
Instead, the second parameter of the <tt>array</tt> template must be
explicit, like so:
</p>

<blockquote><pre>std::array&lt;int, 3&gt; a = { 1, 4, 6 };
</pre></blockquote>

<p>
Doug Gregor proposes the following solution, that assumes
generalized initializer lists.
</p>

<blockquote><pre>template&lt;typename T, typename... Args&gt;
inline array&lt;T, sizeof...(Args)&gt; 
make_array(Args&amp;&amp;... args) 
{ return { std::forward&lt;Args&gt;(args)... };  }
</pre></blockquote>

<p>
Then, the way to build an <tt>array</tt> from a list of unknown size is:
</p>

<blockquote><pre>auto a = make_array&lt;T&gt;(1, 4, 6);
</pre></blockquote>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
Benjamin: Move to Ready?
</p>
<p>
Bjarne: I'm not convinced this is useful enough to add, so I'd like us
to have time to reflect on it.
</p>
<p>
Alisdair: the constraints are wrong, they should be
</p>
<blockquote><pre>template&lt;ValueType T, ValueType... Args&gt;
requires Convertible&lt;Args, T&gt;...
array&lt;T, sizeof...(Args)&gt; make_array(Args&amp;&amp;... args);
</pre></blockquote>
<p>
Alidair: this would be useful if we had a constexpr version.
</p>
<p>
Bjarne: this is probably useful for arrays with a small number of
elements, but it's not clearly useful otherwise.
</p>
<p>
Consensus is to move to Open.
</p>
</blockquote>

<p><i>[
2009-06-07 Daniel adds:
]</i></p>


<blockquote>
<p>
I suggest a fix and a simplification of the current proposal: Recent
prototyping by
Howard showed, that a fix is required because narrowing conversion
8.5.4 [dcl.init.list]/6 b.3
would severely limit the possible distribution of argument types, e.g.
the expression
<tt>make_array&lt;double&gt;(1, 2.0)</tt> is ill-formed, because the narrowing
happens <em>inside</em> the
function body where no constant expressions exist anymore. Furthermore
given e.g.
</p>
<blockquote><pre>int f();
double g();
</pre></blockquote>
<p>
we probably want to support
</p>
<blockquote><pre>make_array&lt;double&gt;(f(), g());
</pre></blockquote>

<p>
as well. To make this feasible, the currently suggested expansion
</p>

<blockquote><pre>{ std::forward&lt;Args&gt;(args)... }
</pre></blockquote>

<p>
needs to be replaced by
</p>

<blockquote><pre>{ static_cast&lt;T&gt;(std::forward&lt;Args&gt;(args))... }
</pre></blockquote>

<p>
which is safe, because we already ensure convertibility via the
element-wise <tt>Convertible&lt;Args, T&gt;</tt> requirement. Some other fixes are
necessary: The <tt>ValueType</tt> requirement for the function <em>parameters</em>
is invalid, because all lvalue arguments will deduce to an lvalue-reference,
thereby no longer satisfying this requirement.
</p>

<p>
The suggested simplification is to provide a default-computed effective
type for the result array based on common_type and decay, in
unconstrained form:
</p>

<blockquote><pre>template&lt;typename... Args&gt;
array&lt;typename decay&lt;typename common_type&lt;Args...&gt;::type&gt;::type,
sizeof...(Args)&gt;
make_array(Args&amp;&amp;... args);
</pre></blockquote>

<p>
The approach used below is similar to that of <tt>make_pair</tt> and <tt>make_tuple</tt>
using a symbol <tt>C</tt> to represent the decayed common type [Note: Special
handling of <tt>reference_wrapper</tt> types is intentionally <em>not</em> provided, because
our target has so satisfy <tt>ValueType</tt>, thus under the revised proposal only
an all-<tt>reference_wrapper</tt>-arguments would be well-formed and an array of
<tt>reference_wrapper</tt> will be constructed]. I do currently not suggest to
add new concepts reflecting <tt>decay</tt> and <tt>common_type</tt>, but an implementor will
need something like this to succeed. Note that we use a similar fuzziness for
<tt>make_pair</tt> and <tt>make_tuple</tt> currently. This fuzziness is not related to
the currently
missing <tt>Constructible&lt;Vi, Ti&amp;&amp;&gt;</tt> requirement for those functions. The following
proposal fixes that miss for <tt>make_array</tt>. If the corresponding <tt>C</tt> type
deduction is
explicitly wanted for standardization, here the implementation
</p>

<blockquote><pre>auto concept DC&lt;typename... T&gt; {
  typename type = typename decay&lt;typename common_type&lt;T...&gt;::type&gt;::type;
}
</pre></blockquote>

<p>
where <tt>C</tt> is identical to <tt>DC&lt;Args...&gt;::type</tt> in the proposed resolution below.
</p>
<p>
I intentionally added no further type relation between type and the concept
template parameters, but instead added this requirement below to make
the specification as transparent as possible. As written this concept is
satisfied, if the corresponding associated type exists.
</p>

<p><b>Suggested Resolution:</b></p>

<ol>
<li>
<p>
Add to the array synopsis in 23.3 [sequences]:
</p>
<blockquote><pre><ins>
template&lt;ReferentType... Args&gt;
requires ValueType&lt;C&gt; &amp;&amp; IdentityOf&lt;Args&gt; &amp;&amp; Constructible&lt;C, Args&amp;&amp;&gt;...
array&lt;C, sizeof...(Args)&gt;
make_array(Args&amp;&amp;... args);
</ins>
</pre></blockquote>
</li>

<li>
<p>
Append after 23.3.1.8 [array.tuple] Tuple interface to class template array
the following new section:
</p>
<blockquote>
<p>
23.4.1.7 Array creation functions [array.creation]
</p>

<pre><ins>
template&lt;ReferentType... Args&gt;
requires ValueType&lt;C&gt; &amp;&amp; IdentityOf&lt;Args&gt; &amp;&amp; Constructible&lt;C, Args&amp;&amp;&gt;...
array&lt;C, sizeof...(Args)&gt;
make_array(Args&amp;&amp;... args);</ins>
</pre>

<blockquote>
<p><ins>
Let <tt>C</tt> be <tt>decay&lt;common_type&lt;Args...&gt;::type&gt;::type</tt>.
</ins></p>
<p>
<ins><i>Returns:</i> an <tt>array&lt;C, sizeof...(Args)&gt;</tt> initialized with
<tt>{ static_cast&lt;C&gt;(std::forward&lt;Args&gt;(args))... }</tt>.
</ins></p>
</blockquote>
</blockquote>

</li>

</ol>

</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
<p>
The proposed resolution uses concepts.
</p>
<p>
Daniel to rewrite the proposed resolution.
</p>
<p>
Leave Open.
</p>
</blockquote>

<p><i>[
2009-07-25 Daniel provides rewritten proposed resolution.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Argument for NAD future: everything about this could be added on. This
does not require changes to the existing text.
</blockquote>



<p><b>Proposed resolution:</b></p>

<ol>
<li>
<p>
Add to the array synopsis in 23.3 [sequences]:
</p>

<blockquote><pre><ins>template&lt;class... Args&gt;
  array&lt;<i>CT</i>, sizeof...(Args)&gt;
  make_array(Args&amp;&amp;... args);</ins>
</pre></blockquote>
</li>

<li>
<p>
Append after 23.3.1.8 [array.tuple] "Tuple interface to class template array" the
following new section:
</p>

<blockquote>
<p>
<ins>XX.X.X.X Array creation functions [array.creation]</ins>
</p>

<pre><ins>
template&lt;class... Args&gt;
array&lt;<i>CT</i>, sizeof...(Args)&gt;
make_array(Args&amp;&amp;... args)
</ins></pre>

<blockquote>
<p>
<ins>Let <i>CT</i> be <tt>decay&lt;common_type&lt;Args...&gt;::type&gt;::type</tt>.</ins>
</p>
<p>
<ins><i>Returns:</i> An <tt>array&lt;<i>CT</i>, sizeof...(Args)&gt;</tt> initialized with <tt>{
static_cast&lt;<i>CT</i>&gt;(std::forward&lt;Args&gt;(args))... }</tt>.</ins>
</p>

<p><ins>
[<i>Example:</i>
</ins></p>
<blockquote><pre><ins>
int i = 0; int&amp; ri = i;
make_array(42u, i, 2.78, ri);
</ins></pre></blockquote>
<p><ins>
returns an array of type
</ins></p>
<blockquote><pre><ins>
array&lt;double, 4&gt;
</ins></pre></blockquote>

<p><ins>
<i>end example</i>]</ins>
</p>
</blockquote>
</blockquote>
</li>

</ol>








<hr>
<h3><a name="855"></a>855. capacity() and reserve() for deque?</h3>
<p><b>Section:</b> 23.3.2.2 [deque.capacity] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Herv Brnnimann <b>Opened:</b> 2008-06-11 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#deque.capacity">issues</a> in [deque.capacity].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The main point is that <tt>capacity</tt> can be viewed as a mechanism to  
guarantee the validity of <tt>iterators</tt> when only <tt>push_back/pop_back</tt>
operations are used.  For <tt>vector</tt>, this goes with reallocation.  For  
<tt>deque</tt>, this is a bit more subtle:  <tt>capacity()</tt> of a <tt>deque</tt> may shrink,  
whereas that of <tt>vector</tt> doesn't.   In a circular buffer impl. of the  
map, as Howard did, there is very similar notion of capacity: as long  
as <tt>size()</tt> is less than <tt>B * (</tt>total size of the map <tt>- 2)</tt>, it is  
guaranteed that no <tt>iterator</tt> is invalidated after any number of  
<tt>push_front/back</tt> and <tt>pop_front/back</tt> operations.  But this does not  
hold for other implementations.
</p>
<p>
Still, I believe, <tt>capacity()</tt> can be defined by <tt>size() +</tt>  how many  
<tt>push_front/back</tt> minus <tt>pop_front/back</tt> that can be performed before  
terators are invalidated.  In a classical impl., <tt>capacity() = size()
+ </tt> the min distance to either "physical" end of the deque (i.e.,  
counting the empty space in the last block plus all the blocks until  
the end of the map of block pointers).  In Howard's circular buffer  
impl., <tt>capacity() = B * (</tt>total size of the map <tt>- 2)</tt> still works with  
this definition, even though the guarantee could be made stronger.
</p>
<p>
A simple picture of a deque:
</p>
<blockquote><pre>A-----|----|-----|---F+|++++|++B--|-----|-----Z
</pre></blockquote>
<p>
(A,Z mark the beginning/end, | the block boundaries, F=front, B=back,  
and - are uninitialized, + are initialized)
In that picture:  <tt>capacity = size() + min(dist(A,F),dist(B,Z)) = min 
(dist(A,B),dist(F,Z))</tt>.
</p>
<p>
<tt>Reserve(n)</tt> can grow the map of pointers and add possibly a number of  
empty blocks to it, in order to guarantee that the next <tt>n-size()
push_back/push_front</tt> operations will not invalidate iterators, and  
also will not allocate (i.e. cannot throw).  The second guarantee is  
not essential and can be left as a QoI.  I know well enough existing  
implementations of <tt>deque</tt> (sgi/stl, roguewave, stlport, and  
dinkumware) to know that either can be implemented with no change to  
the existing class layout and code, and only a few modifications if  
blocks are pre-allocated (instead of always allocating a new block,  
check if the next entry in the map of block pointers is not zero).
</p>
<p>
Due to the difference with <tt>vector</tt>, wording is crucial.  Here's a  
proposed wording to make things concrete;  I tried to be reasonably  
careful but please double-check me:
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
Hans: should the Returns clause for capacity read "1 Returns: A lower
bound..." rather than "1 Returns: An upper bound..."
</p>
<p>
Howard: maybe what's needed is capacity_front and capacity_back. In
fact, I think I implemented a deque that had these members as
implementation details.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>

<p>
Add new signatures to synopsis in 23.3.2 [deque]:
</p>

<blockquote><pre>size_type capacity() const;
bool reserve(size_type n);
</pre></blockquote>

<p>
Add new signatures to 23.3.2.2 [deque.capacity]:
</p>

<blockquote>
<pre>size_type capacity() const;
</pre>
<blockquote>
<p>
1 <i>Returns:</i> An upper bound on <tt>n + max(n_f - m_f, n_b - m_b)</tt>  such  
that, for any sequence of <tt>n_f push_front</tt>, <tt>m_f pop_front</tt>, <tt>n_b  
push_back</tt>, and <tt>m_b pop_back</tt> operations, interleaved in any order,  
starting with the current <tt>deque</tt> of size <tt>n</tt>, the <tt>deque</tt> does not  
invalidate any of its iterators except to the erased elements.
</p>
<p>
2 <i>Remarks:</i>  Unlike a <tt>vector</tt>'s capacity, the capacity of a <tt>deque</tt> can  
decrease after a sequence of insertions at both ends, even if none of  
the operations caused the <tt>deque</tt> to invalidate any of its iterators  
except to the erased elements.
</p>
</blockquote>
</blockquote>

<blockquote>
<pre>bool reserve(size_type n);
</pre>
<blockquote>
<p>
2 <i>Effects:</i> A directive that informs a <tt>deque</tt> of a planned sequence of  
<tt>push_front</tt>, <tt>pop_front</tt>, <tt>push_back</tt>, and <tt>pop_back</tt> operations, so that it  
can manage iterator invalidation accordingly. After <tt>reserve()</tt>,  
<tt>capacity()</tt> is greater or equal to the argument of <tt>reserve</tt> if this  
operation returns <tt>true</tt>; and equal to the previous value of <tt>capacity()</tt>
otherwise.  If an exception is thrown, there are no effects.
</p>
<p>
3 <i>Returns:</i> <tt>true</tt> if iterators are invalidated as a result of this  
operation, and false otherwise.
</p>
<p>
4 <i>Complexity:</i> It does not change the size of the sequence and takes  
at most linear time in <tt>n</tt>.
</p>
<p>
5 <i>Throws:</i> <tt>length_error</tt> if <tt>n &gt; max_size()</tt>.
</p>
<p>
6 <i>Remarks:</i> It is guaranteed that no invalidation takes place during a  
sequence of <tt>insert</tt> or <tt>erase</tt> operations at either end that happens  
after a call to <tt>reserve()</tt> except to the erased elements, until the  
time when an insertion would make <tt>max(n_f-m_f, n_b-m_b)</tt> larger than  
<tt>capacity()</tt>, where <tt>n_f</tt> is the number of <tt>push_front</tt>, <tt>m_f</tt> of <tt>pop_front</tt>,  
<tt>n_b</tt> of <tt>push_back</tt>, and <tt>m_b</tt> of <tt>pop_back</tt> operations since the call to  
<tt>reserve()</tt>.
</p>
<p>
7        An implementation is free to pre-allocate buffers so as to  
offer the additional guarantee that no exception will be thrown  
during such a sequence other than by the element constructors.
</p>
</blockquote>
</blockquote>

<p>
And 23.3.2.3 [deque.modifiers] para 1, can be enhanced:
</p>

<blockquote>
1 <i>Effects:</i> An insertion in the middle of the deque invalidates all the iterators and references to elements of the
deque. An insertion at either end of the deque invalidates all the iterators to the deque,
<ins>unless provisions have been made with reserve,</ins>
but has no effect on the validity of references to elements of the deque.
</blockquote>


<p><b>Rationale:</b></p>
Complication outweighs the benefit.





<hr>
<h3><a name="862"></a>862. Impossible complexity for 'includes'</h3>
<p><b>Section:</b> 25.4.5.1 [includes] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2008-07-02 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#includes">issues</a> in [includes].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 25.4.5.1 [includes] the complexity is "at most -1 comparisons" if passed
two empty ranges.  I don't know how to perform a negative number of
comparisions!
</p>

<p>
This same issue also applies to:
</p>

<ul>
<li><tt>set_union</tt></li>
<li><tt>set_intersection</tt></li>
<li><tt>set_difference</tt></li>
<li><tt>set_symmetric_difference</tt></li>
<li><tt>merge</tt></li>
</ul>

<p><i>[
2009-03-30 Beman adds:
]</i></p>


<blockquote>
Suggest NAD. The complexity of empty ranges is -1 in other places in the
standard. See 25.4.4 [alg.merge] <tt>merge</tt> and
<tt>inplace_merge</tt>, and <tt>forward_list</tt> merge, for example.
The time and effort to find and fix all places in the standard where
empty range[s] result in negative complexity isn't worth the very
limited benefit.
</blockquote>

<p><i>[
2009-05-09 Alisdair adds:
]</i></p>


<blockquote>
<p>
I'm not happy with NAD if we can find a simple solution.
</p>
<p>
How about adding a rider somewhere in clause 17 suggesting that complexities
that specify a negative number of operations are treated as specifying zero
operations?  That should generically solve the issue without looking for
further cases.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Pete to provide "straightforward" wording.
Move to NAD Editorial.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Recommend NAD.
</p>





<hr>
<h3><a name="863"></a>863. What is the state of a stream after close() succeeds</h3>
<p><b>Section:</b> 27.9.1 [fstreams] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Steve Clamage <b>Opened:</b> 2008-07-08 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#fstreams">issues</a> in [fstreams].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Suppose writing to an <tt>[o]fstream</tt> fails and you later close the <tt>stream</tt>.
The <tt>overflow()</tt> function is called to flush the buffer (if it exists).
Then the file is unconditionally closed, as if by calling <tt>flcose</tt>.
</p>
<p>
If either <tt>overflow</tt> or <tt>fclose</tt> fails, <tt>close()</tt> reports failure, and clearly
the <tt>stream</tt> should be in a failed or bad state.
</p>
<p>
Suppose the buffer is empty or non-existent (so that <tt>overflow()</tt> does not
fail), and <tt>fclose</tt> succeeds. The <tt>close()</tt> function reports success, but
what is the state of the <tt>stream</tt>?
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Tom's impression is that the issue is about the <tt>failbit</tt>, etc.
</p>
<p>
Bill responds that the stream is now closed,
and any status bits remain unchanged.
</p>
<p>
See the description of <tt>close()</tt> in 27.9.1.17 [fstream.members].
</p>
<p>
We prefer not to add wording to say that nothing changes.
Move to NAD.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="864"></a>864. Defect in atomic wording</h3>
<p><b>Section:</b> 29.6 [atomics.types.operations] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Anthony Williams <b>Opened:</b> 2008-07-10 <b>Last modified:</b> 2010-10-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#atomics.types.operations">active issues</a> in [atomics.types.operations].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics.types.operations">issues</a> in [atomics.types.operations].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There's an error in 29.6 [atomics.types.operations]/p9:
</p>

<blockquote>
<pre>C atomic_load(const volatile A * object);
C atomic_load_explicit(const volatile A * object, memory_order);
C A ::load(memory_order order = memory_order_seq_cst) const volatile;
</pre>
<blockquote>
<p>
<i>Requires:</i> The <tt>order</tt> argument shall not be <tt>memory_order_acquire</tt> nor
<tt>memory_order_acq_rel</tt>.
</p>
</blockquote>
</blockquote>

<p>
I believe that this should state
</p>
<blockquote>
shall not be <tt>memory_order_release</tt>.
</blockquote>

<p>
There's also an error in 29.6 [atomics.types.operations]/p17:
</p>

<blockquote>
... When only one <tt>memory_order</tt> argument is supplied, the value of success
is <tt>order</tt>, and
the value of failure is <tt>order</tt> except that a value of
<tt>memory_order_acq_rel</tt> shall be replaced by the value
<tt>memory_order_require</tt> ...
</blockquote>
<p>
I believe this should state
</p>
<blockquote>
shall be replaced by the value <tt>memory_order_acquire</tt> ...
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 29.6 [atomics.types.operations]/p9:
</p>

<blockquote>
<pre>C atomic_load(const volatile A * object);
C atomic_load_explicit(const volatile A * object, memory_order);
C A ::load(memory_order order = memory_order_seq_cst) const volatile;
</pre>
<blockquote>
<p>
<i>Requires:</i> The <tt>order</tt> argument shall not be <del><tt>memory_order_acquire</tt></del>
<ins><tt>memory_order_release</tt></ins> nor <tt>memory_order_acq_rel</tt>.
</p>
</blockquote>
</blockquote>

<p>
Change 29.6 [atomics.types.operations]/p17:
</p>

<blockquote>
... When only one <tt>memory_order</tt> argument is supplied, the value of success
is <tt>order</tt>, and
the value of failure is <tt>order</tt> except that a value of
<tt>memory_order_acq_rel</tt> shall be replaced by the value
<del><tt>memory_order_require</tt></del> <ins><tt>memory_order_acquire</tt></ins> ...
</blockquote>



<p><b>Rationale:</b></p>
Already fixed by the time the LWG processed it.





<hr>
<h3><a name="867"></a>867. Valarray and value-initialization</h3>
<p><b>Section:</b> 26.6.2.1 [valarray.cons] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alberto Ganesh Barbati <b>Opened:</b> 2008-07-20 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#valarray.cons">issues</a> in [valarray.cons].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
From 26.6.2.1 [valarray.cons], paragraph 2:
</p>

<blockquote><pre>explicit  valarray(size_t);
</pre>
<blockquote>
The array created by this constructor has a length equal to the value of the argument. The elements
of the array are constructed using the default constructor for the instantiating type <tt>T</tt>.
</blockquote>
</blockquote>

<p>
The problem is that the most obvious <tt>T</tt>s for <tt>valarray</tt> are <tt>float</tt>
and <tt>double</tt>, they don't have a default constructor. I guess the intent is to value-initialize
the elements, so I suggest replacing:
</p>

<blockquote>
The elements of the array are constructed using the default constructor for the instantiating type <tt>T</tt>.
</blockquote>
<p>
with
</p>
<blockquote>
The elements of the array are value-initialized.
</blockquote>

<p>
There is another reference to the default constructor of <tt>T</tt> in the non-normative note in paragraph 9.
That reference should also be replaced. (The normative wording in paragraph 8 refers to <tt>T()</tt>
and so it doesn't need changes).
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to NAD Editorial.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 26.6.2.1 [valarray.cons], paragraph 2:
</p>

<blockquote>
<pre>explicit  valarray(size_t);
</pre>
<blockquote>
The array created by this constructor has a length equal to the value of the argument. The elements
of the array are <del>constructed using the default constructor for the instantiating type <tt>T</tt></del>
<ins>value-initialized (8.5 [dcl.init])</ins>.
</blockquote>
</blockquote>

<p>
Change 26.6.2.7 [valarray.members], paragraph 9:
</p>

<blockquote>
[<i>Example:</i> If the argument has the value -2, the first two elements of the result will be <del>constructed using the 
default constructor</del>
<ins>value-initialized (8.5 [dcl.init])</ins>;
the third element of the result will be assigned the value of the first element of the argument; etc. <i>-- end example</i>]
</blockquote>






<hr>
<h3><a name="873"></a>873. signed integral type and unsigned integral type are not clearly defined</h3>
<p><b>Section:</b> 3.9.1 [basic.fundamental] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Travis Vitek <b>Opened:</b> 2008-06-30 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
    <p>
      Neither the term "signed integral type" nor the term "unsigned
      integral type" is defined in the core language section of the
      standard, therefore the library section should avoid its use.  The
      terms <i>signed integer type</i> and <i>unsigned integer type</i> are
      indeed defined (in 3.9.1 [basic.fundamental]), thus the usages should be
      replaced accordingly.
    </p>

    <p>
      Note that the key issue here is that "signed" + "integral type" !=
      "signed integral type".
      
      The types <code>bool</code>, <code>char</code>, <code>char16_t</code>,
      <code>char32_t</code> and <code>wchar_t</code> are all listed as
      integral types, but are neither of <i>signed integer type</i> or
      <i>unsigned integer type</i>. According to 3.9 [basic.types] p7, a synonym for
      integral type is <i>integer type</i>.
      
      Given this, one may choose to assume that an <i>integral type</i> that
      can represent values less than zero is a <i>signed integral type</i>.
      Unfortunately this can cause ambiguities.
      
      As an example, if <code>T</code> is <code>unsigned char</code>, the
      expression <code>make_signed&lt;T&gt;::type</code>, is supposed to
      name a signed integral type. There are potentially two types that
      satisfy this requirement, namely <code>signed char</code> and
      <code>char</code> (assuming <code>CHAR_MIN &lt; 0</code>).
    </p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
Plum, Sebor to review.
</blockquote>

<p><i>[
Post Summit Daniel adds:
]</i></p>


<blockquote>
The proposed resolution needs to be "conceptualized". Currently we have
in  [concept.support] only concept <tt>IntegralType</tt>
for all "integral types", thus indeed the current <tt>Container</tt>
concept and Iterator concepts are sufficiently satisfied with "integral
types". If the changes are applied, we might ask core for concept
<tt>BilateralIntegerType</tt> and add proper restrictions to the library
concepts.
</blockquote>

  

  <p><b>Proposed resolution:</b></p>
    <p>
      I propose to use the terms "signed integer type" and "unsigned integer
      type" in place of "signed integral type" and "unsigned integral type"
      to eliminate such ambiguities.
    </p>
    
    <p>
      The proposed change makes it absolutely clear that the difference
      between two pointers cannot be <tt>char</tt> or <tt>wchar_t</tt>,
      but could be any of the signed integer types.
      5.7 [expr.add] paragraph 6...
    </p>
    <blockquote>
      <p>
        </p><ol>
          <li>
            When two pointers to elements of the same array object are
            subtracted, the result is the difference of the subscripts of
            the two array elements. The type of the result is an
            implementation-defined <del>signed integral
            type</del><ins>signed integer type</ins>; this type shall be the
            same type that is defined as <code>std::ptrdiff_t</code> in the
            <code>&lt;cstdint&gt;</code> header (18.1)...
          </li>
        </ol>
      <p></p>
    </blockquote>

    <p>
      The proposed change makes it clear that <tt>X::size_type</tt> and
      <tt>X::difference_type</tt> cannot be <tt>char</tt> or
      <tt>wchar_t</tt>, but could be one of the signed or unsigned integer
      types as appropriate.
      20.2.5 [allocator.requirements] table 40...
    </p>
    <blockquote>
      Table 40: Allocator requirements
      <table border="1">
        <thead>
          <tr>
            <th>expression</th>
            <th>return type</th>
            <th>assertion/note/pre/post-condition</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><tt>X::size_type</tt></td>
            <td>
              <del>unsigned integral type</del>
              <ins>unsigned integer type</ins>
            </td>
            <td>a type that can represent the size of the largest object in
            the allocation model.</td>
          </tr>
          <tr>
            <td><tt>X::difference_type</tt></td>
            <td>
              <del>signed integral type</del>
              <ins>signed integer type</ins>
            </td>
            <td>a type that can represent the difference between any two
            pointers in the allocation model.</td>
          </tr>
        </tbody>
      </table>
    </blockquote>

    <p>
      The proposed change makes it clear that <tt>make_signed&lt;T&gt;::type</tt>
      must be one of the signed integer types as defined in 3.9.1. Ditto for
      <tt>make_unsigned&lt;T&gt;type</tt> and unsigned integer types.
      20.7.7.3 [meta.trans.sign] table 48...
    </p>
    <blockquote>
      Table 48: Sign modifications
      <table border="1">
        <thead>
          <tr>
            <th>Template</th>
            <th>Comments</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>
              <tt>template &lt;class T&gt; struct make_signed;</tt>
            </td>
            <td>
              If <code>T</code> names a (possibly cv-qualified) <del>signed
              integral type</del><ins>signed integer type</ins> (3.9.1) then
              the member typedef <code>type</code> shall name the type
              <code>T</code>; otherwise, if <code>T</code> names a (possibly
              cv-qualified) <del>unsigned integral type</del><ins>unsigned
              integer type</ins> then <code>type</code> shall name the
              corresponding <del>signed integral type</del><ins>signed
              integer type</ins>, with the same cv-qualifiers as
              <code>T</code>; otherwise, <code>type</code> shall name the
              <del>signed integral type</del><ins>signed integer type</ins>
              with the smallest rank (4.13) for which <code>sizeof(T) ==
              sizeof(type)</code>, with the same cv-qualifiers as
              <code>T</code>.

              <i>Requires:</i> <code>T</code> shall be a (possibly
              cv-qualified) integral type or enumeration but not a
              <code>bool</code> type.
            </td>
          </tr>
          <tr>
            <td>
              <tt>template &lt;class T&gt; struct make_unsigned;</tt>
            </td>
            <td>
              If <code>T</code> names a (possibly cv-qualified)
              <del>unsigned integral type</del><ins>unsigned integer
              type</ins> (3.9.1) then the member typedef <code>type</code>
              shall name the type <code>T</code>; otherwise, if
              <code>T</code> names a (possibly cv-qualified) <del>signed
              integral type</del><ins>signed integer type</ins> then
              <code>type</code> shall name the corresponding <del>unsigned
              integral type</del><ins>unsigned integer type</ins>, with the
              same cv-qualifiers as <code>T</code>; otherwise,
              <code>type</code> shall name the <del>unsigned integral
              type</del><ins>unsigned integer type</ins> with the smallest
              rank (4.13) for which <code>sizeof(T) == sizeof(type)</code>,
              with the same cv-qualifiers as <code>T</code>.

              <i>Requires:</i> <code>T</code> shall be a (possibly
              cv-qualified) integral type or enumeration but not a
              <code>bool</code> type.
            </td>
          </tr>
        </tbody>
      </table>
    </blockquote>


    <p>
      Note: I believe that the basefield values should probably be
      prefixed with <tt>ios_base::</tt> as they are in 22.4.2.2.2 [facet.num.put.virtuals]

      The listed virtuals are all overloaded on signed and unsigned integer
      types, the new wording just maintains consistency.

      22.4.2.1.2 [facet.num.get.virtuals] table 78...
    </p>
    <blockquote>
      Table 78: Integer Conversions
      <table border="1">
        <thead>
          <tr>
            <th>State</th>
            <th><tt>stdio</tt> equivalent</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><tt>basefield == oct</tt></td>
            <td><tt>%o</tt></td>
          </tr>
          <tr>
            <td><tt>basefield == hex</tt></td>
            <td><tt>%X</tt></td>
          </tr>
          <tr>
            <td><tt>basefield == 0</tt></td>
            <td><tt>%i</tt></td>
          </tr>
          <tr>
            <td><del>signed integral type</del><ins>signed integer
            type</ins></td>
            <td><tt>%d</tt></td>
          </tr>
          <tr>
            <td><del>unsigned integral type</del><ins>unsigned integer
            type</ins></td>
            <td><tt>%u</tt></td>
          </tr>
        </tbody>
      </table>
    </blockquote>

    
    
    <p>
      Rationale is same as above.
      22.4.2.2.2 [facet.num.put.virtuals] table 80...
    </p>
    <blockquote>
      Table 80: Integer Conversions
      <table border="1">
        <thead>
          <tr>
            <th>State</th>
            <th><tt>stdio</tt> equivalent</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><tt>basefield == ios_base::oct</tt></td>
            <td><tt>%o</tt></td>
          </tr>
          <tr>
            <td><tt>(basefield == ios_base::hex) &amp;&amp;
            !uppercase</tt></td>
            <td><tt>%x</tt></td>
          </tr>
          <tr>
            <td><tt>(basefield == ios_base::hex)</tt></td>
            <td><tt>%X</tt></td>
          </tr>
          <tr>
            <td><tt>basefield == 0</tt></td>
            <td><tt>%i</tt></td>
          </tr>
          <tr>
            <td>for a <del>signed integral type</del><ins>signed integer
            type</ins></td>
            <td><tt>%d</tt></td>
          </tr>
          <tr>
            <td>for a <del>unsigned integral type</del><ins>unsigned integer
            type</ins></td>
            <td><tt>%u</tt></td>
          </tr>
        </tbody>
      </table>
    </blockquote>

    
    <p>
      23.2 [container.requirements] table 80...
    </p>
    <blockquote>
      Table 89: Container requirements
      <table border="1">
        <thead>
          <tr>
            <th>expression</th>
            <th>return type</th>
            <th>operational semantics</th>
            <th>assertion/note/pre/post-condition</th>
            <th>complexity</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><tt>X::difference_type</tt></td>
            <td><del>signed integral type</del><ins>signed integer type</ins></td>
            <td>&nbsp;</td>
            <td>is identical to the difference type of <tt>X::iterator</tt>
            and <tt>X::const_iterator</tt></td>
            <td>compile time</td>
          </tr>
          <tr>
            <td><tt>X::size_type</tt></td>
            <td><del>unsigned integral type</del><ins>unsigned integer type</ins></td>
            <td>&nbsp;</td>
            <td><tt>size_type</tt> can represent any non-negative value of
            <tt>difference_type</tt></td>
            <td>compile time</td>
          </tr>
        </tbody>
      </table>
    </blockquote>

    <p>
      X [iterator.concepts] paragraph 1...
    </p>
    <blockquote>
      Iterators are a generalization of pointers that allow a C++ program to
      work with different data structures (containers) in a uniform manner.
      To be able to construct template algorithms that work correctly and
      efficiently on different types of data structures, the library
      formalizes not just the interfaces but also the semantics and
      complexity assumptions of iterators. All input iterators
      <code>i</code> support the expression <code>*i</code>, resulting in a
      value of some class, enumeration, or built-in type <code>T</code>,
      called the <i>value type</i> of the iterator. All output iterators
      support the expression <code>*i = o</code> where <code>o</code> is a
      value of some type that is in the set of types that are
      <i>writable</i> to the particular iterator type of <code>i</code>. All
      iterators <code>i</code> for which the expression <code>(*i).m</code>
      is well-defined, support the expression <code>i-&gt;m</code> with the
      same semantics as <code>(*i).m</code>. For every iterator type
      <code>X</code> for which equality is defined, there is a corresponding
      <del>signed integral type</del> <ins>signed integer type</ins> called
      the <i>difference type</i> of the iterator.
    </blockquote>
    
    <p>
      I'm a little unsure of this change. Previously this paragraph would
      allow instantiations of <tt>linear_congruential_engine</tt> on
      <tt>char</tt>, <tt>wchar_t</tt>, <tt>bool</tt>, and other types. The
      new wording prohibits this.
      26.5.3.1 [rand.eng.lcong] paragraph 2...
    </p>
    <blockquote>
      The template parameter <code>UIntType</code> shall denote an
      <del>unsigned integral type</del><ins>unsigned integer type</ins>
      large enough to store values as large as <code>m - 1</code>. If the
      template parameter <code>m</code> is 0, the modulus <code>m</code>
      used throughout this section 26.4.3.1 is
      <code>numeric_limits&lt;result_type&gt;::max()</code> plus 1.  [Note:
      The result need not be representable as a value of type
      <code>result_type</code>. --end note] Otherwise, the following
      relations shall hold: <code>a &lt; m</code> and <code>c &lt;
      m</code>.
    </blockquote>
    
    <p>
      Same rationale as the previous change.
      X [rand.adapt.xor] paragraph 6...
    </p>
    <blockquote>
      Both <code>Engine1::result_type</code> and
      <code>Engine2::result_type</code> shall denote (possibly different)
      <del>unsigned integral types</del><ins>unsigned integer types</ins>.
      The member <i>result_type</i> shall denote either the type
      <i>Engine1::result_type</i> or the type <i>Engine2::result_type</i>,
      whichever provides the most storage according to clause 3.9.1.
    </blockquote>
    
    <p>
      26.5.7.1 [rand.util.seedseq] paragraph 7...
    </p>
    <blockquote>
      <i>Requires:</i><code>RandomAccessIterator</code> shall meet the
      requirements of a random access iterator (24.1.5) such that
      <code>iterator_traits&lt;RandomAccessIterator&gt;::value_type</code>
      shall denote an <del>unsigned integral type</del><ins>unsigned integer
      type</ins> capable of accomodating 32-bit quantities.  
    </blockquote>

    <p>
      By making this change, integral types that happen to have a signed
      representation, but are not signed integer types, would no longer be
      required to use a two's complement representation. This may go against
      the original intent, and should be reviewed.
      29.6 [atomics.types.operations] paragraph 24...
    </p>
    <blockquote>
      <i>Remark:</i> For <del>signed integral types</del><ins>signed integer
      types</ins>, arithmetic is defined using two's complement
      representation. There are no undefined results. For address types, the
      result may be an undefined address, but the operations otherwise have
      no undefined behavior.
    </blockquote>
    
  




<hr>
<h3><a name="874"></a>874. Missing <tt>initializer_list</tt> constructor for <tt>discrete_distribution</tt></h3>
<p><b>Section:</b> 26.5.8.5.1 [rand.dist.samp.discrete] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-08-22 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.dist.samp.discrete">issues</a> in [rand.dist.samp.discrete].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
During the Sophia Antipolis meeting it was decided to separate from <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#793">793</a> a
subrequest that adds initializer list support to
<tt>discrete_distribution</tt>, specifically,
the issue proposed to add a c'tor taking a <tt>initializer_list&lt;double&gt;</tt>.
</p>



<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
In 26.5.8.5.1 [rand.dist.samp.discrete]/1, class <tt>discrete_distribution</tt>,
just <em>before</em> the member declaration
</p>

<blockquote><pre>explicit discrete_distribution(const param_type&amp; parm);
</pre></blockquote>

<p>
insert
</p>

<blockquote><pre>discrete_distribution(initializer_list&lt;double&gt; wl);
</pre></blockquote>
</li>

<li>
<p>
Between p.4 and p.5 of the same section insert a new
paragraph as part of the new member description:
</p>

<blockquote><pre>discrete_distribution(initializer_list&lt;double&gt; wl);
</pre>

<blockquote>
<i>Effects:</i> Same as <tt>discrete_distribution(wl.begin(), wl.end())</tt>.
</blockquote>
</blockquote>
</li>
</ol>


<p><b>Rationale:</b></p>
Addressed by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2836.pdf">N2836</a> "Wording Tweaks for Concept-enabled Random Number Generation in C++0X".





<hr>
<h3><a name="875"></a>875. Missing <tt>initializer_list</tt> constructor for <tt>piecewise_constant_distribution</tt></h3>
<p><b>Section:</b> 26.5.8.5.2 [rand.dist.samp.pconst] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-08-22 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.dist.samp.pconst">issues</a> in [rand.dist.samp.pconst].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
During the Sophia Antipolis meeting it was decided to separate from
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#794">794</a> a subrequest that adds initializer list support to
<tt>piecewise_constant_distribution</tt>, specifically, the issue proposed
to add a c'tor taking a <tt>initializer_list&lt;double&gt;</tt> and a <tt>Callable</tt> to evaluate
weight values. For consistency with the remainder of this class and
the remainder of the <tt>initializer_list</tt>-aware library the author decided to
change the list argument type to the template parameter <tt>RealType</tt>
instead. For the reasoning to use <tt>Func</tt> instead of <tt>Func&amp;&amp;</tt> as c'tor
function argument see issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#793">793</a>.
</p>


<p><b>Proposed resolution:</b></p>
<p><b>Non-concept version of the proposed resolution</b></p>

<ol>
<li>
<p>
In 26.5.8.5.2 [rand.dist.samp.pconst]/1, class <tt>piecewise_constant_distribution</tt>,
just <em>before</em> the member declaration
</p>

<blockquote><pre>explicit piecewise_constant_distribution(const param_type&amp; parm);
</pre></blockquote>

<p>
insert
</p>

<blockquote><pre>template&lt;typename Func&gt;
piecewise_constant_distribution(initializer_list&lt;RealType&gt; bl, Func fw);
</pre></blockquote>
</li>

<li>
<p>
Between p.4 and p.5 of the same section insert a series of
new paragraphs nominated below as [p5_1], [p5_2], and [p5_3]
as part of the new member description:
</p>

<blockquote><pre>template&lt;typename Func&gt;
piecewise_constant_distribution(initializer_list&lt;RealType&gt; bl, Func fw);
</pre>

<blockquote>

<p>
[p5_1] <i>Complexity:</i> Exactly <tt>nf = max(bl.size(), 1) - 1</tt> invocations of <tt>fw</tt>.
</p>

<p>
[p5_2] <i>Requires:</i>
</p>

<ol type="a">
<li>
<tt>fw</tt> shall be callable with one argument of type <tt>RealType</tt>, and shall
   return values of a type convertible to <tt>double</tt>;
</li>
<li>
The relation <tt>0 &lt; S = w<sub>0</sub>+. . .+w<sub>n-1</sub></tt> shall hold. 
For all sampled values <tt><i>x<sub>k</sub></i></tt> defined below, <tt>fw(<i>x<sub>k</sub></i>)</tt> shall return a weight
   value <tt><i>w<sub>k</sub></i></tt> that is non-negative, non-NaN, and non-infinity;
</li>
<li>
If <tt>nf &gt; 0</tt> let <tt>b<sub><i>k</i></sub> = *(bl.begin() + k), k = 0, . . . , bl.size()-1</tt> and the
following relations shall hold for <tt>k = 0, . . . , nf-1: b<sub><i>k</i></sub> &lt; b<sub><i>k+1</i></sub></tt>.
</li>
</ol>

<p>
[p5_3] <i>Effects:</i>
</p>

<ol type="a">
<li>
<p>If <tt>nf == 0</tt>,</p>
<ol type="a">
<li>
lets the sequence <tt>w</tt> have length <tt>n = 1</tt> and consist of the single
     value <tt>w<sub>0</sub> = 1</tt>, and
</li>
<li>
lets the sequence <tt>b</tt> have length <tt>n+1</tt> with <tt>b<sub>0</sub> = 0</tt> and <tt>b<sub>1</sub> = 1</tt>.
</li>
</ol>
</li>

<li>
<p>Otherwise,</p>
<ol type="a">
<li>
sets <tt>n = nf</tt>, and <tt>[bl.begin(), bl.end())</tt> shall form the sequence <tt>b</tt> of
length <tt>n+1</tt>, and
</li>
<li>
<p>lets the sequences <tt>w</tt> have length <tt>n</tt> and for each <tt>k = 0, . . . ,n-1</tt>,
     calculates:</p>
<blockquote><pre>x<sub><i>k</i></sub> = 0.5*(b<sub><i>k+1</i></sub> + b<sub><i>k</i></sub>)
w<sub><i>k</i></sub> = fw(x<sub><i>k</i></sub>)
</pre></blockquote>
</li>
</ol>
</li>

<li>
<p>
Constructs a <tt>piecewise_constant_distribution</tt> object with
the above computed sequence <tt>b</tt> as the interval boundaries
and with the probability densities:
</p>
<blockquote><pre>&#961;<sub><i>k</i></sub> = w<sub><i>k</i></sub>/(S * (b<sub><i>k+1</i></sub> - b<sub><i>k</i></sub>)) for k = 0, . . . , n-1.
</pre></blockquote>

</li>
</ol>

</blockquote>
</blockquote>
</li>
</ol>

<p><b>Concept version of the proposed resolution</b></p>

<ol>
<li>
<p>
In 26.5.8.5.2 [rand.dist.samp.pconst]/1, class <tt>piecewise_constant_distribution</tt>,
just <em>before</em> the member declaration
</p>

<blockquote><pre>explicit piecewise_constant_distribution(const param_type&amp; parm);
</pre></blockquote>

<p>
insert
</p>

<blockquote><pre>template&lt;Callable&lt;auto, RealType&gt; Func&gt;
 requires Convertible&lt;Func::result_type, double&gt;
piecewise_constant_distribution(initializer_list&lt;RealType&gt; bl, Func fw);
</pre></blockquote>
</li>

<li>
<p>
Between p.4 and p.5 of the same section insert a series of
new paragraphs nominated below as [p5_1], [p5_2], and [p5_3]
as part of the new member description:
</p>

<blockquote><pre>template&lt;Callable&lt;auto, RealType&gt; Func&gt;
 requires Convertible&lt;Func::result_type, double&gt;
piecewise_constant_distribution(initializer_list&lt;RealType&gt; bl, Func fw);
</pre>

<blockquote>

<p>
[p5_1] <i>Complexity:</i> Exactly <tt>nf = max(bl.size(), 1) - 1</tt> invocations of <tt>fw</tt>.
</p>

<p>
[p5_2] <i>Requires:</i>
</p>

<ol type="a">
<li>
The relation <tt>0 &lt; S = w<sub>0</sub>+. . .+w<sub>n-1</sub></tt> shall hold. 
For all sampled values <tt><i>x<sub>k</sub></i></tt> defined below, <tt>fw(<i>x<sub>k</sub></i>)</tt> shall return a weight
   value <tt><i>w<sub>k</sub></i></tt> that is non-negative, non-NaN, and non-infinity;
</li>
<li>
If <tt>nf &gt; 0</tt> let <tt>b<sub><i>k</i></sub> = *(bl.begin() + k), k = 0, . . . , bl.size()-1</tt> and the
following relations shall hold for <tt>k = 0, . . . , nf-1: b<sub><i>k</i></sub> &lt; b<sub><i>k+1</i></sub></tt>.
</li>
</ol>

<p>
[p5_3] <i>Effects:</i>
</p>

<ol type="a">
<li>
<p>If <tt>nf == 0</tt>,</p>
<ol type="a">
<li>
lets the sequence <tt>w</tt> have length <tt>n = 1</tt> and consist of the single
     value <tt>w<sub>0</sub> = 1</tt>, and
</li>
<li>
lets the sequence <tt>b</tt> have length <tt>n+1</tt> with <tt>b<sub>0</sub> = 0</tt> and <tt>b<sub>1</sub> = 1</tt>.
</li>
</ol>
</li>

<li>
<p>Otherwise,</p>
<ol type="a">
<li>
sets <tt>n = nf</tt>, and <tt>[bl.begin(), bl.end())</tt> shall form the sequence <tt>b</tt> of
length <tt>n+1</tt>, and
</li>
<li>
<p>lets the sequences <tt>w</tt> have length <tt>n</tt> and for each <tt>k = 0, . . . ,n-1</tt>,
     calculates:</p>
<blockquote><pre>x<sub><i>k</i></sub> = 0.5*(b<sub><i>k+1</i></sub> + b<sub><i>k</i></sub>)
w<sub><i>k</i></sub> = fw(x<sub><i>k</i></sub>)
</pre></blockquote>
</li>
</ol>
</li>

<li>
<p>
Constructs a <tt>piecewise_constant_distribution</tt> object with
the above computed sequence <tt>b</tt> as the interval boundaries
and with the probability densities:
</p>
<blockquote><pre>&#961;<sub><i>k</i></sub> = w<sub><i>k</i></sub>/(S * (b<sub><i>k+1</i></sub> - b<sub><i>k</i></sub>)) for k = 0, . . . , n-1.
</pre></blockquote>

</li>
</ol>

</blockquote>
</blockquote>
</li>
</ol>



<p><b>Rationale:</b></p>
Addressed by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2836.pdf">N2836</a> "Wording Tweaks for Concept-enabled Random Number Generation in C++0X".





<hr>
<h3><a name="877"></a>877. to <tt>throw()</tt> or to <i>Throw:</i> Nothing.</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Future">NAD Future</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2008-08-23 <b>Last modified:</b> 2010-10-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
       <p>

Recent changes to
the <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2691.pdf">working
draft</a> have introduced a gratuitous inconsistency with the C++ 2003
version of the specification with respect to exception guarantees
provided by standard functions. While the C++ 2003 standard
consistenly uses the empty exception specification, <tt>throw()</tt>,
to declare functions that are guaranteed not to throw exceptions, the
current working draft contains a number of "<i>Throws:</i> Nothing."
clause to specify essentially the same requirement. The difference
between the two approaches is that the former specifies the behavior
of programs that violate the requirement (<tt>std::unexpected()</tt>
is called) while the latter leaves the behavior undefined.

       </p>
       <p>

A survey of the working draft reveals that there are a total of 209
occurrences of <tt>throw()</tt> in the library portion of the spec,
the majority in clause 18, a couple (literally) in 19, a handful in
20, a bunch in 22, four in 24, one in 27, and about a dozen in D.9.

       </p>
       <p>

There are also 203 occurrences of "<i>Throws:</i> Nothing." scattered
throughout the spec.

       </p>
       <p>

While sometimes there are good reasons to use the "<i>Throws:</i>
Nothing."  approach rather than making use of <tt>throw()</tt>, these
reasons do not apply in most of the cases where this new clause has
been introduced and the empty exception specification would be a
better approach.

       </p>
       <p>

First, functions declared with the empty exception specification
permit compilers to generate better code for calls to such
functions. In some cases, the compiler might even be able to eliminate
whole chunks of user-written code when instantiating a generic
template on a type whose operations invoked from the template
specialization are known not to throw. The prototypical example are
the <tt>std::uninitialized_copy()</tt>
and <tt>std::uninitialized_fill()</tt> algorithms where the
entire <tt>catch(...)</tt> block can be optimized away.

       </p>
       <p>

For example, given the following definition of
the <tt>std::uninitialized_copy</tt> function template and a
user-defined type <tt>SomeType</tt>:

       </p>
       <blockquote>
           <pre>template &lt;class InputIterator, class ForwardIterator&gt;
ForwardIterator
uninitialized_copy (InputIterator first, InputIterator last, ForwardIterator res)
{
   typedef iterator_traits&lt;ForwardIterator&gt;::value_type ValueType;

   ForwardIterator start = res;

   try {
       for (; first != last; ++first, ++res)
           ::new (&amp;*res) ValueType (*first);
   }
   catch (...) {
       for (; start != res; --start)
           (&amp;*start)-&gt;~ValueType ();
       throw;
   }
   return res;
}

struct SomeType {
   SomeType (const SomeType&amp;) <ins>throw ()</ins>;
}</pre>
       </blockquote>
       <p>

compilers are able to emit the following efficient specialization
of <tt>std::uninitialized_copy&lt;const SomeType*, SomeType*&gt;</tt>
(note that the <tt>catch</tt> block has been optimized away):

       </p>
       <blockquote>
           <pre>template &lt;&gt; SomeType*
uninitialized_copy (const SomeType *first, const SomeType *last, SomeType *res)
{
   for (; first != last; ++first, ++res)
       ::new (res) SomeType (*first);

   return res;
}</pre>
       </blockquote>
       <p>

Another general example is default constructors which, when decorated
with <tt>throw()</tt>, allow the compiler to eliminate the
implicit <tt>try</tt> and <tt>catch</tt> blocks that it otherwise must
emit around each the invocation of the constructor
in <i>new-expressions</i>.

       </p>
       <p>

For example, given the following definitions of
class <tt>MayThrow</tt> and <tt>WontThrow</tt> and the two
statements below:

       </p>
       <blockquote>
           <pre>struct MayThrow {
   MayThrow ();
};

struct WontThrow {
   WontThrow () <ins>throw ()</ins>;
};

MayThrow  *a = new MayThrow [N];
WontThrow *b = new WontThrow [N];</pre>

       </blockquote>
       <p>

the compiler generates the following code for the first statement:

       </p>
       <blockquote>
           <pre>MayThrow *a;
{
   MayThrow *first = operator new[] (N * sizeof (*a));
   MayThrow *last  = first + N;
   MayThrow *next  = first;
   try {
       for ( ; next != last; ++next)
           new (next) MayThrow;
   }
   catch (...) {
       for ( ; first != first; --next)
           next-&gt;~MayThrow ();
       operator delete[] (first);
       throw;
   }
   a = first;
}</pre>
       </blockquote>
       <p>

but it is can generate much more compact code for the second statement:

       </p>
       <blockquote>
           <pre>WontThrow *b    = operator new[] (N * sizeof (*b));
WontThrow *last = b + N;
for (WontThrow *next = b; next != last; ++next)
   new (next) WontThrow;
</pre>
       </blockquote>
       <p>

Second, in order for users to get the maximum benefit out of the new
<tt>std::has_nothrow_xxx</tt> traits when using standard library types
it will be important for implementations to decorate all non throwing
copy constructors and assignment operators with <tt>throw()</tt>. Note
that while an optimizer may be able to tell whether a function without
an explicit exception specification can throw or not based on its
definition, it can only do so when it can see the source code of the
definition. When it can't it must assume that the function may
throw. To prevent violating the One Definition Rule,
the <tt>std::has_nothrow_xxx</tt> trait must return the most
pessimistic guess across all translation units in the program, meaning
that <tt>std::has_nothrow_xxx&lt;T&gt;::value</tt> must evaluate to
<tt>false</tt> for any <tt>T</tt> whose <tt>xxx</tt>
(where <tt>xxx</tt> is default or copy ctor, or assignment operator)
is defined out-of-line.

       </p>
       <p>

<b>Counterarguments:</b>

       </p>
       <p>

During the discussion of this issue
on <a href="mailto:c++std-lib@accu.org">c++std-lib@accu.org</a>
(starting with post <tt>c++std-lib-21950</tt>) the following arguments
in favor of the "<i>Throws:</i> Nothing." style have been made.

       </p>
       <p>
         </p><ol>
           <li>

Decorating functions that cannot throw with the empty exception
specification can cause the compiler to generate suboptimal code for
the implementation of the function when it calls other functions that
aren't known to the compiler not to throw (i.e., that aren't decorated
with <tt>throw()</tt> even if they don't actually throw). This is a
common situation when the called function is a C or POSIX function.

           </li>
           <li>

Alternate, proprietary mechanisms exist (such as
GCC <a href="http://gcc.gnu.org/onlinedocs/gcc-4.3.0/gcc/Function-Attributes.html#index-g_t_0040code_007bnothrow_007d-function-attribute-2160"><tt>__attribute__((nothrow))</tt></a>
or Visual
C++ <a href="http://msdn.microsoft.com/en-us/library/49147z04(VS.80).aspx"><tt>__declspec(nothrow)</tt></a>)
that let implementers mark up non-throwing functions, often without
the penalty mentioned in (1) above. The C++ standard shouldn't
preclude the use of these potentially more efficient mechanisms.

           </li>
           <li>

There are functions, especially function templates, that invoke
user-defined functions that may or may not be
declared <tt>throw()</tt>. Declaring such functions with the empty
exception specification will cause compilers to generate suboptimal
code when the user-defined function isn't also declared not to throw.

           </li>
        </ol>
       <p></p>
       <p>

The answer to point (1) above is that implementers can (and some have)
declare functions with <tt>throw()</tt> to indicate to the compiler
that calls to the function can safely be assumed not to throw in order
to allow it to generate efficient code at the call site without also
having to define the functions the same way and causing the compiler
to generate suboptimal code for the function definition. That is, the
function is declared with <tt>throw()</tt> in a header but it's
defined without it in the source file. The <tt>throw()</tt>
declaration is suppressed when compiling the definition to avoid
compiler errors. This technique, while strictly speaking no permitted
by the language, is safe and has been employed in practice. For
example, the GNU C library takes this approach. Microsoft Visual C++
takes a similar approach by simply assuming that no function with C
language linkage can throw an exception unless it's explicitly
declared to do so using the language extension <tt>throw(...)</tt>.

       </p>
       <p>

Our answer to point (2) above is that there is no existing practice
where C++ Standard Library implementers have opted to make use of the
proprietary mechanisms to declare functions that don't throw. The
language provides a mechanism specifically designed for this
purpose. Avoiding its use in the specification itself in favor of
proprietary mechanisms defeats the purpose of the feature. In
addition, making use of the empty exception specification
inconsistently, in some areas of the standard, while conspicuously
avoiding it and making use of the "<i>Throws:</i> Nothing." form in
others is confusing to users.

       </p>
       <p>

The answer to point (3) is simply to exercise caution when declaring
functions and especially function templates with the empty exception
specification. Functions that required not to throw but that may call
back into user code are poor candidates for the empty exception
specification and should instead be specified using "<i>Throws:</i>
Nothing." clause.

      </p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
We need someone to do an extensive review.
</p>
<p>
NAD Future.
</p>
</blockquote>

   
   <p><b>Proposed resolution:</b></p>
       <p>

We propose two possible solutions. Our recommendation is to adopt
Option 1 below.

       </p>
       <p>

<b>Option 1:</b>

       </p>
       <p>

Except for functions or function templates that make calls back to
user-defined functions that may not be declared <tt>throw()</tt>
replace all occurrences of the "<i>Throws:</i> Nothing." clause with
the empty exception specification. Functions that are required not to
throw but that make calls back to user code should be specified to
"<i>Throw:</i> Nothing."

       </p>
       <p>

<b>Option 2:</b>

       </p>
       <p>

For consistency, replace all occurrences of the empty exception
specification with a "<i>Throws:</i> Nothing." clause.

       </p>
   



<hr>
<h3><a name="879"></a>879. Atomic load const qualification</h3>
<p><b>Section:</b> 29 [atomics] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alexander Chemeris <b>Opened:</b> 2008-08-24 <b>Last modified:</b> 2010-10-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#atomics">active issues</a> in [atomics].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics">issues</a> in [atomics].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>atomic_address</tt> type and <tt>atomic&lt;T*&gt;</tt> specialization provide atomic
updates to pointers.  However, the current specification requires
that the types pointer be to non-const objects.  This restriction
is unnecessary and unintended.
</p>

<p><i>[
Summit:
]</i></p>

<blockquote>
Move to review.  Lawrence will first check with Peter whether the
current examples are sufficient, or whether they need to be expanded to
include all cases.
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
Lawrence will handle all issues relating to atomics in a single paper.
</p>
<p>
LWG will defer discussion on atomics until that paper appears.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[
2009-08-17 Handled by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2925.html">N2925</a>.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2992.html">N2992</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add const qualification to the pointer values of the <tt>atomic_address</tt>
and <tt>atomic&lt;T*&gt;</tt> specializations.  E.g.
</p>

<blockquote><pre>typedef struct atomic_address {
   void store(<ins>const</ins> void*, memory_order = memory_order_seq_cst) volatile;
   void* exchange( <ins>const</ins> void*, memory_order = memory_order_seq_cst) volatile;
   bool compare_exchange( <ins>const</ins> void*&amp;, <ins>const</ins> void*,
                          memory_order, memory_order) volatile;
   bool compare_exchange( <ins>const</ins> void*&amp;, <ins>const</ins> void*,
                          memory_order = memory_order_seq_cst ) volatile;
   void* operator=(<ins>const</ins> void*) volatile;
} atomic_address;

void atomic_store(volatile atomic_address*, <ins>const</ins> void*);
void atomic_store_explicit(volatile atomic_address*, <ins>const</ins> void*,
                          memory_order);
void* atomic_exchange(volatile atomic_address*<ins>, const void*</ins>);
void* atomic_exchange_explicit(volatile atomic_address*, <ins>const</ins> void*,
                              memory_order);
bool atomic_compare_exchange(volatile atomic_address*,
                            <ins>const</ins> void**, <ins>const</ins> void*);
bool atomic_compare_exchange_explicit(volatile atomic_address*,
                                     <ins>const</ins> void**, <ins>const</ins> void*,
                                     memory_order, memory_order);
</pre></blockquote>





<hr>
<h3><a name="880"></a>880. Missing atomic exchange parameter</h3>
<p><b>Section:</b> 29 [atomics] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Lawrence Crowl <b>Opened:</b> 2008-08-24 <b>Last modified:</b> 2010-10-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#atomics">active issues</a> in [atomics].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics">issues</a> in [atomics].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#942">942</a></p>
<p><b>Discussion:</b></p>
<p>
The <tt>atomic_exchange</tt> and <tt>atomic_exchange_explicit</tt> functions seem to
be inconsistently missing parameters.
</p>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
<p>
Lawrence: Need to write up a list for Pete with details.
</p>
<p>
Detlef: Should not be New, we already talked about in Concurrency group.
</p>
<p>
Recommend Open.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
Lawrence will handle all issues relating to atomics in a single paper.
</p>
<p>
LWG will defer discussion on atomics until that paper appears.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[
2009-08-17 Handled by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2925.html">N2925</a>.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2992.html">N2992</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add the appropriate parameters.  For example,
</p>

<blockquote><pre>bool atomic_exchange(volatile atomic_bool*<ins>, bool</ins>);
bool atomic_exchange_explicit(volatile atomic_bool*, bool<ins>, memory_order</ins>);
</pre></blockquote>





<hr>
<h3><a name="887"></a>887. issue with condition::wait_...</h3>
<p><b>Section:</b> 30.5.1 [thread.condition.condvar] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Lawrence Crowl <b>Opened:</b> 2008-09-15 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.condition.condvar">issues</a> in [thread.condition.condvar].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The Posix/C++ working group has identified an inconsistency between
Posix and the C++ working draft in that Posix requires the clock to be
identified at creation, whereas C++ permits identifying the clock at the
call to wait.  The latter cannot be implemented with the former.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
Howard recommends NAD with the following explanation:
</p>

<p>
The intent of the current wording is for the <tt>condtion_variable::wait_until</tt>
be able to handle user-defined clocks as well as clocks the system knows about.
This can be done by providing overloads for the known clocks, and another
overload for unknown clocks which synchs to a known clock before waiting.
For example:
</p>

<blockquote><pre>template &lt;class Duration&gt;
bool
condition_variable::wait_until(unique_lock&lt;mutex&gt;&amp; lock,
                               const chrono::time_point&lt;chrono::system_clock, Duration&gt;&amp; abs_time)
{
    using namespace chrono;
    nanoseconds d = __round_up&lt;nanoseconds&gt;(abs_time.time_since_epoch());
    __do_timed_wait(lock.mutex()-&gt;native_handle(), time_point&lt;system_clock, nanoseconds&gt;(d));
    return system_clock::now() &lt; abs_time;
}

template &lt;class Clock, class Duration&gt;
bool
condition_variable::wait_until(unique_lock&lt;mutex&gt;&amp; lock,
                               const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time)
{
    using namespace chrono;
    system_clock::time_point    s_entry = system_clock::now();
    typename Clock::time_point  c_entry = Clock::now();
    nanoseconds dn = __round_up&lt;nanoseconds&gt;(abs_time.time_since_epoch() -
                                              c_entry.time_since_epoch());
    __do_timed_wait(lock.mutex()-&gt;native_handle(), s_entry + dn);
    return Clock::now() &lt; abs_time;
}
</pre></blockquote>

<p>
In the above example, <tt>system_clock</tt> is the only clock which the underlying
condition variable knows how to deal with.  One overload just passes that clock
through.  The second overload (approximately) converts the unknown clock into
a <tt>system_clock  time_point</tt> prior to passing it down to the native
condition variable.
</p>

<p>
On Posix systems vendors are free to add implementation defined constructors which
take a clock.  That clock can be stored in the condition_variable, and converted
to (or not as necessary) as shown above.
</p>

<p>
If an implementation defined constructor takes a clock (for example), then part
of the semantics for that implementation defined ctor might include that a
<tt>wait_until</tt> using a clock other than the one constructed with results
in an error (exceptional condition) instead of a conversion to the stored clock.
Such a design is up to the vendor as once an implementation defined ctor is used,
the vendor is free to specifiy the behavior of waits and/or notifies however
he pleases (when the cv is constructed in an implementation defined manner).
</p>
</blockquote>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
<p>
"POSIX people will review the proposed NAD resolution at their upcoming NY
meeting.
</p>

<p>
See the minutes at: <a href="http://wiki.dinkumware.com/twiki/bin/view/Posix/POSIX-CppBindingWorkingGroupNewYork2009">http://wiki.dinkumware.com/twiki/bin/view/Posix/POSIX-CppBindingWorkingGroupNewYork2009</a>.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Move to NAD.
</blockquote>

<p><i>[
2009-07-18 Detlef reopens the issue:
]</i></p>


<blockquote>
<p>
On Friday afternoon in Frankfurt is was decided that 887 is NAD.
This decision was mainly based on a sample implementation presented
by Howard that implemented one clock on top of another.
Unfortunately this implementation doesn't work for the probably most
important case where a system has a monotonic clock and a real-time
clock (or "wall time" clock):
</p>
<p>
If the underlying "system_clock" is a monotonic clock, and
the program waits on the real-time clock, and the real-time clock
is set forward, the wait will unblock too late.
</p>

<p>
If the underlying "system_clock" is a real-time clock, and the
program waits on the monotonic clock, and the real-time clock
is set back, the wait again will unblock too late.
</p>

<p>
Sorry that I didn't remember this on Friday, but it was Friday
afternoon after a busy week...
</p>

<p>
So as the decision was made on a wrong asumption, I propose to re-open
the issue.
</p>
</blockquote>

<p><i>[
2009-07-26 Howard adds:
]</i></p>


<blockquote>
<p>
Detlef correctly argues that <tt>condition_variable::wait_until</tt> could
return "too late" in the context of clocks being adjusted during the wait.  I agree
with his logic.  But I disagree that this makes this interface unimplementable
on POSIX.
</p>

<p>
The POSIX spec also does not guarantee that <tt>pthread_cond_timedwait</tt> does
not return "too late" when clocks are readjusted during the wait.  Indeed, the
POSIX specification lacks any requirements at all concerning how soon
<tt>pthread_cond_timedwait</tt> returns after a time out.  This is evidently a
QOI issue by the POSIX standard.  Here is a quote of the most relevant normative
text concerning <tt>pthread_cond_timedwait</tt> found
<a href="http://www.unix.org/single_unix_specification/">here</a>.
</p>

<blockquote>
The <tt>pthread_cond_timedwait()</tt> function shall be equivalent to
<tt>pthread_cond_wait()</tt>, except that an error is returned if the absolute
time specified by <tt>abstime</tt> passes (that is, system time equals or exceeds
<tt>abstime</tt>) before the condition <tt>cond</tt> is signaled or broadcasted, or if the
absolute time specified by <tt>abstime</tt> has already been passed at the time
of the call.
</blockquote>

<p>
I.e. the POSIX specification speaks of the error code returned in case of a time
out, but not on the timeliness of that return.
</p>

<p>
Might this simply be an oversight, or minor defect in the POSIX specification?
</p>

<p>
I do not believe so.  This same section goes on to say in <em>non-normative</em>
text:
</p>

<blockquote>
For cases when the system clock is advanced discontinuously by an
operator, it is expected that implementations process any timed wait
expiring at an intervening time as if that time had actually occurred.
</blockquote>

<p>
Here is non-normative wording encouraging the implementation to ignore an advancing
underlying clock and subsequently causing an early (spurious) return.  There is
no wording at all which addresses Detlef's example of a "late return".  With
<tt>pthread_cond_timedwait</tt> this would be caused by setting the system clock
backwards.  It seems reasonable to assume, based on the wording that is already
in the POSIX spec, that again, the discontinuously changed clock would be ignored
by <tt>pthread_cond_timedwait</tt>. 
</p>

<p>
A noteworthy difference between <tt>pthread_cond_timedwait</tt> and
<tt>condition_variable::wait_until</tt> is that the POSIX spec appears to
say that <tt>ETIMEDOUT</tt> should be returned if <tt>pthread_cond_timedwait</tt>
returns because of timeout signal, whether or not the system clock was discontinuously
advanced during the wait.  In contrast <tt>condition_variable::wait_until</tt>
always returns:
</p>

<blockquote><pre><tt>Clock::now() &lt; abs_time</tt>
</pre></blockquote>

<p>
That is, the C++ spec requires that the clock be rechecked (detecting discontinuous
adjustments during the wait) at the time of return.  <tt>condition_variable::wait_until</tt>
may indeed return early or late.  But regardless it will return a value
reflecting timeout status at the time of return (even if clocks have been adjusted).
Of course the clock may be adjusted after the return value is computed but before the client has
a chance to read the result of the return.  Thus there are no iron-clad guarantees
here.
</p>

<p>
<tt>condition_variable::wait_until</tt> (and <tt>pthread_cond_timedwait</tt>)
is little more than a convenience function for making sure
<tt>condition_variable::wait</tt> doesn't hang for an unreasonable amount of
time (where the client gets to define "unreasonable").  I do not think it
is in anyone's interest to try to make it into anything more than that.
</p>

<p>
I maintain that this is a useful and flexible specification in the spirit of
C++, and is implementable on POSIX.  The implementation technique described above
is a reasonable approach.  There may also be higher quality approaches.  This
specification, like the POSIX specification, gives a wide latitude for QOI.
</p>

<p>
I continue to recommend NAD, but would not object to a clarifying note regarding
the behavior of <tt>condition_variable::wait_until</tt>.  At the moment, I do
not have good wording for such a note, but welcome suggestions.
</p>

</blockquote>

<p><i>[
2009-09-30: See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2969.html">N2969</a>.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
The LWG is in favor of Detlef to supply revision which adopts Option 2 from
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2969.html">N2969</a>
but is modified by saying that <tt>system_clock</tt> must be available for <tt>wait_until</tt>.
</blockquote>

<p><i>[
2010-02-11 Anthony provided wording.
]</i></p>


<p><i>[
2010-02-22 Anthony adds:
]</i></p>


<blockquote>
<p>
I am strongly against
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2999.html">N2999</a>.
</p>

<p>
Firstly, I think that the most appropriate use of a timed wait on a condition
variable is with a monotonic clock, so it ought to be guaranteed to be available
on systems that support such a clock. Also, making the set of supported clocks
implementation defined essentially kills portability around the use of
user-defined clocks.
</p>

<p>
I also think that <tt>wait_for</tt> is potentially useful, and trivially
implementable given a working templated <tt>wait_until</tt> and a monotonic
clock.
</p>

<p>
I also disagree with many of Detlef's points in the rationale. In a system with
hard latency limits there is likely to be a monotonic clock, otherwise you have
no way of measuring against these latency limits since the <tt>system_clock</tt>
may change arbitrarily. In such systems, you <em>want</em> to be able to use
<tt>wait_for</tt>, or <tt>wait_until</tt> with a monotonic clock.
</p>

<p>
I disagree that the <tt>wait_*</tt> functions cannot be implemented correctly on
top of POSIX: I have done so. The only guarantee in the working draft is that
when the function returns certain properties are true; there is no guarantee
that the function will return <em>immediately</em> that the properties are true.
My resolution to issue 887 makes this clear. How small the latency is is QoI.
</p>

<p>
On systems without a monotonic clock, you cannot measure the problem since the
system clock can change arbitrarily so any timing calculations you make may be
wrong due to clock changes.
</p>

<p>
On systems with a monotonic clock, you can choose to use it for your condition
variables. If you are waiting against a <tt>system_clock::time_point</tt> then
you can check the clock when waking, and either return as a timeout or spurious
wake depending on whether <tt>system_clock::now()</tt> is before or after the
specified <tt>time_point</tt>.
</p>

<p>
Windows <em>does</em> provide condition variables from Vista onwards. I choose
not to use them, but they are there. If people are concerned about
implementation difficulty, the Boost implementation can be used for most
purposes; the Boost license is pretty liberal in that regard.
</p>

<p>
My preferred resolution to issue 887 is currently the PR in the issues list.
</p>
</blockquote>

<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote>
<p>
There is no consensus for moving the related paper
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2999.html">N2999</a>
into the WP.
</p>
<p>
There was support for moving this issue as proposed to Ready, but the support
was insufficient to call a consensus.
</p>
<p>
There was consensus for moving this issue to NAD as opposed to leaving it open.
Rationale added.
</p>
</blockquote>



<p><b>Rationale:</b></p>
<p>
The standard as written is sufficiently implementable and self consistent.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add a new paragraph after 30.2.4 [thread.req.timing]p3:
</p>

<blockquote>
<p>
3 The resolution of timing provided by an implementation depends on both
operating system and hardware. The finest resolution provided by an
implementation is called the <i>native resolution</i>.
</p>

<p><ins>
If a function in this clause takes a timeout argument, and the time point or
elapsed time specified passes before the function returns, the latency between
the timeout occurring and the function returning is unspecified [<i>Note:</i>
Implementations should strive to keep such latency as small as possible, but
portable code should not rely on any specific upper limits  <i>end
note</i>]
</ins></p>
</blockquote>





<hr>
<h3><a name="889"></a>889. thread::id comparisons</h3>
<p><b>Section:</b> 30.3.1.1 [thread.thread.id] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Lawrence Crowl <b>Opened:</b> 2008-09-15 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.thread.id">issues</a> in [thread.thread.id].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 324</b></p>

<p>
The <tt>thread::id</tt> type supports the full set of comparison operators.  This
is substantially more than is required for the associative containers that
justified them.  Please place an issue against the threads library.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
Would depend on proposed extension to POSIX, or non-standard extension.
What about hash? POSIX discussing op. POSIX not known to be considering
support needed for hash, op.
</p>
<p>
Group expresses support for putting ids in both unordered and ordered containers.
</p>
</blockquote>

<p><i>[
post San Francisco:
]</i></p>


<blockquote>
<p>
Howard:  It turns out the current working paper
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a>
<i>already has</i> <tt>hash&lt;thread::id&gt;</tt>
(20.8 [function.objects], 20.8.15 [unord.hash]).  We simply
overlooked it in the meeting.  It is a good thing we voted in favor of it
(again). :-)
</p>
<p>
Recommend NAD.
</p>

</blockquote>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
Recommend to close as NAD. For POSIX, see if we need to add a function to
convert <tt>pthread_t</tt> to integer.
</blockquote>

<p><i>[
Post Summit, Alisdair adds:
]</i></p>


<blockquote>
<p>
The recommendation for LWG-889/UK-324 is NAD, already specified.
</p>
<p>
It is not clear to me that the specification is complete.
</p>
<p>
In particular, the synopsis of <tt>&lt;functional&gt;</tt> in 20.8 [function.objects] does not mention <tt>hash&lt; thread::id
&gt;</tt> nor <tt>hash&lt; error_code &gt;</tt>, although their
existence is implied by 20.8.15 [unord.hash], p1.
</p>
<p>
I am fairly uncomfortable putting the declaration for the
<tt>thread_id</tt> specialization into <tt>&lt;functional&gt;</tt> as
<tt>id</tt> is a nested class inside <tt>std::thread</tt>, so it implies
that <tt>&lt;functional&gt;</tt> would require the definition of the
<tt>thread</tt> class template in order to forward declared
<tt>thread::id</tt> and form this specialization.
</p>
<p>
It seems better to me that the dependency goes the other way around
(<tt>&lt;thread&gt;</tt> will more typically make use of
<tt>&lt;functional&gt;</tt> than vice-versa) and the
<tt>hash&lt;thread::id&gt;</tt> specialization be declared in the
<tt>&lt;thread&gt;</tt> header.
</p>
<p>
I think <tt>hash&lt;error_code&gt;</tt> could go into either
<tt>&lt;system_error&gt;</tt> or <tt>&lt;functional&gt;</tt> and have no
immediate preference either way.  However, it should clearly appear in
the synopsis of one of these two.
</p>
<p>
Recommend moving 889 back to open, and tying in a reference to UK-324.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Howard observes that <tt>thread::id</tt> need not be a nested class;
it could be a <tt>typedef</tt> for a more visible type.
</blockquote>

<p><i>[
2009-05-24 Alisdair adds:
]</i></p>

<blockquote>
I do not believe this is correct.  <tt>thread::id</tt> is explicitly documents as a
nested class, rather than as an unspecified typedef analogous to an
iterator.  If the intent is that this is not implemented as a nested class
(under the as-if freedoms) then this is a novel form of standardese.
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Decided we want to move hash specialization for thread_id to the thread
header. Alisdair to provide wording.
</blockquote>

<p><i>[
2009-07-28 Alisdair provided wording, moved to Review.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Add a strike for <tt>hash&lt;thread::id&gt;</tt>. Move to Ready
</blockquote>

<p><i>[
2009-11-13 The proposed wording of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1182">1182</a> is a superset of the
wording in this issue.
]</i></p>


<p><i>[
2010-02-09 Moved from Ready to Open:
]</i></p>


<blockquote>
<p>
Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1182">1182</a> is not quite a superset of this issue and it is controversial
whether or not the note:
</p>

<blockquote>
hash template specialization allows <tt>thread::id</tt> objects to be used as keys in
unordered containers.
</blockquote>

<p>
should be added to the WP.
</p>


</blockquote>

<p><i>[
2010-02-09 Objections to moving this to NAD Editorial, solved by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1182">1182</a> have been removed.  Set to Tentatively NAD Editorial.
]</i></p>




<p><b>Rationale:</b></p>
<p>
Solved by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1182">1182</a>.
</p>


<p><b>Proposed resolution:</b></p>

<p>
Remove the following prototype from the synopsis in
20.8 [function.objects]:
</p>

<blockquote><pre><del>
template &lt;&gt; struct hash&lt;std::thread::id&gt;;
</del></pre></blockquote>

<p>
Add to 30.3 [thread.threads], p1 Header <tt>&lt;thread&gt;</tt> synopsis:
</p>

<blockquote><pre><ins>template &lt;class T&gt; struct hash;
template &lt;&gt; struct hash&lt;thread::id&gt;;</ins>
</pre></blockquote>

<p>
Add template specialization below class definition in 30.3.1.1 [thread.thread.id]
</p>

<blockquote><pre><ins>template &lt;&gt;
struct hash&lt;thread::id&gt; : public unary_function&lt;thread::id, size_t&gt; {
   size_t operator()(thread::id val) const;
};</ins>
</pre></blockquote>

<p>
Extend note in p2 30.3.1.1 [thread.thread.id] with second sentence:
</p>

<blockquote>
[<i>Note:</i> Relational operators allow <tt>thread::id</tt> objects to be used
as keys in associative containers.
<ins><tt>hash</tt> template specialization allows <tt>thread::id</tt> objects to be used as keys
in unordered containers.</ins>
 <i>end note</i>]
</blockquote>

<p>
Add new paragraph to end of 30.3.1.1 [thread.thread.id]
</p>

<blockquote><pre><ins>template &lt;&gt; struct hash&lt;thread::id&gt;;</ins>
</pre>
<blockquote><ins>
An explicit specialization of the class template hash (20.8.15 [unord.hash])
shall be provided for the type <tt>thread::id</tt>.
</ins></blockquote>
</blockquote>





<hr>
<h3><a name="892"></a>892. Forward_list issues...</h3>
<p><b>Section:</b> 23.3.3.5 [forwardlist.ops] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Ed Smith-Rowland <b>Opened:</b> 2008-09-15 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#forwardlist.ops">issues</a> in [forwardlist.ops].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I was looking at the latest draft on <tt>forward_list</tt>.  Especially the splice methods.
</p>
<p>
The first one splices a whole list after a given iterator in <tt>this</tt>.  The name is <tt>splice_after</tt>.
I think in 23.3.3.5 [forwardlist.ops] paragraph 40
change:
</p>
<blockquote>
<i>Effect:</i> Insert the contents of <tt>x</tt> <del>before</del> <ins>after</ins> <tt>position</tt>, ...
</blockquote>

<p>
A deeper issue involves the complexity.  <tt>forward_list</tt> has no <tt>size</tt> and we
don't know when we've reached the end except to walk up to it.  To
splice we would need to hook the end of the source list to the item
after <tt>position</tt> in this list.  This would involve walking length of the
source list until we got to the last dereference-able element in source.
There's no way we could do this in O(1) unless we stored a bogus end in
<tt>forward_list</tt>.
</p>
<p>
OTOH, the last version of <tt>splice_after</tt> with iterator ranges we could do
in O(1) because we know how to hook the end of the source range to ...
</p>
<p>
Unless I'm misconceiving the whole thing.  Which is possible.  I'll look at it again.
</p>
<p>
I'm pretty sure about the first part though.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
This issue is more complicated than it looks.
</p>
<p>
paragraph 47: replace each <tt>(first, last) with (first, last]</tt>
</p>
<p>
add a statement after paragraph 48 that complexity is O(1)
</p>
<p>
remove the complexity statement from the first overload of splice_after
</p>
<p>
We may have the same problems with other modifiers, like erase_after.
Should it require that all iterators in the range (position, last] be
dereferenceable?
</p>
<p>
We do, however, like the proposed changes and consider them Editorial.
Move to NAD Editorial, Pending. Howard to open a new issue to handle the
problems with the complexity requirements.
</p>
<p>
Opened <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#897">897</a>.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
In 23.3.3.5 [forwardlist.ops] paragraph 40
change:
</p>
<blockquote>
<i>Effect:</i> Insert the contents of <tt>x</tt> <del>before</del> <ins>after</ins> <tt>position</tt>, ...
</blockquote>





<hr>
<h3><a name="895"></a>895. "Requires:" on std::string::at et al</h3>
<p><b>Section:</b> 17.5.1.4 [structure.specifications] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> James Dennett <b>Opened:</b> 2008-09-16 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#structure.specifications">issues</a> in [structure.specifications].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#625">625</a></p>
<p><b>Discussion:</b></p>
<p>
Per discussion, we need an issue open to cover looking at "Requires"
clauses which are not constraints on user code, such as that on
<tt>std::basic_string::at</tt>.
</p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
 Alan to address in paper.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="897"></a>897. Forward_list issues... Part 2</h3>
<p><b>Section:</b> 23.3.3.4 [forwardlist.modifiers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2008-09-22 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#forwardlist.modifiers">issues</a> in [forwardlist.modifiers].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This issue was split off from <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#892">892</a> at the request of the LWG.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
This issue is more complicated than it looks.
</p>
<p>
paragraph 47: replace each <tt>(first, last) with (first, last]</tt>
</p>
<p>
add a statement after paragraph 48 that complexity is O(1)
</p>
<p>
remove the complexity statement from the first overload of splice_after
</p>
<p>
We may have the same problems with other modifiers, like erase_after.
Should it require that all iterators in the range (position, last] be
dereferenceable?
</p>
</blockquote>

<p>
There are actually 3 issues here:
</p>

<ol>
<li>
<p>
What value should <tt>erase_after</tt> return?  With <tt>list</tt>, code often
looks like:
</p>
<blockquote><pre>for (auto i = l.begin(); i != l.end();)
{
    // inspect *i and decide if you want to erase it
    // ...
    if (I want to erase *i)
        i = l.erase(i);
    else
        ++i;
}
</pre></blockquote>
<p>
I.e. the iterator returned from <tt>erase</tt> is useful for setting up the
logic for operating on the next element.  For <tt>forward_list</tt> this might
look something like:
</p>
<blockquote><pre>auto i = fl.before_begin();
auto ip1 = i;
for (++ip1; ip1 != fl.end(); ++ip1)
{
    // inspect *(i+1) and decide if you want to erase it
    // ...
    if (I want to erase *(i+1))
        i = fl.erase_after(i);
    else
        ++i;
    ip1 = i;
}
</pre></blockquote>
<p>
In the above example code, it is convenient if <tt>erase_after</tt> returns
the element <i>prior</i> to the erased element (range) instead of the element
<i>after</i> the erase element (range).
</p>
<p>
Existing practice:
</p>
<ul>
<li>SGI slist returns an iterator referencing the element <i>after</i> the erased range.</li>
<li>CodeWarrior slist returns an iterator referencing the element <i>before</i> the erased range.</li>
</ul>
<p>
There is not a strong technical argument for either solution over the other.
</p>
</li>

<li>
<p>
With all other containers, operations always work on the range
<tt>[first, last)</tt> and/or <i>prior to</i> the given <tt>position</tt>.
</p>
<p>
With <tt>forward_list</tt>, operations sometimes work on the range
<tt>(first, last]</tt> and/or <i>after</i> the given <tt>position</tt>.
</p>
<p>
This is simply due to the fact that in order to operate on
<tt>*first</tt> (with <tt>forward_list</tt>) one needs access to
<tt>*(first-1)</tt>.  And that's not practical with
<tt>forward_list</tt>.  So the operating range needs to start with <tt>(first</tt>,
not <tt>[first</tt> (as the current working paper says). 
</p>
<p>
Additionally, if one is interested in  splicing the range <tt>(first, last)</tt>,
then (with <tt>forward_list</tt>), one needs practical (constant time) access to
<tt>*(last-1)</tt> so that one can set the <i>next</i> field in this node to
the proper value.  As this is not possible with <tt>forward_list</tt>, one must
specify the last element of interest instead of one past the last element of
interest.  The syntax for doing this is to pass <tt>(first, last]</tt> instead
of <tt>(first, last)</tt>.
</p>
<p>
With <tt>erase_after</tt> we have a choice of either erasing the range
<tt>(first, last]</tt> <em>or</em> <tt>(first, last)</tt>.  Choosing the latter
enables:
</p>
<blockquote><pre>x.erase_after(pos, x.end());
</pre></blockquote>

<p>
With the former, the above statement is inconvenient or expensive due to the lack
of constant time access to <tt>x.end()-1</tt>.  However we could introduce:
</p>

<blockquote><pre>iterator erase_to_end(const_iterator position);
</pre></blockquote>

<p>
to compensate.
</p>

<p>
The advantage of the former (<tt>(first, last]</tt>) for <tt>erase_after</tt>
is a consistency with <tt>splice_after</tt> which uses <tt>(first, last]</tt>
as the specified range.  But this either requires the addition of <tt>erase_to_end</tt>
or giving up such functionality.
</p>

</li>

<li>
As stated in the discussion of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#892">892</a>, and reienforced by point 2 above,
a <tt>splice_after</tt> should work on the source range <tt>(first, last]</tt>
if the operation is to be <i>&#927;</i>(1).  When splicing an entire list <tt>x</tt> the
algorithm needs <tt>(x.before_begin(), x.end()-1]</tt>.  Unfortunately <tt>x.end()-1</tt>
is not available in constant time unless we specify that it must be.  In order to
make <tt>x.end()-1</tt> available in constant time, the implementation would have
to dedicate a pointer to it.  I believe the design of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2543.htm">N2543</a>
intended a nominal overhead of <tt>foward_list</tt> of 1 pointer.  Thus splicing
one <i>entire</i> <tt>forward_list</tt> into another can not be <i>&#927;</i>(1).
</li>
</ol>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with the proposed resolution.
</p>
<p>
Move to Review.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
We may need a new issue to correct splice_after, because it may no
longer be correct to accept an rvalues as an argument. Merge may be
affected, too. This might be issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1133">1133</a>. (Howard: confirmed)
</p>
<p>
Move this to Ready, but the Requires clause of the second form of
splice_after should say "(first, last)," not "(first, last]" (there are
three occurrences). There was considerable discussion on this. (Howard: fixed)
</p>
<p>
Alan suggested removing the "foward_last&lt;T. Alloc&gt;&amp;&amp; x"
parameter from the second form of splice_after, because it is redundant.
PJP wanted to keep it, because it allows him to check for bad ranges
(i.e. "Granny knots").
</p>
<p>
We prefer to keep <tt>x</tt>.
</p>
<p>
Beman. Whenever we deviate from the customary half-open range in the
specification, we should add a non-normative comment to the standard
explaining the deviation. This clarifies the intention and spares the
committee much confusion in the future.
</p>
<p>
Alan to write a non-normative comment to explain the use of fully-closed ranges.
</p>
<p>
Move to Ready, with the changes described above. (Howard: awaiting note from Alan)
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial, addressed by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2988.pdf">N2988</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Wording below assumes issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#878">878</a> is accepted, but this issue is
independent of that issue.
</p>

<p>
Change 23.3.3.4 [forwardlist.modifiers]:
</p>

<blockquote>
<pre>iterator erase_after(const_iterator position);
</pre>
<blockquote>
<p>
<i>Requires:</i> The iterator following <tt>position</tt> is dereferenceable.
</p>
<p>
<i>Effects:</i> Erases the element pointed to by the iterator following <tt>position</tt>.
</p>
<p>
<i>Returns:</i> <del>An iterator pointing to the element following the one that was erased, or <tt>end()</tt> if no such 
element exists</del>
<ins>An iterator equal to <tt>position</tt></ins>.
</p>
</blockquote>


<pre>iterator erase_after(const_iterator position, <ins>const_</ins>iterator last);
</pre>
<blockquote>
<p>
<i>Requires:</i> All iterators in the range
<tt><del>[</del><ins>(</ins>position,last)</tt>
are dereferenceable.
</p>
<p>
<i>Effects:</i> Erases the elements in the range
<tt><del>[</del><ins>(</ins>position,last)</tt>.
</p>
<p>
<i>Returns:</i>  <ins>An iterator equal to <tt>position</tt></ins> <del><tt>last</tt></del>
</p>
</blockquote>
</blockquote>

<p>
Change 23.3.3.5 [forwardlist.ops]:
</p>

<blockquote>
<pre>void splice_after(const_iterator position, forward_list&lt;T,Allocator&gt;&amp;&amp; x);
</pre>
<blockquote>
<p>
<i>Requires:</i> <tt>position</tt> is <tt>before_begin()</tt> or a
dereferenceable iterator in the range <tt>[begin(), end))</tt>. <tt>&amp;x != this</tt>.
</p>
<p>
<i>Effects:</i> Inserts the contents of <tt>x</tt> after <tt>position</tt>, and
<tt>x</tt> becomes empty. Pointers and references to 
the moved elements of <tt>x</tt> now refer to those same elements but as members of <tt>*this</tt>.
Iterators referring to the moved elements will continue to refer to their elements,
but they now behave as iterators into <tt>*this</tt>, not into <tt>x</tt>. 
</p>
<p>
<i>Throws:</i> Nothing. 
</p>
<p>
<i>Complexity:</i> <del><i>&#927;</i>(1)</del> <ins><i>&#927;</i>(<tt>distance(x.begin(), x.end())</tt>)</ins>
</p>
</blockquote>

<p>...</p>

<pre>void splice_after(const_iterator position, forward_list&lt;T,Allocator&gt;&amp;&amp; x, 
                  const_iterator first, const_iterator last);
</pre>
<blockquote>
<p>
<i>Requires:</i> <tt>position</tt> is <tt>before_begin()</tt> or a
dereferenceable iterator in the range <tt>[begin(), end))</tt>.
<tt>(first,last)</tt> is a valid range in
<tt>x</tt>, and all iterators in the range
<tt>(first,last)</tt> are dereferenceable.
<tt>position</tt> is not an iterator in the range <tt>(first,last)</tt>.
</p>
<p>
<i>Effects:</i> Inserts elements in the range <tt>(first,last)</tt>
after <tt>position</tt> and removes the elements from <tt>x</tt>.
Pointers and references to the moved elements of <tt>x</tt> now refer to
those same elements but as members of <tt>*this</tt>. Iterators
referring to the moved elements will continue to refer to their
elements, but they now behave as iterators into <tt>*this</tt>, not into
<tt>x</tt>.
</p>
<p>
<ins><i>Complexity:</i> <i>&#927;</i>(1).</ins>
</p>
</blockquote>

</blockquote>






<hr>
<h3><a name="901"></a>901. insert iterators can move from lvalues</h3>
<p><b>Section:</b> 24.5.2.5 [insert.iterator] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2008-09-24 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses UK 282</b></p>

<p>
The requires clause on the <tt>const T &amp;</tt> overloads in
<tt>back_insert_iterator/front_insert_iterator/insert_iterator</tt> mean that the
assignment operator will implicitly move from lvalues of a move-only type.
</p>
<p>
Suggested resolutions are:
</p>
<ol type="a">
<li>
Add another overload with a negative constraint on copy-constructible
and flag it "= delete".
</li>
<li>
Drop the copy-constructible overload entirely and rely on perfect
forwarding to catch move issues one level deeper.
</li>
<li>
This is a fundamental problem in move-syntax that relies on the
presence of two overloads, and we need to look more deeply into this
area as a whole - do not solve this issue in isolation.
</li>
</ol>

<p><i>[
Post Summit, Alisdair adds:
]</i></p>


<blockquote>
<p>
Both comment and issue have been resolved by the adoption of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2844.html">N2844</a>
(rvalue references safety fix) at the last meeting.
</p>

<p>
Suggest resolve as NAD Editorial with a reference to the paper.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree that this has been resolved in the latest Working Draft.
Move to NAD.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Recommend NAD, addressed by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2844.html">N2844</a>.
</p>





<hr>
<h3><a name="902"></a>902. Regular is the wrong concept to constrain numeric_limits</h3>
<p><b>Section:</b> 18.3.1 [limits] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2008-09-24 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#limits">issues</a> in [limits].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses FR 32 and DE 16</b></p>

<p>
<tt>numeric_limits</tt> has functions specifically designed to return NaNs, which
break the model of <tt>Regular</tt> (via its axioms.)  While floating point types
will be acceptible in many algorithms taking <tt>Regular</tt> values, it is not
appopriate for this specific API and we need a less refined constraint.
</p>

<p>FR 32:</p>

<blockquote>
The definition of <tt>numeric_limits&lt;&gt;</tt> as requiring a regular
type is both conceptually wrong and operationally illogical. As we
pointed before, this mistake needs to be corrected. For example, the
template can be left unconstrained. In fact this reflects a much more
general problem with concept_maps/axioms and their interpretations. It
appears that the current text heavily leans toward experimental academic
type theory.
</blockquote>

<p>DE 16:</p>

<blockquote>
The class template <tt>numeric_limits</tt> should not specify the Regular concept
requirement for its template parameter, because it contains functions
returning NaN values for floating-point types; these values violate the
semantics of EqualityComparable.
</blockquote>

<p><i>[
Summit:
]</i></p>


<blockquote>
Move to Open.  Alisdair and Gaby will work on a solution, along with the new
treatment of axioms in clause 14.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="903"></a>903. <tt>back_insert_iterator</tt> issue</h3>
<p><b>Section:</b> 24.5.2.1 [back.insert.iterator] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Dave Abrahams <b>Opened:</b> 2008-09-19 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I just noticed this; don't know how far the problem(?) extends or
whether it's new or existing: <tt>back_insert_iterator</tt>'s <tt>operator*</tt> is not
<tt>const</tt>, so you can't dereference a <tt>const</tt> one.
</p>

<p><i>[
Post Summit Daniel adds:
]</i></p>


<blockquote>
<p>
If done, this change should be applied for <tt>front_insert_iterator</tt>,
<tt>insert_iterator</tt>, <tt>ostream_iterator</tt>, and <tt>ostreambuf_iterator</tt> as well.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Alisdair notes that these all are output iterators.
Howard points out that <tt>++*i</tt>
would no longer work if we made this change.
</p>
<p>
Move to NAD.
</p>
</blockquote>

<p><i>[
2009-05-25 Daniel adds:
]</i></p>


<ol>
<li>
If <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1009">1009</a> is accepted, <tt>OutputIterator</tt> does no longer support post increment.
</li>
<li>
To support backward compatibility a second overload of <tt>operator*</tt>
can be added.
Note that the <tt>HasDereference</tt> concept (and the <tt>HasDereference</tt> part of concept
<tt>Iterator</tt>) was specifically refactored to cope with optional const
qualification and
to properly reflect the dual nature of built-in <tt>operator*</tt> as of
13.5.8 [over.literal]/6.
</li>
</ol>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="905"></a>905. Mutex specification questions</h3>
<p><b>Section:</b> 30.4.1.2.1 [thread.mutex.class] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Herb Sutter <b>Opened:</b> 2008-09-18 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.mutex.class">issues</a> in [thread.mutex.class].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#893">893</a></p>
<p><b>Discussion:</b></p>
<p>
A few questions on the current WP,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a>:
</p>
<p>
30.4.1 [thread.mutex.requirements]/24 says an expression
<tt>mut.unlock()</tt> "Throws: Nothing." I'm assuming that, per 17.6.3.11 [res.on.required], errors that violate the precondition "The
calling thread shall own the mutex" opens the door for throwing an
exception anyway, such as to report unbalanced unlock operations and
unlocking from a thread that does not have ownership. Right?
</p>
<p>
30.4.1.2.1 [thread.mutex.class]/3 (actually numbered paragraph "27"
in the WP; this is just a typo I think) says
</p>
<blockquote>
<p>
The behavior of a program is undefined if:
</p>
<ul>
<li>it destroys a <tt>mutex</tt> object owned by any thread,</li>
<li>a thread that owns a <tt>mutex</tt> object calls <tt>lock()</tt> or <tt>try_lock()</tt> on that object, or</li>
<li>a thread terminates while owning a <tt>mutex</tt> object.</li>
</ul>
</blockquote>

<p>
As already discussed, I think the second bullet should be removed, and
such a <tt>lock()</tt> or <tt>try_lock()</tt> should fail with an
exception or returning <tt>false</tt>, respectively.
</p>
<p>
A potential addition to the list would be
</p>
<ul>
<li>a thread unlocks a <tt>mutex</tt> it does not have ownership of.</li>
</ul>
<p>
but without that the status quo text endorses the technique of the
program logically transferring ownership of a mutex to another thread
with correctness enforced by programming discipline. Was that intended?
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
<p>
Two resolutions: "not a defect" and "duplicate", as follows:
</p>
<ul>
<li>
30.4.1 [thread.mutex.requirements]/24: NAD. If the precondition
fails the program has undefined behaviour and therefore an
implementation may throw an exception already.
</li>
<li>
30.4.1.2.1 [thread.mutex.class]/3 bullet 2: Already addressed by issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#893">893</a>.
</li>
<li>
30.4.1.2.1 [thread.mutex.class]/3 proposed addition: NAD. This is
already covered by the mutex requirements, which have ownership as a
Precondition.
</li>
</ul>
</blockquote>


<p><b>Proposed resolution:</b></p>






<hr>
<h3><a name="906"></a>906. <tt>ObjectType</tt> is the wrong concept to constrain <tt>initializer_list</tt></h3>
<p><b>Section:</b> 18.9 [support.initlist] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-09-26 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The currently proposed constraint on <tt>initializer_list</tt>'s element type
<tt>E</tt> is that is has to meet <tt>ObjectType</tt>. This is an underspecification,
because both core language and library part of <tt>initializer_list</tt>
make clear, that it references an implicitly allocated array:
</p>
<p>
8.5.4 [dcl.init.list]/4:
</p>
<blockquote>
When an initializer list is implicitly converted to a
<tt>std::initializer_list&lt;E&gt;</tt>, the object passed is constructed as if the
implementation allocated an array of N elements of type <tt>E</tt>, where
N is the number of elements in the initializer list.[..]
</blockquote>

<p>
18.9 [support.initlist]/2.
</p>

<blockquote>
An object of type <tt>initializer_list&lt;E&gt;</tt> provides access to an array of
objects of type <tt>const E</tt>.[..]
</blockquote>

<p>
Therefore, <tt>E</tt> needs to fulfill concept <tt>ValueType</tt> (thus excluding
abstract class types). This stricter requirement should be added
to prevent deep instantiation errors known from the bad old times,
as shown in the following example:
</p>

<blockquote><pre>// Header A: (Should concept-check even in stand-alone modus)

template &lt;DefaultConstructible T&gt;
requires MoveConstructible&lt;T&gt;
void generate_and_do_3(T a) {
  std::initializer_list&lt;T&gt; list{T(), std::move(a), T()};
  ...
}

void do_more();
void do_more_or_less();

template &lt;DefaultConstructible T&gt;
requires MoveConstructible&lt;T&gt;
void more_generate_3() {
  do_more();
  generate_and_do_3(T());
}

template &lt;DefaultConstructible T&gt;
requires MoveConstructible&lt;T&gt;
void something_and_generate_3() {
  do_more_or_less();
  more_generate_3();
}

// Test.cpp

#include "A.h"

class Abstract {
public:
  virtual ~Abstract();
  virtual void foo() = 0; // abstract type
  Abstract(Abstract&amp;&amp;){} // MoveConstructible
  Abstract(){} // DefaultConstructible
};

int main() {
  // The restricted template *accepts* the argument, but
  // causes a deep instantiation error in the internal function
  // generate_and_do_3:
  something_and_generate_3&lt;Abstract&gt;();
}
</pre></blockquote>

<p>
The proposed stricter constraint does not minimize the aim to
support more general containers for which <tt>ObjectType</tt> would be
sufficient. If such an extended container (lets assume it's still a
class template) provides a constructor that accepts an <tt>initializer_list</tt>
only <em>this</em> constructor would need to be restricted on <tt>ValueType</tt>:
</p>

<blockquote><pre>template&lt;ObjectType T&gt;
class ExtContainer {
public:
  requires ValueType&lt;T&gt;
  ExtContainer(std::initializer_list&lt;T&gt;);
  ...
};
</pre></blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to Tentatively Ready.
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
Need to look at again without concepts.
</blockquote>



<p><b>Proposed resolution:</b></p>
<ol>
<li>
In 18.9 [support.initlist]/p.1 replace in "header <tt>&lt;initializer_list&gt;</tt> synopsis"
the constraint "<tt>ObjectType</tt>" in the template parameter list by the
constraint "<tt>ValueType</tt>".
</li>
</ol>






<hr>
<h3><a name="908"></a>908. Deleted assignment operators for atomic types must be volatile</h3>
<p><b>Section:</b> X [atomics.types] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Anthony Williams <b>Opened:</b> 2008-09-26 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics.types">issues</a> in [atomics.types].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses US 90</b></p>

<p>
The deleted copy-assignment operators for the atomic types are not
marked as volatile in N2723, whereas the assignment operators from the
associated non-atomic types are. e.g.
</p>
<blockquote><pre>atomic_bool&amp; operator=(atomic_bool const&amp;) = delete;
atomic_bool&amp; operator=(bool) volatile;
</pre></blockquote>

<p>
This leads to ambiguity when assigning a non-atomic value to a
non-volatile instance of an atomic type:
</p>
<blockquote><pre>atomic_bool b;
b=false;
</pre></blockquote>

<p>
Both assignment operators require a standard conversions: the
copy-assignment operator can use the implicit <tt>atomic_bool(bool)</tt>
conversion constructor to convert <tt>false</tt> to an instance of
<tt>atomic_bool</tt>, or <tt>b</tt> can undergo a qualification conversion in order to
use the assignment from a plain <tt>bool</tt>.
</p>

<p>
This is only a problem once issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#845">845</a> is applied.
</p>

<p><i>[
Summit:
]</i></p>

<blockquote>
Move to open. Assign to Lawrence. Related to US 90 comment.
</blockquote>

<p><i>[
2009-08-17 Handled by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2925.html">N2925</a>.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2992.html">N2992</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add volatile qualification to the deleted copy-assignment operator of
all the atomic types:
</p>

<blockquote><pre>atomic_bool&amp; operator=(atomic_bool const&amp;) <ins>volatile</ins> = delete;
atomic_itype&amp; operator=(atomic_itype const&amp;) <ins>volatile</ins> = delete;
</pre></blockquote>

<p>
etc.
</p>
<p>
This will mean that the deleted copy-assignment operator will require
<i>two</i> conversions in the above example, and thus be a worse match than
the assignment from plain <tt>bool</tt>.
</p>





<hr>
<h3><a name="910"></a>910. Effects of MoveAssignable</h3>
<p><b>Section:</b> 20.2.1 [utility.arg.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alberto Ganesh Barbati <b>Opened:</b> 2008-09-29 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#utility.arg.requirements">issues</a> in [utility.arg.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses UK 150</b></p>

<p>
The description of the effect of <tt>operator=</tt> in the <tt>MoveAssignable</tt>
concept, given in paragraph 7 is:
</p>

<blockquote><pre>result_type  T::operator=(T&amp;&amp;  rv);  // inherited from HasAssign&lt;T, T&amp;&amp;&gt;
</pre>

<blockquote>
<i>Postconditions:</i> the constructed <tt>T</tt> object is equivalent to the value of
<tt>rv</tt> before the assignment. [<i>Note:</i> there is no
requirement on the value of <tt>rv</tt> after the assignment.  <i>--end note</i>]
</blockquote>
</blockquote>

<p>
The sentence contains a typo (what is the "constructed <tt>T</tt> object"?)
probably due to a cut&amp;paste from <tt>MoveConstructible</tt>. Moreover, the
discussion of LWG issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#675">675</a> shows that the postcondition is too generic
and might not reflect the user expectations. An implementation of the
move assignment that just calls <tt>swap()</tt> would always fulfill the
postcondition as stated, but might have surprising side-effects in case
the source rvalue refers to an object that is not going to be
immediately destroyed. See LWG issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#900">900</a> for another example. Due to
the sometimes intangible nature of the "user expectation", it seems
difficult to have precise normative wording that could cover all cases
without introducing unnecessary restrictions. However a non-normative
clarification could be a very helpful warning sign that swapping is not
always the correct thing to do.
</p>

<p><i>[
2009-05-09 Alisdair adds:
]</i></p>


<blockquote>
<p>
Issue 910 is exactly the reason BSI advanced the Editorial comment UK-150.
</p>
<p>
The post-conditions after assignment are at a minimum that the object
referenced by rv must be safely destructible, and the transaction should not
leak resources.  Ideally it should be possible to simply assign rv a new
valid state after the call without invoking undefined behaviour, but any
other use of the referenced object would depend upon additional guarantees
made by that type.
</p>
</blockquote>

<p><i>[
2009-05-09 Howard adds:
]</i></p>


<blockquote>
<p>
The intent of the rvalue reference work is that the moved from <tt>rv</tt> is
a valid object.  Not one in a singular state.  If, for example, the moved from
object is a <tt>vector</tt>, one should be able to do anything on that moved-from
<tt>vector</tt> that you can do with any other <tt>vector</tt>.  However you would
first have to query it to find out what its current state is.  E.g. it might have <tt>capacity</tt>,
it might not.  It might have a non-zero <tt>size</tt>, it might not.  But regardless,
you can <tt>push_back</tt> on to it if you want.
</p>

<p>
That being said, most standard code is now conceptized.  That is, the concepts
list the only operations that can be done with templated types - whether or not
the values have been moved from.
</p>

<p>
Here is user-written code which must be allowed to be legal:
</p>
<blockquote><pre>#include &lt;vector&gt;
#include &lt;cstdio&gt;

template &lt;class Allocator&gt;
void
inspect(std::vector&lt;double, Allocator&gt;&amp;&amp; v)
{
    std::vector&lt;double, Allocator&gt; result(move(v));
    std::printf("moved from vector has %u size and %u capacity\n", v.size(), v.capacity());
    std::printf("The contents of the vector are:\n");
    typedef typename std::vector&lt;double, Allocator&gt;::iterator I;
    for (I i = v.begin(), e = v.end(); i != e; ++i)
        printf("%f\n", *i);
}

int main()
{
    std::vector&lt;double&gt; v1(100, 5.5);
    inspect(move(v1));
}
</pre></blockquote>

<p>
The above program does not treat the moved-from <tt>vector</tt> as singular.  It
only treats it as a <tt>vector</tt> with an unknown value.
</p>
<p>
I believe the current proposed wording is consistent with my view on this.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree that the proposed resolution
is an improvement over the current wording.
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
Need to look at again without concepts.
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
Walter will consult with Dave and Doug.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
We believe this is handled by the resolution to issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1204">1204</a>,
but there is to much going on in this area to be sure.  Defer for now.
</blockquote>

<p><i>[
2010-01-23 Moved to Tentatively NAD Concepts after 5 positive votes on c++std-lib.
Rationale added below.
]</i></p>



<p><b>Rationale:</b></p>
<p>
The current <tt>MoveAssignable</tt> requirements say everything that can be said
in general.  Each std-defined type has a more detailed specification of move
assignment.
</p>


<p><b>Proposed resolution:</b></p>
<p>
In  [concept.copymove], replace the postcondition in paragraph 7 with:
</p>

<blockquote>
<i>Postconditions:</i> <tt>*this</tt> is equivalent to the value of <tt>rv</tt> before the
assignment. [<i>Note:</i> there is no requirement on the value of <tt>rv</tt> after the
assignment, but the
effect should be unsurprising to the user even in case <tt>rv</tt> is not
immediately destroyed. This may require that resources previously owned
by <tt>*this</tt> are released instead of transferred to <tt>rv</tt>. <i>-- end note</i>]
</blockquote>





<hr>
<h3><a name="912"></a>912. Array swap needs to be conceptualized</h3>
<p><b>Section:</b> 25.3.3 [alg.swap] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-10-01 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.swap">issues</a> in [alg.swap].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
With the adaption of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#809">809</a>
we have a new algorithm <tt>swap</tt> for C-arrays, which needs to be conceptualized.
</p>

<p><i>[
Post Summit Daniel adds:
]</i></p>


<blockquote>
Recommend as NAD Editorial: The changes have already been applied to the WP
<a href="" ref="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2800.pdf">N2800</a>.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to NAD; the changes have already been made.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Replace in 25.3.3 [alg.swap] before p. 3 until p. 4 by
</p>

<blockquote><pre>template &lt;<del>class</del> <ins>ValueType</ins> T, size_t N&gt;
<ins>requires Swappable&lt;T&gt;</ins>
void swap(T (&amp;a)[N], T (&amp;b)[N]);
</pre>
<blockquote>
<p>
<del><i>Requires:</i> <tt>T</tt> shall be <tt>Swappable</tt>.</del>
</p>
<p>
<i>Effects:</i> <tt>swap_ranges(a, a + N, b);</tt>
</p>
</blockquote>
</blockquote>






<hr>
<h3><a name="913"></a>913. Superfluous requirements for replace algorithms</h3>
<p><b>Section:</b> 25.3.5 [alg.replace] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-10-03 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.replace">issues</a> in [alg.replace].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
(A) 25.3.5 [alg.replace]/1:
</p>

<blockquote>
<i>Requires:</i> The expression <tt>*first = new_value</tt> shall be valid.
</blockquote>

<p>
(B) 25.3.5 [alg.replace]/4:
</p>

<blockquote>
<i>Requires:</i> The results of the expressions <tt>*first</tt> and <tt>new_value</tt> shall
be writable to the result output iterator.[..]
</blockquote>

<p>
Since conceptualization, the quoted content of these clauses is covered
by the existing requirements
</p>

<p>
(A) <tt>OutputIterator&lt;Iter, const T&amp;&gt;</tt>
</p>

<p>
and
</p>

<p>
(B) <tt>OutputIterator&lt;OutIter, InIter::reference&gt; &amp;&amp; OutputIterator&lt;OutIter, const T&amp;&gt;</tt>
</p>

<p>
resp, and thus should be removed.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with the proposed resolution.
</p>
<p>
Move to Tentatively Ready.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<ol type="A">
<li>
<p>
Remove 25.3.5 [alg.replace]/1.
</p>
<blockquote><pre>template&lt;ForwardIterator Iter, class T&gt; 
  requires OutputIterator&lt;Iter, Iter::reference&gt; 
        &amp;&amp; OutputIterator&lt;Iter, const T&amp;&gt; 
        &amp;&amp; HasEqualTo&lt;Iter::value_type, T&gt; 
  void replace(Iter first, Iter last, 
               const T&amp; old_value, const T&amp; new_value); 

template&lt;ForwardIterator Iter, Predicate&lt;auto, Iter::value_type&gt; Pred, class T&gt; 
  requires OutputIterator&lt;Iter, Iter::reference&gt; 
        &amp;&amp; OutputIterator&lt;Iter, const T&amp;&gt; 
        &amp;&amp; CopyConstructible&lt;Pred&gt; 
  void replace_if(Iter first, Iter last, 
                  Pred pred, const T&amp; new_value);
</pre>
<blockquote>
<del>1 <i>Requires:</i> The expression <tt>*first = new_value</tt> shall be valid.</del>
</blockquote>
</blockquote>
</li>
<li>
<p>
25.3.5 [alg.replace]/4: Remove the sentence "The results of the
expressions <tt>*first</tt> and
<tt>new_value</tt> shall be writable to the result output iterator.".
</p>
<blockquote><pre>template&lt;InputIterator InIter, typename OutIter, class T&gt; 
  requires OutputIterator&lt;OutIter, InIter::reference&gt; 
        &amp;&amp; OutputIterator&lt;OutIter, const T&amp;&gt; 
        &amp;&amp; HasEqualTo&lt;InIter::value_type, T&gt; 
  OutIter replace_copy(InIter first, InIter last, 
                       OutIter result, 
                       const T&amp; old_value, const T&amp; new_value);

template&lt;InputIterator InIter, typename OutIter,
         Predicate&lt;auto, InIter::value_type&gt; Pred, class T&gt; 
  requires OutputIterator&lt;OutIter, InIter::reference&gt; 
        &amp;&amp; OutputIterator&lt;OutIter, const T&amp;&gt; 
        &amp;&amp; CopyConstructible&lt;Pred&gt; 
  OutIter replace_copy_if(InIter first, InIter last, 
                          OutIter result, 
                          Pred pred, const T&amp; new_value);
</pre>
<blockquote>
4 <i>Requires:</i> <del>The results of the expressions <tt>*first</tt> and
<tt>new_value</tt> shall be writable to the <tt>result</tt> output
iterator.</del> The ranges <tt>[first,last)</tt> and <tt>[result,result +
(last - first))</tt> shall not overlap.
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="914"></a>914. Superfluous requirement for unique</h3>
<p><b>Section:</b> 25.3.9 [alg.unique] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-10-03 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.unique">issues</a> in [alg.unique].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
25.3.9 [alg.unique]/2: "Requires: The comparison function shall be an
equivalence relation."
</p>

<p>
The essence of this is already covered by the given requirement
</p>

<blockquote><pre>EquivalenceRelation&lt;auto, Iter::value_type&gt; Pred
</pre></blockquote>

<p>
and should thus be removed.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Remove 25.3.9 [alg.unique]/2
</p>

<blockquote><pre>template&lt;ForwardIterator Iter&gt;
  requires OutputIterator&lt;Iter, Iter::reference&gt;
        &amp;&amp; EqualityComparable&lt;Iter::value_type&gt;
  Iter unique(Iter first, Iter last);

template&lt;ForwardIterator Iter, EquivalenceRelation&lt;auto, Iter::value_type&gt; Pred&gt;
  requires OutputIterator&lt;Iter, RvalueOf&lt;Iter::reference&gt;::type&gt;
        &amp;&amp; CopyConstructible&lt;Pred&gt;
  Iter unique(Iter first, Iter last,
               Pred pred);
</pre>
<blockquote>
<p>
1 <i>Effects:</i> ...
</p>
<p>
<del>2 <i>Requires:</i> The comparison function shall be an equivalence relation.</del>
</p>
</blockquote>
</blockquote>





<hr>
<h3><a name="915"></a>915. <tt>minmax</tt> with <tt>initializer_list</tt> should return
<tt>pair</tt> of <tt>T</tt>, not <tt>pair</tt> of <tt>const T&amp;</tt></h3>
<p><b>Section:</b> 25.4.7 [alg.min.max] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-10-04 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.min.max">issues</a> in [alg.min.max].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It seems that the proposed changes for
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2772.pdf">N2772</a>
were not clear enough in
this point:
</p>

<blockquote>
25.4.7 [alg.min.max], before p.23 + p.24 + before p. 27 + p. 28 say that the return
type of the <tt>minmax</tt> overloads with an <tt>initializer_list</tt> is
<tt>pair&lt;const T&amp;, const T&amp;&gt;</tt>,
which is inconsistent with the decision for the other <tt>min/max</tt> overloads which take
a <tt>initializer_list</tt> as argument and return a <tt>T</tt>, not a <tt>const T&amp;</tt>.
Doing otherwise for <tt>minmax</tt> would easily lead to unexpected life-time
problems by using <tt>minmax</tt> instead of <tt>min</tt> and <tt>max</tt> separately.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Moved from Tentatively Ready to Open only because the wording needs to be
tweaked for concepts removal.
</blockquote>

<p><i>[
2009-08-18 Daniel adds:
]</i></p>


<blockquote>
Recommend NAD since the proposed changes have already been performed
as part of editorial work of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2914.pdf">N2914</a>.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Can't find initializer_list form of minmax anymore, only variadic
version. Seems like we had an editing clash with concepts. Leave Open,
at least until editorial issues resolved. Bring this to Editor's
attention.
</blockquote>

<p><i>[
2010 Pittsburgh:  Pete to reapply
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2772.pdf">N2772</a>.
]</i></p>




<p><b>Rationale:</b></p>
Solved by reapplying
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2772.pdf">N2772</a>.


<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
In 25 [algorithms]/2, header <tt>&lt;algorithm&gt;</tt> synopsis change as indicated:
</p>

<blockquote><pre>template&lt;<del>class</del><ins>LessThanComparable</ins> T&gt;
<ins>requires CopyConstructible&lt;T&gt;</ins>
pair&lt;<del>const </del>T<del>&amp;</del>, <del>const </del>T<del>&amp;</del>&gt;
minmax(initializer_list&lt;T&gt; t);

template&lt;class T, <del>class</del><ins>StrictWeakOrder&lt;auto, T&gt;</ins> Compare&gt;
<ins>requires CopyConstructible&lt;T&gt;</ins>
pair&lt;<del>const </del>T<del>&amp;</del>, <del>const </del>T<del>&amp;</del>&gt;
minmax(initializer_list&lt;T&gt; t, Compare comp);
</pre></blockquote>
</li>
<li>
<p>
In 25.4.7 [alg.min.max] change as indicated (Begin: Just before p.20):
</p>
<blockquote><pre>template&lt;<del>class</del><ins>LessThanComparable</ins> T&gt;
  <ins>requires CopyConstructible&lt;T&gt;</ins>
  pair&lt;<del>const </del>T<del>&amp;</del>, <del>const </del>T<del>&amp;</del>&gt;
  minmax(initializer_list&lt;T&gt; t);
</pre>
<blockquote>
<p>
<del>-20- <i>Requires:</i> <tt>T</tt> is <tt>LessThanComparable</tt> and
<tt>CopyConstructible</tt>.</del>
</p>
<p>
-21- <i>Returns:</i> <tt>pair&lt;<del>const </del>T<del>&amp;</del>, <del>const
</del>T<del>&amp;</del>&gt;(x, y)</tt> where <tt>x</tt> is the
smallest value and <tt>y</tt> the largest value in the <tt>initializer_list</tt>.
</p>
</blockquote>

<p>[..]</p>
<pre>template&lt;class T, <del>class</del><ins>StrictWeakOrder&lt;auto, T&gt;</ins> Compare&gt;
  <ins>requires CopyConstructible&lt;T&gt;</ins>
  pair&lt;<del>const </del>T<del>&amp;</del>, <del>const </del>T<del>&amp;</del>&gt;
  minmax(initializer_list&lt;T&gt; t, Compare comp);
</pre>

<blockquote>
<p>
<del>-24- <i>Requires:</i> type <tt>T</tt> is <tt>LessThanComparable</tt> and <tt>CopyConstructible</tt>.</del>
</p>
<p>
-25- <i>Returns:</i> <tt>pair&lt;<del>const </del>T<del>&amp;</del>, <del>const
</del>T<del>&amp;</del>&gt;(x, y)</tt> where <tt>x</tt> is the
smallest value and <tt>y</tt> largest value in the <tt>initializer_list</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="916"></a>916. Redundant move-assignment operator of <tt>pair</tt> should be removed</h3>
<p><b>Section:</b> 20.3.5 [pairs] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-10-04 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#pairs">issues</a> in [pairs].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>see also <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#917">917</a>.</b></p>

<p>
The current WP provides the following assignment operators for <tt>pair</tt>
in 20.3.5 [pairs]/1:
</p>

<ol>
<li>
<pre>template&lt;class U , class V&gt;
requires HasAssign&lt;T1, const U&amp;&gt; &amp;&amp; HasAssign&lt;T2, const V&amp;&gt;
pair&amp; operator=(const pair&lt;U , V&gt;&amp; p);
</pre>
</li>
<li>
<pre>requires MoveAssignable&lt;T1&gt; &amp;&amp; MoveAssignable&lt;T2&gt; pair&amp; operator=(pair&amp;&amp; p );
</pre>
</li>
<li>
<pre>template&lt;class U , class V&gt;
requires HasAssign&lt;T1, RvalueOf&lt;U&gt;::type&gt; &amp;&amp; HasAssign&lt;T2, RvalueOf&lt;V&gt;::type&gt;
pair&amp; operator=(pair&lt;U , V&gt;&amp;&amp; p);
</pre>
</li>
</ol>

<p>
It seems that the functionality of (2) is completely covered by (3), therefore
(2) should be removed.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Bill believes the extra assignment operators are necessary for resolving
ambiguities, but that does not mean it needs to be part of the specification.
</p>
<p>
Move to Open.
We recommend this be looked at in the context of the ongoing work
related to the pair templates.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
Leave this open pending the removal of concepts from the WD.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Mark as NAD, see issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#801">801</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<ol type="A">
<li>
<p>
In 20.3.5 [pairs] p. 1, class <tt>pair</tt> and just before p. 13 remove the declaration:
</p>

<blockquote><pre>requires MoveAssignable&lt;T1&gt; &amp;&amp; MoveAssignable&lt;T2&gt; pair&amp; operator=(pair&amp;&amp; p );
</pre></blockquote>
</li>

<li>
Remove p.13+p.14
</li>

</ol>





<hr>
<h3><a name="917"></a>917. Redundant move-assignment operator of <tt>tuple</tt> should be removed</h3>
<p><b>Section:</b> 20.4.2.1 [tuple.cnstr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-10-04 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#tuple.cnstr">issues</a> in [tuple.cnstr].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>see also <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#916">916</a>.</b></p>
<p>
N2770 (and thus now the WP) removed the
non-template move-assignment operator from tuple's class definition,
but the latter individual member description does still provide this
operator. Is this (a) an oversight and can it (b) be solved as part of an
editorial process?
</p>

<p><i>[
Post Summit Daniel provided wording.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We believe that the proposed resolution's part 1 is editorial.
</p>
<p>
Regarding part 2, we either remove the specification as proposed,
or else add back the declaration to which the specification refers.
Alisdair and Bill prefer the latter.
It is not immediately obvious whether the function is intended to be present.
</p>
<p>
We recommend that the Project Editor restore the missing declaration
and that we keep part 2 of the issue alive.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
Leave this open pending the removal of concepts from the WD.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Mark as NAD, see issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#801">801</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
In 20.4.2 [tuple.tuple], class <tt>tuple</tt> just before member <tt>swap</tt> please
change as indicated:
</p>
<p><i>[
This fixes an editorial loss between N2798 to N2800
]</i></p>

<blockquote><pre>template &lt;class... UTypes&gt;
requires HasAssign&lt;Types, const UTypes&amp;&gt;...
<ins>tuple&amp; operator=(const pair&lt;UTypes...&gt;&amp;);</ins>

template &lt;class... UTypes&gt;
requires HasAssign&lt;Types, RvalueOf&lt;UTypes&gt;::type&gt;...
<ins>tuple&amp; operator=(pair&lt;UTypes...&gt;&amp;&amp;);</ins>
</pre></blockquote>
</li>
<li>
<p>
In 20.4.2.1 [tuple.cnstr], starting just before p. 11 please remove
as indicated:
</p>

<blockquote><pre><del>requires MoveAssignable&lt;Types&gt;... tuple&amp; operator=(tuple&amp;&amp; u);</del>
</pre>
<blockquote>
<p>
<del>-11- <i>Effects:</i> Move-assigns each element of <tt>u</tt> to the corresponding
element of <tt>*this</tt>.</del>
</p>
<p>
<del>-12- <i>Returns:</i> <tt>*this</tt>.</del>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="918"></a>918. Swap for tuple needs to be conceptualized</h3>
<p><b>Section:</b> 20.4.2.3 [tuple.swap] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-10-04 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#522">522</a> was accepted after <tt>tuple</tt> had been conceptualized,
therefore this step needs to be completed.
</p>

<p><i>[
Post Summit Daniel adds
]</i></p>


<blockquote>
This is now NAD Editorial (addressed by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2844.html">N2844</a>)
except for item 3 in the proposed wording.
</blockquote>

<p><i>[
2009-05-01 Daniel adds:
]</i></p>


<blockquote>
As of the recent WP
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2857.pdf">N2857</a>),
this issue is now completely covered by editorial
changes (including the third bullet), therefore I unconditionally recommend
NAD.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We observed that all the proposed changes have already been applied to the
Working Draft, rendering this issue moot.
</p>
<p>
Move to NAD.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
In both 20.4.1 [tuple.general]/2 and 20.4.2.9 [tuple.special] change
</p>

<blockquote><pre>template &lt;<del>class</del> <ins>Swappable</ins>... Types&gt;
void swap(tuple&lt;Types...&gt;&amp; x, tuple&lt;Types...&gt;&amp; y);
</pre></blockquote>

</li>

<li>
<p>
In 20.4.2 [tuple.tuple], class <tt>tuple</tt> definition and in
20.4.2.3 [tuple.swap], change
</p>

<blockquote><pre><ins>requires Swappable&lt;Types&gt;...</ins>void swap(tuple&amp;);
</pre></blockquote>

</li>

<li>
<p>
In 20.4.2.3 [tuple.swap] remove the current requires-clause, which says:
</p>

<blockquote>
<del><i>Requires:</i> Each type in <tt>Types</tt> shall be <tt>Swappable</tt></del>
</blockquote>
</li>

</ol>






<hr>
<h3><a name="919"></a>919. (forward_)list specialized remove algorithms are over constrained</h3>
<p><b>Section:</b> 23.3.3.5 [forwardlist.ops], 23.3.4.4 [list.ops] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2008-10-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#forwardlist.ops">issues</a> in [forwardlist.ops].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The signatures of <tt>forwardlist::remove</tt> and <tt>list::remove</tt>
defined in 23.3.3.5 [forwardlist.ops] before 11 + 23.3.4.4 [list.ops] before 15:
</p>

<blockquote><pre>requires EqualityComparable&lt;T&gt; void remove(const T&amp; value);
</pre></blockquote>

<p>
are asymmetric to their predicate variants (which only require
<tt>Predicate</tt>, <em>not</em> <tt>EquivalenceRelation</tt>) and with the free algorithm
remove (which only require <tt>HasEqualTo</tt>). Also, nothing in the
pre-concept WP
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a>
implies that <tt>EqualityComparable</tt> should
be the intended requirement.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with the proposed resolution,
but would like additional input from concepts experts.
</p>
<p>
Move to Review.
</p>
</blockquote>

<p><i>[
2009-07-21 Alisdair adds:
]</i></p>


<blockquote>
Current rationale and wording for this issue is built around concepts. I
suggest the issue reverts to Open status. I believe there is enough of
an issue to review after concepts are removed from the WP to re-examine
the issue in Santa Cruz, rather than resolve as NAD Concepts.
</blockquote>

<p><i>[
2009-10-10 Daniel adds:
]</i></p>


<blockquote>
Recommend NAD: The concept-free wording as of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2960.pdf">N2960</a>
has no longer the
over-specified requirement
<tt>EqualityComparable</tt> for the remove function that uses <tt>==</tt>. In fact, now
the same test conditions exists
as for the free algorithm <tt>remove</tt> (25.3.8 [alg.remove]). The error was
introduced in the process of conceptifying.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD, solved by the removal of concepts.
</blockquote>



<p><b>Proposed resolution:</b></p>
<ol type="A">
<li>
<p>
Replace in 23.3.3.5 [forwardlist.ops] before 11 and in 23.3.4.4 [list.ops] before 15
</p>

<blockquote><pre>requires <del>EqualityComparable&lt;T&gt;</del> <ins>HasEqualTo&lt;T, T&gt;</ins> void remove(const T&amp; value);
</pre></blockquote>
</li>
</ol>






<hr>
<h3><a name="923"></a>923. atomics with floating-point </h3>
<p><b>Section:</b> 29 [atomics] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Herb Sutter <b>Opened:</b> 2008-10-17 <b>Last modified:</b> 2010-10-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#atomics">active issues</a> in [atomics].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics">issues</a> in [atomics].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Right now, C++0x doesn't have <tt>atomic&lt;float&gt;</tt>. We're thinking of adding
the words to support it for TR2 (note: that would be slightly
post-C++0x). If we need it, we could probably add the words.
</p>
<p>
<b>Proposed resolutions:</b> Using <tt>atomic&lt;FP&gt;::compare_exchange</tt> (weak or
strong) should be either:
</p>

<ol>
<li>
ill-formed, or
</li>
<li>
well-defined.
</li>
</ol>

<p>
I propose Option 1 for C++0x for expediency. If someone wants to argue
for Option 2, they need to say what exactly they want <tt>compare_exchange</tt>
to mean in this case (IIRC, C++0x doesn't even assume IEEE 754).
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Move to open. Blocked until concepts for atomics are addressed.
</blockquote>

<p><i>[
Post Summit Anthony adds:
]</i></p>


<blockquote>
<p>
Recommend NAD. C++0x does have <tt>std::atomic&lt;float&gt;</tt>, and both
<tt>compare_exchange_weak</tt> and <tt>compare_exchange_strong</tt> are well-defined in
this case. Maybe change the note in 29.6 [atomics.types.operations] paragraph 20 to:
</p>

<blockquote>
<p>
[<i>Note:</i> The effect of the compare-and-exchange operations is
</p>
<blockquote><pre>if (!memcmp(object,expected,sizeof(*object)))
    *object = desired;
else
    *expected = *object;
</pre></blockquote>

<p>
This may result in failed comparisons for values that compare equal if
the underlying type has padding bits or alternate representations of
the same value. <i>-- end note</i>]
</p>
</blockquote>

</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2992.html">N2992</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change the note in 29.6 [atomics.types.operations] paragraph 20 to:
</p>

<blockquote>
<p>
[<i>Note:</i> The effect of the compare-and-exchange operations is
</p>
<blockquote><pre>if (<del>*object == *expected</del> <ins>!memcmp(object,expected,sizeof(*object))</ins>)
    *object = desired;
else
    *expected = *object;
</pre></blockquote>

<p><ins>
This may result in failed comparisons for values that compare equal if
the underlying type has padding bits or alternate representations of
the same value.</ins> <i>-- end note</i>]
</p>
</blockquote>






<hr>
<h3><a name="924"></a>924. structs with internal padding</h3>
<p><b>Section:</b> 29 [atomics] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Herb Sutter <b>Opened:</b> 2008-10-17 <b>Last modified:</b> 2010-10-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#atomics">active issues</a> in [atomics].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics">issues</a> in [atomics].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Right now, the <tt>compare_exchange_weak</tt> loop should rapidly converge on the
padding contents. But <tt>compare_exchange_strong</tt> will require a bit more
compiler work to ignore padding for comparison purposes.
</p>
<p>
Note that this isn't a problem for structs with no padding, and we do
already have one portable way to ensure that there is no padding that
covers the key use cases: Have elements be the same type. I suspect that
the greatest need is for a structure of two pointers, which has no
padding problem. I suspect the second need is a structure of a pointer
and some form of an integer. If that integer is <tt>intptr_t</tt>, there will be
no padding.
</p>
<p>
Related but separable issue: For unused bitfields, or other unused
fields for that matter, we should probably say it's the programmer's
responsibility to set them to zero or otherwise ensure they'll be
ignored by <tt>memcmp</tt>.
</p>

<p>
<b>Proposed resolutions:</b> Using
<tt>atomic&lt;struct-with-padding&gt;::compare_exchange_strong</tt> should be either:
</p>

<ol>
<li>
ill-formed, or
</li>
<li>
well-defined.
</li>
</ol>

<p>
I propose Option 1 for C++0x for expediency, though I'm not sure how to
say it. I would be happy with Option 2, which I believe would mean that
<tt>compare_exchange_strong</tt> would be implemented to avoid comparing padding
bytes, or something equivalent such as always zeroing out padding when
loading/storing/comparing. (Either implementation might require compiler
support.)
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Move to open. Blocked until concepts for atomics are addressed.
</blockquote>

<p><i>[
Post Summit Anthony adds:
]</i></p>


<blockquote>
The resoultion of LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#923">923</a> should resolve this issue as well.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2992.html">N2992</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="926"></a>926. Sequentially consistent fences, relaxed operations and modification order</h3>
<p><b>Section:</b> 29.3 [atomics.order] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Anthony Williams <b>Opened:</b> 2008-10-19 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics.order">issues</a> in [atomics.order].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses UK 313</b></p>

<p>
There was an interesting issue raised over on comp.programming.threads
today regarding the following example
</p>

<blockquote><pre>// Thread 1:
x.store(1, memory_order_relaxed);           // SX
atomic_thread_fence(memory_order_seq_cst);  // F1
y.store(1, memory_order_relaxed);           // SY1
atomic_thread_fence(memory_order_seq_cst);  // F2
r1 = y.load(memory_order_relaxed);          // RY

// Thread 2:
y.store(0, memory_order_relaxed);          // SY2
atomic_thread_fence(memory_order_seq_cst); // F3
r2 = x.load(memory_order_relaxed);         // RX
</pre></blockquote>

<p>
is the outcome <tt>r1 == 0</tt> and <tt>r2 == 0</tt> possible?
</p>
<p>
I think the intent is that this is not possible, but I am not sure the
wording guarantees that. Here is my analysis:
</p>
<p>
Since all the fences are SC, there must be a total order between them.
<tt>F1</tt> must be before <tt>F2</tt> in that order since they are in
the same thread. Therefore <tt>F3</tt> is either before <tt>F1</tt>,
between <tt>F1</tt> and <tt>F2</tt> or after <tt>F2</tt>.
</p>
<p>
If <tt>F3</tt> is <em>after</em> <tt>F2</tt>, then we can apply 29.3 [atomics.order]p5 from
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2798.pdf">N2798</a>:
</p>

<blockquote>
For atomic operations <tt>A</tt> and <tt>B</tt> on an atomic object
<tt>M</tt>, where <tt>A</tt> modifies <tt>M</tt> and <tt>B</tt> takes
its value, if there are <tt>memory_order_seq_cst</tt> fences <tt>X</tt>
and <tt>Y</tt> such that <tt>A</tt> is sequenced before <tt>X</tt>,
<tt>Y</tt> is sequenced before <tt>B</tt>, and <tt>X</tt> precedes
<tt>Y</tt> in <tt>S</tt>, then <tt>B</tt> observes either the effects of
<tt>A</tt> or a later modification of <tt>M</tt> in its modification
order.
</blockquote>

<p>
In this case, <tt>A</tt> is <tt>SX</tt>, <tt>B</tt> is <tt>RX</tt>, the
fence <tt>X</tt> is <tt>F2</tt> and the fence <tt>Y</tt> is <tt>F3</tt>,
so <tt>RX</tt> must see 1.
</p>
<p>
If <tt>F3</tt> is <em>before</em> <tt>F2</tt>, this doesn't apply, but
<tt>F3</tt> can therefore be before or after <tt>F1</tt>.
</p>
<p>
If <tt>F3</tt> is <em>after</em> <tt>F1</tt>, the same logic applies, but this
time the fence <tt>X</tt> is <tt>F1</tt>. Therefore again, <tt>RX</tt>
must see 1.
</p>
<p>
Finally we have the case that <tt>F3</tt> is <em>before</em> <tt>F1</tt>
in the SC ordering. There are now no guarantees about <tt>RX</tt>, and
<tt>RX</tt> can see <tt>r2==0</tt>.
</p>
<p>
We can apply 29.3 [atomics.order]p5 again. This time,
<tt>A</tt> is <tt>SY2</tt>, <tt>B</tt> is <tt>RY</tt>, <tt>X</tt> is
<tt>F3</tt> and <tt>Y</tt> is <tt>F1</tt>. Thus <tt>RY</tt> must observe
the effects of <tt>SY2</tt> or a later modification of <tt>y</tt> in its
modification order.
</p>
<p>
Since <tt>SY1</tt> is sequenced before <tt>RY</tt>, <tt>RY</tt> must
observe the effects of <tt>SY1</tt> or a later modification of
<tt>y</tt> in its modification order.
</p>
<p>
In order to ensure that <tt>RY</tt> sees <tt>(r1==1)</tt>, we must see
that <tt>SY1</tt> is later in the modification order of <tt>y</tt> than
<tt>SY2</tt>.
</p>
<p>
We're now skating on thin ice. Conceptually, <tt>SY2</tt> happens-before
<tt>F3</tt>, <tt>F3</tt> is SC-ordered before <tt>F1</tt>, <tt>F1</tt>
happens-before <tt>SY1</tt>, so <tt>SY1</tt> is later in the
modification order <tt>M</tt> of <tt>y</tt>, and <tt>RY</tt> must see
the result of <tt>SY1</tt> (<tt>r1==1</tt>). However, I don't think the
words are clear on that.
</p>

<p><i>[
Post Summit Hans adds:
]</i></p>


<blockquote>
<p>
In my (Hans') view, our definition of fences will always be weaker than
what particular hardware will guarantee.  <tt>Memory_order_seq_cst</tt> fences
inherently don't guarantee sequential consistency anyway, for good
reasons (e.g. because they can't enforce a total order on stores).
 Hence I don't think the issue demonstrates a gross failure to achieve
what we intended to achieve.  The example in question is a bit esoteric.
 Hence, in my view, living with the status quo certainly wouldn't be a
disaster either.
</p>
<p>
In any case, we should probably add text along the lines of the
following between p5 and p6 in 29.3 [atomics.order]:
</p>
<blockquote>
[Note: <tt>Memory_order_seq_cst</tt> only ensures sequential consistency for a
data-race-free program that uses exclusively <tt>memory_order_seq_cst</tt>
operations.  Any use of weaker ordering will invalidate this guarantee
unless extreme care is used.  In particular, <tt>memory_order_seq_cst</tt> fences
only ensure a total order for the fences themselves.  They cannot, in
general, be used to restore sequential consistency for atomic operations
with weaker ordering specifications.]
</blockquote>

<p>
Also see thread beginning at c++std-lib-23271.
</p>

</blockquote>

<p><i>[
Herve's correction:
]</i></p>

<blockquote>
<p>
Minor point, and sorry for the knee jerk reaction: I admit to having
no knowledge of Memory_order_seq_cst, but my former boss (John Lakos)
has ingrained an automatic introspection on the use of "only".   I
think you meant:
</p>

<blockquote>
[Note: <tt>Memory_order_seq_cst</tt> ensures sequential consistency only
for . . . .  In particular, <tt>memory_order_seq_cst</tt> fences ensure a
total order only for . . .
</blockquote>
<p>
Unless, of course, <tt>Memory_order_seq_cst</tt> really do nothing but ensure
sequential consistency for a data-race-free program that uses
exclusively <tt>memory_order_seq_cst</tt> operations.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2992.html">N2992</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add a new paragraph after 29.3 [atomics.order]p5 that says
</p>

<blockquote>
For atomic operations <tt>A</tt> and <tt>B</tt> on an atomic object
<tt>M</tt>, where <tt>A</tt> and <tt>B</tt> modify <tt>M</tt>, if there
are <tt>memory_order_seq_cst</tt> fences <tt>X</tt> and <tt>Y</tt> such
that <tt>A</tt> is sequenced before <tt>X</tt>, <tt>Y</tt> is sequenced
before <tt>B</tt>, and <tt>X</tt> precedes <tt>Y</tt> in <tt>S</tt>,
then <tt>B</tt> occurs later than <tt>A</tt> in the modifiction order of
<tt>M</tt>.
</blockquote>





<hr>
<h3><a name="927"></a>927. <tt>Dereferenceable</tt>  should be <tt>HasDereference</tt></h3>
<p><b>Section:</b> X [allocator.concepts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Pablo Halpern <b>Opened:</b> 2008-10-23 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
X [allocator.concepts] contains a reference to a concept named
<tt>Dereferenceable</tt>. No such concept exists.
</p>

<p><i>[
Daniel adds 2009-02-14:
]</i></p>


<blockquote>
The proposal given in the paper
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2829.pdf">N2829</a>
would automatically resolve this issue.
</blockquote>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
This particular set of changes has already been made.
There are two related changes later on (and possibly also an earlier Example);
these can be handled editorially.
</p>
<p>
Move to NAD Editorial.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change all uses of the concept <tt>Dereferenceable</tt> to
<tt>HasDereference</tt> in X [allocator.concepts].
</p>





<hr>
<h3><a name="928"></a>928. Wrong concepts used for <tt>tuple</tt>'s comparison operators</h3>
<p><b>Section:</b> 20.4.2.7 [tuple.rel] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Joe Gottman <b>Opened:</b> 2008-10-28 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#tuple.rel">issues</a> in [tuple.rel].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In the latest working draft for C++0x, <tt>tuple</tt>'s <tt>operator==</tt> and <tt>operator&lt;</tt>
are declared as 
</p>

<blockquote><pre>template&lt;class... TTypes, class... UTypes&gt; 
  requires EqualityComparable&lt;TTypes, UTypes&gt;... 
  bool operator==(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);
</pre></blockquote>

<p>
and
</p>

<blockquote><pre>template&lt;class... TTypes, class... UTypes&gt; 
  requires LessThanComparable&lt;TTypes, UTypes&gt;... 
  bool operator&lt;(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);
</pre></blockquote>

<p>
But the concepts <tt>EqualityComparable</tt> and <tt>LessThanComparable</tt> only take one 
parameter, not two.  Also, even if <tt>LessThanComparable</tt> could take two 
parameters, the definition of <tt>tuple::operator&lt;()</tt> should also require 
</p>

<blockquote><pre>LessThanComparable&lt;UTypes, TTypes&gt;... // (note the order) 
</pre></blockquote>

<p>
since the algorithm for <tt>tuple::operator&lt;</tt> is the following (pseudo-code)
</p>

<blockquote><pre>for (size_t N = 0; N &lt; sizeof...(TTypes); ++N) { 
    if (get&lt;N&gt;(t) &lt; get&lt;N&gt;(u) return true; 
    else if ((get&lt;N&gt;(u) &lt; get&lt;N&gt;(t)) return false; 
} 

return false; 
</pre></blockquote>

<p>
Similar problems hold for <tt>tuples</tt>'s other comparison operators.
</p>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
Recommend Tentatively Ready.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
In 20.4.1 [tuple.general] and 20.4.2.7 [tuple.rel] change:
</p>

<blockquote><pre>template&lt;class... TTypes, class... UTypes&gt;
  requires <del>EqualityComparable</del><ins>HasEqualTo</ins>&lt;TTypes, UTypes&gt;...
  bool operator==(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;UTypes...&gt;&amp;);

template&lt;class... TTypes, class... UTypes&gt;
  requires <del>LessThanComparable</del><ins>HasLess</ins>&lt;TTypes, UTypes&gt;... <ins>&amp;&amp; HasLess&lt;UTypes, TTypes&gt;...</ins>
  bool operator&lt;(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;UTypes...&gt;&amp;);

template&lt;class... TTypes, class... UTypes&gt;
  requires <del>EqualityComparable</del><ins>HasEqualTo</ins>&lt;TTypes, UTypes&gt;...
  bool operator!=(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;UTypes...&gt;&amp;);

template&lt;class... TTypes, class... UTypes&gt;
  requires <del>LessThanComparable</del><ins>HasLess</ins>&lt;<del>U</del><ins>T</ins>Types, <del>T</del><ins>U</ins>Types&gt;... <ins>&amp;&amp; HasLess&lt;UTypes, TTypes&gt;...</ins>
  bool operator&gt;(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;UTypes...&gt;&amp;);

template&lt;class... TTypes, class... UTypes&gt;
  requires <del>LessThanComparable</del><ins>HasLess</ins>&lt;<del>U</del><ins>T</ins>Types, <del>T</del><ins>U</ins>Types&gt;... <ins>&amp;&amp; HasLess&lt;UTypes, TTypes&gt;...</ins>
  bool operator&lt;=(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;UTypes...&gt;&amp;);

template&lt;class... TTypes, class... UTypes&gt;
  requires <del>LessThanComparable</del><ins>HasLess</ins>&lt;TTypes, UTypes&gt;... <ins>&amp;&amp; HasLess&lt;UTypes, TTypes&gt;...</ins>
  bool operator&gt;=(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;UTypes...&gt;&amp;);
</pre></blockquote>





<hr>
<h3><a name="930"></a>930. Access to std::array data as built-in array type</h3>
<p><b>Section:</b> 23.3.1 [array] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Niels Dekker <b>Opened:</b> 2008-11-17 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#array">issues</a> in [array].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The Working Draft (N2798) allows access to the elements of
<tt>std::array</tt> by its <tt>data()</tt> member function:
</p>

<blockquote>

<h5>23.2.1.4 array::data [array.data]</h5>
<pre> T *data();
 const T *data() const;
</pre>
<ol><li>
 Returns: elems.
</li></ol>
</blockquote>

<p>
Unfortunately, the result of <tt>std::array::data()</tt> cannot be bound
to a reference to a built-in array of the type of <tt>array::elems</tt>.
And <tt>std::array</tt> provides no other way to get a reference to
<tt>array::elems</tt>. 
This hampers the use of <tt>std::array</tt>, for example when trying to
pass its data to a C style API function:
</p>

<pre> // Some C style API function. 
 void set_path( char (*)[MAX_PATH] );

 std::array&lt;char,MAX_PATH&gt; path;
 set_path( path.data() );  // error
 set_path( &amp;(path.data()) );  // error
</pre>

 <p>
Another example, trying to pass the array data to an instance of another
C++ class:
</p>

<pre> // Represents a 3-D point in space.
 class three_d_point {
 public:
   explicit three_d_point(const double (&amp;)[3]); 
 };

 const std::array&lt;double,3&gt; coordinates = { 0, 1, 2 };
 three_d_point point1( coordinates.data() );  // error.
 three_d_point point2( *(coordinates.data()) );  // error.
</pre>

<p>
A user might be tempted to use <tt>std::array::elems</tt> instead, but
doing so isn't recommended, because <tt>std::array::elems</tt> is "for
exposition only".  Note that Boost.Array users might already use
<tt>boost::array::elems</tt>, as its documentation doesn't explicitly
state that <tt>boost::array::elems</tt> is for exposition only:
http://www.boost.org/doc/libs/1_36_0/doc/html/boost/array.html
</p>
<p>
I can think of three options to solve this issue:
</p>
<ol><li>
Remove the words "exposition only" from the definition of
<tt>std::array::elems</tt>, as well as the note saying that "elems is
shown for exposition only."
</li><li>
Change the signature of <tt>std::array::data()</tt>, so that it would
return a reference to the built-in array, instead of a pointer to its
first element.
</li><li>
Add extra member functions, returning a reference to the built-in array.
</li></ol>
<p>
Lawrence Crowl wrote me that it might be better to leave
<tt>std::array::elems</tt> "for exposition only", to allow alternate
representations to allocate the array data dynamically.  This might be
of interest to the embedded community, having to deal with very limited
stack sizes.
</p>
<p>
The second option, changing the return type of
<tt>std::array::data()</tt>, would break backward compatible to current
Boost and TR1 implementations, as well as to the other contiguous
container (<tt>vector</tt> and <tt>string</tt>) in a very subtle way.
For example, the following call to <tt>std::swap</tt> currently swap two
locally declared pointers <tt>(data1, data2)</tt>, for any container
type <tt>T</tt> that has a <tt>data()</tt> member function. When
<tt>std::array::data()</tt> is changed to return a reference, the
<tt>std::swap</tt> call may swap the container elements instead.
</p>

<pre> template &lt;typename T&gt;
 void func(T&amp; container1, T&amp; container2)
 {
   // Are data1 and data2 pointers or references?
   auto data1 = container1.data();
   auto data2 = container2.data();

   // Will this swap two local pointers, or all container elements?
   std::swap(data1, data2);
 }
</pre>

<p>
The following concept is currently satisfied by all contiguous
containers, but it no longer is for <tt>std::array</tt>, when
<tt>array::data()</tt>
is changed to return a reference (tested on ConceptGCC Alpha 7):
</p>

<pre> auto concept ContiguousContainerConcept&lt;typename T&gt;
 {
   typename value_type = typename T::value_type;
   const value_type * T::data() const;
 }
</pre>

<p>
Still it's worth considering having <tt>std::array::data()</tt> return a
reference, because it might be the most intuitive option, from a user's
point of view.  Nicolai Josuttis (who wrote <tt>boost::array</tt>)
mailed me that he very much prefers this option.
</p>
<p>
Note that for this option, the definition of <tt>data()</tt> would also
need to be revised for zero-sized arrays, as its return type cannot be a
reference to a zero-sized built-in array.  Regarding zero-sized array,
<tt>data()</tt> could throw an exception.  Or there could be a partial
specialization of <tt>std::array</tt> where <tt>data()</tt> returns
<tt>T*</tt> or gets removed.
</p>
<p>
Personally I prefer the third option, adding a new member function to
<tt>std::array</tt>, overloaded for const and non-const access,
returning a reference to the built-in array, to avoid those compatible
issues. I'd propose naming the function <tt>std::array::c_array()</tt>,
which sounds intuitive to me. Note that <tt>boost::array</tt> already
has a <tt>c_array()</tt> member, returning a pointer, but Nicolai told
me that this one is only there for historical reasons. (Otherwise a name
like <tt>std::array::native_array()</tt> or
<tt>std::array::builtin_array()</tt> would also be fine with me.) 
According to my proposed resolution, a zero-sized <tt>std::array</tt> does not need
to have <tt>c_array()</tt>, while it is still required to have
<tt>data()</tt> functions.
</p>

<p><i>[
Post Summit:
]</i></p>


<blockquote>

<p>
Alisdair: Don't like p4 suggesting implementation-defined behaviour.
</p>
<p>
Walter: What about an explicit conversion operator, instead of adding
the new member function?
</p>
<p>
Alisdair: Noodling about:
</p>
<blockquote><pre>template&lt;size_t N, ValueType T&gt;
struct array
{
  T elems[N];

// fantasy code starts here

// crazy decltype version for grins only
//requires True&lt;(N&gt;0)&gt;
//explict operator decltype(elems) &amp; () { return elems; }

// conversion to lvalue ref
requires True&lt;(N&gt;0)&gt;
explict operator T(&amp;)[N] () &amp; { return elems; }

// conversion to const lvalue ref
requires True&lt;(N&gt;0)&gt;
explict operator const T(&amp;)[N] () const &amp; { return elems; }

// conversion to rvalue ref using ref qualifiers
requires True&lt;(N&gt;0)&gt;
explict operator T(&amp;&amp;)[N] () &amp;&amp; { return elems; }

// fantasy code ends here

explicit operator bool() { return true; }
};
</pre></blockquote>

<p>
This seems legal but odd. Jason Merrill says currently a CWG issue 613
on the non-static data member that fixes the error that current G++
gives for the non-explicit, non-conceptualized version of this. Verdict
from human compiler: seems legal.
</p>
<p>
Some grumbling about zero-sized arrays being allowed and supported.
</p>
<p>
Walter: Would this address the issue? Are we inclined to go this route?
</p>
<p>
Alan: What would usage look like?
</p>
<blockquote><pre>// 3-d point in space
struct three_d_point
{
  explicit three_d_point(const double (&amp;)[3]);
};

void sink(double*);

const std::array&lt;double, 3&gt; coordinates = { 0, 1, 2 };
three_d_point point1( coordinates.data() ); //error
three_d_point point2( *(coordinates.data()) ); // error
three_d_point point3( coordinates ); // yay!

sink(cooridinates); // error, no conversion
</pre></blockquote>

<p>
Recommended Open with new wording. Take the required clause and add the
explicit conversion operators, not have a <tt>typedef</tt>. At issue still is use
<tt>decltype</tt> or use <tt>T[N]</tt>. In favour of using <tt>T[N]</tt>, even though use of
<tt>decltype</tt> is specially clever.
</p>

</blockquote>

<p><i>[
Post Summit, further discussion in the thread starting with c++std-lib-23215.
]</i></p>


<p><i>[
2009-07 post-Frankfurt (Saturday afternoon group):
]</i></p>


<blockquote>
<p>
The idea to resolve the issue by adding explicit conversion operators
was abandoned, because it would be inconvenient to use, especially when
passing the array to a template function, as mentioned by Daniel. So we
reconsidered the original proposed resolution, which appeared
acceptable, except for its proposed changes to 23.3.1.7 [array.zero], which
allowed <tt>c_array_type</tt> and <tt>c_array()</tt> to be absent for a zero-sized array.
Alisdair argued that such wording would disallow certain generic use
cases. New wording for 23.3.1.7 [array.zero] was agreed upon (Howard: and
is reflected in the proposed resolution).
</p>
<p>
Move to Review
</p>
</blockquote>

<p><i>[
2009-07-31 Alisdair adds:
]</i></p>


<blockquote>
<p>
I will be unhappy voting the proposed resolution for 930 past review
until we have implementation experience with reference qualifiers. 
Specifically, I want to understand the impact of the missing overload
for <tt>const &amp;&amp;</tt> (if any.)
</p>

<p>
If we think the issue is important enough it might be worthwhile
stripping the ref qualifiers for easy progress next meeting, and opening
yet another issue to put them back with experience.
</p>

<p>
Recommend deferring any decision on splitting the issue until we get LWG
feedback next meeting - I may be the lone dissenting voice if others are
prepared to proceed without it.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Mark as NAD. There was not enough consensus that this was sufficiently
useful. There are known other ways to do this, such as small inline
conversion functions.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add to the template definition of array, 23.3.1 [array]/3:
</p>

<blockquote>
<pre><ins>
typedef T c_array_type[N];
c_array_type &amp; c_array() &amp;;
c_array_type &amp;&amp; c_array() &amp;&amp;;
const c_array_type &amp; c_array() const &amp;;
</ins>
</pre>
</blockquote>

<p>
Add the following subsection to 23.3.1 [array], after 23.3.1.4 [array.data]:
</p>

<blockquote>
<h5><ins>23.2.1.5 array::c_array [array.c_array]</ins></h5>
    <pre><ins>
c_array_type &amp; c_array() &amp;;
c_array_type &amp;&amp; c_array() &amp;&amp;;
const c_array_type &amp; c_array() const &amp;;
</ins></pre>
<blockquote>
<p>
<ins><i>Returns:</i> <tt>elems</tt>.</ins>
</p>
</blockquote>

</blockquote>



<p>
Change Zero sized arrays 23.3.1.7 [array.zero]:
</p>

<blockquote>

<p>-2- ...</p>

<p><ins>
The type <tt>c_array_type</tt> is unspecified for a zero-sized array.
</ins></p>

<p>
-3- The effect of calling <ins><tt>c_array()</tt>,</ins> <tt>front()</tt><ins>,</ins> or
<tt>back()</tt> for a zero-sized array is implementation defined.
</p>
</blockquote>






<hr>
<h3><a name="933"></a>933. Unique_ptr defect</h3>
<p><b>Section:</b> 20.9.9.2.5 [unique.ptr.single.modifiers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Future">NAD Future</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2008-11-27 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unique.ptr.single.modifiers">issues</a> in [unique.ptr.single.modifiers].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<p>
If we are supporting stateful deleters, we need an overload for
<tt>reset</tt> that
takes a deleter as well.
</p>

<blockquote><pre>void reset( pointer p, deleter_type d);
</pre></blockquote>

<p>
We probably need two overloads to support move-only deleters, and
this
sounds uncomfortably like the two constructors I have been ignoring
for
now...
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Howard comments that we have the functionality via move-assigment.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Mark as NAD Future.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="935"></a>935. clock error handling needs to be specified</h3>
<p><b>Section:</b> 20.11.5 [time.clock] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Future">NAD Future</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2008-11-24 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Each of the three clocks specified in Clocks 20.11.5 [time.clock]
provides the member function:
</p>

<blockquote><pre>static time_point now();
</pre></blockquote>

<p>
The semantics specified by Clock requirements 20.11.1 [time.clock.req]
make no mention of error handling. Thus the function may throw <tt>bad_alloc</tt>
or an implementation-defined exception (17.6.4.12 [res.on.exception.handling]
paragraph 4).
</p>

<p>
Some implementations of these functions on POSIX, Windows, and
presumably on other operating systems, may fail in ways only detectable
at runtime. Some failures on Windows are due to supporting chipset
errata and can even occur after successful calls to a clock's <tt>now()</tt>
function.
</p>

<p>
These functions are used in cases where exceptions are not appropriate
or where the specifics of the exception or cause of error need to be
available to the user. See
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2828.html">N2828</a>,
<i>Library Support for hybrid error
handling (Rev 1)</i>, for more specific discussion of use cases. Thus some change in
the interface of now is required.
</p>

<p>
The proposed resolution has been implemented in the Boost version of the
chrono library. No problems were encountered.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We recommend this issue be deferred until the next Committee Draft
has been issued and the prerequisite paper has been accepted.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Mark as NAD future. Too late to make this change without having already
accepted the hybrid error handling proposal.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Accept the proposed wording of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2828.html">N2828</a>,
<i>Library Support for hybrid error handling (Rev 1)</i>.
</p>

<p>
Change Clock requirements 20.11.1 [time.clock.req] as indicated:
</p>

<blockquote>
<p>
-2- In Table 55 <tt>C1</tt> and <tt>C2</tt> denote clock types. <tt>t1</tt> and
<tt>t2</tt> are values returned by <tt>C1::now()</tt> where the call 
returning <tt>t1</tt> happens before (1.10) the call returning <tt>t2</tt> and
both of these calls happen before <tt>C1::time_point::max()</tt>.
<ins><tt>ec</tt> denotes an object of type <tt>error_code</tt> 
(19.5.2.1 [syserr.errcode.overview]).</ins>
</p>

<table border="1">
<caption>Table 55 -- Clock requirements</caption>
<tbody><tr>
<th>Expression</th><th>Return type</th><th>Operational semantics</th>
</tr>

<tr>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>

<tr>
<td><tt>C1::now()</tt></td>
<td><tt>C1::time_point</tt></td>
<td>Returns a <tt>time_point</tt> object representing the current point in time.
</td>
</tr>

<tr>
<td><tt><ins>C1::now(ec)</ins></tt></td>
<td><tt><ins>C1::time_point</ins></tt></td>
<td><ins>Returns a <tt>time_point</tt> object representing the current point in time.</ins>
</td>
</tr>
</tbody></table>
</blockquote>

<p>
Change Class system_clock 20.11.5.1 [time.clock.system] as indicated:
</p>

<blockquote><pre>static time_point now(<ins>error_code&amp; ec=throws()</ins>);
</pre></blockquote>

<p>
Change Class monotonic_clock X [time.clock.monotonic] as indicated:
</p>

<blockquote><pre>static time_point now(<ins>error_code&amp; ec=throws()</ins>);
</pre></blockquote>

<p>
Change Class high_resolution_clock 20.11.5.3 [time.clock.hires] as indicated:
</p>

<blockquote><pre>static time_point now(<ins>error_code&amp; ec=throws()</ins>);
</pre></blockquote>






<hr>
<h3><a name="936"></a>936. Mutex type overspecified</h3>
<p><b>Section:</b> 30.4.1 [thread.mutex.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Future">NAD Future</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2008-12-05 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.mutex.requirements">issues</a> in [thread.mutex.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Future">NAD Future</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#961">961</a></p>
<p><b>Discussion:</b></p>



<p>
30.4.1 [thread.mutex.requirements] describes the requirements for a type to be
a "Mutex type". A Mutex type can be used as the template argument for
the <tt>Lock</tt> type that's passed to <tt>condition_variable_any::wait</tt> (although
<tt>Lock</tt> seems like the wrong name here, since <tt>Lock</tt> is given a different
formal meaning in 30.4.2 [thread.lock]) and, although the WD doesn't quite say
so, as the template argument for <tt>lock_guard</tt> and <tt>unique_lock</tt>.
</p>

<p>
The requirements for a Mutex type include:
</p>

<ul>
<li>
<tt>m.lock()</tt> shall be well-formed and have [described] semantics, including a return type of <tt>void</tt>.
</li>
<li>
<tt>m.try_lock()</tt> shall be well-formed and have [described] semantics, including a return type of <tt>bool</tt>.
</li>
<li>
<tt>m.unlock()</tt> shall be well-formed and have [described] semantics, including a return type of <tt>void</tt>.
</li>
</ul>

<p>
Also, a Mutex type "shall not be copyable nor movable".
</p>

<p>
The latter requirement seems completely irrelevant, and the three
requirements on return types are tighter than they need to be. For
example, there's no reason that <tt>lock_guard</tt> can't be instantiated with a
type that's copyable. The rule is, in fact, that <tt>lock_guard</tt>, etc. won't
try to copy objects of that type. That's a constraint on locks, not on
mutexes. Similarly, the requirements for <tt>void</tt> return types are
unnecessary; the rule is, in fact, that <tt>lock_guard</tt>, etc. won't use any
returned value. And with the return type of <tt>bool</tt>, the requirement should
be that the return type is convertible to <tt>bool</tt>.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
<p>
Move to open. Related to conceptualization and should probably be tackled as part of that.
</p>
<ul>
<li>
The intention is not only to place a constraint on what types such as
<tt>lock_guard</tt> may do with mutex types, but on what any code, including user
code, may do with mutex types. Thus the constraints as they are apply to
the mutex types themselves, not the current users of mutex types in the
standard.
</li>
<li>
This is a low priority issue; the wording as it is may be overly
restrictive but this may not be a real issue.
</li>
</ul>
</blockquote>

<p><i>[
Post Summit Anthony adds:
]</i></p>


<blockquote>
<p>
Section 30.4.1 [thread.mutex.requirements] conflates the
requirements on a generic Mutex type (including user-supplied mutexes)
with the requirements placed on the standard-supplied mutex types in an
attempt to group everything together and save space.
</p>
<p>
When applying concepts to chapter 30, I suggest that the concepts
<tt>Lockable</tt> and <tt>TimedLockable</tt> embody the requirements for
*use* of a mutex type as required by
<tt>unique_lock/lock_guard/condition_variable_any</tt>. These should be
relaxed as Pete describes in the issue. The existing words in 30.4.1 [thread.mutex.requirements] are requirements on all of
<tt>std::mutex</tt>, <tt>std::timed_mutex</tt>,
<tt>std::recursive_mutex</tt> and <tt>std::recursive_timed_mutex</tt>,
and should be rephrased as such.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="937"></a>937. Atomics for standard typedef types</h3>
<p><b>Section:</b> 29 [atomics] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Clark Nelson <b>Opened:</b> 2008-12-05 <b>Last modified:</b> 2010-10-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#atomics">active issues</a> in [atomics].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics">issues</a> in [atomics].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses US 89</b></p>

<blockquote>
<p>
The types in the table "Atomics for standard typedef types" should be
typedefs, not classes. These semantics are necessary for compatibility
with C.
</p>

<p>
Change the classes to typedefs.
</p>
</blockquote>

<p>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2427.html">N2427</a>
specified different requirements for atomic analogs of fundamental
integer types (such as <tt>atomic_int</tt>) and for atomic analogs of <tt>&lt;cstdint&gt;</tt>
typedefs (such as <tt>atomic_size_t</tt>). Specifically, <tt>atomic_int</tt> et al. were
specified to be distinct classes, whereas <tt>atomic_size_t</tt> et al. were
specified to be typedefs. Unfortunately, in applying
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2427.html">N2427</a>
to the WD, that distinction was erased, and the atomic analog of every <tt>&lt;cstdint&gt;</tt>
typedef is required to be a distinct class.
</p>

<p>
It shouldn't be required that the atomic analog of every <tt>&lt;cstdint&gt;</tt>
typedef be a typedef for some fundamental integer type. After all,
<tt>&lt;cstdint&gt;</tt> is supposed to provide standard names for extended integer
types. So there was a problem in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2427.html">N2427</a>,
which certainly could have been
interpreted to require that. But the status quo in the WD is even worse,
because it's unambiguously wrong.
</p>

<p>
What is needed are words to require the existence of a bunch of type
names, without specifying whether they are class names or typedef names.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
<p>
Change status to NAD, editorial. See US 89 comment notes above.
</p>
<p>
Direct the editor to turn the types into typedefs as proposed in the
comment. Paper approved by committee used typedefs, this appears to have
been introduced as an editorial change. Rationale: for compatibility
with C.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="940"></a>940. <tt>std::distance</tt></h3>
<p><b>Section:</b> 24.4.4 [iterator.operations] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Thomas <b>Opened:</b> 2008-12-14 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iterator.operations">issues</a> in [iterator.operations].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 270</b></p>

<p>
Regarding the <tt>std::distance</tt> - function, 24.4.4 [iterator.operations]
/ 4 says:
</p>
<blockquote>
Returns the
number of increments or decrements needed to get from first to last.
</blockquote>
<p>
This sentence is completely silent about the sign of the return value.
24.4.4 [iterator.operations] / 1 gives more information about the
underlying operations, but
again no inferences about the sign can be made.
Strictly speaking, that is taking that sentence literally, I think this
sentence even implies a positive return value in all cases, as the
number of increments or decrements is clearly a ratio scale variable,
with a natural zero bound.
</p>
<p>
Practically speaking, my implementations did what common sense and
knowledge based on pointer arithmetic forecasts, namely a positive sign
for increments (that is, going from <tt>first</tt> to <tt>last</tt> by <tt>operator++</tt>), and a
negative sign for decrements (going from <tt>first</tt> to <tt>last</tt> by <tt>operator--</tt>).
</p>
<p>
Here are my two questions:
</p>
<p>
First, is that paragraph supposed to be interpreted in the way what I
called 'common sense', that is negative sign for decrements ? I am
fairly sure that's the supposed behavior, but a double-check here in
this group can't hurt.
</p>
<p>
Second, is the present wording (2003 standard version - no idea about
the draft for the upcoming standard) worth an edit to make it a bit more
sensible, to mention the sign of the return value explicitly ?
</p>

<p><i>[
Daniel adds:
]</i></p>


<blockquote>
<p>
My first thought was that resolution <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#204">204</a> would already cover the
issue report, but it seems that current normative wording is in
contradiction to that resolution:
</p>

<p>
Referring to
<a href="" ref="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2798.pdf">N2798</a>,
24.4.4 [iterator.operations]/ p.4 says:
</p>

<blockquote>
<i>Effects:</i> Returns the number of increments or decrements needed to get
from <tt>first</tt> to <tt>last</tt>.
</blockquote>

<p>
IMO the part " or decrements" is in contradiction to p. 5 which says
</p>

<blockquote>
<i>Requires:</i> <tt>last</tt> shall be reachable from <tt>first</tt>.
</blockquote>

<p>
because "reachable" is defined in X [iterator.concepts]/7 as
</p>

<blockquote>
An iterator <tt>j</tt> is called reachable from an iterator <tt>i</tt> if and only if
there is a finite
sequence of applications of the expression <tt>++i</tt> that makes <tt>i == j</tt>.[..]
</blockquote>

<p>
Here is wording that would be consistent with this definition of "reachable":
</p>

<p>
Change 24.4.4 [iterator.operations] p4 as follows:
</p>

<blockquote>
<i>Effects:</i> Returns the number of increments <del>or decrements</del>
needed to get from <tt>first</tt> to <tt>last</tt>.
</blockquote>

</blockquote>

<p>
Thomas adds more discussion and an alternative view point
<a href="http://groups.google.com/group/comp.std.c++/browse_thread/thread/e8e46dcda0a5d797#">here</a>.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
The proposed wording below was verbally agreed to.  Howard provided.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Pete reports that a recent similar change has been made
for the <tt>advance()</tt> function.
</p>
<p>
We agree with the proposed resolution.
Move to Tentatively Ready.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Moved from Tentatively Ready to Open only because the wording needs to be
tweaked for concepts removal.
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
Leave Open pending arrival of a post-Concepts WD.
</blockquote>

<p><i>[
2009-10-14 Daniel provided de-conceptified wording.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Move to Ready, replacing the Effects clause in the proposed wording with
"If InputIterator meets the requirements of random access iterator then
returns (last - first), otherwise returns the number of increments
needed to get from first to list.".
</blockquote>

<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote>
Moved to NAD Editorial.  Rationale added below.
</blockquote>



<p><b>Rationale:</b></p>
<p>
Solved by N3066.
</p>


<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
Change 24.2.7 [random.access.iterators], Table 105 as indicated [This change is not
essential but it simplifies the specification] for the row with
expression "<tt>b - a</tt>"
and the column Operational semantics:
</p>

<blockquote><pre><del>(a &lt; b) ? </del>distance(a,b)
<del>: -distance(b,a)</del>
</pre></blockquote>
</li>

<li>
<p>
Change 24.4.4 [iterator.operations]/4+5 as indicated:
</p>

<blockquote><pre>template&lt;class InputIterator&gt;
  typename iterator_traits&lt;InputIterator&gt;::difference_type
    distance(InputIterator first, InputIterator last);
</pre>
<blockquote>
<p>
4 <i>Effects:</i> <ins>If <tt>InputIterator</tt> meets the requirements
of random access iterator then returns <tt>(last - first)</tt>,
otherwise</ins> <del>R</del><ins>r</ins>eturns the number of increments
<del>or decrements</del> needed to get from <tt>first</tt> to
<tt>last</tt>.
</p>

<p>
5 <i>Requires:</i> <ins>If <tt>InputIterator</tt> meets the requirements
of random access iterator then <tt>last</tt> shall be reachable from
<tt>first</tt> or <tt>first</tt> shall be reachable from <tt>last</tt>,
otherwise</ins> <tt>last</tt> shall be reachable from <tt>first</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>









<hr>
<h3><a name="941"></a>941. Ref-qualifiers for assignment operators</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Niels Dekker <b>Opened:</b> 2008-12-18 <b>Last modified:</b> 2010-10-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The assignment and equality operators <tt>=</tt> and <tt>==</tt> are easily confused, just
because of their visual similarity, and in this case a simple typo can cause
a serious bug. When the left side of an <tt>operator=</tt> is an rvalue, it's
highly unlikely that the assignment was intended by the programmer:
</p>
<blockquote><pre>if ( func() = value )  // Typical typo: == intended!
</pre></blockquote>
<p>
Built-in types don't support assignment to an rvalue, but unfortunately,
a lot of types provided by the Standard Library do.
</p>
<p>
Fortunately the language now offers a syntax to prevent a certain member
function from having an rvalue as <tt>*this</tt>: by adding a ref-qualifier (<tt>&amp;</tt>)
to the member function declaration.  Assignment operators are explicitly
mentioned as a use case of ref-qualifiers, in "Extending Move Semantics
To <tt>*this</tt> (Revision 1)",
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1821.htm">N1821</a> by Daveed
Vandevoorde and Bronek Kozicki
</p>
<p>
Hereby I would like to propose adding ref-qualifiers to all appropriate
assignment operators in the library.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to Open.
We recommend this be deferred until after the next Committee Draft.
</blockquote>

<p><i>[
Frankfurt 2009-07:
]</i></p>


<blockquote>
<p>
The LWG declined to move forward with
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2819.html">N2819</a>.
</p>
<p>
Moved to NAD.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
A proposed resolution is provided by the paper on this subject,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2819.html">N2819</a>,
<i>Ref-qualifiers for assignment operators of the Standard Library</i>
</p>





<hr>
<h3><a name="942"></a>942. Atomics synopsis typo</h3>
<p><b>Section:</b> 29 [atomics] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Holger Grund <b>Opened:</b> 2008-12-19 <b>Last modified:</b> 2010-10-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#atomics">active issues</a> in [atomics].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics">issues</a> in [atomics].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#880">880</a></p>
<p><b>Discussion:</b></p>



<p>
I'm looking at 29 [atomics] and can't really make sense of a couple of things.
</p>
<p>
Firstly, there appears to be a typo in the <tt>&lt;cstdatomic&gt;</tt> synopsis:
</p>

<blockquote>
<p>
The <tt>atomic_exchange</tt> overload taking an <tt>atomic_address</tt>
is missing the second parameter:
</p>

<blockquote><pre>void* atomic_exchange(volatile atomic_address*);
</pre></blockquote>

<p>
should be
</p>

<blockquote><pre>void* atomic_exchange(volatile atomic_address*<ins>, void*</ins>);
</pre></blockquote>

<p>
Note, that this is <em>not</em> covered by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#880">880</a> "Missing atomic exchange parameter",
which only talks about the <tt>atomic_bool</tt>.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change the synopsis in 29 [atomics]/2:
</p>

<blockquote><pre>void* atomic_exchange(volatile atomic_address*<ins>, void*</ins>);
</pre></blockquote>






<hr>
<h3><a name="944"></a>944. <tt>atomic&lt;bool&gt;</tt> derive from <tt>atomic_bool</tt>?</h3>
<p><b>Section:</b> 29.5 [atomics.types.generic] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Holger Grund <b>Opened:</b> 2008-12-19 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics.types.generic">issues</a> in [atomics.types.generic].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I think it's fairly obvious that <tt>atomic&lt;bool&gt;</tt> is supposed to be derived
from <tt>atomic_bool</tt> (and otherwise follow the <tt>atomic&lt;integral&gt;</tt> interface),
though I think the current wording doesn't support this. I raised this
point along with <tt>atomic&lt;floating-point&gt;</tt> privately with Herb and I seem
to recall it came up in the resulting discussion on this list. However,
I don't see anything on the current libs issue list mentioning this
problem.
</p>

<p>
29.5 [atomics.types.generic]/3 reads
</p>

<blockquote>
There are full specializations over the integral types on the atomic
class template. For each integral type integral in the second column of
table 121 or table 122, the specialization <tt>atomic&lt;integral&gt;</tt> shall be
publicly derived from the corresponding atomic integral type in the
first column of the table. These specializations shall have trivial
default constructors and trivial destructors.
</blockquote>

<p>
Table 121 does not include (<tt>atomic_bool</tt>, <tt>bool</tt>),
so that this should probably be mentioned explicitly in the quoted paragraph.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Move to open. Lawrence will draft a proposed resolution. Also, ask
Howard to fix the title.
</blockquote>

<p><i>[
Post Summit Anthony provided proposed wording.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2992.html">N2992</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Replace paragraph 3 in 29.5 [atomics.types.generic] with
</p>

<blockquote>
-3- There are full specializations over the integral types on the <tt>atomic</tt>
class template. For each integral type <tt>integral</tt> in the second column of
table 121 or table 122, the specialization <tt>atomic&lt;integral&gt;</tt> shall be
publicly derived from the corresponding atomic integral type in the first
column of the table.
<ins>In addition, the specialization <tt>atomic&lt;bool&gt;</tt>
shall be publicly derived from <tt>atomic_bool</tt>.</ins>
These specializations shall have trivial default
constructors and trivial destructors.
</blockquote>





<hr>
<h3><a name="945"></a>945. <tt>system_clock::rep</tt> not specified</h3>
<p><b>Section:</b> 20.11.5.1 [time.clock.system] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2008-12-19 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#time.clock.system">issues</a> in [time.clock.system].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 20.11.5.1 [time.clock.system], the declaration of <tt>system_clock::rep</tt> says "see
below", but there is nothing below that describes it.
</p>

<p><i>[
Howard adds:
]</i></p>


<blockquote>
<p>
This note refers to:
</p>

<blockquote>
-2- <tt>system_clock::duration::min() &lt; system_clock::duration::zero()</tt> shall be <tt>true</tt>.
</blockquote>

<p>
I.e. this is standardeze for "<tt>system_clock::rep</tt> is signed".
Perhaps an editorial note along the lines of:
</p>

<blockquote>
-2- <tt>system_clock::duration::min() &lt; system_clock::duration::zero()</tt>
shall be <tt>true</tt>. <ins>[<i>Note:</i> <tt>system_clock::rep</tt> shall be signed. <i>-- end note</i>].</ins>
</blockquote>

<p>
?
</p>

</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the direction of the proposed resolution.
Move to NAD Editorial.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add a note to 20.11.5.1 [time.clock.system], p2:
</p>
<blockquote>
-2- <tt>system_clock::duration::min() &lt; system_clock::duration::zero()</tt>
shall be <tt>true</tt>. <ins>[<i>Note:</i> <tt>system_clock::rep</tt> shall be signed. <i>-- end note</i>].</ins>
</blockquote>





<hr>
<h3><a name="946"></a>946. <tt>duration_cast</tt> improperly specified</h3>
<p><b>Section:</b> 20.11.3.7 [time.duration.cast] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2008-12-20 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#time.duration.cast">issues</a> in [time.duration.cast].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
20.11.3.7 [time.duration.cast]/3:

<blockquote>
.... All intermediate computations shall be
carried out in the widest possible representation... .
</blockquote>

<p>
So ignoring
floating-point types for the moment, all this arithmetic has to be done
using the implementation's largest integral type, even if both arguments
use int for their representation. This seems excessive. And it's not at
all clear what this means if we don't ignore floating-point types.
</p>

<p>
This issue is related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#952">952</a>.
</p>

<p><i>[
Howard adds:
]</i></p>


<blockquote>
<p>
The intent of this remark is that intermediate computations are carried out
using:
</p>

<blockquote><pre>common_type&lt;typename ToDuration::rep, Rep, intmax_t&gt;::type
</pre></blockquote>

<p>
The Remark was intended to be clarifying prose supporting the rather algorithmic description
of the previous paragraph.  I'm open to suggestions.  Perhaps the entire paragraph
3 (Remarks) would be better dropped?
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We view this as a specific case of issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#952">952</a>,
and should be resolved when that issue is resolved.
</p>
<p>
Move to NAD.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="952"></a>952. Various threading bugs #2</h3>
<p><b>Section:</b> 20.11.3.7 [time.duration.cast] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#time.duration.cast">issues</a> in [time.duration.cast].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.11.3.7 [time.duration.cast] specifies an implementation and imposes
requirements in text (and the implementation doesn't satisfy all of the
text requirements). Pick one.
</p>

<p>
This issue is related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#946">946</a>.
</p>

<p><i>[
2009-05-10 Howard adds:
]</i></p>


<blockquote>
<p>
The <i>Remarks</i> paragraph is an English re-statement of the preceeding
<i>Returns</i> clause.  It was meant to be clarifying and motivating, not
confusing.  I'm not aware with how the <i>Remarks</i> contradicts the <i>Returns</i> clause
but I'm ok with simply removing the <i>Remarks</i>.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Pete suggests that this could be resolved
by rephrasing the Remarks to Notes.
</p>
<p>
Move to NAD Editorial.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="955"></a>955. Various threading bugs #5</h3>
<p><b>Section:</b> 20.11.1 [time.clock.req] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#time.clock.req">issues</a> in [time.clock.req].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.11.1 [time.clock.req] requires that a clock type have a member
typedef named <tt>time_point</tt> that names an instantiation of the
template <tt>time_point</tt>, and a member named <tt>duration</tt> that
names an instantiation of the template <tt>duration</tt>. This mixing of
levels is confusing. The typedef names should be different from the
template names.
</p>

<p><i>[
Post Summit, Anthony provided proposed wording.
]</i></p>


<p><i>[
2009-05-04 Howard adds:
]</i></p>


<blockquote>
<p>
The reason that the typedef names were given the same name as the class templates
was so that clients would not have to stop and think about whether they were
using the clock's native <tt>time_point</tt> / <tt>duration</tt> or the class
template directly.  In this case, one person's confusion is another person's
encapsulation.  The detail that sometimes one is referring to the clock's
native types, and sometimes one is referring to an independent type is
<em>purposefully</em> "hidden" because it is supposed to be an unimportant
detail.  It can be confusing to have to remember when to type <tt>duration</tt>
and when to type <tt>duration_type</tt>, and there is no need to require the
client to remember something like that.
</p>

<p>
For example, here is code that I once wrote in testing out the usability of
this facility:
</p>

<blockquote><pre>template &lt;class Clock, class Duration&gt;
void do_until(const std::chrono::<b>time_point</b>&lt;Clock, Duration&gt;&amp; t)
{
    typename Clock::<b>time_point now</b> = Clock::now();
    if (t &gt; now)
    {
        typedef typename std::common_type
        &lt;
            Duration,
            typename std::chrono::system_clock::<b>duration</b>
        &gt;::type CD;
        typedef std::chrono::<b>duration</b>&lt;double, std::nano&gt; ID;

        CD d = t - now;
        ID us = duration_cast&lt;ID&gt;(d);
        if (us &lt; d)
            ++us;
        ...
    }
}
</pre></blockquote>

<p>
I see no rationale to require the client to append <tt>_type</tt> to <em>some</em>
of those declarations.  It seems overly burdensome on the author of <tt>do_until</tt>:
</p>

<blockquote><pre>template &lt;class Clock, class Duration&gt;
void do_until(const std::chrono::<b>time_point</b>&lt;Clock, Duration&gt;&amp; t)
{
    typename Clock::<b>time_point<font color="#C80000">_type</font></b> now = Clock::now();
    if (t &gt; now)
    {
        typedef typename std::common_type
        &lt;
            Duration,
            typename std::chrono::system_clock::<b>duration<font color="#C80000">_type</font></b>
        &gt;::type CD;
        typedef std::chrono::<b>duration</b>&lt;double, std::nano&gt; ID;

        CD d = t - now;
        ID us = duration_cast&lt;ID&gt;(d);
        if (us &lt; d)
            ++us;
        ...
    }
}
</pre></blockquote>

<p>
Additionally I'm fairly certain that this suggestion hasn't been implemented.
If it had, it would have been discovered that it is incomplete.  <tt>time_point</tt>
also has a nested type (purposefully) named <tt>duration</tt>.
</p>
<blockquote>
That is, the current proposed wording would put the WP into an inconsistent state.
</blockquote>
<p>
In contrast,
the current WP has been implemented and I've received very favorable feedback
from people using this interface in real-world code.
</p>

</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Bill agrees that distinct names should be used for distinct kinds of entities.
</p>
<p>
Walter would prefer not to suffix type names,
especially for such well-understood terms as "duration".
</p>
<p>
Howard reminds us that the proposed resolution is incomplete, per his comment
in the issue.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[
2009-06-07 Howard adds:
]</i></p>


<blockquote>
<p>
Not meaning to be argumentative, but we have a decade of positive experience
with the precedent of using the same name for the nested type as an external
class representing an identical concept.
</p>

<blockquote><pre>template&lt;class Category, class T, class Distance = ptrdiff_t,
         class Pointer = T*, class Reference = T&amp;&gt;
struct <b>iterator</b>
{
    ...
};

template &lt;BidirectionalIterator Iter&gt;
class <b>reverse_iterator</b>
{
    ...
};

template &lt;ValueType T, Allocator Alloc = allocator&lt;T&gt; &gt;
    requires NothrowDestructible&lt;T&gt;
class list
{
public:
    typedef <i>implementation-defined</i>     <b>iterator</b>;
    ...
    typedef reverse_iterator&lt;iterator&gt; <b>reverse_iterator</b>;
    ...
};
</pre></blockquote>

<p>
I am aware of <em>zero</em> complaints regarding the use of <tt>iterator</tt>
and <tt>reverse_iterator</tt> as nested types of the containers despite these
names also having related meaning at namespace std scope.
</p>

<p>
Would we really be doing programmers a favor by renaming these nested types?
</p>

<blockquote><pre>template &lt;ValueType T, Allocator Alloc = allocator&lt;T&gt; &gt;
    requires NothrowDestructible&lt;T&gt;
class list
{
public:
    typedef <i>implementation-defined</i>     <b>iterator_type</b>;
    ...
    typedef reverse_iterator&lt;iterator&gt; <b>reverse_iterator_type</b>;
    ...
};
</pre></blockquote>

<p>
I submit that such design contributes to needless verbosity which ends up
reducing readability.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Mark as NAD.  No concensus for changing the WP.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 20.11 [time]:
</p>

<blockquote><pre>...
template &lt;class Clock, class Duration = typename Clock::duration<ins>_type</ins>&gt; class time_point;
...
</pre></blockquote>

<p>
Change 20.11.1 [time.clock.req]:
</p>

<blockquote>
<table border="1">
<caption>Table 45 -- Clock requirements</caption>
<tbody><tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
</tr>
<tr>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr>
<td><tt>C1::duration<ins>_type</ins></tt></td>
<td><tt>chrono::duration&lt;C1::rep, C1::period&gt;</tt></td>
<td>The native <tt>duration</tt> type of the clock.</td>
</tr>
<tr>
<td><tt>C1::time_point<ins>_type</ins></tt></td>
<td><tt>chrono::time_point&lt;C1&gt;</tt> or <tt>chrono::time_point&lt;C2, C1::duration<ins>_type</ins>&lt;</tt></td>
<td>The native <tt>time_point</tt> type of the clock.   Different clocks may  share a <tt>time_point<ins>_type</ins></tt>
definition if it is valid to 
compare their <tt>time_point<ins>_type</ins></tt>s by 
comparing their respective 
<tt>duration<ins>_type</ins></tt>s. <tt>C1</tt> and <tt>C2</tt> shall 
refer to the same epoch.</td>
</tr>
<tr>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr>
<td><tt>C1::now()</tt></td>
<td><tt>C1::time_point<ins>_type</ins></tt></td>
<td>Returns a <tt>time_point<ins>_type</ins></tt> object 
representing the current point 
in time.
</td>
</tr>
</tbody></table>
</blockquote>

<p>
Change 20.11.5.1 [time.clock.system]:
</p>

<blockquote>
<p>
-1- Objects of class <tt>system_clock</tt> represent wall clock time from the system-wide realtime clock.
</p>

<blockquote><pre>class system_clock { 
public: 
  typedef <i>see below</i> rep; 
  typedef ratio&lt;<i>unspecified</i>, <i>unspecified</i>&gt; period; 
  typedef chrono::duration&lt;rep, period&gt; duration<ins>_type</ins>; 
  typedef chrono::time_point&lt;system_clock&gt; time_point<ins>_type</ins>; 
  static const bool is_monotonic = <i>unspecified</i> ; 

  static time_point<ins>_type</ins> now(); 

  // Map to C API 
  static time_t to_time_t (const time_point<ins>_type</ins>&amp; t); 
  static time_point<ins>_type</ins> from_time_t(time_t t); 
};
</pre></blockquote>

<p>
-2- <tt>system_clock::duration<ins>_type</ins>::min() &lt; system_clock::duration<ins>_type</ins>::zero()</tt> shall be <tt>true</tt>.
</p>

<pre>time_t to_time_t(const time_point<ins>_type</ins>&amp; t);
</pre>

<blockquote>
-3- <i>Returns:</i> A <tt>time_t</tt> object that represents the same
point in time as <tt>t</tt> when both values are truncated to the
coarser of the precisions of <tt>time_t</tt> and <tt>time_point<ins>_type</ins></tt>.
</blockquote>

<pre><tt>time_point<ins>_type</ins></tt> from_time_t(time_t t);
</pre>

<blockquote>
-4- <i>Returns:</i> A <tt>time_point<ins>_type</ins></tt> object that represents the same point
in time as <tt>t</tt> when both values are truncated to the coarser of the
precisions of <tt>time_t</tt> and <tt>time_point<ins>_type</ins></tt>.
</blockquote>
</blockquote>

<p>
Change X [time.clock.monotonic]:
</p>

<blockquote><pre>class monotonic_clock { 
public: 
  typedef <i>unspecified</i>                                rep; 
  typedef ratio&lt;<i>unspecified</i> , <i>unspecified</i>&gt;           period; 
  typedef chrono::duration&lt;rep, period&gt;              duration<ins>_type</ins>; 
  typedef chrono::time_point&lt;<i>unspecified</i> , duration<ins>_type</ins>&gt; time_point<ins>_type</ins>; 
  static const bool is_monotonic =                   true; 

  static time_point<ins>_type</ins> now();
};
</pre></blockquote>

<p>
Change 20.11.5.3 [time.clock.hires]:
</p>

<blockquote><pre>class high_resolution_clock { 
public: 
  typedef <i>unspecified</i>                                rep; 
  typedef ratio&lt;<i>unspecified</i> , <i>unspecified</i>&gt;           period; 
  typedef chrono::duration&lt;rep, period&gt;              duration<ins>_type</ins>; 
  typedef chrono::time_point&lt;<i>unspecified</i> , duration<ins>_type</ins>&gt; time_point<ins>_type</ins>; 
  static const bool is_monotonic =                   true; 

  static time_point<ins>_type</ins> now();
};
</pre></blockquote>






<hr>
<h3><a name="958"></a>958. Various threading bugs #8</h3>
<p><b>Section:</b> 30.5.1 [thread.condition.condvar] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.condition.condvar">issues</a> in [thread.condition.condvar].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
30.5.1 [thread.condition.condvar]: the specification for <tt>wait_for</tt>
with no predicate has an effects clause that says it calls <tt>wait_until</tt>,
and a returns clause that sets out in words how to determine the return
value. Is this description of the return value subtly different from the
description of the value returned by <tt>wait_until</tt>? Or should the effects
clause and the returns clause be merged?
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Move to open. Associate with LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#859">859</a> and any other monotonic-clock
related issues.
</blockquote>

<p><i>[
2009-08-01 Howard adds:
]</i></p>


<blockquote>
I believe that <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#859">859</a> (currently Ready) addresses this issue, and
that this issue should be marked NAD, solved by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#859">859</a> (assuming
it moves to WP).
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Mark as NAD Editorial, solved by resolution of Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#859">859</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="959"></a>959. Various threading bugs #9</h3>
<p><b>Section:</b> 30.5.1 [thread.condition.condvar] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.condition.condvar">issues</a> in [thread.condition.condvar].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
30.5.1 [thread.condition.condvar]: <tt>condition_variable::wait_for</tt>
is required to compute the absolute time by adding the duration value to
<tt>chrono::monotonic_clock::now()</tt>, but <tt>monotonic_clock</tt> is not required to
exist.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Move to open. Associate with LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#859">859</a> and any other monotonic-clock
related issues.
</blockquote>

<p><i>[
2009-08-01 Howard adds:
]</i></p>


<blockquote>
I believe that <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#859">859</a> (currently Ready) addresses this issue, and
that this issue should be marked NAD, solved by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#859">859</a> (assuming
it moves to WP).
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Leave open, but expect to be fixed by N2969 revision that Detlef is writing.
</blockquote>

<p><i>[
2009-11-18 Moved to Tentatively NAD after 5 positive votes on c++std-lib.
Rationale added below.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
</p>


<p><b>Rationale:</b></p>
<p>
<tt>condition_variable::wait_for</tt> no longer refers to
<tt>monotonic_clock</tt>, so this issue is moot.
</p>





<hr>
<h3><a name="961"></a>961. Various threading bugs #11</h3>
<p><b>Section:</b> 30.4.1 [thread.mutex.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Future">NAD Future</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.mutex.requirements">issues</a> in [thread.mutex.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Future">NAD Future</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#936">936</a></p>
<p><b>Discussion:</b></p>
<p>
30.4.1 [thread.mutex.requirements] describes required member
functions of mutex types, and requires that they throw exceptions under
certain circumstances. This is overspecified. User-defined types can
abort on such errors without affecting the operation of templates
supplied by standard-library.
</p>

<p><i>[
Summit:
]</i></p>

<blockquote>
Move to open. Related to conceptualization and should probably be
tackled as part of that.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
<p>
Would be OK to leave it as is for time constraints, could loosen later.
</p>

<p>
Mark as NAD Future.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="969"></a>969. What happened to Library Issue 475?</h3>
<p><b>Section:</b> 25.2.4 [alg.foreach] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2009-01-12 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.foreach">issues</a> in [alg.foreach].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Library Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#475">475</a> has CD1 status, but the non-normative note in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a>
was removed in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2798.pdf">N2798</a>
(25.2.4 [alg.foreach] in both drafts).
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to NAD Editorial.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Restore the non-normative note. It might need to be expressed in terms of concepts.
</p>





<hr>
<h3><a name="971"></a>971. Spurious diagnostic conversion function</h3>
<p><b>Section:</b> 19.5.2.5 [syserr.errcode.nonmembers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2009-01-19 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Anthony Williams raised the question in c++std-lib-22987 "why is there
<tt>std::make_error_code(std::errc)</tt>? What purpose does this serve?"
</p>
<p>
The function <tt>make_error_code(errc e)</tt> is not required, since
<tt>make_error_condition(errc e)</tt> is the function that is needed for <tt>errc</tt>
conversions. <tt>make_error_code(errc e)</tt> appears to be a holdover from my
initial confusion over the distinction between POSIX and operating
systems that conform to the POSIX spec.
</p>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
Recommend Review.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
The designer of the facility (Christopher Kohlhoff)
strongly disagrees that there is an issue here,
and especially disagrees with the proposed resolution.
Bill would prefer to be conservative and not apply this proposed resolution.
Move to Open, and recommend strong consideration for NAD status.
</blockquote>

<p><i>[
2009-05-21 Beman adds:
]</i></p>


<blockquote>
My mistake. Christopher and Bill are correct and the issue should be
NAD. The function is needed by users.
</blockquote>

<p><i>[
2009-07-21 Christopher Kohlhoff adds rationale for <tt>make_error_code</tt>:
]</i></p>


<blockquote>
<p>
Users (and indeed library implementers) may need to use the
<tt>errc</tt> codes in portable code. For example:
</p>

<blockquote><pre>void do_foo(error_code&amp; ec)
{
#if defined(_WIN32)
  // Windows implementation ...
#elif defined(linux)
  // Linux implementation ...
#else
  // do_foo not supported on this platform
  ec = make_error_code(errc::not_supported);
#endif
}
</pre></blockquote>
</blockquote>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
Moved to NAD.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change System error support 19.5 [syserr], Header <tt>&lt;system_error&gt;</tt>
synopsis, as indicated:
</p>

<blockquote><pre><del>error_code make_error_code(errc e);</del>
error_condition make_error_condition(errc e);
</pre></blockquote>

<p>
Delete from Class error_code non-member functions
19.5.2.5 [syserr.errcode.nonmembers]:
</p>

<blockquote><pre><del>error_code make_error_code(errc e);</del>
</pre>
<blockquote>
<del><i>Returns:</i> <tt>error_code(static_cast&lt;int&gt;(e),
generic_category)</tt>.</del>
</blockquote>
</blockquote>






<hr>
<h3><a name="972"></a>972. The term "Assignable" undefined but still in use</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Niels Dekker <b>Opened:</b> 2009-01-07 <b>Last modified:</b> 2010-10-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Previous versions of the Draft had a table, defining the Assignable 
requirement.  For example 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2134.pdf">N2134</a>
Table 79, "Assignable requirements". But I guess the term "Assignable" 
is outdated by now, because the current Committee Draft provides 
<tt>MoveAssignable</tt>, <tt>CopyAssignable</tt>, and <tt>TriviallyCopyAssignable</tt> concepts 
instead. And as far as I can see, it no longer has a definition of 
<tt>Assignable</tt>. (Please correct me if I'm wrong.) Still the word 
"Assignable" is used in eight places in the Draft, 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2800.pdf">N2800</a>.
</p>

<p>
Are all of those instances of "<tt>Assignable</tt>" to be replaced by "<tt>CopyAssignable</tt>"? 
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to NAD Editorial.
</blockquote>


<p><b>Proposed resolution:</b></p>

<p>
Change Exception Propagation 18.8.5 [propagation]:
</p>
<blockquote>
<tt>exception_ptr</tt> shall be <tt>DefaultConstructible</tt>, <tt>CopyConstructible</tt>,
<tt><ins>Copy</ins>Assignable</tt> and <tt>EqualityComparable</tt>.
</blockquote>

<p>
Change Class template reference_wrapper 20.8.4 [refwrap]:
</p>
<blockquote>
<tt>reference_wrapper&lt;T&gt;</tt> is a <tt>CopyConstructible</tt> and <tt><ins>Copy</ins>Assignable</tt> wrapper around a reference to an object of type <tt>T</tt>.
</blockquote>
<p>
Change Placeholders 20.8.10.1.3 [func.bind.place]:
</p>
<blockquote>
It is implementation defined whether placeholder types are <tt><ins>Copy</ins>Assignable</tt>. <tt><ins>Copy</ins>Assignable</tt> placeholders' copy assignment operators shall not throw exceptions.
</blockquote>
<p>
Change Class template shared_ptr 20.9.10.2 [util.smartptr.shared]:
</p>
<blockquote>
Specializations of <tt>shared_ptr</tt> shall be <tt>CopyConstructible</tt>, <tt><ins>Copy</ins>Assignable</tt>, and <tt>LessThanComparable</tt>...
</blockquote>
<p>
Change Class template weak_ptr 20.9.10.3 [util.smartptr.weak]:
</p>
<blockquote>
Specializations of <tt>weak_ptr</tt> shall be <tt>CopyConstructible</tt>, <tt><ins>Copy</ins>Assignable</tt>, and <tt>LessThanComparable</tt>...
</blockquote>
<p>
Change traits typedefs 21.2.2 [char.traits.typedefs] (note: including deletion of reference to 23.1!):
</p>
<blockquote>
<i>Requires:</i> <tt>state_type</tt> shall meet the requirements of <tt><ins>Copy</ins>Assignable</tt><del> (23.1)</del>, <tt>CopyConstructible</tt> (20.1.8), and <tt>DefaultConstructible</tt> types.
</blockquote>
<p>
Change Class seed_seq 26.5.7.1 [rand.util.seedseq] (note again: including deletion of reference to 23.1!):
</p>
<blockquote>
In addition to the requirements set forth below, instances of
<tt>seed_seq</tt> shall meet the requirements of <tt>CopyConstructible</tt> (20.1.8) and of <tt><ins>Copy</ins>Assignable</tt><del> (23.1)</del>.
</blockquote>

<p>
Note: The proposed resolution of this issue does not deal with the
instance of the term "Assignable" in D.12.1 [auto.ptr], as this is dealt
with more specifically by LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#973">973</a>, "<tt>auto_ptr</tt> characteristics", submitted
by Maarten Hilferink.
</p>






<hr>
<h3><a name="973"></a>973. auto_ptr characteristics</h3>
<p><b>Section:</b> D.12.1 [auto.ptr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Maarten Hilferink <b>Opened:</b> 2009-01-21 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#auto.ptr">issues</a> in [auto.ptr].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I think that the Note of D.12.1 [auto.ptr], paragraph 3 needs a rewrite 
since "Assignable" is no longer defined as a concept. 
The relationship of <tt>auto_ptr</tt> with the new <tt>CopyAssignable</tt>, <tt>MoveAssignable</tt>,
 and <tt>MoveConstructible</tt> concepts should be clarified.
Furthermore, since the use of <tt>auto_ptr</tt> is depreciated anyway,
 we can also omit a description of its intended use.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the intent of the proposed resolution.
Move to NAD Editorial.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change D.12.1 [auto.ptr], paragraph 3:
</p>

<blockquote>
The <tt>auto_ptr</tt> provides a semantics of strict ownership. An
<tt>auto_ptr</tt> owns the ob ject it holds a pointer to. Copying an
<tt>auto_ptr</tt> copies the pointer and transfers ownership to the
destination. If more than one <tt>auto_ptr</tt> owns the same ob ject at
the same time the behavior of the program is undefined. [<i>Note:</i>
The uses of <tt>auto_ptr</tt> include providing temporary
exception-safety for dynamically allocated memory, passing ownership of
dynamically allocated memory to a function, and returning dynamically
allocated memory from a function.
<del><tt>auto_ptr</tt> does not meet the
<tt>CopyConstructible</tt> and <tt>Assignable</tt> requirements for
standard library container elements and thus instantiating a standard
library container with an <tt>auto_ptr</tt> results in undefined
behavior.</del>

<ins>Instances of <tt>auto_ptr</tt> shall
meet the <tt>MoveConstructible</tt> and <tt>MoveAssignable</tt>
requirements, but do not meet the <tt>CopyConstructible</tt> and
<tt>CopyAssignable</tt> requirements.</ins>
-- <i>end note</i>]
</blockquote>





<hr>
<h3><a name="976"></a>976. Class template std::stack should be movable</h3>
<p><b>Section:</b> 23.5.3.1 [stack.defn] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-02-01 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The synopsis given in 23.5.3.1 [stack.defn] does not show up
</p>

<blockquote><pre>requires MoveConstructible&lt;Cont&gt; stack(stack&amp;&amp;);
requires MoveAssignable&lt;Cont&gt; stack&amp; operator=(stack&amp;&amp;);
</pre></blockquote>

<p>
although the other container adaptors do provide corresponding
members.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with the proposed resolution.
</p>
<p>
Move to Tentatively Ready.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Moved from Tentatively Ready to Open only because the wording needs to be
tweaked for concepts removal.
</blockquote>

<p><i>[
2009-08-18 Daniel updates the wording and Howard sets to Review.
]</i></p>


<p><i>[
2009-08-23 Howard adds:
]</i></p>


<blockquote>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1194">1194</a> also adds these move members using an editorially different
style.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Mark NAD Editorial, solved by issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1194">1194</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
In the class stack synopsis of 23.5.3.1 [stack.defn] insert:
</p>

<blockquote><pre>template &lt;class T, class Container = deque&lt;T&gt; &gt;
class stack {
  [..]
  explicit stack(const Container&amp;);
  explicit stack(Container&amp;&amp; = Container());
  <ins>stack(stack&amp;&amp; s) : c(std::move(s.c)) {}</ins>
  <ins>stack&amp; operator=(stack&amp;&amp; s) { c = std::move(s.c); return *this; }</ins>
  [..]
};
</pre></blockquote>








<hr>
<h3><a name="977"></a>977. insert iterators inefficient for expensive to move types</h3>
<p><b>Section:</b> 24.5.2 [insert.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-02-02 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#insert.iterators">issues</a> in [insert.iterators].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The new concepts for the insert iterators mandate an extra copy when
inserting an lvalue:
</p>

<blockquote><pre>requires CopyConstructible&lt;Cont::value_type&gt;
  back_insert_iterator&lt;Cont&gt;&amp; 
  operator=(const Cont::value_type&amp; value);
</pre>
<blockquote>
-1- <i>Effects:</i> <tt>push_back(*container, <b>Cont::value_type(</b>value<b>)</b>);</tt>
</blockquote>
</blockquote>

<p>
The reason is to convert <tt>value</tt> into an rvalue because the current
<tt>BackInsertionContainer</tt> concept only handles <tt>push_back</tt>-ing
rvalues:
</p>

<blockquote><pre>concept BackInsertionContainer&lt;typename C&gt; : Container&lt;C&gt; { 
  void push_back(C&amp;, value_type&amp;&amp;); 
}
</pre></blockquote>

<p>
Without the conversion of <tt>value</tt> to an rvalue, the assignment operator
fails to concept check.
</p>

<p>
A solution is to modify the <tt>BackInsertionContainer</tt> concept so that
the client can pass in the parameter type for <tt>push_back</tt> similar to
what is already done for the <tt>OutputIterator</tt> concept:
</p>

<blockquote><pre>concept BackInsertionContainer&lt;typename C, typename Value = C::value_type&amp;&amp;&gt;
  : Container&lt;C&gt; { 
     void push_back(C&amp;, Value); 
}
</pre></blockquote>

<p>
This allows the assignment operator to be adjusted appropriately:
</p>

<blockquote><pre>requires BackInsertionContainer&lt;Cont, Cont::value_type const&amp;&gt; &amp;&amp;
         CopyConstructible&lt;Cont::value_type&gt;
  back_insert_iterator&lt;Cont&gt;&amp; 
  operator=(const Cont::value_type&amp; value);
</pre>
<blockquote>
-1- <i>Effects:</i> <tt>push_back(*container, value);</tt>
</blockquote>
</blockquote>

<p><i>[
We may want to propagate this fix to other concepts such as <tt>StackLikeContainer</tt>.
]</i></p>


<p><i>[
Solution and wording collaborated on by Doug and Howard.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Howard notes that "these operations behaved efficiently until concepts were added."
</p>
<p>
Alisdair is uncertain that the proposed resolution is syntactically correct.
</p>
<p>
Move to Open, and recommend the issue be deferred until after the next
Committee Draft is issued.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD, solved by the removal of concepts.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change  [container.concepts.free]:
</p>

<blockquote>
<pre>concept FrontInsertionContainer&lt;typename C<ins>, typename Value = C::value_type&amp;&amp;</ins>&gt;
    : Container&lt;C&gt; { 
  void push_front(C&amp;, <del>value_type&amp;&amp;</del> <ins>Value</ins>); 

  axiom FrontInsertion(C c, <del>value_type</del> <ins>Value</ins> x) { 
    x == (push_front(c, x), front(c)); 
  } 
}
</pre>

<p>...</p>

<pre>concept BackInsertionContainer&lt;typename C<ins>, typename Value = C::value_type&amp;&amp;</ins>&gt;
    : Container&lt;C&gt; { 
  void push_back(C&amp;, <del>value_type&amp;&amp;</del> <ins>Value</ins>); 
}
</pre>

<p>...</p>

<pre>concept InsertionContainer&lt;typename C<ins>, typename Value = C::value_type&amp;&amp;</ins>&gt;
    : Container&lt;C&gt; { 
  iterator insert(C&amp;, const_iterator, <del>value_type&amp;&amp;</del> <ins>Value</ins>); 

  axiom Insertion(C c, const_iterator position, <del>value_type</del> <ins>Value</ins> v) { 
    v == *insert(c, position, v); 
  } 
}
</pre>

</blockquote>

<p>
Change  [container.concepts.member]:
</p>

<blockquote>
<pre>auto concept MemberFrontInsertionContainer&lt;typename C<ins>, typename Value = C::value_type&amp;&amp;</ins>&gt;
    : MemberContainer&lt;C&gt; { 
  void C::push_front(<del>value_type&amp;&amp;</del> <ins>Value</ins>); 

  axiom MemberFrontInsertion(C c, <del>value_type</del> <ins>Value</ins> x) { 
    x == (c.push_front(x), c.front()); 
  } 
}
</pre>

<p>...</p>

<pre>auto concept MemberBackInsertionContainer&lt;typename C<ins>, typename Value = C::value_type&amp;&amp;</ins>&gt;
    : MemberContainer&lt;C&gt; { 
  void C::push_back(<del>value_type&amp;&amp;</del> <ins>Value</ins>); 
}
</pre>

<p>...</p>

<pre>auto concept MemberInsertionContainer&lt;typename C<ins>, typename Value = C::value_type&amp;&amp;</ins>&gt;
    : MemberContainer&lt;C&gt; { 
  iterator C::insert(const_iterator, <del>value_type&amp;&amp;</del> <ins>Value</ins>); 

  axiom MemberInsertion(C c, const_iterator position, <del>value_type</del> <ins>Value</ins> v) { 
    v == *c.insert(position, v); 
  } 
}
</pre>
</blockquote>

<p>
Change  [container.concepts.maps]:
</p>

<blockquote>
<pre>template &lt;MemberFrontInsertionContainer C<ins>, typename Value = C::value_type&amp;&amp;</ins>&gt; 
concept_map FrontInsertionContainer&lt;C<ins>, Value</ins>&gt; { 
  typedef Container&lt;C&gt;::value_type value_type;

  void push_front(C&amp; c, <del>value_type&amp;&amp;</del> <ins>Value</ins> v) { c.push_front(static_cast&lt;<del>value_type&amp;&amp;</del> <ins>Value</ins>&gt;(v)); } 
}
</pre>

<p>...</p>

<pre>template &lt;MemberBackInsertionContainer C<ins>, typename Value = C::value_type&amp;&amp;</ins>&gt; 
concept_map BackInsertionContainer&lt;C<ins>, Value</ins>&gt; { 
  typedef Container&lt;C&gt;::value_type value_type;

  void push_back(C&amp; c, <del>value_type&amp;&amp;</del> <ins>Value</ins> v) { c.push_back(static_cast&lt;<del>value_type&amp;&amp;</del> <ins>Value</ins>&gt;(v)); } 
}
</pre>

<p>...</p>

<pre>template &lt;MemberInsertionContainer C<ins>, typename Value = C::value_type&amp;&amp;</ins>&gt; 
concept_map InsertionContainer&lt;C<ins>, Value</ins>&gt; { 
  typedef Container&lt;C&gt;::value_type value_type;
  Container&lt;C&gt;::iterator insert(C&amp; c, Container&lt;C&gt;::const_iterator i, <del>value_type&amp;&amp;</del> <ins>Value</ins> v) 
  { return c.insert(i, static_cast&lt;<del>value_type&amp;&amp;</del> <ins>Value</ins>&gt;(v)); } 
}
</pre>

</blockquote>

<p>
Change 24.5.2.1 [back.insert.iterator]:
</p>

<blockquote><pre>template &lt;BackInsertionContainer Cont&gt; 
class back_insert_iterator {
  ...
  requires <ins>BackInsertionContainer&lt;Cont, const Cont::value_type&amp;&gt;</ins>
           <del>CopyConstructible&lt;Cont::value_type&gt;</del>
    back_insert_iterator&lt;Cont&gt;&amp; 
      operator=(const Cont::value_type&amp; value);
  ...
</pre></blockquote>

<p>
Change 24.5.2.2.2 [back.insert.iter.op=]:
</p>

<blockquote>
<pre>requires <ins>BackInsertionContainer&lt;Cont, const Cont::value_type&amp;&gt;</ins>
         <del>CopyConstructible&lt;Cont::value_type&gt;</del>
  back_insert_iterator&lt;Cont&gt;&amp; 
    operator=(const Cont::value_type&amp; value);
</pre>
<blockquote>
-1- <i>Effects:</i> <tt>push_back(*container, <del>Cont::value_type(</del>value<del>)</del>);</tt>
</blockquote>
</blockquote>

<p>
Change 24.5.2.3 [front.insert.iterator]:
</p>

<blockquote><pre>template &lt;FrontInsertionContainer Cont&gt; 
class front_insert_iterator {
  ...
  requires <ins>FrontInsertionContainer&lt;Cont, const Cont::value_type&amp;&gt;</ins>
           <del>CopyConstructible&lt;Cont::value_type&gt;</del>
    front_insert_iterator&lt;Cont&gt;&amp; 
      operator=(const Cont::value_type&amp; value);
  ...
</pre></blockquote>

<p>
Change 24.5.2.4.2 [front.insert.iter.op=]:
</p>

<blockquote>
<pre>requires <ins>FrontInsertionContainer&lt;Cont, const Cont::value_type&amp;&gt;</ins>
         <del>CopyConstructible&lt;Cont::value_type&gt;</del>
  front_insert_iterator&lt;Cont&gt;&amp; 
    operator=(const Cont::value_type&amp; value);
</pre>
<blockquote>
-1- <i>Effects:</i> <tt>push_front(*container, <del>Cont::value_type(</del>value<del>)</del>);</tt>
</blockquote>
</blockquote>

<p>
Change 24.5.2.5 [insert.iterator]:
</p>

<blockquote><pre>template &lt;InsertionContainer Cont&gt; 
class insert_iterator {
  ...
  requires <ins>InsertionContainer&lt;Cont, const Cont::value_type&amp;&gt;</ins>
           <del>CopyConstructible&lt;Cont::value_type&gt;</del>
    insert_iterator&lt;Cont&gt;&amp; 
      operator=(const Cont::value_type&amp; value);
  ...
</pre></blockquote>

<p>
Change 24.5.2.6.2 [insert.iter.op=]:
</p>

<blockquote>
<pre>requires <ins>InsertionContainer&lt;Cont, const Cont::value_type&amp;&gt;</ins>
         <del>CopyConstructible&lt;Cont::value_type&gt;</del>
  insert_iterator&lt;Cont&gt;&amp; 
    operator=(const Cont::value_type&amp; value);
</pre>
<blockquote>
<p>
-1- <i>Effects:</i>
</p>
<blockquote><pre>iter = insert(*container, iter, <del>Cont::value_type(</del>value<del>)</del>); 
++iter;
</pre></blockquote>
</blockquote>
</blockquote>






<hr>
<h3><a name="979"></a>979. Bad example</h3>
<p><b>Section:</b> 24.5.3 [move.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-02-03 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
24.5.3 [move.iterators] has an incorrect example:
</p>

<blockquote>
<p>
-2- [<i>Example:</i>
</p>

<blockquote><pre>set&lt;string&gt; s; 
// populate the set s 
vector&lt;string&gt; v1(s.begin(), s.end());          // copies strings into v1 
vector&lt;string&gt; v2(make_move_iterator(s.begin()), 
                  make_move_iterator(s.end())); // moves strings into v2
</pre></blockquote>

<p>
<i>-- end example</i>]
</p>
</blockquote>

<p>
One can not move from a <tt>set</tt> because the iterators return <tt>const</tt>
references.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution. Move to NAD Editorial.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 24.5.3 [move.iterators]/2:
</p>

<blockquote>
<p>
-2- [<i>Example:</i>
</p>

<blockquote><pre><del>set</del><ins>list</ins>&lt;string&gt; s; 
// populate the <del>set</del><ins>list</ins> s 
vector&lt;string&gt; v1(s.begin(), s.end());          // copies strings into v1 
vector&lt;string&gt; v2(make_move_iterator(s.begin()), 
                  make_move_iterator(s.end())); // moves strings into v2
</pre></blockquote>

<p>
<i>-- end example</i>]
</p>
</blockquote>





<hr>
<h3><a name="980"></a>980. <tt>mutex lock()</tt> missing error conditions</h3>
<p><b>Section:</b> 30.4.1 [thread.mutex.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Ion Gaztaaga <b>Opened:</b> 2009-02-07 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.mutex.requirements">issues</a> in [thread.mutex.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
POSIX 2008 adds two return values for <tt>pthread_mutex_xxxlock()</tt>:
<tt>EOWNERDEAD</tt> (<tt>owner_dead</tt>) and <tt>ENOTRECOVERABLE</tt>
(<tt>state_not_recoverable</tt>). In the first case the mutex is locked,
in the second case the mutex is not locked.
</p>

<p>
Throwing an exception in the first case can be incompatible with the use
of Locks, since the <tt>Lock::owns_lock()</tt> will be <tt>false</tt> when the lock is
being destroyed.
</p>

<p>
Consider:
</p>

<blockquote><pre>//Suppose mutex.lock() throws "owner_dead"
unique_lock ul(&amp;mutex);
//mutex left locked if "owner_dead" is thrown
</pre></blockquote>

<p>
Throwing an exception with <tt>owner_dead</tt> might be also undesirable if
robust-mutex support is added to C++ and the user has the equivalent of
<tt>pthread_mutex_consistent()</tt> to notify the user has fixed the corrupted
data and the mutex state should be marked consistent.
</p>

<ol>
<li>
For <tt>state_not_recoverable</tt> add it to the list of Error conditions:
</li>
<li>
For <tt>owner_dead</tt>, no proposed resolution.
</li>
</ol>

<p><i>[
Summit:
]</i></p>


<blockquote>
Not a defect. Handling these error conditions is an implementation
detail and must be handled below the C++ interface.
</blockquote>



<p><b>Proposed resolution:</b></p>

<p>
Add to 30.4.1 [thread.mutex.requirements], p12:
</p>

<blockquote>
<p>
-12- <i>Error conditions:</i>
</p>

<ul>
<li>
<tt>operation_not_permitted</tt> -- if the thread does not have the necessary permission to change 
the state of the mutex.
</li>
<li>
<tt>resource_deadlock_would_occur</tt> -- if the current thread already owns the mutex and is able 
to detect it.
</li>
<li>
<tt>device_or_resource_busy</tt> --  if the mutex is already locked and blocking is not possible.
</li>
<li>
<ins><tt>state_not_recoverable</tt> -- if the state protected by the mutex is not recoverable.</ins>
</li>
</ul>
</blockquote>





<hr>
<h3><a name="988"></a>988. <tt>Reflexivity</tt> meaningless?</h3>
<p><b>Section:</b> X [concept.comparison] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-02-24 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#concept.comparison">issues</a> in [concept.comparison].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
X [concept.comparison] p2:
</p>
<p>
Due to the subtle meaning of <tt>==</tt> inside axioms, the <tt>Reflexivity</tt> axiom does
not do anything as written. It merely states that a value is substitutable
with itself, rather than asserting a property of the <tt>==</tt> operator.
</p>

<b>
Original proposed resolution:
</b>

<p>
Change the definition of <tt>Reflexivity</tt> in X [concept.comparison]:
</p>

<blockquote><pre>axiom Reflexivity(T a) { <ins>(</ins>a == a<ins>) == true</ins>; }
</pre></blockquote>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
<p>
Alisdair: I was wrong.
</p>
<p>
Recommend NAD.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
NAD.
</p>





<hr>
<h3><a name="989"></a>989. late_check and library</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-02-24 <b>Last modified:</b> 2010-10-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The example in 6.9p2 shows how late_check blocks inhibit concept_map lookup
inside a constrained context, and so inhibit concept map adaption by users
to meet template requirements.
</p>
<p>
Do we need some text in clause 17 prohibitting use of late_check in library
template definitions unless otherwise documented?
</p>

<p><i>[
Doug adds:
]</i></p>


<blockquote>
We need something like this, but it should be a more general statement
about implementations respecting the concept maps provided by the
user. Use of late_check is one way in which implementations can
subvert the concept maps provided by the user, but there are other
ways as well ("pattern-based" overloading, tricks with "auto" concept
maps and defaulted associated type arguments).
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to Open, pending proposed wording from Alisdair and/or Doug for further review.
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="992"></a>992. Response to UK 169</h3>
<p><b>Section:</b> 17.6.1.1 [contents] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2009-03-03 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#contents">issues</a> in [contents].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses UK 169</b></p>
<p>
This phrasing contradicts later freedom to implement the C standard
library portions in the global namespace as well as std. (17.6.2.3p4)
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
The proposed wording seems to go too far.
Move back to Open.
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
<p>
Howard to add NB reference to the description of this issue.
</p>
<p>
Move to NAD. This comment is informative and not normative by the use of
the word "are" instead of the word "shall."
</p>
<p>
A note linking to Annex D would help clarify the intention, here.
</p>
<p>
Robert to Open a separate issue proposing that the standard C headers be
undeprecated, for the purpose of clarifying the standard.
</p>
</blockquote>

<p><i>[
2009-07-22 Bill modified the proposed wording with a clarifying footnote.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Add a footnote to 17.6.1.1 [contents], p2:
</p>

<blockquote>
<p>
-2- All library entities except macros, <tt>operator new</tt> and <tt>operator
delete</tt> are defined within the namespace <tt>std</tt> or namespaces
nested within namespace <tt>std</tt><ins><sup>*</sup></ins>.
</p>

<p><ins>
<sup>*</sup>The C standard library headers D.7 [depr.c.headers] also define
names within the global namespace, while the C++ headers for
C library facilities 17.6.1.2 [headers] may also define names within
the global namespace.
</ins></p>
</blockquote>






<hr>
<h3><a name="995"></a>995. Operational Semantics Unclear</h3>
<p><b>Section:</b> 17.5.1.3 [structure.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> David Abrahams <b>Opened:</b> 2009-03-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
As a practical matter there's disagreement on the meaning of <i>operational
semantics</i>.  If the text in 17.5.1.3 [structure.requirements]p4 isn't
clear, it should be clarified.  However, it's not clear whether the
disagreement is merely due to people not being aware of the text.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Agree with the recommended NAD resolution.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Recommend NAD.  The text in 17.5.1.3 [structure.requirements] is
perfectly clear.
</p>





<hr>
<h3><a name="996"></a>996. Move operation not well specified</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> David Abrahams <b>Opened:</b> 2009-03-06 <b>Last modified:</b> 2010-10-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There are lots of places in the standard where we talk about "the move
constructor" but where we mean "the move operation," i.e.  <tt>T( move( x ) )</tt>.
</p>
<p>
We also don't account for whether that operation modifies <tt>x</tt> or not, and
we need to.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to Open, pending proposed wording from Dave for further
review.
</blockquote>



<p><i>[
2010 Rapperswil:
]</i></p>


<blockquote>
Move to NAD.  We define what we expect from a moved-from object in Table 34 [movesconstructible].
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="1000"></a>1000. adjacent_find is over-constrained</h3>
<p><b>Section:</b> 25.2.8 [alg.adjacent.find] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Chris Jefferson <b>Opened:</b> 2009-03-09 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.adjacent.find">issues</a> in [alg.adjacent.find].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<b>Addresses UK 296</b>
</p>

<p>
<tt>adjacent_find</tt> in C++03 allows an arbitrary predicate, but in C++0x
<tt>EqualityComparable/EquivalenceRelation</tt> is required. This forbids a
number of use cases, including:
</p>
<blockquote>
<table>
<tbody><tr>
<td valign="top">
<tt>adjacent_find(begin,&nbsp;end,&nbsp;less&lt;double&gt;)</tt>
</td>
<td>
Find the first
place where a range is not ordered in decreasing order - in use to check
for sorted ranges.
</td>
</tr>
<tr>
<td valign="top">
<tt>adjacent_find(begin,&nbsp;end,&nbsp;DistanceBiggerThan(6)&nbsp;)&nbsp;)</tt>
</td>
<td>
Find the first
place in a range where values differ by more than a given value - in use
to check an algorithm which produces points in space does not generate
points too far apart.
</td>
</tr>
</tbody></table>
</blockquote>

<p>
A number of books use predicate which are not equivalence relations in
examples, including "Thinking in C++" and "C++ Primer".
</p>

<p>
Adding the requirement that the predicate is an <tt>EquivalenceRelation</tt>
does not appear to open up any possibility for a more optimised algorithm.
</p>



<p><b>Proposed resolution:</b></p>
<p>
Change the definition of adjacent_find in the synopsis of 25 [algorithms]
and 25.2.8 [alg.adjacent.find] to:
</p>

<blockquote><pre>template&lt;ForwardIterator Iter&gt; 
  requires <del>EqualityComparable</del><ins>HasEqualTo</ins>&lt;Iter::value_type<ins>, Iter::value_type</ins>&gt;
  Iter adjacent_find(Iter first, Iter last);

template&lt;ForwardIterator Iter, <del>EquivalenceRelation</del><ins>Predicate</ins>&lt;auto, Iter::value_type<ins>, Iter::value_type</ins>&gt; Pred&gt; 
  requires CopyConstructible&lt;Pred&gt; 
  Iter adjacent_find(Iter first, Iter last, Pred pred);
</pre></blockquote>





<hr>
<h3><a name="1001"></a>1001. Pointers, concepts and headers</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-10 <b>Last modified:</b> 2010-10-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 78</b></p>

<p>
Related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1063">1063</a>.
</p>

<p>
This is effectively an extension of LWG issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#343">343</a>.
</p>
<p>
We know there is an increasing trend (encouraged by conformance testers and
some users) that each library header should supply no more than required to
satisfy the synopsis in the standard.  This is typically achieved by
breaking larger headers into smaller subsets, and judicious use of forward
declarations.
</p>
<p>
If we apply this policy to C++0x (per
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2800.pdf">N2800</a>)
it will be very surprising for
people using library algorithms over ranges defined by pointers that they
must <tt>#include &lt;iterator_concepts&gt;</tt> for their code to compile again.  That is
because pointers do not satisfy any of the iterator concepts without the
<tt>concept_map</tt> supplied in this header.
</p>
<p>
Therefore, I suggest we should require all library headers that make use of
iterator concepts are specifically required to <tt>#include &lt;iterator_concepts&gt;</tt>.
</p>
<p>
At a minimum, the list of headers would be: (assuming all are constrained by
concepts)
</p>
<blockquote><pre>algorithm
array
deque
forward_list
initializer_list
iterator
locale
list
map
memory          // if <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1029">1029</a> is adopted
memory_concepts
numeric
random
regex
set
string
tuple
unordered_map
unordered_set
utility
vector
</pre></blockquote>

<p><i>[
Ganesh adds:
]</i></p>


<blockquote>
<p>
The same problems exists for <tt>&lt;memory_concepts&gt;</tt> and
<tt>&lt;container_concepts&gt;</tt>.
</p>
<p>
In order to compile <tt>&lt;vector&gt;</tt> you just need the
definitions of the concepts in <tt>&lt;memory_concepts&gt;</tt>, the
concept maps defined there are not necessary. Yet, from the user point
of view, if the concept map template for <tt>AllocatableElement</tt> are
not in scope, <tt>&lt;vector&gt;</tt> is pretty useless. Same for
<tt>&lt;tuple&gt;</tt> and <tt>ConstructibleWithAllocator</tt>.
</p>
<p>
Similarly, <tt>&lt;queue&gt;</tt> is not very useful if the concept map
template for <tt>QueueLikeContainer</tt> is not in scope, although the
definition of concept alone is theoretically sufficient.
</p>
<p>
There's a pattern here: if a concept has concept maps "attached", they
should never be separated.
</p>
</blockquote>

<p><i>[
Beman provided the proposed resolution for the May 2009 mailing. He 
comments:
]</i></p>


<blockquote>

<p>Initially I tried to specify exactly what header should include what other 
headers. This was verbose, error prone, hard to maintain, and appeared to add 
little value compared to just stating the general rule.</p>

</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Pete believes the proposed wording overconstrains implementers.
Instead of specifying the mechanism,
he prefers a solution that spells out what needs to be declared,
rather than how those declarations are to be provided,
e.g.,
</p>
<blockquote>
A C++ header shall provide the names
that are required to be defined in that header.
</blockquote>
<p>
Bill suggests approaching the wording from a programmer's perspective.
We may want to consider promising that certain widely-used headers
(e.g., the concept headers) are included when needed by other headers.
He feels, however, there is nothing broken now,
although we may want to consider "something nicer."
</p>
<p>
Move to Open status.
</p>

</blockquote>

<p><i>[
2009-06-16 Beman updated the proposed resolution:
]</i></p>


<blockquote>
  <ul>
    <li>The mechanism is no longer specified, as requested in Batavia.</li>
    <li>The footnote has been removed since it specified mechanism and also did 
    not reflect existing practice.</li>
    <li>A sentence was added that makes it clear that the existing practice is 
    permitted.</li>
  </ul>
</blockquote>

<p><i>[
2009-07-15 Beman updated the proposed resolution:
]</i></p>


<p><i>[
2009-07-17 Beman updated the proposed resolution based on feedback from the LWG in Frankfurt:
]</i></p>


<blockquote>
<ul>
<li>Strike two pieces of text considered unnecessary.</li>
<li>Change "definitions" to "declarations and definitions" in two places.</li>
<li>Wording tightened slightly.</li>
</ul>
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
<p>
Revised Proposed Resolution:
</p>
<p>
A C++ header may include other C++ headers. A C++ header shall provide
the declarations and definitions that appear in its synopsis (3.2
[basic.def.odr]). A C++ header shown in its synopsis as including other
C++ headers shall provide the declarations and definitions that appear
in the synopses of those other headers.
</p>
<p>
Alisdair: Does this address the BSI comment?
</p>
<p>
Beman: There were several overlapping comments. I tried to handle them
all with one resolution.
</p>
<p>
Alisdair: I'd prefer to see this closed as NAD and have this resolution
be the subject of some other, new issue.
</p>
<p>
Move to NAD Concepts. Howard to open a new issue (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1178">1178</a>) in Ready state with the
Proposed Resolution above. Beman will write up a discussion for the new
issue.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p><i>Change 17.6.4.2 [res.on.headers], Headers, paragraph 1, as indicated:</i></p>

<blockquote>

<p>
A C++ header may include other C++
headers.<del><sup>[footnote]</sup></del> <ins>A C++ header shall provide
the declarations and definitions that appear in its synopsis
(3.2 [basic.def.odr]). A C++ header shown in its synopsis as including 
other C++ headers shall provide the same declarations and definitions as
if those other headers were included.</ins>
</p>

  <p><del><sup>[footnote]</sup> C++ headers must include a C++ header that contains 
  any needed definition (3.2).</del></p>
</blockquote>






<hr>
<h3><a name="1002"></a>1002. Response to UK 170</h3>
<p><b>Section:</b> 17.6.1.2 [headers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#headers">issues</a> in [headers].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 170</b></p>

<p>
One of goals of C++0x is to make language easier to teach and for
'incidental' programmers. The fine-grained headers of the C++ library
are valuable in large scale systems for managing dependencies and
optimising build times, but overcomplicated for simple development and
tutorials. Add additional headers to support the whole library through a
single include statement.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We do not all agree that this is an issue,
but we agree that if it needs solving this is the right way to do it.
Move to Tentatively Ready.
</blockquote>

<p><i>[
2009-07-06 Beman notes:
]</i></p>


<blockquote>
<p>
This issue
adds a header <tt>&lt;std&gt;</tt>.
</p>
<p>
There is a paper to be looked at,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2905.pdf">N2905</a>
Aggregation headers, that adds
a header <tt>&lt;std-all&gt;</tt> that is the same thing except it excludes
deprecated headers.
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2905.pdf">N2905</a>
also proposes a second aggregation header.
</p>
<p>
Seems like this issue should be held in abeyance until the LWG has had
a chance to look at <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2905.pdf">N2905</a>.
</p>
</blockquote>

<p><i>[
2009-07-06 Howard:  I've pulled this issue back to Review.
]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
No consensus for change.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Insert a new paragraph in 17.6.1.2 [headers] between p4 and p5
</p>
<blockquote>
An additional header <tt>&lt;std&gt;</tt> shall have the effect of
supplying the entire standard library.  [<i>Note:</i> for example, it
might be implemented as a file with an <tt>#include</tt> statement for each of the
headers listed in tables 13 and 14. <i>-- end note</i>]
</blockquote>





<hr>
<h3><a name="1003"></a>1003. Response to JP 23</h3>
<p><b>Section:</b> 17.6.1.3 [compliance] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#compliance">issues</a> in [compliance].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses JP 23</b></p>

<p>
There is a freestanding implementation including
<tt>&lt;type_traits&gt;</tt>, <tt>&lt;array&gt;</tt>,
<tt>&lt;ratio&gt;</tt>, lately added to Table 13, C++ library headers.
Programmers think them useful and hope that these headers are also added
to Table 15, C++ headers for freestanding implementations, that shows
the set of headers which a freestanding implementation shall include at
least.
</p>

<p><b>Original proposed resolution</b></p>

<p>
Add <tt>&lt;type_traits&gt;</tt>, <tt>&lt;array&gt;</tt>,
<tt>&lt;ratio&gt;</tt> to Table 15.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
<p>
 The <tt>&lt;array&gt;</tt> header has far too many dependencies to require for a
free-standing implementation.
</p>
<p>
The <tt>&lt;ratio&gt;</tt> header would be useful, has no dependencies, but is not
strictly necessary.
</p>
<p>
The <tt>&lt;type_traits&gt;</tt> header is fundamentally a core language facility with a
library interface, so should be supported.
</p>

<p>
(it is anticipated the resolution will come via an update to paper
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2814.pdf">N2814</a>)
(see also LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#833">833</a>)
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Leave in Review status pending a paper on freestanding implementations
by Martin Tasker.
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
<p>
Move this to NAD.
</p>
<p>
We considered all of the listed headers, and found a compelling case
only for the inclusion of <tt>&lt;type_traits&gt;</tt> in the list of headers required
of a freestanding implementation.
</p>
<p>
See Martin Tasker's paper 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2932.pdf">Fixing Freestanding</a>
which provides the wording to include <tt>&lt;type_traits&gt;</tt> into freestanding
implementations.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add <tt>&lt;type_traits&gt;</tt> to Table 15.
</p>






<hr>
<h3><a name="1005"></a>1005. <tt>numeric_limits</tt> partial specializations not concept enabled</h3>
<p><b>Section:</b> 18.3.1.1 [numeric.limits] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses JP 26</b></p>

<p>
<tt>numeric_limits</tt> [partial specializations] does not use concept.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Alisdair will provide a soltion as part of treatment of axioms and LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#902">902</a>.
</blockquote>

<p><i>[
Post Summit:
]</i></p>


<blockquote>
Alisdair recommends NAD as the partial specializations are already
constrained by requirements on the primary template.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
The Working Draft does not in general repeat a primary template's constraints
in any specializations.
Move to NAD.
</blockquote>

<p><i>[
2009-05-25 Howard adds:
]</i></p>


<blockquote>
A c++std-lib thread starting at c++std-lib-23880 has cast doubt that NAD is the
correct resolution of this issue.  Indeed the discussion also casts doubt that
the current proposed wording is the correct resolution as well.  Personally I'm
inclined to reset the status to Open.  However I'm reverting the status to 
that which it had prior to the Batavia recommendation.  I'm setting back to Review.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 18.3.1.1 [numeric.limits]:
</p>

<blockquote><pre>template&lt;<del>class</del> <ins>Regular</ins> T&gt; class numeric_limits&lt;const T&gt;;
template&lt;<del>class</del> <ins>Regular</ins> T&gt; class numeric_limits&lt;volatile T&gt;;
template&lt;<del>class</del> <ins>Regular</ins> T&gt; class numeric_limits&lt;const volatile T&gt;;
</pre></blockquote>






<hr>
<h3><a name="1007"></a>1007. <tt>throw_with_nested</tt> not concept enabled</h3>
<p><b>Section:</b> 18.8.6 [except.nested] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#except.nested">issues</a> in [except.nested].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses JP 29</b></p>

<p>
<tt>throw_with_nested</tt> does not use concept.
</p>

<p><i>[
Summit:
]</i></p>

 
<blockquote>
Agreed.
</blockquote>



<p><b>Proposed resolution:</b></p>

<p>
Alisdair initially proposed wording in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2619.pdf">N2619</a>.
</p>
<p>
We are awaiting an updated paper based on feedback from the San Francisco
review.
</p>





<hr>
<h3><a name="1008"></a>1008. <tt>nested_exception</tt> wording unclear</h3>
<p><b>Section:</b> 18.8.6 [except.nested] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#except.nested">issues</a> in [except.nested].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses JP 31</b></p>

<p>
It is difficult to understand in which case <tt>nested_exception</tt> is applied.
</p>

<p><i>[
Summit:
]</i></p>

 
<blockquote>
Alisdair will add an example in an update to
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2619.pdf">N2619</a>.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
It doesn't appear that N2619 really addresses this. Alisdair to propose wording.
</blockquote>

<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote>
Mark issue 1008 as NAD, the type is adequately described.
</blockquote>



<p><b>Rationale:</b></p>
<p>
nested_exception is intended to be inherited from by exception classes
that are to be thrown during the handling of another exception, i.e.
when translating from one exception type to another. nested_exception
allows the originally thrown exception to be easily retained in that
scenario.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1009"></a>1009. <tt>InputIterator</tt> post-increment dangerous</h3>
<p><b>Section:</b> 24.2.2 [iterator.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 251</b></p>

<p>
The post-increment operator is dangerous for a general InputIterator.
The multi-pass guarantees that make it meaningful are defined as part of
the ForwardIterator refinement. Any change will affect only constrained
templates that have not yet been written, so should not break existing
user iterators which remain free to add these operations. This change
will also affect the generalised OutputIterator, although there is no
percieved need for the post-increment operator in this case either.
</p>

<p><i>[
2009-07-28 Alisdair adds:
]</i></p>


<blockquote>
We still think the issue is relevant, but needs totally rewording in
non-concept language.  We would like to see the issue retained as Open,
rather than deferred as NAD Concepts.  Review status is no longer
appropriate.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD.  Without concepts we do not feel that input iterator post increment
is broken.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 24.2.2 [iterator.iterators]:
</p>

<blockquote><pre>concept Iterator&lt;typename X&gt; : Semiregular&lt;X&gt; { 
  MoveConstructible reference = typename X::reference; 
  <del>MoveConstructible postincrement_result;</del>

  <del>requires HasDereference&lt;postincrement_result&gt;;</del>

  reference operator*(X&amp;&amp;); 
  X&amp; operator++(X&amp;); 
  <del>postincrement_result operator++(X&amp;, int);</del>
}
</pre>

<p>...</p>
<pre><del>postincrement_result operator++(X&amp; r, int);</del>
</pre>

<blockquote>
<del>-3- <i>Effects:</i> equivalent to <tt>{ X tmp = r; ++r; return tmp; }</tt>.</del>
</blockquote>

</blockquote>

<p>
Change 24.2.3 [input.iterators]:
</p>

<blockquote>
<pre>concept InputIterator&lt;typename X&gt; : Iterator&lt;X&gt;, EqualityComparable&lt;X&gt; { 
  ObjectType value_type = typename X::value_type; 
  MoveConstructible pointer = typename X::pointer; 

  SignedIntegralLike difference_type = typename X::difference_type; 

  requires IntegralType&lt;difference_type&gt; 
        &amp;&amp; Convertible&lt;reference, const value_type &amp;&gt;; 
        &amp;&amp; Convertible&lt;pointer, const value_type*&gt;; 

  <del>requires Convertible&lt;HasDereference&lt;postincrement_result&gt;::result_type, const value_type&amp;&gt;;</del>

  pointer operator-&gt;(const X&amp;); 
}
</pre>
</blockquote>

<p>
Change 24.2.4 [output.iterators]:
</p>

<blockquote>
<pre>auto concept OutputIterator&lt;typename X, typename Value&gt; { 
  requires Iterator&lt;X&gt;; 

  typename reference = Iterator&lt;X&gt;::reference; 
  <del>typename postincrement_result = Iterator&lt;X&gt;::postincrement_result;</del>
  requires SameType&lt;reference, Iterator&lt;X&gt;::reference&gt; 
        <del>&amp;&amp; SameType&lt;postincrement_result, Iterator&lt;X&gt;::postincrement_result&gt;</del>
        <del>&amp;&amp; Convertible&lt;postincrement_result, const X&amp;&gt;</del>
        &amp;&amp; HasAssign&lt;reference, Value&gt; 
        <del>&amp;&amp; HasAssign&lt;HasDereference&lt;postincrement_result&gt;::result_type, Value&gt;</del>;
}
</pre>
</blockquote>

<p>
Change 24.2.5 [forward.iterators]:
</p>

<p><i>[
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1084">1084</a> which is attempting to change this same area in a compatible
way.
]</i></p>


<blockquote>
<pre>concept ForwardIterator&lt;typename X&gt; : InputIterator&lt;X&gt;, Regular&lt;X&gt; { 
  <del>requires Convertible&lt;postincrement_result, const X&amp;&gt;;</del>

  <ins>MoveConstructible postincrement_result;</ins>
  <ins>requires HasDereference&lt;postincrement_result&gt;
        &amp;&amp; Convertible&lt;HasDereference&lt;postincrement_result&gt;::result_type, const value_type&amp;&gt;;</ins>

  <ins>postincrement_result operator++(X&amp;, int);</ins>

  axiom MultiPass(X a, X b) { 
    if (a == b) *a == *b; 
    if (a == b) ++a == ++b; 
  } 
}
</pre>

<blockquote>
<p>-4- ...</p>
</blockquote>

<pre><ins>postincrement_result operator++(X&amp; r, int);</ins>
</pre>

<blockquote>
<p>
<ins>-5- <i>Effects:</i> equivalent to <tt>{ X tmp = r; ++r; return tmp; }</tt>.</ins>
</p>
</blockquote>

</blockquote>






<hr>
<h3><a name="1010"></a>1010. <tt>operator-=</tt> should use default in concept</h3>
<p><b>Section:</b> 24.2.7 [random.access.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#random.access.iterators">issues</a> in [random.access.iterators].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 263</b></p>

<p>
This requirement on <tt>operator-=</tt> would be better expressed as a default
implementation in the concept, with a matching axiom.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
The proposed resolution should also remove
paragraph 5 and the declaration that precedes it.
Further, we should provide an axiom
that captures the desired semantics.
This may be a broader policy to be applied.
Move to Open.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 24.2.7 [random.access.iterators]:
</p>

<blockquote><pre>concept RandomAccessIterator&lt;typename X&gt; : BidirectionalIterator&lt;X&gt;, LessThanComparable&lt;X&gt; {
  ...
  X&amp; operator-=(X&amp; <ins>x</ins>, difference_type <ins>n</ins>)<ins> { return x += -n</ins>;<ins> }</ins>
  ...
}
</pre></blockquote>






<hr>
<h3><a name="1013"></a>1013. Response to UK 305</h3>
<p><b>Section:</b> 25.4.7 [alg.min.max] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.min.max">issues</a> in [alg.min.max].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 305</b></p>

<p>
The negative requirement on <tt>IsSameType</tt> is a hold-over from an earlier
draught with a variadic template form of <tt>min/max</tt> algorith. It is no
longer necessary.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
We believe this is NAD, but this needs to be reviewed against the
post-remove-concepts draft.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 25 [algorithms]:
</p>

<blockquote><pre>template&lt;class T, StrictWeakOrder&lt;auto, T&gt; Compare&gt;
  <del>requires !SameType&lt;T, Compare&gt; &amp;&amp; CopyConstructible&lt;Compare&gt;</del>
  const T&amp; min(const T&amp; a, const T&amp; b, Compare comp);
...
template&lt;class T, StrictWeakOrder&lt;auto, T&gt; Compare&gt;
  <del>requires !SameType&lt;T, Compare&gt; &amp;&amp; CopyConstructible&lt;Compare&gt;</del>
  const T&amp; max(const T&amp; a, const T&amp; b, Compare comp);
...
template&lt;class T, StrictWeakOrder&lt;auto, T&gt; Compare&gt;
  <del>requires !SameType&lt;T, Compare&gt; &amp;&amp; CopyConstructible&lt;Compare&gt;</del>
  pair&lt;const T&amp;, const T&amp;&gt; minmax(const T&amp; a, const T&amp; b, Compare comp);
</pre></blockquote>

<p>
Change 25.4.7 [alg.min.max], p1, p9 and p17:
</p>

<blockquote><pre>template&lt;class T, StrictWeakOrder&lt;auto, T&gt; Compare&gt;
  <del>requires !SameType&lt;T, Compare&gt; &amp;&amp; CopyConstructible&lt;Compare&gt;</del>
  const T&amp; min(const T&amp; a, const T&amp; b, Compare comp);
...
template&lt;class T, StrictWeakOrder&lt;auto, T&gt; Compare&gt;
  <del>requires !SameType&lt;T, Compare&gt; &amp;&amp; CopyConstructible&lt;Compare&gt;</del>
  const T&amp; max(const T&amp; a, const T&amp; b, Compare comp);
...
template&lt;class T, StrictWeakOrder&lt;auto, T&gt; Compare&gt;
  <del>requires !SameType&lt;T, Compare&gt; &amp;&amp; CopyConstructible&lt;Compare&gt;</del>
  pair&lt;const T&amp;, const T&amp;&gt; minmax(const T&amp; a, const T&amp; b, Compare comp);
</pre></blockquote>






<hr>
<h3><a name="1015"></a>1015. Response to UK 199</h3>
<p><b>Section:</b> X [concept.transform] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#concept.transform">issues</a> in [concept.transform].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 199</b></p>

<p>
The requirement that programs do not supply <tt>concept_maps</tt> should
probably be users do not supply their own <tt>concept_map</tt>
specializations. The program will almost certainly supply
<tt>concept_maps</tt> - the standard itself supplies a specialization
for <tt>RvalueOf</tt> references. Note that the term <i>program</i> is
defined in 3.5 [basic.link]p1 and makes no account of the
standard library being treated differently to user written code.
</p>

<p><i>[
2009-05-09 Alisdair adds:
]</i></p>


<blockquote>
<p>
The same problem is present in the words added for the
<tt>LvalueReference/RvalueReference</tt> concepts last meeting.
</p>
<p>
With three subsections requiring the same constraint, I'm wondering if there
is a better way to organise this section.
Possible 20.2.1 -&gt; 20.2.3 belong in the fundamental concepts clause in
 [concept.support]?  While they can be implemented purely as a
library feature without additional compiler support, they are pretty
fundamental and we want the same restriction on user-concept maps as is
mandated there.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the issue,
but believe the wording needs further improvement.
We want to investigate current definitions for nomenclature such as
"user" and "program."
Move to Open pending the recommended investigation.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change X [concept.transform] p2:
</p>

<blockquote>
-2- A <del>program</del> <ins>user</ins> shall not provide concept maps for
any concept in 20.1.1.
</blockquote>

<p>
Change  [concept.true] p2:
</p>

<blockquote>
-2- <i>Requires:</i> a <del>program</del> <ins>user</ins> shall not
provide a concept map for the <tt>True</tt> concept.
</blockquote>

<p>
Change  [concept.classify] p2:
</p>

<blockquote>
-2- <i>Requires:</i> a <del>program</del><ins>user</ins> shall not provide concept
maps for any concept in this section.
</blockquote>






<hr>
<h3><a name="1016"></a>1016. Response to JP 33</h3>
<p><b>Section:</b> X [concept.comparison] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#concept.comparison">issues</a> in [concept.comparison].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses JP 33</b></p>

<p>
<tt>LessThanComparable</tt> and <tt>EqualityComparable</tt> don't correspond to NaN. 
</p>

<p><b>Original proposed resolution:</b></p>

<p>
Apply <tt>concept_map</tt> to these concepts at <tt>FloatingPointType</tt>.
</p>

<p><i>[
Post Summit, Alisdair adds:
]</i></p>


<blockquote>
<p>
I don't understand the proposed resolution - there is no such thing as a
'negative' concept_map, and these concepts are auto concepts that match
float/double etc. Also not clear how we are supposed to match values to
concepts.
</p>
<p>
Recommend NAD and treat as a subset of issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#902">902</a>.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Recommend NAD.
</p>





<hr>
<h3><a name="1017"></a>1017. Response to US 66</h3>
<p><b>Section:</b> X [concept.regular] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses US 66</b></p>

<p>
Application of the <tt>Regular</tt> concept to floating-point types appears to be
controversial (see long discussion on std-lib reflector). 
</p>

<p><b>Original proposed resolution:</b></p>

<p>
State that the <tt>Regular</tt> concept does not apply to floating-point types. 
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
<p>
Recommend that we handle the same as JP 33 / <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1016">1016</a>.
</p>
</blockquote>

<p><i>[
Post Summit, Alisdair adds:
]</i></p>


<blockquote>
<p>
Recommend Open, and review after resolution of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#902">902</a> and revised axiom
feature.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1018"></a>1018. Response to US 70</h3>
<p><b>Section:</b> 20.7 [meta] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta">issues</a> in [meta].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses US 70</b></p>

<p>
Specifications now expressed via narrative text are more accurately and
clearly expressed via executable code.
</p>
<p>
Wherever concepts are available that directly match this section's type
traits, express the traits in terms of the concepts instead of via
narrative text. Where the type traits do not quite match the
corresponding concepts, bring the two into alignment so as to avoid two
nearly-identical notions.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
<p>
We think that this is a good idea, but it requires a lot of work. If someone
submits a paper proposing specific changes, we would be happy to review it
at the next meeting.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1020"></a>1020. Response to UK 204</h3>
<p><b>Section:</b> 20.7.7.6 [meta.trans.other] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta.trans.other">issues</a> in [meta.trans.other].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 204</b></p>

<p>
It is not possible to create a variant union based on a parameter pack
expansion, e.g. to implement a classic discriminated union template. 
</p>

<p><b>Original proposed resolutuion:</b></p>

<p>
Restore <tt>aligned_union</tt> template that was removed by LWG issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#856">856</a>. 
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Agree. The need for <tt>aligned_union</tt> is compelling enough to reinstate.
</blockquote>

<p><i>[
Post Summit, Alisdair adds:
]</i></p>


<blockquote>
paper
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2843.html">N2843</a>
proposes an extension to the <tt>[[align]]</tt> attribute
that further diminishes the need for this template.  Recommend NAD.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Mark NAD as suggested.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1022"></a>1022. Response to UK 212</h3>
<p><b>Section:</b> 20.9.11 [util.dynamic.safety] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#util.dynamic.safety">issues</a> in [util.dynamic.safety].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 212</b></p>

<p>
The pointer-safety API is nothing to do with smart pointers, so does not
belong in 20.9.10 [util.smartptr]. In fact it is a set of language
support features are really belongs in clause 18 [language.support], with the contents declared in a header that
deals with language-support of memory management.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Agree in principle, but not with the proposed resolution. We believe it
belongs either a subsection of either 20 [utilities] or 20.9 [memory] as part of the general reorganization of 20 [utilities]. The declaration should stay in
<tt>&lt;memory&gt;</tt>.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1023"></a>1023. Response to DE 22</h3>
<p><b>Section:</b> 20.8.14.2 [func.wrap.func] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#func.wrap.func">issues</a> in [func.wrap.func].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses DE 22</b></p>

<p>Related to issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1114">1114</a>.</p>

<p>
The conditions for deriving from <tt>std::unary_function</tt> and
<tt>std::binary_function</tt> are unclear: The condition would also be satisfied if
<tt>ArgTypes</tt> were <tt>std::vector&lt;T1&gt;</tt>, because it (arguably)
"contains" <tt>T1</tt>.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Agree. <tt>std::reference_wrapper</tt> has the same structure, and we
suggest that <tt>std::function</tt> be presented in the same way as
<tt>std::reference_wrapper</tt>.
</blockquote>

<p><i>[
2009-05-09 Alisdair adds:
]</i></p>


<blockquote>
Phrasing should be "publicly and
unambiguously derived from" and probably back in reference_wrapper too.  Updated
wording supplied.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed wording.
Move to NAD Editorial.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
(no changes to <tt>&lt;functional&gt;</tt> synopsis required)
</p>

<p>
Change synopsis in Class template function 20.8.14.2 [func.wrap.func]:
</p>

<blockquote><pre>template&lt;Returnable R, CopyConstructible... ArgTypes&gt; 
class function&lt;R(ArgTypes...)&gt; 
  : public unary_function&lt;T1, R&gt;      // <del><i>iff</i> sizeof...(ArgTypes) == 1 <i>and</i></del> <ins><i>see below</i></ins>
                                      <del>// ArgTypes <i>contains</i> T1</del>
  : public binary_function&lt;T1, T2, R&gt; // <del><i>iff</i> sizeof...(ArgTypes) == 2 <i>and</i></del> <ins><i>see below</i></ins>
                                      <del>// ArgTypes <i>contains</i> T1 <i>and</i> T2</del>
{
   ...
</pre></blockquote>

<p>
Add new p1/p2 before 20.8.14.2.1 [func.wrap.func.con]:
</p>

<blockquote>
<p><ins>
The template instantiation <tt>function&lt;R(T1)&gt;</tt> shall be publicly and
unambiguously derived from 
<tt>std::unary_function&lt;T1,R&gt;</tt> if and only if the template type parameter
is a function type taking one argument of type <tt>T1</tt> and returning <tt>R</tt>.
</ins></p>

<p><ins>
The template instantiation <tt>function&lt;R(T1,T2)&gt;</tt> shall be publicly and
unambiguously derived from 
<tt>std::binary_function&lt;T1,T2,R&gt;</tt> if and only if the template type
parameter is a function type taking two arguments of type <tt>T1</tt> and <tt>T2</tt> and
returning <tt>R</tt>.
</ins></p>

<pre>explicit function();
</pre>
</blockquote>






<hr>
<h3><a name="1024"></a>1024. Response to JP 39</h3>
<p><b>Section:</b> 20.8.14.2 [func.wrap.func] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#func.wrap.func">issues</a> in [func.wrap.func].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses JP 39</b></p>

<p>
There are no requires corresponding to <tt>F</tt> of <tt>std::function</tt>.
</p>

<p><i>[
2009-05-01 Daniel adds:
]</i></p>


<blockquote>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1070">1070</a> removes the second constructor.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to Tentatively Ready.
If issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1070">1070</a> is accepted,
the changes to the second constructor
in this issue are moot.
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
Constructors have no definition.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Correct as follows in 20.8.14.2 [func.wrap.func] (class definition)
</p>

<blockquote><pre> template&lt;class F, Allocator Alloc&gt;
   <ins>requires ConstructibleWithAllocator&lt;F, Alloc&gt;
     &amp;&amp; call=Callable&lt;F, ArgTypes...&gt;
     &amp;&amp; Convertible&lt;call::result_type, R&gt;</ins>
   function(allocator_arg_t, const Alloc&amp;, F);
 template&lt;class F, Allocator Alloc&gt;
   <ins>requires ConstructibleWithAllocator&lt;F,Alloc&gt;
     &amp;&amp; call=Callable&lt;F, ArgTypes...&gt;
     &amp;&amp; Convertible&lt;call::result_type, R&gt;</ins>
   function(allocator_arg_t, const Alloc&amp;, F&amp;&amp;);
</pre></blockquote>






<hr>
<h3><a name="1025"></a>1025. Response to UK 208</h3>
<p><b>Section:</b> 20.8.15 [unord.hash] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Future">NAD Future</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unord.hash">issues</a> in [unord.hash].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 208</b></p>

<p>
<tt>std::hash</tt> should be implemented for much more of the standard
library. In particular for <tt>pair</tt>, <tt>tuple</tt> and all the
standard containers.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1026"></a>1026. Response to UK 209</h3>
<p><b>Section:</b> 20.9 [memory] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#memory">issues</a> in [memory].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 209</b></p>

<p>
Smart pointers cannot be used in constrained templates.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
We look forward to a paper on this topic. We recommend no action until a
paper is available. We understand that a paper is forthcoming.
</blockquote>

<p><i>[
Peter Dimov adds:
]</i></p>


<blockquote>
<tt>shared_ptr&lt;T&gt;</tt> and <tt>weak_ptr&lt;T&gt;</tt> support all
types <tt>T</tt> for which <tt>T*</tt> is valid. In other words, a
possible (partial) resolution is to change class <tt>T</tt> to
<tt>PointeeType T</tt> for <tt>shared_ptr</tt>, <tt>weak_ptr</tt> and
possibly <tt>enable_shared_from_this</tt>.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1027"></a>1027. Response to UK 213</h3>
<p><b>Section:</b> 20.9.5 [default.allocator] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 213</b></p>

<p>
<tt>std::allocator</tt> should be constrained to simplify its use on constrained
contexts. This library component models allocation from free store via the
new operator so choose constraints to 
match. The Allocator concept allows for a wider variety of allocators that
users may choose to supply if their allocation model does not require
operator new, without impacting the 
requirements of this template. 
</p>

<p>
Suggested direction:
</p>
<p>
The primary allocator template should be constrained to require
<tt>ObjectType&lt;T&gt;</tt> and <tt>FreeStoreAllocatable&lt;T&gt;</tt>.
Further operations to be constrained as required.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Agree as stated. A future paper will address additional related issues.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1028"></a>1028. Response to UK 214</h3>
<p><b>Section:</b> 20.9.6 [storage.iterator] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 214</b></p>

<p>
<tt>raw_storage_iterator</tt> needs constraining as an iterator adaptor to be safely
used in constrained templates 
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
We look forward to a paper on this topic. We recommend no action until a
paper is available.
</blockquote>

<p><i>[
Post Summit Alisdair provided wording and rationale.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
20.9 [memory] p2
</p>
<p>
Update the synopsis for <tt>&lt;memory&gt;</tt>
</p>
<blockquote><pre>// 20.7.8, raw storage iterator:
template &lt;<del>class</del> <ins>ForwardIterator</ins> Out<del>put</del>Iter<del>ator</del>, <del>class</del> <ins>ObjectType</ins> T&gt; 
  <ins>requires OutputIterator&lt; OutIter, T &gt;</ins>
    class raw_storage_iterator;

<ins>template &lt;ForwardIterator OutIter, ObjectType T&gt; 
  requires OutputIterator&lt; OutIter, T &gt;
  concept_map Iterator&lt;raw_storage_iterator&lt; OutIter, T &gt; &gt; { }</ins>
</pre></blockquote>


<p>
20.9.6 [storage.iterator] p1
</p>
<p>
Replace class template definition with:
</p>
<blockquote><pre>namespace std { 
  template &lt;<del>class</del> <ins>ForwardIterator</ins> Out<del>put</del>Iter<del>ator</del>, <del>class</del> <ins>ObjectType</ins> T&gt; 
    <ins>requires OutputIterator&lt; OutIter, T &gt;</ins>
  class raw_storage_iterator 
    : public iterator&lt;output_iterator_tag,void,void,void,void&gt; { 
  public: 
    explicit raw_storage_iterator(Out<del>put</del>Iter<del>ator</del> x); 

    raw_storage_iterator<del>&lt;OutputIterator,T&gt;</del>&amp; operator*(); 
    raw_storage_iterator<del>&lt;OutputIterator,T&gt;</del>&amp; operator=(const T&amp; element); 
    raw_storage_iterator<del>&lt;OutputIterator,T&gt;</del>&amp; operator++(); 
    raw_storage_iterator<del>&lt;OutputIterator,T&gt;</del> operator++(int); 
  }; 

  <ins>template &lt;ForwardIterator OutIter, ObjectType T&gt; 
    requires OutputIterator&lt; OutIter, T &gt;
    concept_map Iterator&lt;raw_storage_iterator&lt; OutIter, T &gt; &gt; { }</ins>
}
</pre></blockquote>


<p><b>Rationale:</b></p>
<p>
<tt>raw_storage_iterator</tt> has to adapt a <tt>ForwardIterator</tt>,
rather than just an <tt>InputIterator</tt> for two reasons:
</p>

<ol type="i">
<li>
The initial iterator passed by value is expected to remain valid,
pointing to the initialized region of memory.
</li>
<li>
to avoid breaking the declaration of post-increment operator which would
require some kind of proxy formulation to support generalised InputIterators.
</li>
</ol>






<hr>
<h3><a name="1029"></a>1029. Response to UK 210</h3>
<p><b>Section:</b> 20.9.8 [specialized.algorithms] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#specialized.algorithms">issues</a> in [specialized.algorithms].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 210</b></p>

<p>Related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#582">582</a></p>

<p>
Specialized algorithms for memory managenment need requirements to be
easily usable in constrained templates.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
We look forward to a paper on this topic. We recommend no action until a
paper is available.
</blockquote>

<p><i>[
Post Summit Alisdair provided wording.
]</i></p>


<p><i>[
Post Summit:
]</i></p>


<blockquote>
<p>
Daniel adds:
</p>

<blockquote>
<ol>
<li>
I suggest <tt>Size</tt> should require <tt>IntegralLike</tt> and not <tt>UnsignedIntegralLike</tt>,
because otherwise simple int-literals could not be provided as arguments
and it would conflict with other algorithms that only require <tt>IntegralLike</tt>.
</li>
<li>
<p>
The current for-loop-test relies on evaluation in boolean context which is
not provided by <tt>ArithmeticLike</tt> and it's refinements. I propose to change the
corresponding for-loop-headers to:
</p>
<ol type="a">
<li>
for <tt>uninitialized_copy_n</tt>: <tt>for ( ; n &gt; Size(0); ++result, ++first, --n) {</tt>
</li>
<li>
for <tt>uninitialized_fill_n</tt>: <tt>for (; n &gt; Size(0); ++first, --n) {</tt>
</li>
</ol>
</li>
</ol>
</blockquote>

<p>
Alisdair adds:
</p>
<blockquote>
For the record I agree with Daniel's suggestion.
</blockquote>

</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
20.9 [memory] p2
</p>
<p>
Update the synopsis for <tt>&lt;memory&gt;</tt>
</p>
<blockquote><pre>template &lt;<del>class</del> InputIterator <ins>InIter</ins>,
         <del>class ForwardIterator</del> <ins>OutputIterator&lt;auto, InIter::reference&gt; OutIter</ins>&gt; 
   <ins>requires ForwardIterator&lt;OutIter&gt;</ins>
   <del>ForwardIterator</del> <ins>OutIter</ins>
   uninitialized_copy(<del>InputIterator</del> <ins>InIter</ins> first, <del>InputIterator</del> <ins>InIter</ins> last, 
                      <del>ForwardIterator</del> <ins>OutIter</ins> result);

template &lt;<del>class</del> InputIterator <ins>InIter</ins>,
          <del>class</del> <ins>IntegralLike</ins> Size,
          <del>class ForwardIterator</del> <ins>OutputIterator&lt;auto, InIter::reference&gt; OutIter</ins>&gt; 
  <ins>requires ForwardIterator&lt;OutIter&gt;</ins>
  <del>ForwardIterator</del> <ins>OutIter</ins>
  uninitialized_copy_n(<del>InputIterator</del> <ins>InIter</ins> first, Size n, 
                       <del>ForwardIterator</del> <ins>OutIter</ins> result);

template &lt;<del>class</del> ForwardIterator <ins>Iter</ins>, <del>class</del> <ins>ObjectType</ins> T&gt;
  <ins>requires Constructible&lt; Iter::value_type, const T&amp; &gt;</ins>
  void uninitialized_fill(<del>ForwardIterator</del> <ins>Iter</ins> first, <del>ForwardIterator</del> <ins>Iter</ins> last, 
                          const T&amp; x);

template &lt;<del>class</del> ForwardIterator <ins>Iter</ins>, <del>class</del> <ins>IntegralLike</ins> Size, <del>class</del> <ins>ObjectType</ins> T&gt; 
  <ins>requires Constructible&lt; Iter::value_type, const T&amp; &gt;</ins>
  void
  uninitialized_fill_n(<del>ForwardIterator</del> <ins>Iter</ins> first, Size n, const T&amp; x);
</pre></blockquote>

<p>
Update as follows:
</p>

<p>
uninitialized_copy 20.9.8.2 [uninitialized.copy]
</p>

<blockquote><pre>template &lt;<del>class</del> InputIterator <ins>InIter</ins>,
         <del>class ForwardIterator</del> <ins>OutputIterator&lt;auto, InIter::reference&gt; OutIter</ins>&gt; 
   <ins>requires ForwardIterator&lt;OutIter&gt;</ins>
   <del>ForwardIterator</del> <ins>OutIter</ins>
   uninitialized_copy(<del>InputIterator</del> <ins>InIter</ins> first, <del>InputIterator</del> <ins>InIter</ins> last, 
                      <del>ForwardIterator</del> <ins>OutIter</ins> result);
</pre>

<blockquote>
<p>
-1- <i>Effects:</i>
</p>
<blockquote><pre>for (; first != last; ++result, ++first)  {
   new (static_cast&lt;void*&gt;(&amp;*result))
       <del>typename iterator_traits&lt;ForwardIterator&gt;</del> <ins>OutIter</ins>::value_type(*first);
}
</pre></blockquote>

<p>
-2- <i>Returns:</i> <tt>result</tt>
</p>

</blockquote>

<pre>template &lt;<del>class</del> InputIterator <ins>InIter</ins>,
          <del>class</del> <ins>IntegralLike</ins> Size,
          <del>class ForwardIterator</del> <ins>OutputIterator&lt;auto, InIter::reference&gt; OutIter</ins>&gt; 
  <ins>requires ForwardIterator&lt;OutIter&gt;</ins>
  <del>ForwardIterator</del> <ins>OutIter</ins>
  uninitialized_copy_n(<del>InputIterator</del> <ins>InIter</ins> first, Size n, 
                       <del>ForwardIterator</del> <ins>OutIter</ins> result);
</pre>

<blockquote>
<p>
-3- Effects:
</p>
<blockquote><pre>for ( ; n &gt; <ins>Size(</ins>0<ins>)</ins>; ++result, ++first, --n) {
   new (static_cast&lt;void*&gt;(&amp;*result))
       <del>typename iterator_traits&lt;ForwardIterator&gt;</del> <ins>OutIter</ins>::value_type(*first);
}
</pre></blockquote>
<p>
-4- <i>Returns:</i> result
</p>
</blockquote>

</blockquote>


<p>
uninitialized_fill 20.9.8.3 [uninitialized.fill]
</p>

<blockquote><pre>template &lt;<del>class</del> ForwardIterator <ins>Iter</ins>, <del>class</del> <ins>ObjectType</ins> T&gt;
  <ins>requires Constructible&lt; Iter::value_type, const T&amp; &gt;</ins>
  void uninitialized_fill(<del>ForwardIterator</del> <ins>Iter</ins> first, <del>ForwardIterator</del> <ins>Iter</ins> last, 
                          const T&amp; x);
</pre>

<blockquote>
<p>
-1- <i>Effects:</i>
</p>
<blockquote><pre>for (; first != last; ++first) {
   new ( static_cast&lt;void*&gt;( &amp;*first) ) 
       <del>typename iterator_traits&lt;ForwardIterator&gt;</del> <ins>Iter</ins>::value_type(x);
}
</pre></blockquote>
</blockquote>
</blockquote>


<p>
uninitialized_fill_n 20.9.8.4 [uninitialized.fill.n]
</p>

<blockquote><pre>template &lt;<del>class</del> ForwardIterator <ins>Iter</ins>, <del>class</del> <ins>IntegralLike</ins> Size, <del>class</del> <ins>ObjectType</ins> T&gt; 
  <ins>requires Constructible&lt; Iter::value_type, const T&amp; &gt;</ins>
  void
  uninitialized_fill_n(<del>ForwardIterator</del> <ins>Iter</ins> first, Size n, const T&amp; x);
</pre>

<blockquote>
<p>
-1- <i>Effects:</i>
</p>
<blockquote><pre>for (; n<del>--</del> <ins>&gt; Size(0)</ins>; ++first<ins>, --n</ins>) {
   new ( static_cast&lt;void*&gt;( &amp;*first) ) 
       <del>typename iterator_traits&lt;ForwardIterator&gt;</del> <ins>Iter</ins>::value_type(x);
}
</pre></blockquote>
</blockquote>
</blockquote>






<hr>
<h3><a name="1031"></a>1031. Response to US 78</h3>
<p><b>Section:</b> 20.9.10.2 [util.smartptr.shared] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Future">NAD Future</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#util.smartptr.shared">issues</a> in [util.smartptr.shared].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses US 78</b></p>

<p>
There is presently no way to convert directly from a <tt>shared_ptr</tt> to a
<tt>unique_ptr</tt>. Add an interface that performs the conversion. 
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
We look forward to a paper on this topic. We recommend no action until a
paper is available. We believe that the shared pointer must use the default
deleter for the conversion to succeed.
</blockquote>

<p><i>[
Peter Dimov adds:
]</i></p>


<blockquote>
This is basically a request for <tt>shared_ptr&lt;&gt;::release</tt> in
disguise, with all the associated problems. Not a good idea.
</blockquote>

<p><i>[
2009-07 post-Frankfurt:
]</i></p>


<blockquote>
<p>
The rationale for the omission of a release() member function from shared_ptr is given in:
<a href="http://www.boost.org/doc/libs/1_39_0/libs/smart_ptr/shared_ptr.htm">http://www.boost.org/doc/libs/1_39_0/libs/smart_ptr/shared_ptr.htm</a>
</p>
<p>
The implementation of such a member is non-trivial (and maybe
impossible), because it would need to account for the deleter.
</p>
</blockquote>

<p><i>[
2009-07-26 Howard sets to Tentatively NAD Future.
]</i></p>


<blockquote>
<p>
I took an online poll and got 3 votes for NAD and 3 for NAD Future.  Personally
I prefer NAD Future as this does refer to an extension that could conceivably be
considered beyond C++0X.
</p>

<p>
However such an extension would need to solve a couple of problems:
</p>

<ol>
<li>What is the interface for such a conversion when the <tt>shared_ptr</tt> does
not have unique ownership?  Throw an exception?  Create a null <tt>unique_ptr</tt>?
Undefined behavior?
</li>

<li>
<p>
How does one handle custom deleters given to the <tt>shared_ptr</tt> constructor?
</p>
<p>
I do not believe it is possible to implement a general answer to this question.
The <tt>shared_ptr</tt> deleter is a run time (or construction time) characteristic.
The <tt>unique_ptr</tt> deleter is a compile time characteristic.  In general one
can not know to what type of <tt>unqiue_ptr</tt> you are converting to.
</p>
<p>
One answer is for the user of the conversion to specify the deleter type and perhaps
throw an exception if the specification turns out to be incorrect.
</p>
<p>
Another answer is for the conversion to only be valid when the underlying deleter
is <tt>default_delete</tt>.  We would probalby need to specify that this is indeed the
underlying deleter of a <tt>shared_ptr</tt> when a custom deleter is not given in
the constructor.
</p>
</li>
</ol>

<p>
At any rate, there are non-trivial design issues which would need to be implemented
and tested in the field for usability prior to standardization.
</p>
</blockquote>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
Moved to NAD Future.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1032"></a>1032. Response to JP 45</h3>
<p><b>Section:</b> 20.11 [time] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#time">issues</a> in [time].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses JP 45</b></p>

<p>
<tt>Rep</tt>, <tt>Period</tt>, <tt>Clock</tt> and <tt>Duration</tt>
don't correspond to concept.
</p>
<blockquote><pre>template &lt;class Rep, class Period = ratio&lt;1&gt;&gt; class duration; 
template &lt;class Clock, class Duration = typename Clock::duration&gt; class time_point; 
</pre></blockquote>
<p>
Make concept for <tt>Rep</tt>, <tt>Period</tt>, <tt>Clock</tt> and <tt>Duration</tt>.
Fix 20.11 [time] and <tt>wait_until</tt>
and <tt>wait_for</tt>'s template parameter at 30 [thread]. 
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
We agree that this section needs concepts. We look forward to a paper on
this topic. We recommend no action until a paper is available.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1035"></a>1035. Response to UK 226</h3>
<p><b>Section:</b> 23.2.1 [container.requirements.general] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12 <b>Last modified:</b> 2010-10-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#container.requirements.general">active issues</a> in [container.requirements.general].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#container.requirements.general">issues</a> in [container.requirements.general].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 226</b></p>

<p>
<tt>&lt;array&gt;</tt> must be added to this list. In particular it
doesn't satisfy: - no <tt>swap()</tt> function invalidates any
references, pointers, or iterators referring to the elements of the
containers being swapped. and probably doesn't satisfy: - no
<tt>swap()</tt> function throws an exception.
</p>
<p>
If <tt>&lt;array&gt;</tt> remains a container, this will have to also
reference <tt>array</tt>, which will then have to say which of these
points it satisfies.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Agree. The proposed resolution is incomplete. Further work required.
</blockquote>

<p><i>[
2009-05-01 Daniel adds:
]</i></p>


<blockquote>
Issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1099">1099</a> also suggests
adding move constructor to this.
</blockquote>

<p><i>[
2009-07 post-Frankfurt:
]</i></p>


<blockquote>
Howard is to draft a note that explains what happens to references.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Mark as NAD.  No consensus for change.
</blockquote>



<p><i>[
2009-08-01 Howard provided wording.
]</i></p>


<p><b>Proposed resolution:</b></p>
<p>
Add a paragraph to 23.3.1.2 [array.special]:
</p>

<blockquote><pre>template &lt;Swappable T, size_t N&gt; void swap(array&lt;T,N&gt;&amp; x, array&lt;T,N&gt;&amp; y);
</pre>
<blockquote>
<p>
<i>Effects:</i>
</p>
<blockquote><pre>swap_ranges(x.begin(), x.end(), y.begin());
</pre></blockquote>

<p><ins>
[<i>Note:</i>
Outstanding iterators, references and pointers may be invalidated.
 <i>end note</i>]
</ins></p>
</blockquote>
</blockquote>





<hr>
<h3><a name="1036"></a>1036. Response to UK 231</h3>
<p><b>Section:</b> 23.2.3 [sequence.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#sequence.reqmts">issues</a> in [sequence.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 231</b></p>

<p>
p9-p11 are redundant now that Concepts define what it means to be an
Iterator and guide overload resolution accordingly. 
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Agree with issue and change to 23.2.3 [sequence.reqmts]. The
changes required to 21 [strings] will be part of the general
concept support for that clause.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Strike 23.2.3 [sequence.reqmts]p9-11. Make sure <tt>std::basic_string</tt>
has constraints similar to
<tt>std::vector</tt> to meet this old guarantee. 
</p>





<hr>
<h3><a name="1041"></a>1041. Response to UK 239</h3>
<p><b>Section:</b> 23.2.4 [associative.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Future">NAD Future</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12 <b>Last modified:</b> 2010-10-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 239</b></p>

<p>
It is not possible to take a move-only key out of an unordered
container, such as (<tt>multi</tt>)<tt>set</tt> or
(<tt>multi</tt>)<tt>map</tt>, or the new unordered containers.
</p>

<p>
Add below <tt>a.erase(q)</tt>, <tt>a.extract(q)</tt>, with the following notation:
</p>
<p>
<tt>a.extract(q)&gt;</tt>, Return type <tt>pair&lt;key, iterator&gt;</tt>
Extracts the element pointed to by <tt>q</tt> and erases it from the
<tt>set</tt>. Returns a <tt>pair</tt> containing the value pointed to by
<tt>q</tt> and an <tt>iterator</tt> pointing to the element immediately
following <tt>q</tt> prior to the element being erased. If no such
element exists,returns <tt>a.end()</tt>.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
We look forward to a paper on this topic. We recommend no action until a
paper is available. The paper would need to address exception safety.
</blockquote>

<p><i>[
Post Summit Alisdair adds:
]</i></p>


<blockquote>
Would <tt>value_type</tt> be a better return type than <tt>key_type</tt>?
</blockquote>

<p><i>[
2009-07 post-Frankfurt:
]</i></p>


<blockquote>
Leave Open. Alisdair to contact Chris Jefferson about this.
</blockquote>

<p><i>[
2009-09-20 Howard adds:
]</i></p>


<blockquote>
See the 2009-09-19 comment of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#839">839</a> for an API which
accomplishes this functionality and also addresses several other use
cases which this proposal does not.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Mark as NAD Future. No consensus to make the change at this time.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
In 23.2.4 [associative.reqmts] Table 85, add:
</p>

<blockquote>
<table border="1">
<caption>Table 85 --  Associative container requirements (in addition to container)</caption>
<tbody><tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion/note<br>pre-/post-condition</th>
<th>Complexity</th>
</tr>
<tr><td><tt>a.erase(q)</tt></td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr><tr>
<td><ins><tt>a.extract(q)</tt></ins></td>
<td><ins><tt>pair&lt;key_type, iterator&gt;</tt></ins></td>
<td><ins>Extracts the element pointed to by <tt>q</tt> and erases it from the <tt>set</tt>. 
Returns a <tt>pair</tt> containing the value pointed to by <tt>q</tt> and an <tt>iterator</tt>
pointing to the element immediately following <tt>q</tt> prior to the element being
erased. If no such element 
exists, returns <tt>a.end()</tt>.</ins></td>
<td><ins>amortized constant</ins></td>
</tr>
</tbody></table>
</blockquote>

<p>
In 23.2.5 [unord.req] Table 87, add:
</p>

<blockquote>
<table border="1">
<caption>Table 87 -- Unordered associative container requirements (in addition to container)</caption>
<tbody><tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion/note<br>pre-/post-condition</th>
<th>Complexity</th>
</tr>
<tr><td><tt>a.erase(q)</tt></td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr><tr>
<td><ins><tt>a.extract(q)</tt></ins></td>
<td><ins><tt>pair&lt;key_type, iterator&gt;</tt></ins></td>
<td><ins>Extracts the element pointed to by <tt>q</tt> and erases it from the <tt>set</tt>. 
Returns a <tt>pair</tt> containing the value pointed to by <tt>q</tt> and an <tt>iterator</tt>
pointing to the element immediately following <tt>q</tt> prior to the element being
erased. If no such element 
exists, returns <tt>a.end()</tt>.</ins></td>
<td><ins>amortized constant</ins></td>
</tr>
</tbody></table>
</blockquote>





<hr>
<h3><a name="1042"></a>1042. Response to UK 244</h3>
<p><b>Section:</b> 23.3 [sequences] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#sequences">issues</a> in [sequences].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 244</b></p>

<p>
The validity of the expression <tt>&amp;a[n] == &amp;a[0] + n</tt> is contingent on
<tt>operator&amp;</tt> doing the "right thing" (as captured by the <tt>CopyConstructible</tt>
requirements in table 30 in C++2003). However this constraint has been
lost in the Concepts of C++0x. This applies to <tt>vector</tt> and <tt>array</tt> (it
actually applies to <tt>string</tt> also, but that's a different chapter, so I'll
file a separate comment there and cross-reference).
</p>

<p>
Suggested solution:
</p>

<p>
Define a <tt>ContiguousStrorage</tt> and apply it to
<tt>vector</tt>, <tt>array</tt> and <tt>string</tt>.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Agree with the issue but not the details of the proposed solution. Walter to
provide wording for the new concept.
</blockquote>

<p><i>[
Post Summit Alisdair adds:
]</i></p>


<blockquote>
Another LWG subgroup wondered if this concept
should extend to <tt>complex&lt;T&gt;</tt>, and so not be built on the container concept at
all?
</blockquote>

<p><i>[
2009-07 post-Frankfurt:
]</i></p>


<blockquote>
Leave Open, pending a post-Concepts Working Draft.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Mark issue 1042 as NAD, in rationale state that this was solved by removal of concepts.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add to <tt>&lt;container_concepts&gt;</tt> synopsis in  [container.concepts]
</p>

<blockquote><pre><ins>concept&lt; typename C &gt; ContiguousStorageContainer <i>see below</i>;</ins>
</pre></blockquote>

<p>
Add a new section to the end of  [container.concepts]
</p>

<blockquote>
<p>
23.1.6.x ContiguousStorageContainer concept [container.concepts.contiguous]
</p>

<pre>concept ContiguousStorageContainer&lt; typename C &gt;
  : Container&lt;C&gt;
{
  value_type* data(C&amp;);

  axiom Contiguity(C&amp; c, size_type i) {
    if( i &lt; size(c) ) {
         addressof( * (data(c) + i) )
      == addressof( * advance(data(c), i) );
    }
  }
}
</pre>

<p>
The <tt>ContiguousStorageContainer</tt> concept describes a container whose elements
are allocated in a single region of memory, and are stored sequentially
without intervening padding other than to meet alignment requirements.
For example, the elements may be stored in a
single array of suitable length.
</p>

<pre>value_type * data( C&amp; );
</pre>

<blockquote>
<i>Returns:</i> a pointer to the first element in the region of storage.
Result is unspecified for an empty container.
</blockquote>

</blockquote>

<p>
Change 23.3.1 [array] p1:
</p>

<blockquote>
-1- The header <tt>&lt;array&gt;</tt> defines a class template for
storing fixed-size sequences of objects. An <tt>array</tt> supports
random access iterators. An instance of <tt>array&lt;T, N&gt;</tt>
stores <tt>N</tt> elements of type <tt>T</tt>, so that <tt>size() ==
N</tt> is an invariant. The elements of an <tt>array</tt> are stored
contiguously, meaning that <del>if <tt>a</tt> is</del> an
<tt>array&lt;T, N&gt;</tt> <del>then it obeys the identity <tt>&amp;a[n]
== &amp;a[0] + n</tt> for all <tt>0 &lt;= n &lt; N</tt></del>
<ins>satisfies the concept <tt>ContiguousStorageContainer&lt; array&lt;T,
N&gt;&gt;</tt></ins>.
</blockquote>

<p>
Add to the synopsis in 23.3.1 [array]:
</p>

<blockquote><pre>    ...
    T * data(); 
    const T * data() const; 
  };

  <ins>template&lt; typename T, size_t N &gt;</ins>
    <ins>concept_map ContiguousStorageContainer&lt; array&lt;T, N&gt;&gt; {};</ins>
} 
</pre></blockquote>

<p>
Change 23.4.1 [vector] p1:
</p>

<blockquote>
A <tt>vector</tt> is a sequence container that supports random access
iterators. In addition, it supports (amortized) constant time insert and
erase operations at the end; insert and erase in the middle take linear
time. Storage management is handled automatically, though hints can be
given to improve efficiency. The elements of a vector are stored
contiguously, meaning that <del>if <tt>v</tt> is</del> a
<tt>vector&lt;T, Alloc&gt;</tt> <ins>(</ins>where <tt>T</tt> is some
type other than <tt>bool</tt><ins>)</ins><del>, then it obeys the
identity <tt>&amp;v[n] == &amp;v[0] + n</tt> for all <tt>0 &lt;= n &lt;
v.size()</tt></del> <ins>satisfies the concept <tt>ContiguousStorageContainer&lt;
vector&lt; T, Alloc&gt;&gt;</tt></ins>.
</blockquote>

<p>
Add at the end of the synopsis in 23.4.1 [vector] p2:
</p>

<blockquote><pre><ins>template&lt; typename T, typename A &gt;
  requires !SameType&lt; T, bool &gt;
  concept_map ContiguousStorageContainer&lt; vector&lt;T, A&gt;&gt; {};</ins>
</pre></blockquote>



<p><b>Rationale:</b></p>
Solved by removal of concepts.





<hr>
<h3><a name="1043"></a>1043. Response to US 91</h3>
<p><b>Section:</b> 29.6 [atomics.types.operations] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12 <b>Last modified:</b> 2010-10-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#atomics.types.operations">active issues</a> in [atomics.types.operations].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics.types.operations">issues</a> in [atomics.types.operations].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses US 91</b></p>

<p>
It is unclear whether or not a failed <tt>compare_exchange</tt> is a RMW operation
(as used in 1.10 [intro.multithread]).
</p>

<p>
Suggested solution:
</p>

<p>
Make failing <tt>compare_exchange</tt> operations <b>not</b> be RMW.
</p>

<p><i>[
Anthony Williams adds:
]</i></p>


<blockquote>
In 29.6 [atomics.types.operations] p18 it says that "These
operations are atomic read-modify-write operations" (final sentence).
This is overly restrictive on the implementations of
<tt>compare_exchange_weak</tt> and <tt>compare_exchange_strong</tt> on platforms without a
native CAS instruction.
</blockquote>


<p><i>[
Summit:
]</i></p>


<blockquote>
Group agrees with the resolution as proposed by Anthony Williams in the attached note.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We recommend the proposed resolution be reviewed
by members of the Concurrency Subgroup.
</blockquote>

<p><i>[
2009-07 post-Frankfurt:
]</i></p>


<blockquote>
This is likely to be addressed by Lawrence's upcoming paper. He will
adopt the proposed resolution.
</blockquote>

<p><i>[
2009-08-17 Handled by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2925.html">N2925</a>.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2992.html">N2992</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 29.6 [atomics.types.operations] p18:
</p>

<blockquote>
-18- <i>Effects:</i> Atomically, compares the value pointed to by
<tt>object</tt> or by <tt>this</tt> for equality with that in
<tt>expected</tt>, and if true, replaces the value pointed to by
<tt>object</tt> or by <tt>this</tt> with desired, and if false, updates
the value in <tt>expected</tt> with the value pointed to by
<tt>object</tt> or by <tt>this</tt>. Further, if the comparison is true,
memory is affected according to the value of <tt>success</tt>, and if the
comparison is false, memory is affected according to the value of
<tt>failure</tt>. When only one <tt>memory_order</tt> argument is
supplied, the value of <tt>success</tt> is <tt>order</tt>, and the value
of <tt>failure</tt> is <tt>order</tt> except that a value of
<tt>memory_order_acq_rel</tt> shall be replaced by the value
<tt>memory_order_acquire</tt> and a value of
<tt>memory_order_release</tt> shall be replaced by the value
<tt>memory_order_relaxed</tt>. <ins>If the comparison is <tt>true</tt>, </ins>
<del>T</del><ins>t</ins>hese operations are atomic
read-modify-write operations (1.10). 
<ins>If the comparison is <tt>false</tt>, these
operations are atomic load operations.</ins>
</blockquote>






<hr>
<h3><a name="1046"></a>1046. Response to UK 329</h3>
<p><b>Section:</b> 30.6 [futures] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#futures">issues</a> in [futures].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 329</b></p>

<p>
<tt>future</tt>, <tt>promise</tt> and <tt>packaged_task</tt> provide a
framework for creating future values, but a simple function to tie all
three components together is missing. Note that we only need a *simple*
facility for C++0x. Advanced thread pools are to be left for TR2.
</p>

<p>
Simple Proposal:
</p>

<p>
Provide a simple function along the lines of: 
</p>
<blockquote><pre>template&lt; typename F, typename ... Args &gt;
  requires Callable&lt; F, Args... &gt;
    future&lt; Callable::result_type &gt; async( F&amp;&amp; f, Args &amp;&amp; ... ); 
</pre></blockquote>

<p>
Semantics are similar to creating a <tt>thread</tt> object with a <tt>packaged_task</tt>
invoking <tt>f</tt> with <tt>forward&lt;Args&gt;(args...)</tt>
but details are left unspecified to allow different scheduling and thread
spawning implementations. 
</p>
<p>
It is unspecified whether a task submitted to async is run on its own thread
or a thread previously used for another async task. If a call to <tt>async</tt>
succeeds, it shall be safe to wait for it from any thread. 
</p>
<p>
The state of <tt>thread_local</tt> variables shall be preserved during <tt>async</tt> calls. 
</p>
<p>
No two incomplete async tasks shall see the same value of
<tt>this_thread::get_id()</tt>. 
</p>
<p>
[<i>Note:</i> this effectively forces new tasks to be run on a new thread, or a
fixed-size pool with no queue. If the 
library is unable to spawn a new thread or there are no free worker threads
then the <tt>async</tt> call should fail. <i>--end note</i>] 
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
<p>
The concurrency subgroup has revisited this issue and decided that it
could be considered a defect according to the Kona compromise. A task
group was formed lead by Lawrence Crowl and Bjarne Stroustrup to write a
paper for Frankfort proposing a simple asynchronous launch facility
returning a <tt>future</tt>. It was agreed that the callable must be run on a
separate thread from the caller, but not necessarily a brand-new thread.
The proposal might or might not allow for an implementation that uses
fixed-size or unlimited thread pools.
</p>
<p>
Bjarne in c++std-lib-23121: I think that what we agreed was that to
avoid deadlock <tt>async()</tt> would almost certainly be specified to  launch in
a different thread from the thread that executed <tt>async()</tt>, but I don't
think it was a specific design constraint.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Proposed resolution: see
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2996.html">N2996</a>
(Herb's and Lawrence's paper on Async). Move state to NAD editorial.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1047"></a>1047. Response to UK 334</h3>
<p><b>Section:</b> 30.6.6 [futures.unique_future] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#futures.unique_future">issues</a> in [futures.unique_future].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 334</b></p>

<p>
Behaviour of <tt>get()</tt> is undefined if calling <tt>get()</tt> while
not <tt>is_ready()</tt>. The intent is that <tt>get()</tt> is a blocking
call, and will wait for the future to become ready.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
<p>
Agree, move to Review.
</p>
</blockquote>

<p><i>[
2009-04-03 Thomas J. Gritzan adds:
]</i></p>


<blockquote>
<p>
This issue also applies to <tt>shared_future::get()</tt>.
</p>

<p>
Suggested wording:
</p>

<p>
Add a paragraph to 30.6.7 [futures.shared_future]:
</p>

<blockquote><pre>void shared_future&lt;void&gt;::get() const;
</pre>
<blockquote>
<i>Effects:</i> If <tt>is_ready()</tt> would return <tt>false</tt>, block on the asynchronous 
result associated with <tt>*this</tt>.
</blockquote>
</blockquote>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
It is not clear to us that this is an issue,
because the proposed resolution's Effects clause seems to duplicate
information already present in the Synchronization clause.
Keep in Review status.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2997.html">N2997</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add a paragraph to 30.6.6 [futures.unique_future]:
</p>

<blockquote><pre>R&amp;&amp; unique_future::get(); 
R&amp; unique_future&lt;R&amp;&gt;::get(); 
void unique_future&lt;void&gt;::get();
</pre>
<blockquote>
<p><i>Note:</i>...</p>
<p>
<ins><i>Effects:</i> If <tt>is_ready()</tt> would return <tt>false</tt>,
block on the asynchronous result associated with <tt>*this</tt>.</ins>
</p>
<p>
<i>Synchronization:</i> if <tt>*this</tt> is associated with a
<tt>promise</tt> object, the completion of <tt>set_value()</tt> or
<tt>set_exception()</tt> to that <tt>promise</tt> happens before (1.10)
<tt>get()</tt> returns.
</p>
</blockquote>
</blockquote>





<hr>
<h3><a name="1048"></a>1048. Response to UK 335</h3>
<p><b>Section:</b> 30.6.6 [futures.unique_future] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#futures.unique_future">issues</a> in [futures.unique_future].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 335</b></p>

<p>
<tt>std::unique_future</tt> is <tt>MoveConstructible</tt>, so you can transfer the
association with an asynchronous result from one instance to another.
However, there is no way to determine whether or not an instance has
been moved from, and therefore whether or not it is safe to wait for it.
</p>

<blockquote><pre>std::promise&lt;int&gt; p;
std::unique_future&lt;int&gt; uf(p.get_future());
std::unique_future&lt;int&gt; uf2(std::move(uf));
uf.wait(); <font color="#C80000">// oops, uf has no result to wait for. </font>
</pre></blockquote>

<p>
Suggest we add a <tt>waitable()</tt> function to <tt>unique_future</tt>
(and <tt>shared_future</tt>) akin to <tt>std::thread::joinable()</tt>,
which returns <tt>true</tt> if there is an associated result to wait for
(whether or not it is ready).
</p>

<p>
Then we can say:
</p>

<blockquote><pre>if(uf.waitable()) uf.wait();
</pre></blockquote>

<p><i>[
Summit:
]</i></p>


<blockquote>
<p>
Create an issue. Requires input from Howard. Probably NAD.
</p>
</blockquote>

<p><i>[
Post Summit, Howard thows in his two cents:
]</i></p>


<blockquote>
<p>
Here is a copy/paste of my last prototype of <tt>unique_future</tt> which was
several years ago.  At that time I was calling <tt>unique_future</tt> <tt>future</tt>:
</p>

<blockquote><pre>template &lt;class R&gt;
class future
{
public:
    typedef R result_type;
private:
    future(const future&amp;);// = delete;
    future&amp; operator=(const future&amp;);// = delete;

    template &lt;class R1, class F1&gt; friend class prommise;
public:
    future();
    ~future();

    future(future&amp;&amp; f);
    future&amp; operator=(future&amp;&amp; f);

    void swap(future&amp;&amp; f);

    <b>bool joinable() const;</b>
    bool is_normal() const;
    bool is_exceptional() const;
    bool is_ready() const;

    R get();

    void join();
    template &lt;class ElapsedTime&gt;
        bool timed_join(const ElapsedTime&amp;);
};
</pre></blockquote>

<p>
<tt>shared_future</tt> had a similar interface.  I intentionally reused
the <tt>thread</tt> interface where possible to lessen the learning
curve std::lib clients will be faced with.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2997.html">N2997</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1049"></a>1049. Response to UK 339</h3>
<p><b>Section:</b> 30.6.5 [futures.promise] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12 <b>Last modified:</b> 2010-10-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#futures.promise">active issues</a> in [futures.promise].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#futures.promise">issues</a> in [futures.promise].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 339</b></p>

<p>
Move assignment is goiing in the wrong direction, assigning from
<tt>*this</tt> to the passed rvalue, and then returning a reference to
an unusable <tt>*this</tt>.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
<p>
Agree, move to Review.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We recommend deferring this issue until after Detlef's paper (on futures)
has been issued.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2997.html">N2997</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Strike 30.6.5 [futures.promise] p6 and change p7:
</p>

<blockquote><pre>promise&amp; operator=(promise&amp;&amp; rhs);
</pre>
<blockquote>
<p>
<del>-6- <i>Effects:</i> move assigns its associated state to <tt>rhs</tt>.</del>
</p>
<p>
-7- <i>Postcondition:</i> <del><tt>*this</tt> has no associated
state.</del> <ins>associated state of <tt>*this</tt> is the same as the
associated state of <tt>rhs</tt> before the call. <tt>rhs</tt> has no
associated state.</ins>
</p>
</blockquote>
</blockquote>






<hr>
<h3><a name="1050"></a>1050. Response to UK 340</h3>
<p><b>Section:</b> 30.6.5 [futures.promise] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12 <b>Last modified:</b> 2010-10-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#futures.promise">active issues</a> in [futures.promise].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#futures.promise">issues</a> in [futures.promise].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 340</b></p>

<p>
There is an implied postcondition for <tt>get_future()</tt> that the state of the
<tt>promise</tt> is transferred into the <tt>future</tt> leaving the <tt>promise</tt> with no
associated state. It should be spelled out.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
<p>
Agree, move to Review.
</p>
</blockquote>

<p><i>[
2009-04-03 Thomas J. Gritzan adds:
]</i></p>


<blockquote>
<p>
<tt>promise::get_future()</tt> must not invalidate the state of the promise object. 
</p>
<p>
A promise is used like this: 
</p>
<blockquote><pre>promise&lt;int&gt; p; 
unique_future&lt;int&gt; f = p.get_future(); 
<font color="#C80000">// post 'p' to a thread that calculates a value </font>
<font color="#C80000">// use 'f' to retrieve the value. </font>
</pre></blockquote>
<p>
So <tt>get_future()</tt> must return an object that shares the same associated 
state with <tt>*this</tt>. 
</p>
<p>
But still, this function should throw an <tt>future_already_retrieved</tt> error 
when it is called twice. 
</p>
<p>
<tt>packaged_task::get_future()</tt> throws <tt>std::bad_function_call</tt> if its <tt>future</tt>
was already retrieved. It should throw 
<tt>future_error(future_already_retrieved)</tt>, too. 
</p>
<p>
Suggested resolution: 
</p>
<p>
Replace p12/p13 30.6.5 [futures.promise]: 
</p>
<blockquote>
<p>
-12- <i>Throws:</i> <tt>future_error</tt> if <del><tt>*this</tt> has no associated state</del>
<ins>the <tt>future</tt> has already been retrieved</ins>.
</p>
<p>
-13- <i>Error conditions:</i> <tt>future_already_retrieved</tt> if <del><tt>*this</tt>
has no associated state</del>
<ins>the <tt>future</tt> associated with 
the associated state has already been retrieved</ins>.
</p>
<p>
<ins><i>Postcondition:</i> The returned object and <tt>*this</tt> share the associated state.</ins>
</p>
</blockquote>
<p>
Replace p14 30.6.10 [futures.task]: 
</p>
<blockquote>
<p>
-14- <i>Throws:</i> <tt><del>std::bad_function_call</del> <ins>future_error</ins></tt> if the future <del>associated with
the task</del> has already been retrieved.
</p>

<p><ins>
<i>Error conditions:</i> <tt>future_already_retrieved</tt> if the <tt>future</tt> associated with 
the task has already been retrieved. 
</ins></p>
<p>
<ins><i>Postcondition:</i> The returned object and <tt>*this</tt> share the associated task.</ins>
</p>
</blockquote>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Keep in Review status
pending Detlef's forthcoming paper on futures.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2997.html">N2997</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add after p13 30.6.5 [futures.promise]:
</p>

<blockquote><pre>unique_future&lt;R&gt; get_future();
</pre>
<blockquote>
<p>
-13- ...
</p>
<p>
<i>Postcondition:</i> <tt>*this</tt> has no associated state.
</p>
</blockquote>
</blockquote>






<hr>
<h3><a name="1051"></a>1051. Response to UK 279</h3>
<p><b>Section:</b> 24.5.1.3.12 [reverse.iter.opindex], 24.5.3.3.12 [move.iter.op.index] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 279</b></p>

<p>
The reason the return type became unspecified is LWG issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#386">386</a>. This
reasoning no longer applies as there are at least two ways to get the right
return type with the new language facilities added since the previous
standard. 
</p>

<p>
Proposal: Specify the return type using either decltype or the Iter concept_map.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
<p>
Under discussion. This is a general question about all iterator
adapters.
</p>
</blockquote>

<p><i>[
Howard adds post Summit:
]</i></p>


<blockquote>
I am requesting test cases to demonstrate a position.
</blockquote>

<p><i>[
2009-07-24 Daniel adds:
]</i></p>


<blockquote>
<p>
I recommend NAD. Without concepts we can no longer
restrict this member in a trivial way. Using <tt>decltype</tt> the
declaration would be along the lines of
</p>
<blockquote><pre>static const Iter&amp; __base(); // not defined
auto operator[](difference_type n) const -&gt; decltype(__base()[-n-1]);
</pre></blockquote>

<p>
but once <tt>reverse_iterator</tt> is instantiated for some given type
<tt>Iter</tt> which cannot form a well-formed expression <tt>__base()[-n-1]</tt>
this would cause an ill-formed function declaration, diagnostic
required, and no silent SFINAE elimination.
</p>

</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Moved to NAD.
</blockquote>

<p><i>[
2009-10-22 Daniel adds:
]</i></p>


<blockquote>
<p>
IMO, my original comment regarding ill-formedness of the described
construction is still correct, but I must add that I should weaken my
assertion "Without concepts we can no longer restrict this member in
a trivial way".
</p>

<p>
In fact with the existence of default template arguments for function
templates it is not too hard to implement this like as follows, which
shows that we can indeed simulate to some sense constrained
member functions in C++0x.
</p>

<p>
My example does not really proof that the specification is easy, but
it should be possible. I assume that the implementation would not
be ABI compatible, though.
</p>

<p>
It is now your own decision how to proceed ;-)
</p>

<blockquote><pre>#include &lt;type_traits&gt;
#include &lt;cstddef&gt;

template&lt;class T&gt;
typename std::add_rvalue_reference&lt;T&gt;::type declval();

template&lt;class It&gt;
struct reverse_iterator {
    It base;
    
    typedef std::ptrdiff_t difference_type;
    
    template&lt;class U = It, class Res =
     decltype(declval&lt;const U&amp;&gt;()[declval&lt;difference_type&gt;()])
    &gt;
    Res operator[](difference_type n) const  {
        return base[-n-1];
    }    
};

struct MyIter {
};

int main() {
    reverse_iterator&lt;int*&gt; ri;
    ri[0] = 2;
    reverse_iterator&lt;MyIter&gt; ri2;
}
</pre></blockquote>

<p>
The above declaration could be simplified, but the ideal solution
</p>

<blockquote><pre>template&lt;class U = It&gt;
  decltype(declval&lt;const U&amp;&gt;()[declval&lt;difference_type&gt;()])
     operator[](difference_type n) const;
</pre></blockquote>

<p>
does not work yet on gcc 4.4.1.
</p>

</blockquote>




<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1052"></a>1052. Response to UK 281</h3>
<p><b>Section:</b> 24.5.1.3.5 [reverse.iter.opref] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Future">NAD Future</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 281</b></p>

<p>
The current specification for return value for <tt>reverse_iterator::operator-&gt;</tt>
will always be a true pointer type, but <tt>reverse_iterator</tt> supports proxy
iterators where the pointer type may be some kind of 'smart pointer'.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
<p>
<tt>move_iterator</tt> avoids this problem by returning a value of the wrapped
Iterator type.
study group formed to come up with a suggested resolution.
</p>
<p>
<tt>move_iterator</tt> solution shown in proposed wording.
</p>
</blockquote>

<p><i>[
2009-07 post-Frankfurt:
]</i></p>


<blockquote>
Howard to deconceptize. Move to Review after that happens.
</blockquote>

<p><i>[
2009-08-01 Howard deconceptized:
]</i></p>


<blockquote>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
<p>
We can't think of any reason we can't just define reverse
iterator's pointer types to be the same as the underlying iterator's
pointer type, and get it by calling the right arrow directly.
</p>
<p>
Here is the proposed wording that was replaced:
</p>
<blockquote><pre>template &lt;class Iterator&gt; 
class reverse_iterator { 
  ...
  typedef <del>typename iterator_traits&lt;</del>Iterator<del>&gt;::pointer</del> pointer;
</pre></blockquote>

<p>
Change 24.5.1.3.5 [reverse.iter.opref]:
</p>

<blockquote><pre>pointer operator-&gt;() const;
</pre>
<blockquote>
<i>Returns:</i>
<blockquote><pre><del>&amp;(operator*());</del>
<ins>this-&gt;tmp = current;</ins>
<ins>--this-&gt;tmp;</ins>
<ins>return this-&gt;tmp;</ins>
</pre></blockquote>
</blockquote>
</blockquote>
</blockquote>

<p><i>[
2010-03-03 Daniel opens:
]</i></p>


<blockquote>
<ol>

<li>
There is a minor problem with the exposition-only declaration of the private
member <tt>deref_tmp</tt> which is modified in a const member function (and the
same problem occurs in the specification of <tt>operator*</tt>). The fix is to
make it a mutable member.
</li>

<li>
<p>
The more severe problem is that the resolution for some reasons
does not explain in the rationale why it was decided to differ from
the suggested fix (using <tt>deref_tmp</tt> instead of <tt>tmp</tt>) in the
[ 2009-10 Santa Cruz] comment:
</p>

<blockquote><pre>this-&gt;deref_tmp = current;
--this-&gt;deref_tmp;
return this-&gt;deref_tmp;
</pre></blockquote>

<p>
combined with the change of
</p>

<blockquote><pre>typedef typename iterator_traits&lt;Iterator&gt;::pointer pointer;
</pre></blockquote>

<p>
to
</p>

<blockquote><pre>typedef Iterator pointer;
</pre></blockquote>

<p>
The problem of the agreed on wording is that the following rather
typical example, that compiled with the wording before 1052 had
been applied, won't compile anymore:
</p>

<blockquote><pre>#include &lt;iterator&gt;
#include &lt;utility&gt;

int main() {
  typedef std::pair&lt;int, double&gt; P;
  P op;
  std::reverse_iterator&lt;P*&gt; ri(&amp;op + 1);
  ri-&gt;first; // Error
}
</pre></blockquote>

<p>
Comeau online returns (if a correspondingly changed
<tt>reverse_iterator</tt> is used):
</p>

<blockquote><pre>"error: expression must have class type
     return deref_tmp.operator-&gt;();
            ^
         detected during instantiation of "Iterator
                   reverse_iterator&lt;Iterator&gt;::operator-&gt;() const [with
                   Iterator=std::pair&lt;int, double&gt; *]""
</pre></blockquote>

<p>
Thus the change will break valid, existing code based
on <tt>std::reverse_iterator</tt>.
</p>

</li>

</ol>

<p>
IMO the suggestion proposed in the comment is a necessary fix, which harmonizes
with the similar specification of <tt>std::move_iterator</tt> and properly
reflects the recursive nature of the evaluation of <tt>operator-&gt;</tt>
overloads.
</p>

<p>
Suggested resolution:
</p>

<ol>

<li>
<p>
In the class template <tt>reverse_iterator</tt> synopsis of 24.5.1.1 [reverse.iterator] change as indicated:
</p>

<blockquote><pre>namespace std {
template &lt;class Iterator&gt;
class reverse_iterator : public
             iterator&lt;typename iterator_traits&lt;Iterator&gt;::iterator_category,
             typename iterator_traits&lt;Iterator&gt;::value_type,
             typename iterator_traits&lt;Iterator&gt;::difference_type,
             <del>typename iterator_traits&lt;</del>Iterator<del>&gt;::pointer</del>,
             typename iterator_traits&lt;Iterator&gt;::reference&gt; {
public:
  [..]
  typedef <del>typename iterator_traits&lt;</del>Iterator<del>&gt;::pointer</del> pointer;
  [..]
protected:
  Iterator current;
private:
  <ins>mutable</ins> Iterator deref_tmp; // exposition only
};
</pre></blockquote>
</li>

<li>
Change 24.5.1.3.5 [reverse.iter.opref]/1 as indicated:

<blockquote><pre>pointer operator-&gt;() const;
</pre>

<blockquote>
1 <i><del>Returns</del> <ins>Effects</ins>:</i> <del><tt>&amp;(operator*())</tt>.</del>
<blockquote><pre><ins>deref_tmp = current;</ins>
<ins>--deref_tmp;</ins>
<ins>return deref_tmp;</ins>
</pre></blockquote>
</blockquote>
</blockquote>

</li>

</ol>

</blockquote>

<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote>
<p>
We prefer to make to use a local variable instead of <tt>deref_tmp</tt> within
<tt>operator-&gt;()</tt>.  And although this means that the <tt>mutable</tt>
change is no longer needed, we prefer to keep it because it is needed for
<tt>operator*()</tt> anyway.
</p>

<p>
Here is the proposed wording that was replaced:
</p>

<blockquote class="note">
<p>
Change 24.5.1.3.5 [reverse.iter.opref]:
</p>

<blockquote><pre>pointer operator-&gt;() const;
</pre>

<blockquote>

<i>Returns:</i>
<blockquote><pre><del>&amp;(operator*());</del>
<ins>deref_tmp = current;
--deref_tmp;
return deref_tmp::operator-&gt;();</ins>
</pre></blockquote>

</blockquote>
</blockquote>


</blockquote>
</blockquote>

<p><i>[
2010-03-10 Howard adds:
]</i></p>


<blockquote>
<p>
Here are three tests that the current proposed wording passes, and no
other solution I've seen passes all three:
</p>

<ol>
<li>
<p>
Proxy pointer support:
</p>
<blockquote><pre>#include &lt;iterator&gt;
#include &lt;cassert&gt;

struct X { int m; };

X x;

struct IterX {
    typedef std::bidirectional_iterator_tag iterator_category;
    typedef X&amp; reference;
    struct pointer
    {
        pointer(X&amp; v) : value(v) {}
        X&amp; value;
        X* operator-&gt;() const {return &amp;value;}
    };
    typedef std::ptrdiff_t difference_type;
    typedef X value_type;
    // additional iterator requirements not important for this issue
    
    reference operator*() const { return x; }
    pointer operator-&gt;() const { return pointer(x); }
    IterX&amp; operator--() {return *this;}

};

int main()
{
    std::reverse_iterator&lt;IterX&gt; ix;
    assert(&amp;ix-&gt;m == &amp;(*ix).m);
}
</pre></blockquote>
</li>
<li>
<p>
Raw pointer support:
</p>
<blockquote><pre>#include &lt;iterator&gt;
#include &lt;utility&gt;

int main() {
  typedef std::pair&lt;int, double&gt; P;
  P op;
  std::reverse_iterator&lt;P*&gt; ri(&amp;op + 1);
  ri-&gt;first; // Error
}
</pre></blockquote>
</li>
<li>
<p>
Caching iterator support:
</p>
<blockquote><pre>#include &lt;iterator&gt;
#include &lt;cassert&gt;

struct X { int m; };

struct IterX {
    typedef std::bidirectional_iterator_tag iterator_category;
    typedef X&amp; reference;
    typedef X* pointer;
    typedef std::ptrdiff_t difference_type;
    typedef X value_type;
    // additional iterator requirements not important for this issue
    
    reference operator*() const { return value; }
    pointer operator-&gt;() const { return &amp;value; }
    IterX&amp; operator--() {return *this;}

private:
    mutable X value;
};

int main()
{
    std::reverse_iterator&lt;IterX&gt; ix;
    assert(&amp;ix-&gt;m == &amp;(*ix).m);
}
</pre></blockquote>
</li>
</ol>
</blockquote>

<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote>
Moved to NAD Future, rationale added.
</blockquote>




<p><b>Rationale:</b></p>
<p>
The LWG did not reach a consensus for a change to the WP.
</p>


<p><b>Proposed resolution:</b></p>

<ol>

<li>
<p>
In the class template <tt>reverse_iterator</tt> synopsis of 24.5.1.1 [reverse.iterator] change as indicated:
</p>

<blockquote><pre>namespace std {
template &lt;class Iterator&gt;
class reverse_iterator : public
             iterator&lt;typename iterator_traits&lt;Iterator&gt;::iterator_category,
             typename iterator_traits&lt;Iterator&gt;::value_type,
             typename iterator_traits&lt;Iterator&gt;::difference_type,
             <del>typename iterator_traits&lt;</del>Iterator<ins>&amp;</ins><del>&gt;::pointer</del>,
             typename iterator_traits&lt;Iterator&gt;::reference&gt; {
public:
  [..]
  typedef <del>typename iterator_traits&lt;</del>Iterator<ins>&amp;</ins><del>&gt;::pointer</del> pointer;
  [..]
protected:
  Iterator current;
private:
  <ins>mutable</ins> Iterator deref_tmp; // exposition only
};
</pre></blockquote>
</li>

<li>
Change 24.5.1.3.5 [reverse.iter.opref]/1 as indicated:

<blockquote><pre>pointer operator-&gt;() const;
</pre>

<blockquote>
1 <i><del>Returns</del> <ins>Effects</ins>:</i> <del><tt>&amp;(operator*())</tt>.</del>
<blockquote><pre><ins>deref_tmp = current;</ins>
<ins>--deref_tmp;</ins>
<ins>return deref_tmp;</ins>
</pre></blockquote>
</blockquote>
</blockquote>

</li>

</ol>










<hr>
<h3><a name="1053"></a>1053. Response to UK 295</h3>
<p><b>Section:</b> 25 [algorithms] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Future">NAD Future</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#algorithms">issues</a> in [algorithms].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 295</b></p>

<p>
There is a level of redundancy in the library specification for many
algorithms that can be eliminated with the combination of concepts and
default parameters for function templates. Eliminating redundancy simplified
specification and reduces the risk of introducing accidental
inconsistencies.
</p>
<p>
Proposed resolution: Adopt
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2743.pdf">N2743</a>.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
<p>
NAD, this change would break code that takes the address of an
algorithm.
</p>
</blockquote>

<p><i>[
Post Summit Alisdair adds:
]</i></p>


<blockquote>
<p>
Request 'Open'.  The issues in the paper go beyond just reducing
the number of signatures, but cover unifying the idea of the ordering
operation used by algorithms, containers and other library components.  At
least, it takes a first pass at the problem.
</p>

<p>
For me (personally) that was the more important part of the paper, and not
clearly addressed by the Summit resolution.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Too inventive, too late, would really need a paper. Moved to NAD Future.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1056"></a>1056. Must all Engines and Distributions be Streamable?</h3>
<p><b>Section:</b> 26.5 [rand] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand">issues</a> in [rand].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Both the concepts <tt>RandomNumberEngine</tt> and <tt>RandomNumberDistribution</tt> have
requirements to be <tt>InputStreamable</tt> and <tt>OutputStreamable</tt>.
</p>
<p>
I have no problems leaving the WP in an inconsistent state on the best-faith
assumption these concepts will be provided later, however disagree with the
proposers that these constraints are not separable, orthogonal to the basic
concepts of generating random number distributions.
</p>
<p>
These constraints should be dropped, and applied to specific algorithms as
needed.
</p>
<p>
If a more refined concept (certainly deemed useful by the proposers) is
proposed there is no objection, but the basic concept should not require
persistence via streaming.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to Open.
</blockquote>

<p><i>[
2009-05-31 Alisdair adds:
]</i></p>


<blockquote>
<p>
Working on constraining the stream iterators, I have a few more observations
to make on the concepts proposed while constraining the random number
facility.
</p>
<p>
While I still believe the concerns are orthogonal, I don't believe the
existing constraints go far enough either!  The goal we want to achieve is
not that a <tt>RandomNumberEngine</tt> / <tt>RandomNumberDistribution</tt> supports the stream
operators, but that it is <tt>Serializable</tt>.  I.e. there is a relationship
between the insert and extract operations that guarantees to restore the
state of the original object.  This implies a coupling of the concepts
together in a broader concept (<tt>Serializable</tt>) with at least one axiom to
assert the semantics.
</p>
<p>
One problem is that <tt>istream</tt> and <tt>ostream</tt> may be fundamentally different
types, although we can hook a relation if we are prepared to drop down to
the <tt>char</tt> type and <tt>char_traits</tt> template parameters.  Doing so ties us to a
form of serialization that demands implementation via the std iostreams
framework, which seems overly prescriptive.  I believe the goal is generally
to support serialization without regard to how it is expressed - although
this is getting even more inventive in terms of concepts we do not have
today.
</p>
</blockquote>

<p><i>[
2009-11-03 Alisdair adds:
]</i></p>


<blockquote>
<p>
I can't find the record in the wiki minutes, but it was agreed at both
Frankfurt and Santa Cruz that this issue is NAD.
</p>
<p>
The agreement in SC was that I would provide you with the rationale (see
below) to include when moving to NAD.
</p>
</blockquote>

<p><i>[
2009-11-03 Howard adds:
]</i></p>


<blockquote>
Moved to Tentatively NAD after 5 positive votes on c++std-lib.
</blockquote>


<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>
The issue suggests a more refined concept should be used if we want to
require streaming, to separate concerns from the basic
<tt>RandomNumberEngine</tt> behaviour.  In Frankfurt it was observed
that <tt>RandomNumberEngine</tt> <em>is</em> that more refined concept,
and the basic concept used in the framework is
<tt>UniformRandomNumberGenerator</tt>, which it refines.
</p>

<p>
We concur, and expect this to have no repurcussions re-writing this
clause now concepts are removed.
</p>





<hr>
<h3><a name="1057"></a>1057. <tt>RandomNumberEngineAdaptor</tt></h3>
<p><b>Section:</b> 26.5 [rand] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand">issues</a> in [rand].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The <tt>RandomNumberEngineAdaptor</tt> concept breaks precedent in the
way the library has been specified by grouping requirements into a
concept that is never actually used in the library.
</p>
<p>
This is undoubtedly a very helpful device for documentation, but we are not
comfortable with the precedent - especially as we have rejected national
body comments on the same grounds.
</p>
<p>
Suggest either removing the concept, or providing an algorithm/type that
requires this concept in their definition (such as a factory function to
create new engines).
</p>
<p>
The preference is to create a single new algorithm and retain the value of
the existing documentation.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Walter points out that it is unlikely that any algorithm would ever
require this concept, but that the concept nonetheless is useful as
documentation, and (via concept maps) as a means of checking specific adapters.
</p>
<p>
Alisdair disagrees as to the concept's value as documentation.
</p>
<p>
Marc points out that the <tt>RandomNumberDistribution</tt>
is also a concept not used elsewhere in the Standard.
</p>
<p>
Pete agrees that a policy of not inventing concepts
that aren't used in the Standard is a good starting point,
but should not be used as a criterion for rejecting a concept.
</p>
<p>
Move to Open.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1058"></a>1058. New container issue</h3>
<p><b>Section:</b> 23.2.3 [sequence.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#sequence.reqmts">issues</a> in [sequence.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Sequence containers 23.2.3 [sequence.reqmts]:
</p>

<p>
The return value of new calls added to table 83 are not specified.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with the proposed resolution.
</p>
<p>
Move to NAD Editorial.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Add after p6 23.2.3 [sequence.reqmts]:
</p>

<blockquote>
<p>
-6- ...
</p>
<p><ins>
The iterator returned from <tt>a.insert(p,rv)</tt> points to the copy of <tt>rv</tt>
inserted into <tt>a</tt>.
</ins></p>
<p><ins>
The iterator returned from <tt>a.emplace(p, args)</tt> points to the new
element constructed from <tt>args</tt> inserted into <tt>a</tt>.
</ins></p>
</blockquote>





<hr>
<h3><a name="1059"></a>1059. Usage of no longer existing FunctionType concept</h3>
<p><b>Section:</b> 20.8.14.2 [func.wrap.func] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-03-13 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#func.wrap.func">issues</a> in [func.wrap.func].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Due to a deliberate core language decision, the earlier called
"foundation" concept <tt>std::FunctionType</tt> had been removed in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2773.pdf">N2773</a>
shortly
before the first "conceptualized" version of the WP
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2798.pdf">N2798</a>)
had been
prepared. This caused a break of the library, which already used this
concept in the adapted definition of <tt>std::function</tt>
(20.8 [function.objects]/2, header <tt>&lt;functional&gt;</tt> synopsis and
20.8.14.2 [func.wrap.func]).
</p>
<p>
A simple fix would be to either (a) make <tt>std::function</tt>'s primary template
unconstrained or to (b) add constraints based on existing (support) concepts.
A more advanced fix would (c) introduce a new library concept.
</p>
<p>
The big disadvantage of (a) is, that users can define templates which
cause compiler errors during instantiation time because of under-constrainedness
and would thus violate the basic advantage of constrained
code.
</p>
<p>
For (b), the ideal constraints for <tt>std::function</tt>'s template parameter would
be one which excludes everything else but the single provided partial
specialization that matches every "free function" type (i.e. any function
type w/o cv-qualifier-seq and w/o ref-qualifier).
Expressing such a type as as single requirement would be written as
</p>
<blockquote><pre>template&lt;typename T&gt;
requires ReferentType&lt;T&gt; // Eliminate cv void and function types with cv-qual-seq
                         //   or ref-qual (depending on core issue #749)
      &amp;&amp; PointeeType&lt;T&gt;  // Eliminate reference types
      &amp;&amp; !ObjectType&lt;T&gt;  // Eliminate object types
</pre></blockquote>
<p>
Just for completeness approach (c), which would make sense, if the
library has more reasons to constrain for free function types:
</p>
<blockquote><pre>auto concept FreeFunctionType&lt;typename T&gt;
  : ReferentType&lt;T&gt;, PointeeType&lt;T&gt;, MemberPointeeType&lt;T&gt;
{
  requires !ObjectType&lt;T&gt;;
}
</pre></blockquote>
<p>
I mention that approach because I expect that free function types belong
to the most natural type categories for every days coders. Potential
candidates in the library are <tt>addressof</tt> and class template <tt>packaged_task</tt>.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Alisdair would prefer to have a core-supported <tt>FunctionType</tt> concept
in order that any future changes be automatically correct
without need for a library solution to catch up;
he points to type traits as a precedent.
Further, he believes that a published concept can't in the future
be changed.
</p>
<p>
Bill feels this category of entity would change sufficiently slowly
that he would be willing to take the risk.
</p>
<p>
Of the discussed solutions, we tend toward option (c).
We like the idea of having a complete taxonomy of native types,
and perhaps erred in trimming the set.
</p>
<p>
We would like to have this issue reviewed by Core and would like
their feedback.  Move to Open.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
Change in 20.8 [function.objects]/2, Header <tt>&lt;functional&gt;</tt> synopsis:
</p>
<blockquote><pre>// 20.6.16 polymorphic function wrappers:
class bad_function_call;
template&lt;<del>FunctionType</del><ins>ReferentType F</ins>&gt;
<ins>requires PointeeType&lt;F&gt; &amp;&amp; !ObjectType&lt;F&gt;</ins>
class function; // undefined
</pre></blockquote>
</li>
<li>
<p>
Change in 20.8.14.2 [func.wrap.func]:
</p>
<blockquote><pre>namespace std {
template&lt;<del>FunctionType</del><ins>ReferentType F</ins>&gt;
<ins>requires PointeeType&lt;F&gt; &amp;&amp; !ObjectType&lt;F&gt;</ins>
class function; // undefined
</pre></blockquote>
</li>
</ol>





<hr>
<h3><a name="1060"></a>1060. Embedded nulls in NTBS</h3>
<p><b>Section:</b> 17.5.2.1.4.1 [byte.strings] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-13 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Definition of null-terminated sequences allow for embedded nulls. This is
surprising, and probably not supportable with the intended use cases.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the issue, but believe this can be handled editorially.
Move to NAD Editorial.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1061"></a>1061. Bad indexing for tuple access to pair (Editorial?)</h3>
<p><b>Section:</b> 20.3.5.4 [pair.astuple] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-13 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The definition of <tt>get</tt> implies that <tt>get</tt> must return the second element if
given a negative integer.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to NAD Editorial.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
20.3.5.4 [pair.astuple] p5:
</p>

<blockquote><pre>template&lt;<del>int</del> <ins>size_t</ins> I, class T1, class T2&gt; 
  requires True&lt;(I &lt; 2)&gt; 
  const P&amp; get(const pair&lt;T1, T2&gt;&amp;);
</pre>
</blockquote>






<hr>
<h3><a name="1062"></a>1062. Missing insert_iterator for stacks/queues</h3>
<p><b>Section:</b> 24.5.2 [insert.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-13 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#insert.iterators">issues</a> in [insert.iterators].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
It is odd that we have an iterator to insert into a <tt>vector</tt>, but not an
iterator to insert into a <tt>vector</tt> that is adapted as a <tt>stack</tt>. The standard
container adapters all have a common interface to <tt>push</tt> and <tt>pop</tt> so it should
be simple to create an iterator adapter to complete the library support.
</p>

<p>
We should provide an <tt>AdaptedContainer</tt> concept supporting <tt>push</tt> and <tt>pop</tt>
operations. Create a new insert iterator and factory function that inserts
values into the container by calling <tt>push</tt>.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Walter recommends NAD Future.
</p>
<p>
Move to Open, and recommend deferring the issue until after the next
Committee Draft is issued.
</p>
</blockquote>

<p><i>[
2009-07-29 Howard moves to Tentatively NAD Future.
]</i></p>


<blockquote>
A poll on the LWG reflector voted unanimously to move this issue to Tentatively NAD Future.
</blockquote>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
Moved to NAD.  The intent of these adapters are to restrict the interfaces.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1063"></a>1063. 03 iterator compatibilty</h3>
<p><b>Section:</b> X [iterator.backward] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-15 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Which header must a user <tt>#include</tt> to obtain the library-supplied
<tt>concept_maps</tt> declared in this paragraph?
</p>

<p>
This is important information, as existing user code will break if this
header is not included, and we should make a point of mandating this header
is <tt>#include</tt>-d by library headers likely to make use of it, notably
<tt>&lt;algorithm&gt;</tt>.  See issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1001">1001</a> for more details.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the direction of the proposed resolution.
Move to Tentatively Ready.
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
We believe this is NAD Concepts, but this needs to be reviewed against the
post-remove-concepts draft.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p><i>Change  [depr.lib.iterator.primitives], Iterator primitives, as
indicated:</i></p>

<blockquote>
  <p>To simplify the use of iterators and provide backward compatibility with
  previous C++ Standard Libraries,
  the library provides several classes and functions. <ins>Unless otherwise
  specified, these classes and functions shall be defined in header <tt>&lt;iterator&gt;</tt>.</ins></p>
</blockquote>
<p><i>Change X [iterator.backward], Iterator backward compatibility, as
indicated:</i></p>
<blockquote>
  <p>The library provides concept maps that allow iterators specified with
  <tt>iterator_traits</tt> to interoperate with
  algorithms that require iterator concepts. <ins>These concept maps shall be
  defined in the same header that defines the iterator.</ins> [<i>Example:</i></p>
</blockquote>





<hr>
<h3><a name="1064"></a>1064. Response to UK 152</h3>
<p><b>Section:</b> 17.3.18 [defns.obj.state] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-03-15 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 152</b></p>

<p>
Object state is using a definition of object (instance of a class) from
outside the standard, rather than the 'region of storage' definiton in
1.8 [intro.object]p1
</p>

<p><i>[
Summit:
]</i></p>

<blockquote>
We think we're removing this; See X [func.referenceclosure.cons].
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Mark as NAD.  This will not affect user or implementer code
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="1067"></a>1067. simplified wording for inner_product</h3>
<p><b>Section:</b> 26.7 [numeric.ops] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-17 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p>
One of the motivating examples for introducing requirements-aliases was to
simplify the wording of the <tt>inner_product</tt> requirements.  As the paper
adopting the feature and constrained wording for the library went through in
the same meeting, it was not possible to make the change at the time.  The
simpler form should be adopted now though.  Similarly, most the other
numerical algorithms can benefit from a minor cleanup.
</p>
<p>
Note that in each case, the second more generalised form of the algorithm
does not benefit, as there are already named constraints supplied by the
template type parameters.
</p>

<p><i>[
2009-05-02 Daniel adds:
]</i></p>


<blockquote>
<p>
one part of the suggested resolution suggests the removal of the
<tt>MoveConstructible&lt;T&gt;</tt> requirement from
<tt>inner_product</tt>. According to 26.7.2 [inner.product]
</p>

<blockquote>
Computes its result by initializing the accumulator <tt>acc</tt> with the
initial value <tt>init</tt>
</blockquote>

<p>
this step requires at least <tt>MoveConstructible</tt>.
</p>

<p>
Therefore I strongly suggest to take this removal back (Note also
that the corresponding overload with a functor argument still has
the same <tt>MoveConstructible&lt;T&gt;</tt> requirement).
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with the proposed resolution as amended by Daniel's suggestion
to restore <tt>MoveConstructible</tt>,
reflected in the updated proposed resolution below.
</p>
<p>
Move to Tentatively Ready.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change in 26.7 [numeric.ops] and 26.7.1 [accumulate]:
</p>

<blockquote><pre>template &lt;InputIterator Iter, MoveConstructible T&gt;
 requires <ins>add =</ins> HasPlus&lt;T, Iter::reference&gt;
       &amp;&amp; HasAssign&lt;T, <del>HasPlus&lt;T, Iter::reference&gt;</del> <ins>add</ins>::result_type&gt;
 T accumulate(Iter first, Iter last, T init);
</pre></blockquote>

<p>
Change in 26.7 [numeric.ops] and 26.7.2 [inner.product]:
</p>

<blockquote><pre>template &lt;InputIterator Iter1, InputIterator Iter2, MoveConstructible T&gt;
  requires <ins>mult =</ins> HasMultiply&lt;Iter1::reference, Iter2::reference&gt;
        &amp;&amp; <ins>add =</ins> HasPlus&lt;T, <del>HasMultiply&lt;Iter1::reference, Iter2::reference&gt;</del> <ins>mult</ins>::result_type&gt;
        &amp;&amp; HasAssign&lt; 
             T,
             <del>HasPlus&lt;T,
                     HasMultiply&lt;Iter1::reference, Iter2::reference&gt;::result_type&gt;</del> <ins>add</ins>::result_type&gt;
  T inner_product(Iter1 first1, Iter1 last1, Iter2 first2, T init);
</pre></blockquote>

<p>
Change in 26.7 [numeric.ops] and 26.7.3 [partial.sum]:
</p>

<blockquote><pre>template &lt;InputIterator InIter, OutputIterator&lt;auto, const InIter::value_type&amp;&gt; OutIter&gt;
  requires <ins>add =</ins> HasPlus&lt;InIter::value_type, InIter::reference&gt;
        &amp;&amp; HasAssign&lt;InIter::value_type,
                     <del>HasPlus&lt;InIter::value_type, InIter::reference&gt;</del> <ins>add</ins>::result_type&gt;
        &amp;&amp; Constructible&lt;InIter::value_type, InIter::reference&gt;
  OutIter partial_sum(InIter first, InIter last, OutIter result);
</pre></blockquote>

<p>
Change in 26.7 [numeric.ops] and 26.7.4 [adjacent.difference]:
</p>

<blockquote><pre>template &lt;InputIterator InIter, OutputIterator&lt;auto, const InIter::value_type&amp;&gt; OutIter&gt;
  requires <ins>sub =</ins> HasMinus&lt;InIter::value_type, InIter::value_type&gt;
        &amp;&amp; Constructible&lt;InIter::value_type, InIter::reference&gt;
        &amp;&amp; OutputIterator&lt;OutIter, <del>HasMinus&lt;InIter::value_type, InIter::value_type&gt;</del> <ins>sub</ins>::result_type&gt;
        &amp;&amp; MoveAssignable&lt;InIter::value_type&gt;
  OutIter adjacent_difference(InIter first, InIter last, OutIter result);
</pre></blockquote>






<hr>
<h3><a name="1068"></a>1068. class random_device should be movable</h3>
<p><b>Section:</b> 26.5.6 [rand.device] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-18 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.device">issues</a> in [rand.device].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
class <tt>random_device</tt> should be movable.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to Open, and recommend this issue be deferred until after the next
Committee Draft is issued.
</blockquote>

<p><i>[
2009-10 post-Santa Cruz:
]</i></p>


<blockquote>
Leave open. Walter to provide drafting as part of his planned paper.
</blockquote>

<p><i>[
2010 Pittsburgh:  Moved to NAD.
]</i></p>




<p><b>Rationale:</b></p>
<p>
WP is correct as written.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1069"></a>1069. class seed_seq should support efficient move operations</h3>
<p><b>Section:</b> 26.5.7.1 [rand.util.seedseq] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-18 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.util.seedseq">issues</a> in [rand.util.seedseq].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
class <tt>seed_seq</tt> should support efficient move operations.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to Open, and recommend this issue be deferred until after the next
Committee Draft is issued.
</blockquote>

<p><i>[
2009-10 post-Santa Cruz:
]</i></p>


<blockquote>
Leave open. Walter to provide drafting as part of his planned paper.
</blockquote>

<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote>
<tt>seed_seq</tt> is explicitly not copyable, so, much like LWG issue
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1068">1068</a>, LWG issue 1069 could be marked NAD to be consistent
with this.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1072"></a>1072. Is std::hash a constrained template or not?</h3>
<p><b>Section:</b> 20.8.15 [unord.hash] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-19 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unord.hash">issues</a> in [unord.hash].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Is <tt>std::hash</tt> a constrained template or not?
</p>
<p>
According to Class template hash 20.8.15 [unord.hash], the definition is:
</p>

<blockquote><pre>template &lt;class T&gt;
struct hash : public std::unary_function&lt;T, std::size_t&gt; {
  std::size_t operator()(T val) const;
};
</pre></blockquote>

<p>
And so unconstrained.
</p>
<p>
According to the <tt>&lt;functional&gt;</tt> synopsis in p2 Function objects
20.8 [function.objects] the template is declared as:
</p>

<blockquote><pre>template &lt;ReferentType T&gt; struct hash;
</pre></blockquote>

<p>
which would make hash a constrained template.
</p>

<p><i>[
2009-03-22 Daniel provided wording.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Alisdair is not certain that Daniel's proposed resolution is sufficient,
and recommends we leave the hash template unconstrained for now.
</p>
<p>
Recommend that the Project Editor make the constrained declaration consistent
with the definition in order to make the Working Paper internally consistent,
and that the issue then be revisited.
</p>
<p>
Move to Open.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>

<p>
[To the editor: This resolution is merge-compatible to the
resolution of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1078">1078</a>]
</p>

<ol>
<li>
<p>
In 20.8 [function.objects]/2, header <tt>&lt;functional&gt;</tt> synopsis, change as indicated:
</p>

<blockquote><pre>// 20.6.17, hash function base template:
template &lt;ReferentType T&gt; struct hash; <ins>// undefined</ins>
</pre></blockquote>
</li>
<li>
<p>
In 20.8.15 [unord.hash]/1 change as indicated:
</p>
<blockquote><pre>namespace std {
 <del>template &lt;class T&gt;
 struct hash : public std::unary_function&lt;T, std::size_t&gt; {
 std::size_t operator()(T val) const;
 };</del>
 <ins>template &lt;ReferentType T&gt; struct hash; // undefined</ins>
}
</pre></blockquote>
</li>
<li>
<p>
In 20.8.15 [unord.hash]/2 change as indicated:
</p>

<blockquote>
-2-  <ins>For all library-provided specializations, the template
instantiation <tt>hash&lt;T&gt;</tt>
  shall provide a public <tt>operator()</tt> with return type <tt>std::size_t</tt> to
satisfy the concept
  requirement <tt>Callable&lt;const hash&lt;T&gt;, const T&amp;&gt;</tt>. If <tt>T</tt> is an object
type or reference to
  object, <tt>hash&lt;T&gt;</tt> shall be publicly derived from
<tt>std::unary_function&lt;T, std::size_t&gt;</tt>.
  </ins> The return value of <tt>operator()</tt> is unspecified, except that
equal arguments
  shall yield the same result. <tt>operator()</tt> shall not throw exceptions.
</blockquote>
</li>
<li>
<p>
In 18.7 [support.rtti]/1, header <tt>&lt;typeinfo&gt;</tt> synopsis change as indicated:
</p>
<blockquote><pre>namespace std {
  class type_info;
  class type_index;
  template &lt;<del>class</del><ins>ReferentType</ins> T&gt; struct hash;
</pre></blockquote>
</li>
</ol>





<hr>
<h3><a name="1074"></a>1074. concept map broken by N2840</h3>
<p><b>Section:</b> X [allocator.element.concepts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-19 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p>
p7 Allocator-related element concepts X [allocator.element.concepts]
</p>

<p>
The changes to the <tt>AllocatableElement</tt> concept mean this <tt>concept_map</tt>
specialization no longer matches the original concept:
</p>

<blockquote><pre>template &lt;Allocator Alloc, class T, class ... Args&gt;
  requires HasConstructor&lt;T, Args...&gt;
    concept_map AllocatableElement&lt;Alloc, T, Args&amp;&amp;...&gt; {
      void construct_element(Alloc&amp; a, T* t, Args&amp;&amp;... args) {
        Alloc::rebind&lt;T&gt;(a).construct(t, forward(args)...);
      }
    }
</pre></blockquote>

<p><i>[
2009-03-23 Pablo adds:
]</i></p>


<blockquote>
Actually, this is incorrect,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2840.pdf">N2840</a>
says. "In section 
X [allocator.element.concepts] paragraph 8, modify the definition of the
<tt>AllocatableElement</tt> concept and eliminate the related concept map:" but
then neglects to include the red-lined text of the concept map that was
to be eliminated. Pete also missed this, but I caught it he asked me to
review his edits.  Pete's updated WP removes the concept map entirely,
which was the original intent.  The issue is, therefore, moot.  Note, as
per my presentation of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2840.pdf">N2840</a>
in summit, <tt>construct()</tt> no longer has a
default implementation.  This regrettable fact was deemed (by David
Abrahams, Doug, and myself) to be preferable to the complexity of
providing a default implementation that would not under-constrain a more
restrictive allocator (like the scoped allocators).
</blockquote>

<p><i>[
2009-05-01 Daniel adds:
]</i></p>

<blockquote>
<p>
it seems to me that #1074 should be resolved as a NAD, because the
current WP has already removed the previous AllocatableElement concept map.
It introduced auto concept AllocatableElement instead, but as of
X [allocator.element.concepts]/7 this guy contains now
</p>
<blockquote><pre>requires FreeStoreAllocatable&lt;T&gt;;
void Alloc::construct(T*, Args&amp;&amp;...);
</pre></blockquote>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
The affected code is no longer part of the Working Draft.
</p>
<p>
Move to NAD.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change X [allocator.element.concepts]:
</p>

<blockquote><pre>template &lt;Allocator Alloc, class T, class ... Args&gt;
  requires HasConstructor&lt;T, Args...&gt;
    concept_map AllocatableElement&lt;Alloc, T, Args&amp;&amp;...&gt; {
      void construct_element(<del>Alloc&amp; a,</del> T* t, Args&amp;&amp;... args) {
        Alloc::rebind&lt;T&gt;(a).construct(t, forward(args)...);
      }
    }
</pre></blockquote>






<hr>
<h3><a name="1076"></a>1076. unary/binary_negate need constraining and move support</h3>
<p><b>Section:</b> 20.8.9 [negators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-20 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The class templates <tt>unary/binary_negate</tt> need constraining and move support.
</p>
<p>
Ideally these classes would be deprecated, allowing <tt>unary/binary_function</tt> to
also be deprecated.  However, until a generic negate adaptor is introduced
that can negate any <tt>Callable</tt> type, they must be supported so should be
constrained.  Likewise, they should be movable, and support adopting a
move-only predicate type.
</p>
<p>
In order to preserve ABI compatibility, new rvalue overloads are supplied in
preference to changing the existing pass-by-const-ref to pass-by-value.
</p>
<p>
Do not consider the issue of forwarding mutable lvalues at this point,
although remain open to another issue on the topic.
</p>

<p><i>[
2009-05-01 Daniel adds:
]</i></p>

<blockquote>
<p>
IMO the currently proposed resolution needs some updates
because it is ill-formed at several places:
</p>

<ol>
<li>
<p>
In concept AdaptableUnaryFunction change
</p>
<blockquote><pre>typename X::result_type;
typename X::argument_type;
</pre></blockquote>
<p>
to
</p>
<blockquote><pre>Returnable result_type = typename X::result_type;
typename argument_type = typename X::argument_type;
</pre></blockquote>
<p>
[The replacement "Returnable result_type" instead of "typename
result_type" is non-editorial, but maybe you prefer that as well]
</p>
</li>
<li>
<p>
In concept AdaptableBinaryFunction change
</p>
<blockquote><pre>typename X::result_type;
typename X::first_argument_type;
typename X::second_argument_type;
</pre></blockquote>
<p>
to
</p>
<blockquote><pre>Returnable result_type = typename X::result_type;
typename first_argument_type = typename X::first_argument_type;
typename second_argument_type = typename X::second_argument_type;
</pre></blockquote>
<p>
[The replacement "Returnable result_type" instead of "typename
result_type" is non-editorial, but maybe you prefer that as well.]
</p>
</li>

<li>
<p>
In class unary/binary_function
</p>
<ol type="a">
<li>
I suggest to change "ReturnType" to "Returnable" in both cases.
</li>
<li>
I think you want to replace the remaining occurrences of "Predicate" by "P"
(in both classes in copy/move from a predicate)
</li>
</ol>
</li>
<li>
<p>
I think you need to change the proposed signatures of not1 and not2, because
they would still remain unconstrained: To make them constrained at least a
single requirement needs to be added to enable requirement implication. This
could be done via a dummy ("requires True&lt;true&gt;") or just explicit as follows:
</p>
<ol type="a">
<li>
<blockquote><pre>template &lt;AdaptableUnaryFunction P&gt;
requires Predicate&lt; P, P::argument_type&gt;
unary_negate&lt;P&gt; not1(const P&amp;&amp; pred);
template &lt;AdaptableUnaryFunction P&gt;
requires Predicate&lt; P, P::argument_type &gt;
unary_negate&lt;P&gt; not1(P&amp;&amp; pred);
</pre>
<blockquote>
-3- Returns: unary_negate&lt;P&gt;(pred).
</blockquote>
</blockquote>
<p>
[Don't we want a move call for the second overload as in
</p>
<blockquote><pre>unary_negate&lt;P&gt;(std::move(pred))
</pre></blockquote>
<p>
in the Returns clause ?]
</p>
</li>
<li>
<pre>template &lt;AdaptableBinaryFunction P&gt;
requires Predicate&lt; P, P::first_argument_type, P::second_argument_type &gt;
binary_negate&lt;P&gt; not2(const P&amp; pred);
template &lt;AdaptableBinaryFunction P&gt;
requires Predicate&lt; P, P::first_argument_type, P::second_argument_type &gt;
binary_negate&lt;P&gt; not2(P&amp;&amp; pred);
</pre>
<p>
-5- Returns: binary_negate&lt;P&gt;(pred).
</p>
<p>
[Don't we want a move call for the second overload as in
</p>
<blockquote><pre>binary_negate&lt;P&gt;(std::move(pred))
</pre></blockquote>
<p>
in the Returns clause ?]
</p>
</li>
</ol>
</li>
</ol>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
There is concern that complicating the solution
to preserve the ABI seems unnecessary,
since we're not in general preserving the ABI.
</p>
<p>
We would prefer a separate paper consolidating all Clause 20
issues that are for the purpose of providing constrained versions
of the existing facilities.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[
2009-10 post-Santa Cruz:
]</i></p>


<blockquote>
Leave open pending the potential move constructor paper. Note that
we consider the "constraining" part NAD Concepts.
</blockquote>

<p><i>[
2010-01-31 Alisdair removes the current proposed wording from the proposed
wording section because it is based on concepts.  That wording is proposed here:
]</i></p>


<blockquote class="note">
<p>
Add new concepts where appropriate::
</p>

<blockquote><pre>auto concept AdaptableUnaryFunction&lt; typename X &gt; {
  typename X::result_type;
  typename X::argument_type;
}

auto concept AdaptableBinaryFunction&lt; typename X &gt; {
  typename X::result_type;
  typename X::first_argument_type;
  typename X::second_argument_type;
}
</pre></blockquote>

<p>
Revise as follows:
</p>

<p>
Base X [base] (Only change is constrained Result)
</p>

<blockquote>
<p>
-1-  The following classes are provided to simplify the typedefs of the
argument and result types:
</p>
<pre>namespace std {
  template &lt;class Arg, <del>class</del> <ins>ReturnType</ins> Result&gt;
  struct unary_function {
     typedef Arg    argument_type;
     typedef Result result_type;
  };

  template &lt;class Arg1, class Arg2, <del>class</del> <ins>ReturnType</ins> Result&gt;
  struct binary_function {
     typedef Arg1   first_argument_type;
     typedef Arg2   second_argument_type;
     typedef Result result_type;
  };
}
</pre></blockquote>

<p>
Negators 20.8.9 [negators]:
</p>

<blockquote>
<p>
-1- Negators <tt>not1</tt> and <tt>not2</tt> take a unary and a binary predicate,
respectively, and return their complements (5.3.1).
</p>

<pre>template &lt;<del>class</del> <ins>AdaptableUnaryFunction</ins> P<del>redicate</del>&gt;
  <ins>requires Predicate&lt; P, P::argument_type &gt;</ins>
  class unary_negate
    : public unary_function&lt;<del>typename</del> P<del>redicate</del>::argument_type,bool&gt; {
  public:
    <ins>unary_negate(const unary_negate &amp; ) = default;</ins>
    <ins>unary_negate(unary_negate &amp;&amp; );</ins>

    <ins>requires CopyConstructible&lt; P &gt;</ins>
       explicit unary_negate(const Predicate&amp; pred); 
    <ins>requires MoveConstructible&lt; P &gt;
       explicit unary_negate(Predicate &amp;&amp; pred);</ins>

    bool operator()(const <del>typename</del> P<del>redicate</del>::argument_type&amp; x) const;
  };
</pre>
<blockquote>
-2 <tt>operator()</tt> returns <tt>!pred(x)</tt>.
</blockquote>

<pre>template &lt;class Predicate&gt;
  unary_negate&lt;Predicate&gt; not1(const Predicate&amp;amp; pred);
<ins>template &lt;class Predicate&gt;
  unary_negate&lt;Predicate&gt; not1(Predicate&amp;&amp; pred);</ins>
</pre>
<blockquote>
-3-  <i>Returns:</i> <tt>unary_negate&lt;Predicate&gt;(pred)</tt>.
</blockquote>

<pre>template &lt;<del>class</del> <ins>AdaptableBinaryFunction</ins> P<del>redicate</del> &gt;
  <ins>requires Predicate&lt; P, P::first_argument_type, P::second_argument_type &gt;</ins>
  class binary_negate
    : public binary_function&lt;<del>typename</del> P<del>redicate</del>::first_argument_type,
                              <del>typename</del> P<del>redicate</del>::second_argument_type, bool&gt; {
  public:
    <ins>biary_negate(const binary_negate &amp; ) = default;</ins>
    <ins>binary_negate(binary_negate &amp;&amp; );</ins>

    <ins>requires CopyConstructible&lt; P &gt;</ins>
       explicit binary_negate(const Predicate&amp; pred);
    <ins>requires MoveConstructible&lt; P &gt;
       explicit binary_negate(const Predicate&amp; pred);</ins>

    bool operator()(const <del>typename</del> P<del>redicate</del>::first_argument_type&amp; x,
                    const <del>typename</del> P<del>redicate</del>::second_argument_type&amp; y) const;
  };
</pre>
<blockquote>
-4- <tt>operator()</tt> returns <tt>!pred(x,y)</tt>.
</blockquote>

<pre>template &lt;class Predicate&gt;
  binary_negate&lt;Predicate&gt; not2(const Predicate&amp; pred);
<ins>template &lt;class Predicate&gt;
  binary_negate&lt;Predicate&gt; not2(Predicate&amp;&amp; pred);</ins>
</pre>

<blockquote>
-5- <i>Returns:</i> <tt>binary_negate&lt;Predicate&gt;(pred)</tt>.
</blockquote>
</blockquote>

</blockquote>


<p><i>[
2010 Rapperswil:
]</i></p>


<blockquote>
Move to NAD Concepts.  The move-semantic part has been addressed by a core language change, which implicitly generates appropriate move constructors and move-assignment operators.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1077"></a>1077. Nonesense <tt>tuple</tt> declarations</h3>
<p><b>Section:</b> 20.4.2 [tuple.tuple] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-03-20 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#tuple.tuple">issues</a> in [tuple.tuple].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Class template tuple 20.4.2 [tuple.tuple]:
</p>

<blockquote><pre>template &lt;class... UTypes&gt;
  requires Constructible&lt;Types, const UTypes&amp;&gt;...
template &lt;class... UTypes&gt;
  requires Constructible&lt;Types, RvalueOf&lt;UTypes&gt;::type&gt;...
</pre></blockquote>

<p>
Somebody needs to look at this and say what it should be.
</p>

<p><i>[
2009-03-21 Daniel provided wording.
]</i></p>


<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
The resolution looks correct; move to NAD Editorial.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
In 20.4.2 [tuple.tuple], class <tt>tuple</tt>, change as indicated:
</p>

<blockquote><pre>template &lt;class... UTypes&gt;
  requires Constructible&lt;Types, const UTypes&amp;&gt;...
  <ins>tuple(const pair&lt;UTypes...&gt;&amp;);</ins>
template &lt;class... UTypes&gt;
  requires Constructible&lt;Types, RvalueOf&lt;UTypes&gt;::type&gt;...
  <ins>tuple(pair&lt;UTypes...&gt;&amp;&amp;);</ins>
</pre></blockquote>

<p>
[NB.: The corresponding prototypes do already exist in 20.4.2.1 [tuple.cnstr]/7+8]
</p>





<hr>
<h3><a name="1078"></a>1078. DE-17: Remove class type_index</h3>
<p><b>Section:</b> 20.13 [type.index] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Doug Gregor <b>Opened:</b> 2009-03-20 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses DE 17</b></p>

<p>
DE-17: 
</p>
<p>
The class <tt>type_index</tt> should be removed; it provides no additional
functionality beyond providing appropriate concept maps.
</p>

<p><i>[
2009-03-31 Peter adds:
]</i></p>


<blockquote>
<p>
It is not true, in principle, that <tt>std::type_index</tt> provides no  utility
compared to bare <tt>std::type_info*</tt>.
</p>
<p>
<tt>std::type_index</tt> can avoid the lifetime issues with <tt>type_info</tt> when  the
DLL that has produced the <tt>type_info</tt> object is unloaded. A raw
<tt>type_info*</tt> does not, and cannot, provide any protection in this  case.
A <tt>type_index</tt> can (if the implementor so chooses) because it  can wrap a
smart (counted or even cloning) pointer to the <tt>type_info</tt>  data that is
needed for <tt>name()</tt> and <tt>before()</tt> to work.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>Modify the header &lt;typeinfo&gt; synopsis in 
  18.7 [support.rtti]p1 as follows:</p>

<blockquote><pre>namespace std { 
  class type_info; 
  <del>class type_index;</del>
  template &lt;class T&gt; struct hash;
  template&lt;&gt; struct hash&lt;<del>type_index</del><ins>const type_info *</ins>&gt; : public std::unary_function&lt;<del>type_index</del><ins>const type_info *</ins>, size_t&gt; {
    size_t operator()(<del>type_index</del><ins>const type_info *</ins> <del>index</del><ins>t</ins>) const;
  }<ins>;</ins>
  <ins>concept_map LessThanComparable&lt;const type_info *&gt; <i>see below</i></ins>
  class bad_cast; 
  class bad_typeid;
}
</pre></blockquote>

<p>Add the following new subsection</p>
<blockquote>
<p>
<ins>18.7.1.1 Template specialization <code>hash&lt;const type_info *&gt;</code>
[type.info.hash]</ins></p>

<pre><ins>size_t operator()(const type_info *x) const;</ins>
</pre>
<ol>
<li><ins><i>Returns</i>: <code>x-&gt;hash_code()</code></ins></li>
</ol>
</blockquote>

 <p>Add the following new subsection</p>
 <blockquote>
<p><ins>18.7.1.2 <code>type_info</code> concept map [type.info.concepts]</ins></p>


<pre><ins>concept_map LessThanComparable&lt;const type_info *&gt; {</ins>
  <ins>bool operator&lt;(const type_info *x, const type_info *y) { return x-&gt;before(*y); }</ins>
  <ins>bool operator&lt;=(const type_info *x, const type_info *y) { return !y-&gt;before(*x); }</ins>
  <ins>bool operator&gt;(const type_info *x, const type_info *y) { return y-&gt;before(*x); }</ins>
  <ins>bool operator&gt;=(const type_info *x, const type_info *y) { return !x-&gt;before(*y); }</ins>
<ins>}</ins>
</pre>
<ol>
  <li><ins><i>Note</i>: provides a well-defined ordering among
  <code>type_info const</code> pointers, which makes such pointers
  usable in associative containers (23.4).</ins></li>
</ol>
</blockquote>

<p>Remove section 20.13 [type.index]</p>





<hr>
<h3><a name="1080"></a>1080. Concept ArithmeticLike should provide explicit boolean  conversion</h3>
<p><b>Section:</b> X [concept.arithmetic] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-03-21 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Astonishingly, the current concept ArithmeticLike as specified in
X [concept.arithmetic] does not provide explicit conversion
to <tt>bool</tt> although this is a common property of arithmetic types
(4.12 [conv.bool]). Recent proposals that introduced such types
(integers of arbitrary precision,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2143.pdf">n2143</a>,
decimals
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2732.pdf">n2732</a>
indirectly
via conversion to <tt>long long</tt>) also took care of such a feature.
</p>
<p>
Adding such an explicit conversion associated function would also
partly solve a currently invalid effects clause in library, which bases
on this property, 24.2.7 [random.access.iterators]/2:
</p>
<blockquote><pre>{ difference_type m = n;
 if (m &gt;= 0) while (m--) ++r;
 else while (m++) --r;
 return r; }
</pre></blockquote>

<p>
Both while-loops take advantage of a contextual conversion to <tt>bool</tt>
(Another problem is that the &gt;= comparison uses the no
longer supported existing implicit conversion from <tt>int</tt> to <tt>IntegralLike</tt>).
</p>

<b>Original proposed resolution:</b>
<ol>
<li>
<p>
In X [concept.arithmetic], add to the list of less refined
concepts one further concept:
</p>

<blockquote><pre>concept ArithmeticLike&lt;typename T&gt;
  : Regular&lt;T&gt;, LessThanComparable&lt;T&gt;, HasUnaryPlus&lt;T&gt;, HasNegate&lt;T&gt;,
    HasPlus&lt;T, T&gt;, HasMinus&lt;T, T&gt;, HasMultiply&lt;T, T&gt;, HasDivide&lt;T, T&gt;,
    HasPreincrement&lt;T&gt;, HasPostincrement&lt;T&gt;, HasPredecrement&lt;T&gt;,
    HasPostdecrement&lt;T&gt;,
    HasPlusAssign&lt;T, const T&amp;&gt;, HasMinusAssign&lt;T, const T&amp;&gt;,
    HasMultiplyAssign&lt;T, const T&amp;&gt;,
    HasDivideAssign&lt;T, const T&amp;&gt;<ins>, ExplicitlyConvertible&lt;T, bool&gt;</ins> {
</pre></blockquote>
</li>
<li>
<p>
In 24.2.7 [random.access.iterators]/2 change the current effects clause
as indicated [The proposed insertion fixes the problem that the previous
implicit construction from integrals has been changed to an explicit
constructor]:
</p>
<blockquote><pre>{ difference_type m = n;
 if (m &gt;= <ins>difference_type(</ins>0<ins>)</ins>) while (m--) ++r;
 else while (m++) --r;
 return r; }
</pre></blockquote>
</li>
</ol>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree that arithmetic types ought be convertible to <tt>bool</tt>,
and we therefore agree with the proposed resolution's paragraph 1.
</p>
<p>
We do not agree that the cited effects clause is invalid,
as it expresses intent rather than specific code.
</p>
<p>
Move to Review, pending input from concepts experts.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
In X [concept.arithmetic], add to the list of less refined
concepts one further concept:
</p>

<blockquote><pre>concept ArithmeticLike&lt;typename T&gt;
  : Regular&lt;T&gt;, LessThanComparable&lt;T&gt;, HasUnaryPlus&lt;T&gt;, HasNegate&lt;T&gt;,
    HasPlus&lt;T, T&gt;, HasMinus&lt;T, T&gt;, HasMultiply&lt;T, T&gt;, HasDivide&lt;T, T&gt;,
    HasPreincrement&lt;T&gt;, HasPostincrement&lt;T&gt;, HasPredecrement&lt;T&gt;,
    HasPostdecrement&lt;T&gt;,
    HasPlusAssign&lt;T, const T&amp;&gt;, HasMinusAssign&lt;T, const T&amp;&gt;,
    HasMultiplyAssign&lt;T, const T&amp;&gt;,
    HasDivideAssign&lt;T, const T&amp;&gt;<ins>, ExplicitlyConvertible&lt;T, bool&gt;</ins> {
</pre></blockquote>





<hr>
<h3><a name="1081"></a>1081. Response to UK 216</h3>
<p><b>Section:</b> 21 [strings] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-03-22 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#strings">issues</a> in [strings].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses UK 216, JP 46, JP 48</b></p>

<p>
All the containers use concepts for their iterator usage, exect for
<tt>basic_string</tt>. This needs fixing.
</p>

<p>
Use concepts for iterator template parameters throughout the chapter.
</p>

<p><i>[
Summit:
]</i></p>

<blockquote>
NB comments to be handled by Dave Abrahams and Howard Hinnant with
advice from PJP: UK216 (which duplicates) JP46, JP48. JP46 supplies
extensive proposed wording; start there.
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1082"></a>1082. Response to JP 49</h3>
<p><b>Section:</b> 22 [localization] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-03-22 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#localization">issues</a> in [localization].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses JP 49</b></p>

<p>
<tt>codecvt</tt> does not use concept. For example, create <tt>CodeConvert</tt>
concept and change as follows.
</p>

<blockquote><pre>template&lt;CodeConvert Codecvt, class Elem = wchar_t&gt;
  class wstring_convert {
</pre></blockquote>

<p><i>[
Summit:
]</i></p>

<blockquote>
To be handled by Howard Hinnant, Dave Abrahams, Martin Sebor, PJ Plauger.
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1083"></a>1083. Response to JP 52, 53</h3>
<p><b>Section:</b> 22 [localization] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-03-22 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#localization">issues</a> in [localization].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses JP 52, JP 53</b></p>

<p>
<tt>InputIterator</tt> does not use concept.
</p>

<p>
<tt>OutputIterator</tt> does not use concept.
</p>

<p>
Comments include proposed wording.
</p>

<p><i>[
Summit:
]</i></p>

<blockquote>
To be handled by Howard Hinnant, Dave Abrahams, Martin Sebor, PJ Plauger.
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1084"></a>1084. Response to UK 250</h3>
<p><b>Section:</b> 24.2.5 [forward.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-03-22 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#forward.iterators">issues</a> in [forward.iterators].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses UK 250</b></p>

<p>
A default implementation should be supplied for the post-increment
operator to simplify implementation of iterators by users.
</p>

<p>
Copy the Effects clause into the concept description as the default
implementation. Assumes a default value for postincrement_result
</p>

<p><i>[
Summit:
]</i></p>

<blockquote>
Howard will open an issue.
</blockquote>

<p><i>[
2009-06-07 Daniel adds:
]</i></p>


<blockquote>
This issue cannot currently be resolved as suggested, because
that would render auto-detection of the return type
<tt>postincrement_result</tt> invalid, see  [concept.map.assoc]/4+5. The
best fix would be to add a default type to that associated type, but
unfortunately any default type will prevent auto-deduction of types of
associated functions as quoted above. A corresponding core issue
is in preparation.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p><i>[
This wording assumes the acceptance of UK 251 / <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1009">1009</a>.  Both
wordings change the same paragraphs.
]</i></p>


<p>
Change 24.2.5 [forward.iterators]:
</p>

<blockquote>
<pre>concept ForwardIterator&lt;typename X&gt; : InputIterator&lt;X&gt;, Regular&lt;X&gt; { 

  MoveConstructible postincrement_result;
  requires HasDereference&lt;postincrement_result&gt;
        &amp;&amp; Convertible&lt;HasDereference&lt;postincrement_result&gt;::result_type, const value_type&amp;&gt;;

  postincrement_result operator++(X&amp; r, int)<del>;</del> <ins>{
     X tmp = r;
     ++r;
     return tmp;
  }</ins>

  axiom MultiPass(X a, X b) { 
    if (a == b) *a == *b; 
    if (a == b) ++a == ++b; 
  } 
}
</pre></blockquote>






<hr>
<h3><a name="1085"></a>1085. Response to UK 258</h3>
<p><b>Section:</b> 24.2.6 [bidirectional.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-03-22 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#bidirectional.iterators">issues</a> in [bidirectional.iterators].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses UK 258</b></p>

<p>
A default implementation should be supplied for the post-decrement
operator to simplify implementation of iterators by users.
</p>

<p>
Copy the Effects clause into the concept description as the default
implementation. Assumes a default value for postincrement_result
</p>

<p><i>[
Summit:
]</i></p>

<blockquote>
Howard will open an issue.
</blockquote>

<p><i>[
2009-06-07 Daniel adds:
]</i></p>


<blockquote>
This issue cannot currently be resolved as suggested, because
that would render auto-detection of the return type
<tt>postdecrement_result</tt> invalid, see <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1084">1084</a>.
</blockquote>


<p><b>Proposed resolution:</b></p>

<p>
Change 24.2.6 [bidirectional.iterators]:
</p>

<blockquote>
<pre>concept BidirectionalIterator&lt;typename X&gt; : ForwardIterator&lt;X&gt; { 
  MoveConstructible postdecrement_result; 
  requires HasDereference&lt;postdecrement_result&gt; 
        &amp;&amp; Convertible&lt;HasDereference&lt;postdecrement_result&gt;::result_type, const value_type&amp;&gt; 
        &amp;&amp; Convertible&lt;postdecrement_result, const X&amp;&gt;; 
  X&amp; operator--(X&amp;); 
  postdecrement_result operator--(X&amp; <ins>r</ins>, int)<del>;</del> <ins>{
     X tmp = r;
     --r;
     return tmp;
  }</ins>
}
</pre></blockquote>






<hr>
<h3><a name="1086"></a>1086. Response to UK 284</h3>
<p><b>Section:</b> 24.6 [stream.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-03-22 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses UK 284</b></p>

<p>
The stream iterators need constraining with concepts/requrires clauses.
</p>

<p><i>[
Summit:
]</i></p>

<blockquote>
We agree. To be handled by Howard, Martin and PJ.
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1087"></a>1087. Response to UK 301</h3>
<p><b>Section:</b> 25.3.5 [alg.replace] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-03-22 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.replace">issues</a> in [alg.replace].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses UK 301</b></p>

<p>
<tt>replace</tt> and <tt>replace_if</tt> have the requirement: <tt>OutputIterator&lt;Iter,
Iter::reference&gt;</tt> Which implies they need to copy some values in the
range the algorithm is iterating over. This is not however the case, the
only thing that happens is <tt>const T&amp;</tt>s might be copied over existing
elements (hence the <tt>OutputIterator&lt;Iter, const T&amp;&gt;</tt>.
</p>

<p>
Remove <tt>OutputIterator&lt;Iter, Iter::reference&gt;</tt> from <tt>replace</tt>
and <tt>replace_if</tt>.
</p>

<p><i>[
Summit:
]</i></p>

<blockquote>
We agree. To be handled by Howard.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change in  [algorithms.syn] and 25.3.5 [alg.replace]:
</p>

<blockquote><pre>template&lt;ForwardIterator Iter, class T&gt; 
  requires <del>OutputIterator&lt;Iter, Iter::reference&gt; 
        &amp;&amp;</del> OutputIterator&lt;Iter, const T&amp;&gt; 
        &amp;&amp; HasEqualTo&lt;Iter::value_type, T&gt; 
  void replace(Iter first, Iter last, 
               const T&amp; old_value, const T&amp; new_value); 

template&lt;ForwardIterator Iter, Predicate&lt;auto, Iter::value_type&gt; Pred, class T&gt; 
  requires <del>OutputIterator&lt;Iter, Iter::reference&gt; 
        &amp;&amp;</del> OutputIterator&lt;Iter, const T&amp;&gt; 
        &amp;&amp; CopyConstructible&lt;Pred&gt; 
  void replace_if(Iter first, Iter last,
                  Pred pred, const T&amp; new_value);
</pre></blockquote>





<hr>
<h3><a name="1088"></a>1088. Response to UK 342</h3>
<p><b>Section:</b> 30.6.5 [futures.promise] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-03-22 <b>Last modified:</b> 2010-10-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#futures.promise">active issues</a> in [futures.promise].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#futures.promise">issues</a> in [futures.promise].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses UK 342</b></p>

<p>
<tt>std::promise</tt> is missing a non-member overload of <tt>swap</tt>. This is
inconsistent with other types that provide a <tt>swap</tt> member function.
</p>

<p>
Add a non-member overload <tt>void swap(promise&amp;&amp; x,promise&amp;&amp; y){ x.swap(y); }</tt>
</p>

<p><i>[
Summit:
]</i></p>

<blockquote>
Create an issue. Move to review, attention: Howard. Detlef will also
look into it.
</blockquote>

<p><i>[
Post Summit Daniel provided wording.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2997.html">N2997</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
In 30.6.5 [futures.promise], before p.1, immediately after class template
promise add:
</p>
<blockquote><pre><ins>
template &lt;class R&gt;
void swap(promise&lt;R&gt;&amp; x, promise&lt;R&gt;&amp; y);
</ins>
</pre></blockquote>
</li>
<li>
<p>
Change 30.6.5 [futures.promise]/10 as indicated (to fix a circular definition):
</p>
<blockquote>
<p>
-10- <i>Effects:</i> <del>swap(*this, other)</del><ins>Swaps the associated state
of <tt>*this</tt> and <tt>other</tt></ins>
</p>
<p>
<ins><i>Throws:</i> Nothing.</ins>
</p>
</blockquote>
</li>
<li>
<p>
After the last paragraph in 30.6.5 [futures.promise] add the following
prototype description:
</p>
<blockquote><pre><ins>
template &lt;class R&gt;
void swap(promise&lt;R&gt;&amp; x, promise&lt;R&gt;&amp; y);
</ins></pre>
<blockquote>
<p>
<ins><i>Effects:</i> <tt>x.swap(y)</tt></ins>
</p>
<p>
<ins><i>Throws:</i> Nothing.</ins>
</p>
</blockquote>
</blockquote>
</li>

</ol>






<hr>
<h3><a name="1090"></a>1090. Missing description of <tt>packaged_task</tt> member <tt>swap</tt>,  missing non-member <tt>swap</tt></h3>
<p><b>Section:</b> 30.6.10 [futures.task] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-03-22 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#futures.task">issues</a> in [futures.task].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Class template <tt>packaged_task</tt> in 30.6.10 [futures.task] shows a member <tt>swap</tt>
declaration, but misses to
document it's effects (No prototype provided). Further on this class
misses to provide a non-member
swap.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Alisdair notes that paragraph 2 of the proposed resolution has already been
applied in the current Working Draft.
</p>
<p>
We note a pending <tt>future</tt>-related paper by Detlef;
we would like to wait for this paper before proceeding.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[
2009-05-24 Daniel removed part 2 of the proposed resolution.
]</i></p>


<p><i>[
2009-10 post-Santa Cruz:
]</i></p>


<blockquote>
Move to Tentatively Ready, removing bullet 3 from the proposed
resolution but keeping the other two bullets.
</blockquote>

<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote>
Moved to NAD Editorial.  Rationale added below.
</blockquote>



<p><b>Rationale:</b></p>
<p>
Solved by N3058.
</p>


<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
In 30.6.10 [futures.task], immediately after the definition of class
template packaged_task add:
</p>
<blockquote><pre><ins>
template&lt;class R, class... Argtypes&gt;
void swap(packaged_task&lt;R(ArgTypes...)&gt;&amp;, packaged_task&lt;R(ArgTypes...)&gt;&amp;);
</ins>
</pre></blockquote>
</li>
</ol>

<ol start="4">

<li>
<p>
At the end of 30.6.10 [futures.task] (after p. 20), add add the following
prototype description:
</p>

<blockquote><pre><ins>
template&lt;class R, class... Argtypes&gt;
void swap(packaged_task&lt;R(ArgTypes...)&gt;&amp; x, packaged_task&lt;R(ArgTypes...)&gt;&amp; y);
</ins></pre>
<blockquote>
<p><ins>
<i>Effects:</i> <tt>x.swap(y)</tt>
</ins></p>
<p><ins>
<i>Throws:</i> Nothing.
</ins></p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="1091"></a>1091. Multimap description confusing</h3>
<p><b>Section:</b> 23.6.2.2 [multimap.modifiers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-03-22 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 246</b></p>
<p>
The content of this sub-clause is purely trying to describe in words the
effect of the requires clauses on these operations, now that we have
Concepts. As such, the description is more confusing than the signature
itself. The semantic for these functions is adequately covered in the
requirements tables in 23.2.4 [associative.reqmts].
</p>

<p><i>[
Beman adds:
]</i></p>


<blockquote>
Pete is clearly right that
this one is technical rather than editorial.
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with the proposed resolution.
</p>
<p>
Move to Review.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Mark as NAD, solved by removing concepts.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Strike 23.6.2.2 [multimap.modifiers] entirely
(but do NOT strike these signatures from the class template definition!).
</p>





<hr>
<h3><a name="1092"></a>1092. Class template <tt>integral_constant</tt> should be a  constrained template</h3>
<p><b>Section:</b> 20.7.3 [meta.help] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-03-22 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta.help">issues</a> in [meta.help].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
A first step to change the type traits predicates to constrained templates is to
constrain their common base template <tt>integral_constant</tt>. This can be done,
without enforcing depending classes to be constrained as well, but not
vice versa
without brute force <tt>late_check</tt> usages. The following proposed resolution depends
on the resolution of LWG issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1019">1019</a>.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to Open, pending a paper that looks at constraints
for the entirety of the type traits
and their relationship to the foundation concepts.
We recommend this be deferred
until after the next Committee Draft is issued.
</blockquote>


<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
In 20.7.2 [meta.type.synop], Header <tt>&lt;type_traits&gt;</tt>
synopsis change as indicated:
</p>
<blockquote><pre>namespace std {
// 20.5.3, helper class:
template &lt;<del>class</del><ins>IntegralConstantExpressionType</ins> T, T v&gt; struct integral_constant;
</pre></blockquote>
</li>
<li>
<p>
In 20.7.3 [meta.help] change as indicated:
</p>
<blockquote><pre>template &lt;<del>class</del><ins>IntegralConstantExpressionType</ins> T, T v&gt;
struct integral_constant {
  static constexpr T value = v;
  typedef T value_type;
  typedef integral_constant&lt;T,v&gt; type;
  constexpr operator value_type() { return value; }
};
</pre></blockquote>
</li>
</ol>





<hr>
<h3><a name="1093"></a>1093. Multiple definitions for random_shuffle algorithm</h3>
<p><b>Section:</b> 25.3.12 [alg.random.shuffle] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-22 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.random.shuffle">issues</a> in [alg.random.shuffle].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p>
There are a couple of issues with the declaration of the <tt>random_shuffle</tt>
algorithm accepting a random number engine.
</p>

<ol type="i">
<li>
The Iterators must be shuffle iterators, yet this requirement is missing.
</li>
<li>
The <tt>RandomNumberEngine</tt> concept is now provided by the random number
library
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2836.pdf">n2836</a>)
and the placeholder should be removed.
</li>
</ol>

<p><i>[
2009-05-02 Daniel adds:
]</i></p>


<blockquote>
<p>
this issue completes adding necessary requirement to the
third new <tt>random_shuffle</tt> overload. The current suggestion is:
</p>

<blockquote><pre>template&lt;RandomAccessIterator Iter, UniformRandomNumberGenerator Rand&gt;
requires ShuffleIterator&lt;Iter&gt;
void random_shuffle(Iter first, Iter last, Rand&amp;&amp; g);
</pre></blockquote>

<p>
IMO this is still insufficient and I suggest to add the requirement
</p>
<blockquote><pre>Convertible&lt;Rand::result_type, Iter::difference_type&gt;
</pre></blockquote>
<p>
to the list (as the two other overloads already have).
</p>

<p>
Rationale:
</p>

<blockquote>
<p>
Its true that this third overload is somewhat different from the remaining
two. Nevertheless we know from <tt>UniformRandomNumberGenerator</tt>, that
it's <tt>result_type</tt> is an integral type and that it satisfies
<tt>UnsignedIntegralLike&lt;result_type&gt;</tt>.
</p>
<p>
To realize it's designated task, the algorithm has to invoke the
<tt>Callable</tt> aspect of <tt>g</tt> and needs to perform some algebra involving
it's <tt>min()/max()</tt> limits to compute another index value that
at this point is converted into <tt>Iter::difference_type</tt>. This is so,
because 24.2.7 [random.access.iterators] uses this type as argument
of it's algebraic operators. Alternatively consider the equivalent
iterator algorithms in 24.4.4 [iterator.operations] with the same result.
</p>
<p>
This argument leads us to the conclusion that we also need
<tt>Convertible&lt;Rand::result_type, Iter::difference_type&gt;</tt> here.
</p>
</blockquote>

</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Alisdair notes that point (ii) has already been addressed.
</p>
<p>
We agree with the proposed resolution to point (i)
with Daniel's added requirement.
</p>
<p>
Move to Review.
</p>
</blockquote>

<p><i>[
2009-06-05 Daniel updated proposed wording as recommended in Batavia.
]</i></p>


<p><i>[
2009-07-28 Alisdair adds:
]</i></p>


<blockquote>
Revert to Open, with a note there is consensus on direction but the
wording needs updating to reflect removal of concepts.
</blockquote>

<p><i>[
2009-10 post-Santa Cruz:
]</i></p>


<blockquote>
Leave Open, Walter to work on it.
</blockquote>

<p><i>[
2010 Pittsburgh:  Moved to NAD Editorial, solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3056.pdf">N3056</a>.
]</i></p>




<p><b>Rationale:</b></p>
<p>
Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3056.pdf">N3056</a>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change in  [algorithms.syn] and 25.3.12 [alg.random.shuffle]:
</p>

<blockquote><pre><del>concept UniformRandomNumberGenerator&lt;typename Rand&gt; { }</del>
template&lt;RandomAccessIterator Iter, UniformRandomNumberGenerator Rand&gt;
  <ins>requires ShuffleIterator&lt;Iter&gt; &amp;&amp;
  Convertible&lt;Rand::result_type, Iter::difference_type&gt;</ins>
  void random_shuffle(Iter first, Iter last, Rand&amp;&amp; g);
</pre></blockquote>






<hr>
<h3><a name="1096"></a>1096. unconstrained rvalue ref parameters</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> David Abrahams <b>Opened:</b> 2009-03-21 <b>Last modified:</b> 2010-10-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
TODO: Look at all cases of unconstrained rvalue ref parameters and check
that concept req'ts work when <tt>T</tt> deduced as reference.
</p>

<p>
 We found some instances where that was not done correctly and we figure
   the possibility of deducing <tt>T</tt> to be an lvalue reference was probably
   overlooked elsewhere.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to Open, pending proposed wording from Dave for further review.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="1099"></a>1099. Various issues</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> David Abrahams <b>Opened:</b> 2009-03-21 <b>Last modified:</b> 2010-10-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Notes
</p>
<blockquote>
<p>
[2009-03-21 Sat] p. 535 at the top we need MoveConstructible V1,
MoveConstructible V2 (where V1,V2 are defined on 539).  Also make_tuple
on 550
</p>

<blockquote>
<p>
CD-1 reads:
</p>

<blockquote><pre>template &lt;MoveConstructible T1, MoveConstructible T2&gt; 
pair&lt;V1, V2&gt; make_pair(T1&amp;&amp;, T2&amp;&amp;); 
</pre></blockquote>

<p>
Actually I'm guessing we need something like <tt>MoveConstructible&lt;V1,T1&gt;</tt>,
i.e. "<tt>V1</tt> can be constructed from an rvalue of type <tt>T1</tt>."
</p>

<p>
Ditto for <tt>make_tuple</tt>
</p>
</blockquote>

<p>
[2009-03-21 Sat] p1183 thread ctor, and in general, we need a way to
talk about "copiable from generalized rvalue ref argument" for cases
where we're going to forward and copy.  
</p>
<blockquote>
<p>
   This issue may well be quite large.  Language in para 4 about "if
   an lvalue" is wrong because types aren't expressions.
</p>

<blockquote>
<p>
Maybe we should define the term "move" so we can just say in the
effects, "<tt>f</tt> is moved into the newly-created thread" or something, and
agree (and ideally document) that saying "<tt>f</tt> is moved" implies 
</p>

<blockquote><pre>F x(move(f))
</pre></blockquote>

<p>
is required to work.  That would cover both ctors at once.
</p>
</blockquote>

<p>
   p1199, call_once has all the same issues.
</p>
</blockquote>
<p>
[2009-03-21 Sat] p869 InputIterator pointer type should not be required
to be convertible to const value_type*, rather it needs to have a
operator-&gt; of its own that can be used for the value type.
</p>

<blockquote>
This one is serious and unrelated to the move issue.
</blockquote>

<p>
[2009-03-21 Sat] p818 stack has the same problem with default ctor.
</p>
<p>
[2009-03-21 Sat] p816 priority_queue has the same sorts of problems as queue, only more so
</p>
<blockquote><pre>   requires MoveConstructible&lt;Cont&gt; 
     explicit priority_queue(const Compare&amp; x = Compare(), Cont&amp;&amp; = Cont()); 
</pre>
<p>
   Don't require MoveConstructible when default constructing Cont.
   Also missing semantics for move ctor.
</p>
</blockquote>
<p>
 [2009-03-21 Sat] Why are Allocators required to be CopyConstructible as
 opposed to MoveConstructible?
</p>
<p>
 [2009-03-21 Sat] p813 queue needs a separate default ctor (Cont needn't
 be MoveConstructible).  No documented semantics for move c'tor.  Or
 *any* of its 7 ctors!
</p>
<p>
 [2009-03-21 Sat] std::array should have constructors for C++0x,
 consequently must consider move construction.
</p>

<p><i>[
2009-05-01 Daniel adds:
]</i></p>


<blockquote>
This could be done as part of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1035">1035</a>, which already handles
deviation of <tt>std::array</tt> from container tables.
</blockquote>

<p>
 [2009-03-21 Sat] p622 all messed up.
</p>
<blockquote>
<p>
   para 8 "implementation-defined" is the wrong term; should be "see
   below" or something.  
</p>
<p>
   para 12 "will be selected" doesn't make any sense because we're not
   talking about actual arg types.
</p>
<p>
   paras 9-13 need to be totally rewritten for concepts.
</p>
</blockquote>

<p>
 [2009-03-21 Sat] Null pointer comparisons (p587) have all become
 unconstrained.  Need to fix that
</p>
<p>
 [2009-03-21 Sat] mem_fun_t etc. definition doesn't match declaration.
  We think CopyConstructible is the right reqt.
</p>
<p>
 make_pair needs Constructible&lt;V1, T1&amp;&amp;&gt; requirements!
</p>
<p>
 make_tuple needs something similar
</p>
<p>
 tuple bug in synopsis:
</p>
<blockquote><pre>   template &lt;class... UTypes&gt;
   requires Constructible&lt;Types, const UTypes&amp;&gt;...
   template &lt;class... UTypes&gt;
   requires Constructible&lt;Types, RvalueOf&lt;UTypes&gt;::type&gt;...
</pre>
<p>
   Note: removal of MoveConstructible requirements in std::function makes
   these routines unconstrained!
</p>
</blockquote>

<p><i>[
2009-05-02 Daniel adds:
]</i></p>


<blockquote>
This part of the issue is already covered by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1077">1077</a>.
</blockquote>

<p>
 these unique_ptr constructors are broken [ I think this is covered in "p622 all messed up" ]
</p>
<blockquote><pre> unique_ptr(pointer p, implementation-defined d);
 unique_ptr(pointer p, implementation-defined d);
</pre></blockquote>
<p>
 multimap range constructor should not have MoveConstructible&lt;value_type&gt; requirement.
</p>
<blockquote>
   same with insert(..., P&amp;&amp;); multiset has the same issue, as do
   unordered_multiset and unordered_multimap. Review these!
</blockquote>

</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to Open, pending proposed wording from Dave for further review.
</blockquote>

<p><i>[
2009-10 post-Santa Cruz:
]</i></p>


<blockquote>
Tentatively NAD.  We are not sure what has been addressed and what hasn't.
Recommend closing unless someone sorts this out into something more readable.
</blockquote>



<p><b>Rationale:</b></p>
<p>
The issue(s) at hand not adequately communicated.
</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="1101"></a>1101. <tt>unique</tt> requirements</h3>
<p><b>Section:</b> 25.3.9 [alg.unique] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-04-25 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.unique">issues</a> in [alg.unique].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
From Message c++std-core-14160 Howard wrote:
</p>

<blockquote>
It was the intent of the rvalue reference proposal for unique to only require MoveAssignable:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1860.html#25.2.9%20-%20Unique">N1860</a>.
</blockquote>

<p>
And Pete replied:
</p>

<blockquote>
That was overridden by the subsequent changes made for concepts in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2573.pdf">N2573</a>,
which reimposed the C++03 requirements.
</blockquote>

<p>
My impression is that this overwrite was a simple (unintentional) mistake.
Wording below to correct it.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Howard notes this issue resolves a discrepancy between the synopsis
and the description.
</p>
<p>
Move to NAD Editorial.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change 25.3.9 [alg.unique]:
</p>

<blockquote><pre>template&lt;ForwardIterator Iter&gt; 
  requires OutputIterator&lt;Iter, <ins>RvalueOf&lt;</ins>Iter::reference<ins>&gt;::type</ins>&gt; 
        &amp;&amp; EqualityComparable&lt;Iter::value_type&gt; 
  Iter unique(Iter first, Iter last); 

template&lt;ForwardIterator Iter, EquivalenceRelation&lt;auto, Iter::value_type&gt; Pred&gt; 
  requires OutputIterator&lt;Iter, RvalueOf&lt;Iter::reference&gt;::type&gt; 
        &amp;&amp; CopyConstructible&lt;Pred&gt; 
  Iter unique(Iter first, Iter last, Pred pred);
</pre></blockquote>

<p>
Note that the synopsis in  [algorithms.syn] is already correct.
</p>






<hr>
<h3><a name="1102"></a>1102. <tt>std::vector</tt>'s reallocation policy still unclear</h3>
<p><b>Section:</b> 23.4.1.2 [vector.capacity] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-04-20 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#vector.capacity">issues</a> in [vector.capacity].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I have the impression that even the wording of current draft
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2857.pdf">N2857</a>
does insufficiently express the intent of <tt>vector</tt>'s
reallocation strategy. This has produced not too old library
implementations which release memory in the <tt>clear()</tt> function
and even modern articles about C++ programming cultivate
the belief that <tt>clear</tt> is allowed to do exactly this. A typical
example is something like this:
</p>

<blockquote><pre>const int buf_size = ...;
std::vector&lt;T&gt; buf(buf_size);
for (int i = 0; i &lt; some_condition; ++i) {
  buf.resize(buf_size);
  write_or_read_data(buf.data());
  buf.clear(); // Ensure that the next round get's 'zeroed' elements
}
</pre></blockquote>
<p>
where still the myth is ubiquitous that <tt>buf</tt> might be
allowed to reallocate it's memory *inside* the <tt>for</tt> loop.
</p>
<p>
IMO the problem is due to the fact, that
</p>

<ol type="a">
<li>
the actual memory-reallocation stability of <tt>std::vector</tt>
is explained in 23.4.1.2 [vector.capacity]/3 and /6 which
are describing just the effects of the <tt>reserve</tt>
function, but in many examples (like above) there
is no explicit call to <tt>reserve</tt> involved. Further-more
23.4.1.2 [vector.capacity]/6 does only mention <em>insertions</em>
and never mentions the consequences of erasing
elements.
</li>
<li>
<p>
the effects clause of <tt>std::vector</tt>'s <tt>erase</tt> overloads in
23.4.1.4 [vector.modifiers]/4 is silent about capacity changes. This
easily causes a misunderstanding, because the counter
parting insert functions described in 23.4.1.4 [vector.modifiers]/2
explicitly say, that
</p>
<blockquote>
Causes reallocation if the new size is greater than the
old capacity. If no reallocation happens, all the iterators
and references before the insertion point remain valid.
</blockquote>
<p>
It requires a complex argumentation chain about four
different places in the standard to provide the - possibly
weak - proof that calling <tt>clear()</tt> also does <em>never</em> change
the capacity of the <tt>std::vector</tt> container. Since <tt>std::vector</tt>
is the de-facto replacement of C99's dynamic arrays this
type is near to a built-in type and it's specification should
be clear enough that usual programmers can trust their
own reading.
</p>
</li>
</ol>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Bill believes paragraph 1 of the proposed resolution is unnecessary
because it is already implied (even if tortuously) by the current wording.
</p>
<p>
Move to Review.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Mark as NAD. Rationale: there is no consensus to clarify the standard,
general consensus that the standard is correct as written.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p><i>[
This is a minimum version. I also
suggest that the wording explaining the allocation strategy
of <tt>std::vector</tt> in 23.4.1.2 [vector.capacity]/3 and /6 is moved into
a separate sub paragraph of 23.4.1.2 [vector.capacity] <em>before</em>
any of the prototype's are discussed, but I cannot provide
reasonable wording changes now
]</i></p>


<ol>
<li>
<p>
Change 23.4.1.2 [vector.capacity]/6 as follows:
</p>
<blockquote>
It is guaranteed that no reallocation takes place during
insertions <ins>or erasures</ins> that happen after a call
to <tt>reserve()</tt> until the time when an insertion would make
the size of the vector greater than the value of <tt>capacity()</tt>.
</blockquote>
</li>
<li>
<p>
Change 23.4.1.4 [vector.modifiers]/4 as follows:
</p>
<blockquote>
<i>Effects:</i> <ins>The capacity shall remain unchanged and no reallocation shall
happen.</ins>
Invalidates iterators and references at or after the point
of the erase.
</blockquote>
</li>
</ol>





<hr>
<h3><a name="1105"></a>1105. Shouldn't <tt>Range</tt> be an <tt>auto concept</tt></h3>
<p><b>Section:</b> X [iterator.concepts.range] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> David Abrahams <b>Opened:</b> 2009-04-23 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><i>[
2009-04-26 Herb adds:
]</i></p>


<blockquote>
<p>
Here's a common example: We have many ISV customers who have built lots of
in-house STL-like containers. Imagine that, for the past ten years, the user
has been happily using his <tt>XYZCorpContainer&lt;T&gt;</tt> that has <tt>begin()</tt> and <tt>end()</tt>
and an iterator typedef, and indeed satisfies nearly all of <tt>Container</tt>,
though maybe not quite all just like <tt>valarray</tt>. The user upgrades to a
range-enabled version of a library, and now <tt>lib_algo( xyz.begin(), xyz.end());</tt>
no longer works -- compiler error.
</p>
<p>
Even though <tt>XYZCorpContainer</tt> matches the pre-conceptized version of the
algorithm, and has been working for years, it appears the user has to write
at least this:
</p>
<blockquote><pre>template&lt;class T&gt; concept_map Range&lt;XYZCorpContainer&lt;T&gt;&gt; {};

template&lt;class T&gt; concept_map Range&lt;const XYZCorpContainer&lt;T&gt;&gt; {};
</pre></blockquote>
<p>
Is that correct?
</p>
<p>
But he may actually have to write this as we do for initializer list:
</p>
<blockquote><pre>template&lt;class T&gt;
concept_map Range&lt;XYZCorpContainer&lt;T&gt;&gt; {
   typedef T* iterator;
   iterator begin(XYZCorpContainer&lt;T&gt; c) { return c.begin(); }
   iterator end(XYZCorpContainer&lt;T&gt; c) { return c.end(); }
};

template&lt;class T&gt;
concept_map Range&lt;const XYZCorpContainer&lt;T&gt;&gt; {
   typedef T* iterator;
   iterator begin(XYZCorpContainer&lt;T&gt; c) { return c.begin(); }
   iterator end(XYZCorpContainer&lt;T&gt; c) { return c.end(); }
};
</pre></blockquote>

</blockquote>

<p><i>[
2009-04-28 Alisdair adds:
]</i></p>


<blockquote>
<p>
I recommend NAD, although remain concerned about header organisation.
</p>
<p>
A user container will satisfy the <tt>MemberContainer</tt> concept, which IS auto.
There is a concept_map for all <tt>MemberContainers</tt> to <tt>Container</tt>, and then a
further concept_map for all <tt>Container</tt> to <tt>Range</tt>, so the stated problem is not
actually true.  User defined containers will automatically match the <tt>Range</tt>
concept without explicitly declaring a concept_map.
</p>
<p>
The problem is that they should now provide an additional two headers,
<tt>&lt;iterator_concepts&gt;</tt> and <tt>&lt;container_concepts&gt;</tt>.
 The only difference from
making <tt>Range</tt> an auto concept would be this reduces to a single header,
<tt>&lt;iterator_concepts&gt;</tt>.
</p>
<p>
I am strongly in favour of any resolution that tackles the issue of
explicitly requiring concept headers to make these concept maps available.
</p>
</blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We observe there is a recent paper by Bjarne that overlaps this issue.
</p>
<p>
Alisdair continues to recommend NAD.
</p>
<p>
Move to Open, and recommend the issue be deferred until after the next
Committee Draft is issued.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1106"></a>1106. Multiple exceptions from connected <tt>shared_future::get()</tt>?</h3>
<p><b>Section:</b> 30.6.7 [futures.shared_future] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Thomas J. Gritzan <b>Opened:</b> 2009-04-03 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#futures.shared_future">issues</a> in [futures.shared_future].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It is not clear, if multiple threads are waiting in a 
<tt>shared_future::get()</tt> call, if each will rethrow the stored exception.
</p>
<p>
Paragraph 9 reads: 
</p>
<blockquote>
<i>Throws:</i> the stored exception, if an exception was stored and not 
retrieved before.
</blockquote>
<p>
The "not retrieved before" suggests that only one exception is thrown, 
but one exception for each call to <tt>get()</tt> is needed, and multiple calls 
to <tt>get()</tt> even on the same <tt>shared_future</tt> object seem to be allowed. 
</p>
<p>
I suggest removing "and not retrieved before" from the Throws paragraph. 
I recommend adding a note that explains that multiple calls on <tt>get()</tt> are 
allowed, and each call would result in an exception if an exception was 
stored. 
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We note there is a pending paper by Detlef
on such <tt>future</tt>-related issues;
we would like to wait for his paper before proceeding.
</p>
<p>
Alisdair suggests we may want language to clarify that this
<tt>get()</tt> function can be called from several threads
with no need for explicit locking.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[
2010-01-23 Moved to Tentatively NAD Editorial after 5 positive votes on
c++std-lib.
]</i></p>




<p><b>Rationale:</b></p>
<p>
Resolved by paper
<a href="file:///Users/hinnant/std%20documents/C++Mailings/papers/2009/n2997.htm">N2997</a>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 30.6.7 [futures.shared_future]:
</p>

<blockquote><pre>const R&amp; shared_future::get() const; 
R&amp; shared_future&lt;R&amp;&gt;::get() const; 
void shared_future&lt;void&gt;::get() const;
</pre>
<blockquote>
<p>...</p>
<p>
-9- <i>Throws:</i> the stored exception, if an exception was stored<del> and not retrieved before</del>.
<ins>
[<i>Note:</i> Multiple calls on <tt>get()</tt> are 
allowed, and each call would result in an exception if an exception was 
stored.  <i>end note</i>]
</ins>
</p>
</blockquote>
</blockquote>






<hr>
<h3><a name="1107"></a>1107. constructor <tt>shared_future(unique_future)</tt> by value?</h3>
<p><b>Section:</b> 30.6.7 [futures.shared_future] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Thomas J. Gritzan <b>Opened:</b> 2009-04-03 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#futures.shared_future">issues</a> in [futures.shared_future].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In the <tt>shared_future</tt> class definition in 30.6.7 [futures.shared_future]
the move constructor 
that constructs a <tt>shared_future</tt> from an <tt>unique_future</tt> receives the 
parameter by value. In paragraph 3, the same constructor receives it as 
const value. 
</p>

<p>
I think that is a mistake and the constructor should take a r-value 
reference: 
</p>

<blockquote><pre>shared_future(unique_future&lt;R&gt;&amp;&amp; rhs);
</pre></blockquote>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with the proposed resolution.
</p>
<p>
Move to Tentatively Ready.
</p>
</blockquote>

<p><i>[
2009-07-05 Daniel notes:
]</i></p>


<blockquote>
The proposed change has already been incorported into the current working draft
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2914.pdf">N2914</a>.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change the synopsis in 30.6.7 [futures.shared_future]:
</p>

<blockquote><pre>shared_future(unique_future&lt;R&gt;<ins>&amp;&amp;</ins> rhs);
</pre></blockquote>

<p>
Change the definition of the constructor in 30.6.7 [futures.shared_future]:
</p>

<blockquote><pre>shared_future(<del>const</del> unique_future&lt;R&gt;<ins>&amp;&amp;</ins> rhs);
</pre></blockquote>






<hr>
<h3><a name="1109"></a>1109. <tt>std::includes</tt> should require <tt>CopyConstructible</tt> predicate</h3>
<p><b>Section:</b> 25.4.5.1 [includes] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-04-28 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#includes">issues</a> in [includes].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
All the set operation algorithms require a <tt>CopyConstructible</tt> predicate, with
the exception of <tt>std::includes</tt>.  This looks like a typo as much as anything,
given the general library requirement that predicates are copy
constructible, and wording style of other set-like operations.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
We agree with the proposed resolution.
Move to NAD Editorial.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Change  [algorithms.syn] and 25.4.5.1 [includes]:
</p>

<blockquote><pre>template&lt;InputIterator Iter1, InputIterator Iter2,
         <del>typename</del> <ins>CopyConstructible</ins> Compare&gt;
  requires Predicate&lt;Compare, Iter1::value_type, Iter2::value_type&gt;
        &amp;&amp; Predicate&lt;Compare, Iter2::value_type, Iter1::value_type&gt;
  bool includes(Iter1 first1, Iter1 last1,
                Iter2 first2, Iter2 last2,
                Compare comp);
</pre></blockquote>





<hr>
<h3><a name="1111"></a>1111. associative containers underconstrained</h3>
<p><b>Section:</b> 23.6 [associative] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-04-29 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#associative">issues</a> in [associative].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
According to table 87 (n2857) the expression <tt>X::key_equal</tt> for an unordered
container shall return a value of type <tt>Pred</tt>, where <tt>Pred</tt> is an equivalence
relation.
</p>

<p>
However, all 4 containers constrain <tt>Pred</tt> to be merely a <tt>Predicate</tt>,
and not <tt>EquivalenceRelation</tt>.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We agree with the proposed resolution.
</p>
<p>
Move to Review.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
For ordered containers, replace 
</p>
<blockquote><pre>Predicate&lt;auto, Key, Key&gt; Compare = less&lt;Key&gt;
</pre></blockquote>
<p>
with 
</p>
<blockquote><pre>StrictWeakOrder&lt;auto, Key, Key&gt; Compare = less&lt;Key&gt;
</pre></blockquote>

<p>
For unordered containers, replace 
</p>
<blockquote><pre>Predicate&lt;auto, Key, Key&gt; Compare = less&lt;Key&gt;
</pre></blockquote>
<p>
with 
</p>
<blockquote><pre>EquivalenceRelation&lt;auto, Key, Key&gt; Compare = less&lt;Key&gt;
</pre></blockquote>
<p>
As in the following declarations:
</p>

<blockquote>
<p>
Associative containers 23.6 [associative]
</p>
<p>
 1 Headers &lt;map&gt; and &lt;set&gt;:
</p>
<p>
   Header &lt;map&gt; synopsis
</p>
<blockquote><pre>   namespace std {
     template &lt;ValueType Key, ValueType T,
               <del>Predicate</del><ins>StrictWeakOrder</ins>&lt;auto, Key<del>, Key</del>&gt; Compare = less&lt;Key&gt;,
               Allocator Alloc = allocator&lt;pair&amp;lt;&lt;b&gt;const Key, T&gt; &gt; &gt;
       requires NothrowDestructible&lt;Key&gt; &amp;&amp; NothrowDestructible&lt;T&gt;
             &amp;&amp; CopyConstructible&lt;Compare&gt;
             &amp;&amp; AllocatableElement&lt;Alloc, Compare, const Compare&amp;&gt;
             &amp;&amp; AllocatableElement&lt;Alloc, Compare, Compare&amp;&amp;&gt;
     class map;

     ...

     template &lt;ValueType Key, ValueType T,
               <del>Predicate</del><ins>StrictWeakOrder</ins>&lt;auto, Key<del>, Key</del>&gt; Compare = less&lt;Key&gt;,
               Allocator Alloc = allocator&lt;pair&amp;lt;&lt;b&gt;const Key, T&gt; &gt; &gt;
       requires NothrowDestructible&lt;Key&gt; &amp;&amp; NothrowDestructible&lt;T&gt;
             &amp;&amp; CopyConstructible&lt;Compare&gt;
             &amp;&amp; AllocatableElement&lt;Alloc, Compare, const Compare&amp;&gt;
             &amp;&amp; AllocatableElement&lt;Alloc, Compare, Compare&amp;&amp;&gt;
     class multimap;

     ...

   }
</pre></blockquote>

<p>
   Header &lt;set&gt; synopsis
</p>
<blockquote><pre>   namespace std {
     template &lt;ValueType Key, <del>Predicate</del><ins>StrictWeakOrder</ins>&lt;auto, Key<del>, Key</del>&gt; Compare = less&lt;Key&gt;,
               Allocator Alloc = allocator&lt;Key&gt; &gt;
       requires NothrowDestructible&lt;Key&gt; &amp;&amp; CopyConstructible&lt;Compare&gt;
             &amp;&amp; AllocatableElement&lt;Alloc, Compare, const Compare&amp;&gt;
             &amp;&amp; AllocatableElement&lt;Alloc, Compare, Compare&amp;&amp;&gt;
     class set;

     ...

     template &lt;ValueType Key, <del>Predicate</del><ins>StrictWeakOrder</ins>&lt;auto, Key<del>, Key</del>&gt; Compare = less&lt;Key&gt;,
               Allocator Alloc = allocator&lt;Key&gt; &gt;
       requires NothrowDestructible&lt;Key&gt; &amp;&amp; CopyConstructible&lt;Compare&gt;
             &amp;&amp; AllocatableElement&lt;Alloc, Compare, const Compare&amp;&gt;
             &amp;&amp; AllocatableElement&lt;Alloc, Compare, Compare&amp;&amp;&gt;
     class multiset;

     ...

   }
</pre></blockquote>

<p>
 23.4.1p2 Class template map [map]
</p>
<blockquote><pre> namespace std {
   template &lt;ValueType Key, ValueType T,
             <del>Predicate</del><ins>StrictWeakOrder</ins>&lt;auto, Key<del>, Key</del>&gt; Compare = less&lt;Key&gt;,
             Allocator Alloc = allocator&lt;pair&amp;lt;&lt;b&gt;const Key, T&gt; &gt; &gt;
     requires NothrowDestructible&lt;Key&gt; &amp;&amp; NothrowDestructible&lt;T&gt;
           &amp;&amp; CopyConstructible&lt;Compare&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Compare, const Compare&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Compare, Compare&amp;&amp;&gt;
   class map {
     ...
   };
 }
</pre></blockquote>


<p>
 23.4.2p2 Class template multimap [multimap]
</p>
<blockquote><pre> namespace std {
   template &lt;ValueType Key, ValueType T,
             <del>Predicate</del><ins>StrictWeakOrder</ins>&lt;auto, Key<del>, Key</del>&gt; Compare = less&lt;Key&gt;,
             Allocator Alloc = allocator&lt;pair&amp;lt;&lt;b&gt;const Key, T&gt; &gt; &gt;
     requires NothrowDestructible&lt;Key&gt; &amp;&amp; NothrowDestructible&lt;T&gt;
           &amp;&amp; CopyConstructible&lt;Compare&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Compare, const Compare&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Compare, Compare&amp;&amp;&gt;
   class multimap {
     ...
   };
 }
</pre></blockquote>


<p>
 23.4.3p2 Class template set [set]
</p>
<blockquote><pre> namespace std {
   template &lt;ValueType Key, <del>Predicate</del><ins>StrictWeakOrder</ins>&lt;auto, Key<del>, Key</del>&gt; Compare = less&lt;Key&gt;,
             Allocator Alloc = allocator&lt;Key&gt; &gt;
     requires NothrowDestructible&lt;Key&gt; &amp;&amp; CopyConstructible&lt;Compare&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Compare, const Compare&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Compare, Compare&amp;&amp;&gt;
   class set {
     ...
   };
 }
</pre></blockquote>


<p>
 23.4.4p2 Class template multiset [multiset]
</p>
<blockquote><pre> namespace std {
   template &lt;ValueType Key, <del>Predicate</del><ins>StrictWeakOrder</ins>&lt;auto, Key<del>, Key</del>&gt; Compare = less&lt;Key&gt;,
             Allocator Alloc = allocator&lt;Key&gt; &gt;
     requires NothrowDestructible&lt;Key&gt; &amp;&amp; CopyConstructible&lt;Compare&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Compare, const Compare&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Compare, Compare&amp;&amp;&gt;
   class multiset {
     ...
   };
 }
</pre></blockquote>

<p>
 23.5 Unordered associative containers [unord]
</p>
<p>
 1 Headers &lt;unordered_map&gt; and &lt;unordered_set&gt;:
</p>
<p>
 Header &lt;unordered_map&gt; synopsis
</p>
<blockquote><pre> namespace std {
   // 23.5.1, class template unordered_map:
   template &lt;ValueType Key,
             ValueType T,
             Callable&lt;auto, const Key&amp;&gt; Hash = hash&lt;Key&gt;,
             <del>Predicate</del><ins>EquivalenceRelation</ins>&lt;auto, Key<del>, Key</del>&gt; Pred = equal_to&lt;Key&gt;,
             Allocator Alloc = allocator&lt;pair&amp;lt;&lt;b&gt;const Key, T&gt; &gt; &gt;
     requires NothrowDestructible&lt;Key&gt; &amp;&amp; NothrowDestructible&lt;T&gt;
           &amp;&amp; SameType&lt;Hash::result_type, size_t&gt;
           &amp;&amp; CopyConstructible&lt;Hash&gt; &amp;&amp; CopyConstructible&lt;Pred&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, const Pred&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, Pred&amp;&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, const Hash&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, Hash&amp;&amp;&gt;
     class unordered_map;

   // 23.5.2, class template unordered_multimap:
   template &lt;ValueType Key,
             ValueType T,
             Callable&lt;auto, const Key&amp;&gt; Hash = hash&lt;Key&gt;,
             <del>Predicate</del><ins>EquivalenceRelation</ins>&lt;auto, Key<del>, Key</del>&gt; Pred = equal_to&lt;Key&gt;,
             Allocator Alloc = allocator&lt;pair&amp;lt;&lt;b&gt;const Key, T&gt; &gt; &gt;
     requires NothrowDestructible&lt;Key&gt; &amp;&amp; NothrowDestructible&lt;T&gt;
           &amp;&amp; SameType&lt;Hash::result_type, size_t&gt;
           &amp;&amp; CopyConstructible&lt;Hash&gt; &amp;&amp; CopyConstructible&lt;Pred&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, const Pred&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, Pred&amp;&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, const Hash&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, Hash&amp;&amp;&gt;
     class unordered_multimap;

   ...
 }
</pre></blockquote>

<p>
 Header &lt;unordered_set&gt; synopsis
</p>
<blockquote><pre> namespace std {
   // 23.5.3, class template unordered_set:
   template &lt;ValueType Value,
             Callable&lt;auto, const Value&amp;&gt; Hash = hash&lt;Value&gt;,
             <del>Predicate</del><ins>EquivalenceRelation</ins>&lt;auto, Value<del>, Value</del>&gt; class Pred = equal_to&lt;Value&gt;,
             Allocator Alloc = allocator&lt;Value&gt; &gt;
     requires NothrowDestructible&lt;Value&gt;
           &amp;&amp; SameType&lt;Hash::result_type, size_t&gt;
           &amp;&amp; CopyConstructible&lt;Hash&gt; &amp;&amp; CopyConstructible&lt;Pred&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, const Pred&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, Pred&amp;&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, const Hash&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, Hash&amp;&amp;&gt;
     class unordered_set;

   // 23.5.4, class template unordered_multiset:
   template &lt;ValueType Value,
             Callable&lt;auto, const Value&amp;&gt; Hash = hash&lt;Value&gt;,
             <del>Predicate</del><ins>EquivalenceRelation</ins>&lt;auto, Value<del>, Value</del>&gt; class Pred = equal_to&lt;Value&gt;,
             Allocator Alloc = allocator&lt;Value&gt; &gt;
     requires NothrowDestructible&lt;Value&gt;
           &amp;&amp; SameType&lt;Hash::result_type, size_t&gt;
           &amp;&amp; CopyConstructible&lt;Hash&gt; &amp;&amp; CopyConstructible&lt;Pred&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, const Pred&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, Pred&amp;&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, const Hash&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, Hash&amp;&amp;&gt;
     class unordered_multiset;

   ...
 }
</pre></blockquote>

<p>
 23.5.1p3 Class template unordered_map [unord.map]
</p>
<blockquote><pre> namespace std {
   template &lt;ValueType Key,
             ValueType T,
             Callable&lt;auto, const Key&amp;&gt; Hash = hash&lt;Key&gt;,
             <del>Predicate</del><ins>EquivalenceRelation</ins>&lt;auto, Key<del>, Key</del>&gt; Pred = equal_to&lt;Key&gt;,
             Allocator Alloc = allocator&lt;pair&amp;lt;&lt;b&gt;const Key, T&gt; &gt; &gt;
     requires NothrowDestructible&lt;Key&gt; &amp;&amp; NothrowDestructible&lt;T&gt;
           &amp;&amp; SameType&lt;Hash::result_type, size_t&gt;
           &amp;&amp; CopyConstructible&lt;Hash&gt; &amp;&amp; CopyConstructible&lt;Pred&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, const Pred&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, Pred&amp;&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, const Hash&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, Hash&amp;&amp;&gt;
   class unordered_map
   {
     ...
   };
 }
</pre></blockquote>

<p>
 23.5.2p3 Class template unordered_multimap [unord.multimap]
</p>
<blockquote><pre> namespace std {
   template &lt;ValueType Key,
             ValueType T,
             Callable&lt;auto, const Key&amp;&gt; Hash = hash&lt;Key&gt;,
             <del>Predicate</del><ins>EquivalenceRelation</ins>&lt;auto, Key<del>, Key</del>&gt; Pred = equal_to&lt;Key&gt;,
             Allocator Alloc = allocator&lt;pair&amp;lt;&lt;b&gt;const Key, T&gt; &gt; &gt;
     requires NothrowDestructible&lt;Key&gt; &amp;&amp; NothrowDestructible&lt;T&gt;
           &amp;&amp; SameType&lt;Hash::result_type, size_t&gt;
           &amp;&amp; CopyConstructible&lt;Hash&gt; &amp;&amp; CopyConstructible&lt;Pred&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, const Pred&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, Pred&amp;&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, const Hash&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, Hash&amp;&amp;&gt;
   class unordered_multimap
   {
     ...
   };
 }
</pre></blockquote>

<p>
 23.5.3p3 Class template unordered_set [unord.set]
</p>
<blockquote><pre> namespace std {
   template &lt;ValueType Value,
             Callable&lt;auto, const Value&amp;&gt; Hash = hash&lt;Value&gt;,
             <del>Predicate</del><ins>EquivalenceRelation</ins>&lt;auto, Value<del>, Value</del>&gt; class Pred = equal_to&lt;Value&gt;,
             Allocator Alloc = allocator&lt;Value&gt; &gt;
     requires NothrowDestructible&lt;Value&gt;
           &amp;&amp; SameType&lt;Hash::result_type, size_t&gt;
           &amp;&amp; CopyConstructible&lt;Hash&gt; &amp;&amp; CopyConstructible&lt;Pred&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, const Pred&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, Pred&amp;&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, const Hash&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, Hash&amp;&amp;&gt;
   class unordered_set
   {
     ...
   };
 }
</pre></blockquote>
<p>
 23.5.4p3 Class template unordered_multiset [unord.multiset]
</p>
<blockquote><pre> namespace std {
   template &lt;ValueType Value,
             Callable&lt;auto, const Value&amp;&gt; Hash = hash&lt;Value&gt;,
             <del>Predicate</del><ins>EquivalenceRelation</ins>&lt;auto, Value<del>, Value</del>&gt; class Pred = equal_to&lt;Value&gt;,
             Allocator Alloc = allocator&lt;Value&gt; &gt;
     requires NothrowDestructible&lt;Value&gt;
           &amp;&amp; SameType&lt;Hash::result_type, size_t&gt;
           &amp;&amp; CopyConstructible&lt;Hash&gt; &amp;&amp; CopyConstructible&lt;Pred&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, const Pred&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Pred, Pred&amp;&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, const Hash&amp;&gt;
           &amp;&amp; AllocatableElement&lt;Alloc, Hash, Hash&amp;&amp;&gt;
   class unordered_multiset
   {
     ...
   };
 }
</pre></blockquote>

</blockquote>






<hr>
<h3><a name="1112"></a>1112. bitsets and new style for loop</h3>
<p><b>Section:</b> 20.5 [template.bitset] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Future">NAD Future</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-06 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#template.bitset">issues</a> in [template.bitset].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>Std::bitset</tt> is a homogeneous container-like sequence of bits, yet it does
not model the Range concept so cannot be used with the new for-loop syntax.
It is the only such type in the library that does NOT support the new for
loop.
</p>
<p>
The obvious reason is that bitset does not support iterators.
</p>
<p>
At least two reasonable solutions are available:
</p>
<ol type="i">
<li>
Add an iterator interface to <tt>bitset</tt>, bringing its interface close to that
of <tt>std::array</tt>
</li>
<li>
Provide an unspecified concept_map for <tt>Range&lt;bitset&gt;</tt>.
</li>
</ol>
<p>
The latter will still need some kind of iterator-like adapter for <tt>bitset</tt>,
but gives implementers greater freedom on the details. E.g. begin/end return
some type that simply invokes <tt>operator[]</tt> on the object it wraps, and
increments its index on <tt>operator++</tt>.  A vendor can settle for <tt>InputIterator</tt>
support, rather than wrapping up a full <tt>RandomAccessIterator</tt>.
</p>
<p>
I have a mild preference for option (ii) as I think it is less work to
specify at this stage of the process, although (i) is probably more useful
in the long run.
</p>
<p>
Hmm, my wording looks a little woolly, as it does not say what the element
type of the range is.  Do I get a range of <tt>bool</tt>, <tt>bitset&lt;N&gt;::reference</tt>, or
something else entirely?
</p>
<p>
I guess most users will assume the behaviour of reference, but expect to
work with <tt>bool</tt>.  <tt>Bool</tt> is OK for read-only traversal, but you really need to
take a reference to a <tt>bitset::reference</tt> if you want to write back.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
Move to Open.
We further recommend this be deferred until after the next Committee Draft.
</blockquote>

<p><i>[
2009-05-25 Alisdair adds:
]</i></p>


<blockquote>
<p>
I just stumbled over the <tt>Range concept_map</tt> for <tt>valarray</tt> and this should
probably set the precedent on how to write the wording.
</p>

<p><i>[
Howard: I've replaced the proposed wording with Alisdair's suggestion.
]</i></p>


</blockquote>

<p><i>[
2009-07-24 Daniel modifies the proposed wording for non-concepts.
]</i></p>


<p><i>[
2009-10 post-Santa Cruz:
]</i></p>


<blockquote>
Mark as Tentatively NAD Future due to the loss of concepts.
</blockquote>



<p><b>Rationale:</b></p>
<p>
All concepts-related text has been removed from the draft.
</p>


<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
Modify the section 20.5 [template.bitset] <tt>&lt;bitset&gt;</tt> synopsis by adding
the following at the end of the synopsis:
</p>
<blockquote><pre><ins>
// XX.X.X bitset range access [bitset.range]
template&lt;size_t N&gt; <i>unspecified-1</i> begin(bitset&lt;N&gt;&amp;);
template&lt;size_t N&gt; <i>unspecified-2</i> begin(const bitset&lt;N&gt;&amp;);
template&lt;size_t N&gt; <i>unspecified-1</i> end(bitset&lt;N&gt;&amp;);
template&lt;size_t N&gt; <i>unspecified-2</i> end(const bitset&lt;N&gt;&amp;);
</ins>
</pre></blockquote>
</li>
<li>
<p>
Add a new section <ins>"bitset range access" [bitset.range]</ins>
after the current section 20.5.4 [bitset.operators] with the following series of
paragraphs:
</p>
<blockquote>
<p>
<ins>
1.  In the <tt>begin</tt> and <tt>end</tt> function templates that follow, <i>unspecified-1</i>
is a type that meets the requirements of a mutable random access
iterator (24.2.7 [random.access.iterators]) whose <tt>value_type</tt> is <tt>bool</tt> and
whose reference type is <tt>bitset&lt;N&gt;::reference</tt>.
<i>unspecified-2</i> is a type that meets the requirements of a constant
random access iterator (24.2.7 [random.access.iterators]) whose <tt>value_type</tt>
is <tt>bool</tt> and whose reference type is <tt>bool</tt>.
</ins>
</p>
<pre><ins>
template&lt;size_t N&gt; <i>unspecified-1</i> begin(bitset&lt;N&gt;&amp;);
template&lt;size_t N&gt; <i>unspecified-2</i> begin(const bitset&lt;N&gt;&amp;);
</ins>
</pre>
<blockquote>
<ins>2.  Returns: an iterator referencing the first bit in the bitset.</ins>
</blockquote>

<pre><ins>
template&lt;size_t N&gt; <i>unspecified-1</i> end(bitset&lt;N&gt;&amp;);
template&lt;size_t N&gt; <i>unspecified-2</i> end(const bitset&lt;N&gt;&amp;);
</ins></pre>

<blockquote>
<ins>3.  Returns: an iterator referencing one past the last bit in the
bitset.</ins>
</blockquote>
</blockquote>
</li>
</ol>












<hr>
<h3><a name="1115"></a>1115. <tt>va_copy</tt> missing from Standard macros table</h3>
<p><b>Section:</b> C.2 [diff.library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Miles Zhao <b>Opened:</b> 2009-05-23 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#diff.library">issues</a> in [diff.library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In "Table 122 -- Standard macros" of C.2 [diff.library], which lists the 56 macros
inherited from C library, <tt>va_copy</tt> seems to be missing. But in
"Table 21 -- Header <tt>&lt;cstdarg&gt;</tt> synopsis" (18.10 [support.runtime]), there is.
</p>

<p><i>[
2009-10 post-Santa Cruz:
]</i></p>


<blockquote>
Mark as Tentatively NAD Editorial, if Pete disagrees, Howard
will move to Tentatively Ready
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add <tt>va_copy</tt> to Table 122 -- Standard macros in C.2 [diff.library].
</p>





<hr>
<h3><a name="1119"></a>1119. tuple query APIs do not support references</h3>
<p><b>Section:</b> 20.4.2.5 [tuple.helper] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-23 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#tuple.helper">issues</a> in [tuple.helper].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>tuple</tt> query APIs <tt>tuple_size</tt> and
<tt>tuple_element</tt> do not support references-to-tuples.  This can be
annoying when a template deduced a parameter type to be a reference,
which must be explicitly stripped with <tt>remove_reference</tt> before calling
these APIs.
</p>
<p>
I am not proposing a resolution at this point, as there is a
combinatorial explosion with lvalue/rvalue references and
cv-qualification (see previous issue) that suggests some higher
refactoring is in order.  This might be something to kick back over to
Core/Evolution.
</p>
<p>
Note that we have the same problem in numeric_limits.
</p>

<p><i>[
2009-10 post-Santa Cruz:
]</i></p>


<blockquote>
Move to Open. Alisdair to provide wording.
</blockquote>


<p><i>[
2010 Rapperswil:
]</i></p>


<blockquote>
Move to NAD.  This is an extension after the FCD, without a clear motivation.  May consider as NAD Future if motivating examples come forward.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1120"></a>1120. New type trait - remove_all</h3>
<p><b>Section:</b> 20.7 [meta] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Future">NAD Future</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-23 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta">issues</a> in [meta].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Sometimes it is necessary to remove all qualifiers from a type before
passing on to a further API.  A good example would be calling the
<tt>tuple</tt> query APIs <tt>tuple_size</tt> or <tt>tuple_element</tt>
with a deduced type inside a function template.  If the deduced type is
cv-qualified or a reference then the call will fail.  The solution is to
chain calls to
<tt>remove_cv&lt;remove_reference&lt;T&gt;::type&gt;::type</tt>, and
note that the order matters.
</p>
<p>
Suggest it would be helpful to add a new type trait,
<tt>remove_all</tt>, that removes all top-level qualifiers from a type
i.e. cv-qualification and any references.  Define the term in such a way
that if additional qualifiers are added to the language, then
<tt>remove_all</tt> is defined as stripping those as well.
</p>

<p><i>[
2009-10-14 Daniel adds:
]</i></p>


<blockquote>
<tt>remove_all</tt> seems too generic, a possible alternative matching
the current naming style could be <tt>remove_cv_reference</tt> or
<tt>remove_reference_cv</tt>. It should also be considered whether this
trait should also remove 'extents', or pointer 'decorations'. Especially
if the latter situations are considered as well, it might be easier to
chose the name not in terms of what it <em>removes</em> (which might be
a lot), but in terms of it <em>creates</em>. In this case I could think
of e.g. <tt>extract_value_type</tt>.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Future.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1121"></a>1121. Support for multiple arguments</h3>
<p><b>Section:</b> 20.6.2 [ratio.arithmetic] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Future">NAD Future</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-25 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ratio.arithmetic">issues</a> in [ratio.arithmetic].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Both add and multiply could sensibly be called with more than two arguments.
The variadic template facility makes such declarations simple, and is likely
to be frequently wrapped by end users if we do not supply the variant
ourselves.
</p>
<p>
We deliberately ignore divide at this point as it is not transitive.
Likewise, subtract places special meaning on the first argument so I do not
suggest extending that immediately.  Both could be supported with analogous
wording to that for add/multiply below.
</p>
<p>
Note that the proposed resolution is potentially incompatible with that
proposed for <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#921">921</a>, although the addition of the typedef to ratio would be
equally useful.
</p>

<p><i>[
2009-10-30 Alisdair adds:
]</i></p>


<blockquote>
<p>
The consensus of the group when we reviewed this in Santa Cruz was that
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#921">921</a> would proceed to Ready as planned, and the
multi-paramater add/multiply templates should be renamed as
<tt>ratio_sum</tt> and <tt>ratio_product</tt> to avoid the problem
mixing template aliases with partial specializations.
</p>

<p>
It was also suggested to close this issue as NAD Future as it does not
correspond directly to any NB comment.  NBs are free to submit a
specific comment (and re-open) in CD2 though.
</p>

<p>
Walter Brown also had concerns on better directing the order of
evaluation to avoid overflows if we do proceed for 0x rather than TR1,
so wording may not be complete yet.
</p>

<p><i>[
Alisdair updates wording.
]</i></p>


</blockquote>

<p><i>[
2009-10-30 Howard:
]</i></p>


<blockquote>
Moved to Tentatively NAD Future after 5 positive votes on c++std-lib.
</blockquote>



<p><b>Rationale:</b></p>
<p>
Does not have sufficient support at this time. May wish to reconsider for a
future standard.
</p>


<p><b>Proposed resolution:</b></p>

<p>
Add the following type traits to p3 20.6 [ratio]
</p>

<blockquote><pre>// ratio arithmetic
template &lt;class R1, class R2&gt; struct ratio_add;
template &lt;class R1, class R2&gt; struct ratio_subtract;
template &lt;class R1, class R2&gt; struct ratio_multiply;
template &lt;class R1, class R2&gt; struct ratio_divide;
<ins>template &lt;class R1, class ... RList&gt; struct ratio_sum;</ins>
<ins>template &lt;class R1, class ... RList&gt; struct ratio_product;</ins>
</pre></blockquote>

<p>
after 20.6.2 [ratio.arithmetic] p1: add
</p>

<blockquote><pre>template &lt;class R1, class ... RList&gt; struct ratio_sum; // declared, never defined

template &lt;class R1&gt; struct ratio_sum&lt;R1&gt; : R1 {};
</pre>

<blockquote>
<i>Requires:</i> <tt>R1</tt> is a specialization of class template <tt>ratio</tt>
</blockquote>

<pre>template &lt;class R1, class R2, class ... RList&gt; 
 struct ratio_sum&lt;R1, R2, RList...&gt;
   : ratio_add&lt; R1, ratio_sum&lt;R2, RList...&gt;&gt; {
};
</pre>

<blockquote>
<i>Requires:</i> <tt>R1</tt> and each element in parmater pack
<tt>RList</tt> is a specialization of class template <tt>ratio</tt>
</blockquote>
</blockquote>

<p>
after 20.6.2 [ratio.arithmetic] p3: add
</p>

<blockquote><pre>template &lt;class R1, class ... RList&gt; struct ratio_product; // declared, never defined

template &lt;class R1&gt; struct ratio_product&lt;R1&gt; : R1 {};
</pre>

<blockquote>
<i>Requires:</i> <tt>R1</tt> is a specialization of class template <tt>ratio</tt>
</blockquote>

<pre>template &lt;class R1, class R2, class ... RList&gt; 
 struct ratio_sum&lt;R1, R2, RList...&gt;
   : ratio_add&lt; R1, ratio_product&lt;R2, RList...&gt;&gt; {
};
</pre>

<blockquote>
<i>Requires:</i> <tt>R1</tt> and each element in parmater pack
<tt>RList</tt> is a specialization of class template <tt>ratio</tt>
</blockquote>
</blockquote>








<hr>
<h3><a name="1124"></a>1124.  Invalid definition of concept RvalueOf</h3>
<p><b>Section:</b> X [concept.transform] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-05-28 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#concept.transform">issues</a> in [concept.transform].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
A recent news group
<a href="http://groups.google.de/group/comp.std.c++/browse_frm/thread/8eb92768a19fb46f">article</a>
points to several defects in the
specification of reference-related concepts.
</p>
<p>
One problem of the concept <tt>RvalueOf</tt> as currently defined in
X [concept.transform]:
</p>

<blockquote><pre>concept RvalueOf&lt;typename T&gt; {
 typename type = T&amp;&amp;;
 requires ExplicitlyConvertible&lt;T&amp;,type&gt; &amp;&amp; Convertible&lt;T&amp;&amp;,type&gt;;
}

template&lt;typename T&gt; concept_map RvalueOf&lt;T&amp;&gt; {
 typedef T&amp;&amp; type;
}
</pre></blockquote>

<p>
is that if <tt>T</tt> is an lvalue-reference, the requirement
<tt>Convertible&lt;T&amp;&amp;,type&gt;</tt> isn't satisfied for
lvalue-references, because after reference-collapsing in the concept
definition we have <tt>Convertible&lt;T&amp;,type&gt;</tt> in this case,
which isn't satisfied in the concept map template and also is not the
right constraint either. I think that the reporter is right that
<tt>SameType</tt> requirements should do the job and that we also should
use the new <tt>RvalueReference</tt> concept to specify a best matching
type requirement.
</p>


<p><b>Proposed resolution:</b></p>
<p>
In X [concept.transform] before p. 4 change as indicated:
</p>

<blockquote><pre>auto concept RvalueOf&lt;typename T&gt; {
  <del>typename</del><ins>RvalueReference</ins> type = T&amp;&amp;;
  requires <del>ExplicitlyConvertible&lt;T&amp;, type&gt; &amp;&amp; Convertible&lt;T&amp;&amp;, type&gt;</del><ins>SameType&lt;T&amp;, type&amp;&gt;</ins>;
}
</pre></blockquote>





<hr>
<h3><a name="1125"></a>1125. ostream_iterator does not work with movable types</h3>
<p><b>Section:</b> 24.6.2.2 [ostream.iterator.ops] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-28 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>ostream_iterator</tt> has not been updated to support moveable types, in a
similar manner to the insert iterators.
Note that this is not a problem for <tt>ostreambuf_iterator</tt>, as the types it is
restricted to dealing with do not support extra-efficient moving.
</p>

<p><i>[
2009-11-10 Howard adds:
]</i></p>


<blockquote>
Moved to Tentatively NAD after 5 positive votes on c++std-lib.  Rationale
added below.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Add second <tt>operator=</tt> overload to class <tt>template ostream_iterator</tt>
in 24.6.2 [ostream.iterator], para 2:
</p>

<blockquote><pre>ostream_iterator&lt;T,charT,traits&gt;&amp; operator=(const T&amp; value);
<ins>ostream_iterator&lt;T,charT,traits&gt;&amp; operator=(T&amp;&amp; value);</ins>
</pre></blockquote>

<p>
Add a new paragraph: in 24.6.2.2 [ostream.iterator.ops]:
</p>

<blockquote>
<pre>ostream_iterator&amp; operator=(T&amp;&amp; value);
</pre>
<blockquote>
<p>
-2- <i>Effects:</i>
</p>
<blockquote><pre>*out_stream &lt;&lt; std::move(value);
if(delim != 0)
  *out_stream &lt;&lt; delim;
return (*this);
</pre></blockquote>
</blockquote>
</blockquote>



<p><b>Rationale:</b></p>
<p>
Several objections to move forward with this issue were voiced in the thread
starting with c++std-lib-25438.  Among them is that we know of no motivating
use case to make streaming rvalues behave differently than streaming const
lvalues.
</p>





<hr>
<h3><a name="1127"></a>1127. rvalue references and iterator traits</h3>
<p><b>Section:</b> 24.4.1 [iterator.traits] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-28 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iterator.traits">issues</a> in [iterator.traits].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The deprecated support for <tt>iterator_traits</tt> and legacy (unconstrained)
iterators features the (exposition only) concept:
</p>

<blockquote><pre>concept IsReference&lt;typename T&gt; { } // exposition only
template&lt;typename T&gt; concept_map IsReference&lt;T&amp;&gt; { }
</pre></blockquote>
<p>
Now this looks exactly like the <tt>LvalueReference</tt> concept recently added to
clause 20, so I wonder if we should use that instead?
Then I consider the lack of rvalue-reference support, which means that
<tt>move_iterator</tt> would always flag as merely supporting the <tt>input_iterator_tag</tt>
category.  This suggests we retain the exposition concept, but add a second
concept_map to support rvalue references.
</p>
<p>
I would suggest adding the extra concept_map is the right way forward, but
still wonder if the two exposition-only concepts in this clause might be
worth promoting to clause 20.  That question might better be answered with a
fuller investigation of type_trait/concept unification though.
</p>


<p><b>Proposed resolution:</b></p>
<p>
In Iterator traits 24.4.1 [iterator.traits] para 4 add:
</p>

<blockquote><pre>concept IsReference&lt;typename T&gt; { } // exposition only
template&lt;typename T&gt; concept_map IsReference&lt;T&amp;&gt; { }
<ins>template&lt;typename T&gt; concept_map IsReference&lt;T&amp;&amp;&gt; { }</ins>
</pre></blockquote>






<hr>
<h3><a name="1128"></a>1128. Missing definition of <tt>iterator_traits&lt;T*&gt;</tt></h3>
<p><b>Section:</b> X [iterator.syn] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-28 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>&lt;iterator&gt;</tt> header synopsis declares a partial specialization of
<tt>iterator_traits</tt> to support pointers, X [iterator.syn].  The implication
is that specialization will be described in D10, yet it did not follow the
rest of the deprecated material into this clause.
</p>
<p>
However, this is not as bad as it first seems!
There are partial specializations of <tt>iterator_traits</tt> for types that satisfy
the various Iterator concepts, and there are concept_maps for pointers to
explicitly support the <tt>RandomAccessIterator</tt> concept, so the required
template will be present - just not in the manner advertised.
</p>
<p>
I can see two obvious solutions:
</p>

<ol type="i">
<li>
Restore the <tt>iterator_traits&lt;T*&gt;</tt> partial specialization in D.10
</li>
<li>
Remove the declaration of <tt>iterator_traits&lt;T*&gt;</tt> from 24.3 synopsis
</li>
</ol>
<p>
I recommend option (ii) in the wording below
</p>
<p>
Option (ii) could be extended to strike all the declarations of deprecated
material from the synopsis, as it is effectively duplicating D.10 anyway.
This is the approach taken for deprecated library components in the 98/03
standards.  This is probably a matter best left to the Editor though.
</p>


<p><b>Proposed resolution:</b></p>
<p>
In X [iterator.syn] strike:
</p>

<blockquote><pre><del>template&lt;class T&gt; struct iterator_traits&lt;T*&gt;;</del>
</pre></blockquote>






<hr>
<h3><a name="1129"></a>1129. <tt>istream(buf)_iterator</tt> should support literal sentinel value</h3>
<p><b>Section:</b> 24.6.1.1 [istream.iterator.cons], 24.6.3 [istreambuf.iterator] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-30 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#istream.iterator.cons">issues</a> in [istream.iterator.cons].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>istream_iterator</tt> and <tt>istreambuf_iterator</tt> should support literal sentinel
values.  The default constructor is frequently used to terminate ranges, and
could easily be a literal value for <tt>istreambuf_iterator</tt>, and
<tt>istream_iterator</tt> when iterating value types.  A little more work using a
suitably sized/aligned char-array for storage (or an updated component like
<tt>boost::optional</tt> proposed for TR2) would allow <tt>istream_iterator</tt> to support
<tt>constexpr</tt> default constructor in all cases, although we might leave this
tweak as a QoI issue.  Note that requiring <tt>constexpr</tt> be supported also
allows us to place no-throw guarantees on this constructor too.
</p>

<p><i>[
2009-06-02 Daniel adds:
]</i></p>


<blockquote>
<p>
I agree with the usefulness of the issue suggestion, but we need
to ensure that <tt>istream_iterator</tt> <em>can</em> satisfy be literal if needed.
Currently this is not clear, because 24.6.1 [istream.iterator]/3 declares
a copy constructor and a destructor and explains their semantic in
24.6.1.1 [istream.iterator.cons]/3+4.
</p>
<p>
The prototype semantic specification is ok (although it seems
somewhat redundant to me, because the semantic doesn't say
anything interesting in both cases), but for support of trivial class
types we also need a trivial copy constructor and destructor as of
9 [class]/6. The current non-informative specification of these
two special members suggests to remove their explicit declaration
in the class and add explicit wording that says that if <tt>T</tt> is
trivial a default constructed iterator is also literal, alternatively it
would be possible to mark both as defaulted and add explicit
(memberwise) wording that guarantees that they are trivial.
</p>
<p>
Btw.: I'm quite sure that the <tt>istreambuf_iterator</tt> additions to
ensure triviality are not sufficient as suggested, because the
library does not yet give general guarantees that a defaulted
special member declaration makes this member also trivial.
Note that e.g. the atomic types do give a general statement!
</p>
<p>
Finally there is a wording issue: There does not exist something
like a "literal constructor". The core language uses the term
"constexpr constructor" for this.
</p>
<p>
Suggestion:
</p>
<ol>
<li>
<p>
Change 24.6.1 [istream.iterator]/3 as indicated:
</p>
<blockquote><pre><ins>constexpr</ins> istream_iterator();
istream_iterator(istream_type&amp; s);
istream_iterator(const istream_iterator<del>&lt;T,charT,traits,Distance&gt;</del>&amp; x)<ins> = default</ins>;
~istream_iterator()<ins> = default</ins>;
</pre></blockquote>
</li>
<li>
<p>
Change 24.6.1.1 [istream.iterator.cons]/1 as indicated:
</p>
<blockquote><pre><ins>constexpr</ins> istream_iterator();
</pre>
<blockquote>
-1- <i>Effects:</i> Constructs the end-of-stream iterator. <ins>If <tt>T</tt> is a literal type,
then this constructor shall be a constexpr constructor.</ins>
</blockquote>
</blockquote>
</li>
<li>
<p>
Change 24.6.1.1 [istream.iterator.cons]/3 as indicated:
</p>
<blockquote><pre>istream_iterator(const istream_iterator<del>&lt;T,charT,traits,Distance&gt;</del>&amp; x)<ins> = default</ins>;
</pre>
<blockquote>
-3- <i>Effects:</i> Constructs a copy of <tt>x</tt>. <ins>If <tt>T</tt> is a literal type, then
this constructor shall be a trivial copy constructor.</ins>
</blockquote>
</blockquote>
</li>
<li>
<p>
Change 24.6.1.1 [istream.iterator.cons]/4 as indicated:
</p>

<blockquote><pre>~istream_iterator()<ins> = default</ins>;
</pre>
<blockquote>
-4- <i>Effects:</i> The iterator is destroyed. <ins>If <tt>T</tt> is a literal type, then
this destructor shall be a trivial
destructor.</ins>
</blockquote>
</blockquote>
</li>
<li>
<p>
Change 24.6.3 [istreambuf.iterator] before p. 1 as indicated:
</p>

<blockquote><pre><ins>constexpr</ins> istreambuf_iterator() throw();
<ins>istreambuf_iterator(const istreambuf_iterator&amp;)  throw() = default;</ins>
<ins>~istreambuf_iterator()  throw() = default;</ins>
</pre></blockquote>
</li>
<li>
<p>
Change 24.6.3 [istreambuf.iterator]/1 as indicated:
</p>
<blockquote>
[..] The default constructor <tt>istreambuf_iterator()</tt> and the constructor
<tt>istreambuf_iterator(0)</tt> both
construct an end of stream iterator object suitable for use as an
end-of-range. <ins>All
specializations of <tt>istreambuf_iterator</tt> shall have a trivial copy
constructor, a constexpr default
constructor and a trivial destructor.</ins>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2994.html">N2994</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
24.6.1 [istream.iterator] para 3
</p>

<blockquote><pre><ins>constexpr</ins> istream_iterator();
</pre></blockquote>

<p>
24.6.1.1 [istream.iterator.cons]
</p>

<blockquote><pre><ins>constexpr</ins> istream_iterator();
</pre>
<blockquote>
-1- <i>Effects:</i> Constructs the end-of-stream iterator.
<ins>If <tt>T</tt> is a literal type, then this constructor shall
be a literal constructor.</ins>
</blockquote>
</blockquote>

<p>
24.6.3 [istreambuf.iterator]
</p>

<blockquote><pre><ins>constexpr</ins> istreambuf_iterator() throw();
</pre></blockquote>






<hr>
<h3><a name="1132"></a>1132. JP-30: nested exceptions</h3>
<p><b>Section:</b> 18.8.6 [except.nested] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Seiji Hayashida <b>Opened:</b> 2009-06-01 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#except.nested">issues</a> in [except.nested].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses JP 30</b></p>

<p>
C++0x <tt>nested_exception</tt> cannot handle a structured exception well. The
following codes show two types of tree structured exception handling.
</p>
<p>
The first one is based on <tt>nested_exception</tt> in C++0x,
while the second one is based on my library <tt>trickerr.h</tt> (in Japanese).
<a href="http://tricklib.com/cxx/dagger/trickerr.h">http://tricklib.com/cxx/dagger/trickerr.h</a>
</p>
<p>
Assume that Function <tt>A()</tt> calls two sub functions <tt>A_a()</tt> and <tt>A_b()</tt>, both might
throw tree structured exceptions, and <tt>A_b()</tt> must be called even if <tt>A_a()</tt>
throws an exception.
</p>
<p>
List A (code of tree structured exception handling based on nested_exception
in C++0x)
</p>

<blockquote><pre>void A()
{
    try
    {
        std::vector&lt;exception_ptr&gt; exception_list;
        try
        {
            // A_a() does a similar processing as A().
            A_a();
        }
        catch(...)
        {
            exception_list.push_back(current_exception());
        }

        // ***The processing A() has to do even when A_a() fails. ***
        try
        {
            // A_b() does a similar processing as A().
            A_b();
        }
        catch(...)
        {
            exception_list.push_back(current_exception());
        }
        if (!exception_list.empty())
        {
            throw exception_list;
        }
    }
    catch(...)
    {
        throw_with_nested(A_exception("someone error"));
    }
}
void print_tree_exception(exception_ptr e, const std::string &amp; indent ="")
{
    const char * indent_unit = " ";
    const char * mark = "- ";
    try
    {
        rethow_exception(e);
    }
    catch(const std::vector&lt;exception_ptr&gt; e)
    {
        for(std::vector&lt;exception_ptr&gt;::const_iterator i = e.begin(); i!=e.end(); ++i)
        {
            print_tree_exception(i, indent);
        }
    }
    catch(const std::nested_exception  e)
    {
        print_tree_exception(evil_i(e), indent +indent_unit);
    }
    catch(const std::exception e)
    {
        std::cout &lt;&lt; indent &lt;&lt; mark &lt;&lt; e.what() &lt;&lt; std::endl;
    }
    catch(...)
    {
        std::cout &lt;&lt; indent &lt;&lt; mark &lt;&lt; "unknown exception" &lt;&lt; std::endl;
    }
}
int main(int, char * [])
{
    try
    {
        A();
    }
    catch()
    {
        print_tree_exception(current_exception());
    }
    return EXIT_SUCCESS;
}
</pre></blockquote>

<p>
List B ( code of tree structured exception handling based on <tt>trickerr.h</tt>. )
"trickerr.h" (in Japanese), refer to:
<a href="http://tricklib.com/cxx/dagger/trickerr.h">http://tricklib.com/cxx/dagger/trickerr.h</a>.
</p>

<blockquote><pre>void A()
{
    tricklib::error_listener_type error_listener;
    // A_a() is like A(). A_a() can throw tree structured exception.
    A_a();

    // *** It must do process so that A_a() throws exception in A(). ***
    // A_b() is like A(). A_b() can throw tree structured exception.
    A_b();

    if (error_listener.has_error()) // You can write this "if block" in destructor
                                    //  of class derived from error_listener_type.
    {
        throw_error(new A_error("someone error",error_listener.listener_off().extract_pending_error()));
    }
}
void print_tree_error(const tricklib::error_type &amp;a_error, const std::string &amp; indent = "")
{
    const char * indent_unit = " ";
    const char * mark = "- ";

    tricklib::error_type error = a_error;
    while(error)
    {
        std::cout &lt;&lt; indent &lt;&lt; mark &lt;&lt; error-&gt;message &lt;&lt; std::endl;
        if (error-&gt;children)
        {
            print_tree_error(error-&gt;children, indent +indent_unit);
        }
        error = error-&gt;next;
    }
}
int main(int, char * [])
{
    tricklib::error_thread_power error_thread_power_on; // This object is necessary per thread.

    try
    {
        A();
    }
    catch(error_type error)
    {
        print_tree_error(error);
    }
    catch(...)
    {
        std::cout &lt;&lt; "- unknown exception" &lt;&lt; std::endl;
    }
    return EXIT_SUCCESS;
}
</pre></blockquote>

<p>
Prospect
</p>
<p>
We will focus on the method A() since the other methods, also main(), occur
only once respectively.
</p>

<ul>
<li>
 In the List A above (of the nested exception handling), it is hard to
 find out an active reason to use the nested exception handling at this
 scene. Rather, we can take a simpler description by throwing the entire
 exception_list directly to the top level.
</li>
<li>
 The code in the same example gives us a kind of redundant impression,
 which might have come from the fact that the try-throw-catch framework does
 not assume a tree structured exception handling.
</li>
</ul>

<p>
According to the above observation, we cannot help concluding that it is not
so easy to use the nested_exception handling as a tree structured exception
handling mechanism in a practical sense.
</p>
<p>
This text is based on the web page below (in Japanese).
<a href="http://d.hatena.ne.jp/wraith13/20081231/1230715424">http://d.hatena.ne.jp/wraith13/20081231/1230715424</a>
</p>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Mark as NAD. The committee agrees that nested_exception is not a good
match for this usage model. The committee did not see a way of improving
this within the timeframe allowed.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="1139"></a>1139. Thread support library not concept enabled</h3>
<p><b>Section:</b> 30 [thread] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-15 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread">issues</a> in [thread].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses US 93, JP 79, UK 333, JP 81</b></p>

<p>
The thread chapter is not concept enabled.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1140"></a>1140. Numerics library not concept enabled</h3>
<p><b>Section:</b> 26 [numerics] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-15 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#numerics">issues</a> in [numerics].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses US 84</b></p>

<p>
The numerics chapter is not concept enabled.
</p>

<p>
The portion of this comment dealing with random numbers was resolved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2836.pdf">N2836</a>,
which was accepted in Summit.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1141"></a>1141. Input/Output library not concept enabled</h3>
<p><b>Section:</b> 27 [input.output] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-15 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#input.output">issues</a> in [input.output].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses US 85, JP 67, JP 68, JP 69, JP 72, UK 308</b></p>

<p>
The input/output chapter is not concept enabled.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1142"></a>1142. Regular expressions library not concept enabled</h3>
<p><b>Section:</b> 28 [re] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-15 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#re">issues</a> in [re].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses US 86, UK 309, UK 310</b></p>

<p>
The regular expressions chapter is not concept enabled.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1143"></a>1143. Atomic operations library not concept enabled</h3>
<p><b>Section:</b> 29 [atomics] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-15 <b>Last modified:</b> 2010-10-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#atomics">active issues</a> in [atomics].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics">issues</a> in [atomics].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses US 87, UK 311</b></p>

<p>
The atomics chapter is not concept enabled.
</p>

<p>
Needs to also consider issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#923">923</a> and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#924">924</a>.
</p>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2992.html">N2992</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1145"></a>1145. inappropriate headers for atomics</h3>
<p><b>Section:</b> 29 [atomics] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-16 <b>Last modified:</b> 2010-10-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#atomics">active issues</a> in [atomics].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics">issues</a> in [atomics].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 312</b></p>

<p>
The contents of the <tt>&lt;stdatomic.h&gt;</tt> header are not listed anywhere,
and <tt>&lt;cstdatomic&gt;</tt> is listed as a C99 header in chapter 17.
If we intend to use these for compatibility with a future C standard,
we should not use them now.
</p>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2992.html">N2992</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Remove <tt>&lt;cstdatomic&gt;</tt> from the C99 headers in table 14.
Add a new header <tt>&lt;atomic&gt;</tt> to the headers in table 13.
Update chapter 29 to remove reference to <tt>&lt;stdatomic.h&gt;</tt>
and replace the use of <tt>&lt;cstdatomic&gt;</tt> with <tt>&lt;atomic&gt;</tt>.
</p>
<p><i>[
If and when WG14 adds atomic operations to C
we can add corresponding headers to table 14 with a TR.
]</i></p>






<hr>
<h3><a name="1146"></a>1146. "lockfree" does not say enough</h3>
<p><b>Section:</b> 29.4 [atomics.lockfree] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2009-06-16 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics.lockfree">issues</a> in [atomics.lockfree].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses US 88</b></p>

<p>
The "lockfree" facilities do not tell the programmer enough.
</p>

<p>
There are 2 problems here.
First, at least on x86,
it's less important to me whether some integral types are lock free
than what is the largest type I can pass to atomic and have it be lock-free.
For example, if <tt>long long</tt>s are not lock-free,
<tt>ATOMIC_INTEGRAL_LOCK_FREE</tt> is probably 1,
but I'd still be interested in knowing whether longs are always lock-free.
Or if long longs at any address are lock-free,
I'd expect <tt>ATOMIC_INTEGRAL_LOCK_FREE</tt> to be 2,
but I may actually care whether I have access to
the <code>cmpxchg16b</code> instruction.
None of the support here helps with that question.
(There are really 2 related questions here:
what alignment requirements are there for lock-free access;
and what processor is the program actually running on,
as opposed to what it was compiled for?)
</p>

<p>
Second, having <tt>atomic_is_lock_free</tt> only apply to individual objects
is pretty useless
(except, as Lawrence Crowl points out,
for throwing an exception when an object is unexpectedly not lock-free).
I'm likely to want to use its result to decide what algorithm to use,
and that algorithm is probably going to allocate new memory
containing atomic objects and then try to act on them.
If I can't predict the lock-freedom of the new object
by checking the lock-freedom of an existing object,
I may discover after starting the algorithm that I can't continue.
</p>

<p><i>[
2009-06-16 Jeffrey Yasskin adds:
]</i></p>


<blockquote>
<p>
To solve the first problem, I think 2 macros would help:
<tt>MAX_POSSIBLE_LOCK_FREE_SIZE</tt> and <tt>MAX_GUARANTEED_LOCK_FREE_SIZE</tt>,
which expand to the maximum value of <tt>sizeof(T)</tt> for which atomic may
(or will, respectively) use lock-free operations.
Lawrence points out that this
"relies heavily on implementations
using word-size compare-swap on sub-word-size types,
which in turn requires address modulation."
He expects that to be the end state anyway, so it doesn't bother him much.
</p>

<p>
To solve the second,
I think one could specify that equally aligned objects of the same type
will return the same value from <tt>atomic_is_lock_free()</tt>.
I don't know how to specify "equal alignment".
Lawrence suggests an additional function, <tt>atomic_is_always_lock_free()</tt>.
</p>
</blockquote>

<p><i>[
2009-10-22 Benjamin Kosnik:
]</i></p>


<blockquote>
<p>
In the evolution discussion of N2925, "More Collected Issues with
Atomics," there is an action item with respect to
LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1146">1146</a>, US 88
</p>

<p>
This is stated in the paper as:
</p>
<p>
Relatedly, Mike Sperts will create an issue to propose adding a traits
mechanism to check the compile-time properties through a template
mechanism rather than macros
</p>

<p>
Here is my attempt to do this. I don't believe that a separate trait is
necessary for this, and that instead <tt>atomic_integral::is_lock_free</tt> can
be re-purposed with minimal work as follows.
</p>

<p><i>[
Howard: Put Benjamin's wording in the proposed wording section.
]</i></p>


</blockquote>

<p><i>[
2009-10-22 Alberto Ganesh Barbati:
]</i></p>


<blockquote>
<p>
Just a thought... wouldn't it be better to use a scoped enum instead of
plain integers? For example:
</p>

<blockquote><pre>enum class is_lock_free
{
    never = 0, sometimes = 1, always = 2;
};
</pre></blockquote>

<p>
if compatibility with C is deemed important, we could use an unscoped
enum with suitably chosen names.  It would still be more descriptive
than 0, 1 and 2.
</p>

</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2992.html">N2992</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Header <tt>&lt;cstdatomic&gt;</tt> synopsis  [atomics.synopsis]
</p>

<p>
Edit  as follows:
</p>

<blockquote><pre>namespace std {
...
// 29.4, lock-free property
<del>#define ATOMIC_INTEGRAL_LOCK_FREE unspecified</del>
<ins>#define ATOMIC_CHAR_LOCK_FREE unspecified
#define ATOMIC_CHAR16_T_LOCK_FREE unspecified
#define ATOMIC_CHAR32_T_LOCK_FREE unspecified
#define ATOMIC_WCHAR_T_LOCK_FREE unspecified
#define ATOMIC_SHORT_LOCK_FREE unspecified
#define ATOMIC_INT_LOCK_FREE unspecified
#define ATOMIC_LONG_LOCK_FREE unspecified
#define ATOMIC_LLONG_LOCK_FREE unspecified</ins>
#define ATOMIC_ADDRESS_LOCK_FREE unspecified
</pre></blockquote>

<p>
Lock-free Property 29.4 [atomics.lockfree]
</p>

<p>
Edit the synopsis as follows.
</p>

<blockquote><pre>namespace std {
   <del>#define ATOMIC_INTEGRAL_LOCK_FREE unspecified</del>
   <ins>#define ATOMIC_CHAR_LOCK_FREE unspecified
   #define ATOMIC_CHAR16_T_LOCK_FREE unspecified
   #define ATOMIC_CHAR32_T_LOCK_FREE unspecified
   #define ATOMIC_WCHAR_T_LOCK_FREE unspecified
   #define ATOMIC_SHORT_LOCK_FREE unspecified
   #define ATOMIC_INT_LOCK_FREE unspecified
   #define ATOMIC_LONG_LOCK_FREE unspecified
   #define ATOMIC_LLONG_LOCK_FREE unspecified</ins>
   #define ATOMIC_ADDRESS_LOCK_FREE unspecified
}
</pre></blockquote>

<p>
Edit paragraph 1 as follows.
</p>

<blockquote>
The <ins>ATOMIC_...._LOCK_FREE</ins> macros <del>ATOMIC_INTEGRAL_LOCK_FREE and ATOMIC_ADDRESS_LOCK_FREE</del> indicate the general lock-free
property of <del>integral and address atomic</del> <ins>the corresponding atomic integral</ins> types<ins>, with the
signed and unsigned variants grouped together</ins>.
<del>The properties also apply to the corresponding specializations of the atomic template.</del>
A value of 0
indicates that the types are never lock-free. A value of 1
indicates that the types are sometimes lock-free. A value of 2
indicates that the types are always lock-free.
</blockquote>

<p>
Operations on Atomic Types 29.6 [atomics.types.operations]
</p>

<p>
Edit as follows.
</p>

<blockquote><pre><del>void</del> <ins>static constexpr bool</ins> A::is_lock_free() const volatile;
</pre>
<blockquote>
<i>Returns:</i> True if the <del>object's</del> <ins>types's</ins> operations are lock-free, false
otherwise.
<ins>
[<i>Note:</i> In the same way that <tt>&lt;limits&gt;</tt>
<tt>std::numeric_limits&lt;short&gt;::max()</tt> is related to
<tt>&lt;limits.h&gt;</tt> <tt>__LONG_LONG_MAX__</tt>, <tt>&lt;atomic&gt;
std::atomic_short::is_lock_free</tt> is related to
<tt>&lt;stdatomic.h&gt;</tt> and <tt>ATOMIC_SHORT_LOCK_FREE</tt> 
<i>end note</i>]
</ins>
</blockquote>
</blockquote>






<hr>
<h3><a name="1147"></a>1147. non-volatile atomic functions</h3>
<p><b>Section:</b> 29.6 [atomics.types.operations] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2009-06-16 <b>Last modified:</b> 2010-10-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#atomics.types.operations">active issues</a> in [atomics.types.operations].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics.types.operations">issues</a> in [atomics.types.operations].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses US 90</b></p>

<p>
The C++0X draft
declares all of the functions dealing with atomics (section 29.6 [atomics.types.operations])
to take volatile arguments.
Yet it also says (29.4-3),
</p>

<blockquote>
<p>
[ Note: Many operations are volatile-qualified.
The "volatile as device register" semantics have not changed in the standard.
This qualification means that volatility is preserved
when applying these operations to volatile objects.
It does not mean that operations on non-volatile objects become volatile.
Thus, volatile qualified operations on non-volatile objects
may be merged under some conditions. end note ]
</p>
</blockquote>

<p>
I was thinking about how to implement this in gcc,
and I believe that we'll want to overload most of the functions
on volatile and non-volatile.
Here's why:
</p>

<p>
To let the compiler take advantage of the permission
to merge non-volatile atomic operations and reorder atomics in certain,
we'll need to tell the compiler backend
about exactly which atomic operation was used.
So I expect most of the functions of the form atomic_&lt;op&gt;_explicit()
(e.g. atomic_load_explicit, atomic_exchange_explicit,
atomic_fetch_add_explicit, etc.)
to become compiler builtins.
A builtin can tell whether its argument was volatile or not,
so those functions don't really need extra explicit overloads.
However, I don't expect that we'll want to add builtins
for every function in chapter 29,
since most can be implemented in terms of the _explicit free functions:
</p>

<pre><code>class atomic_int {
  __atomic_int_storage value;
 public:
  int fetch_add(int increment, memory_order order = memory_order_seq_cst) volatile {
    // &amp;value has type "volatile __atomic_int_storage*".
    atomic_fetch_add_explicit(&amp;value, increment, order);
  }
  ...
};
</code></pre>

<p>
But now this <em>always</em> calls
the volatile builtin version of atomic_fetch_add_explicit(),
even if the atomic_int wasn't declared volatile.
To preserve volatility and the compiler's permission to optimize,
I'd need to write:
</p>

<pre><code>class atomic_int {
  __atomic_int_storage value;
 public:
  int fetch_add(int increment, memory_order order = memory_order_seq_cst) volatile {
    atomic_fetch_add_explicit(&amp;value, increment, order);
  }
  int fetch_add(int increment, memory_order order = memory_order_seq_cst) {
    atomic_fetch_add_explicit(&amp;value, increment, order);
  }
  ...
};
</code></pre>

<p>
But this is visibly different from the declarations in the standard
because it's now overloaded.
(Consider passing &amp;atomic_int::fetch_add as a template parameter.)
</p>

<p>
The implementation may already have permission to add overloads
to the member functions:
</p>

<blockquote>
<p>
17.6.4.5 [member.functions] An implementation may declare additional non-virtual
member function signatures within a class:<br>
...
</p>
<ul>
<li>by adding a member function signature for a member function name.</li>
</ul>
</blockquote>

<p>
but I don't see an equivalent permission to add overloads to the free functions.
</p>

<p><i>[
2009-06-16 Lawrence adds:
]</i></p>


<blockquote>
<p>
I recommend allowing non-volatile overloads.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2992.html">N2992</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1148"></a>1148. Wrong argument type of I/O stream manipulators <tt>setprecision()</tt>
and <tt>setw()</tt></h3>
<p><b>Section:</b> 27.7 [iostream.format] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Marc Steinbach <b>Opened:</b> 2009-06-20 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iostream.format">issues</a> in [iostream.format].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The header <tt>&lt;iomanip&gt;</tt> synopsis in 27.7 [iostream.format] specifies
</p>
<blockquote><pre>T5 setprecision(int n);
T6 setw(int n);
</pre></blockquote>

<p>
The argument types should be streamsize, as in class <tt>ios_base</tt>
(see 27.5.2 [ios.base]):
</p>
<blockquote><pre>streamsize precision() const;
streamsize precision(streamsize prec);
streamsize width() const;
streamsize width(streamsize wide);
</pre></blockquote>

<p>
(Editorial: 'wide' should probably be renamed as 'width', or maybe just 'w'.)
</p>

<p><i>[
2009-07-29 Daniel clarified wording.
]</i></p>


<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
<p>
No concensus for this change.  There was some interest in doing the opposite
fix:  Change the <tt>streamsize</tt> in <tt>&lt;ios&gt;</tt> to <tt>int</tt>.
But ultimately there was no concensus for that change either.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
In 27.7 [iostream.format], header <tt>&lt;iomanip&gt;</tt> synopsis change as indicated:
</p>

<blockquote><pre>T5 setprecision(<del>int</del><ins>streamsize</ins> n);
T6 setw(<del>int</del><ins>streamsize</ins> n);
</pre></blockquote>
</li>

<li>
<p>
In 27.7.3 [std.manip], just before p. 6 change as indicated:
</p>

<blockquote><pre>unspecified setprecision(<del>int</del><ins>streamsize</ins> n);
</pre></blockquote>
</li>

<li>
<p>
In 27.7.3 [std.manip], just before p. 7 change as indicated:
</p>

<blockquote><pre>unspecified setw(<del>int</del><ins>streamsize</ins> n);
</pre></blockquote>
</li>
</ol>








<hr>
<h3><a name="1149"></a>1149. Reformulating NonemptyRange axiom</h3>
<p><b>Section:</b> X [rand.concept.urng] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Walter Brown <b>Opened:</b> 2009-06-25 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In X [rand.concept.urng], we have the following:
</p>
<blockquote><pre>concept UniformRandomNumberGenerator&lt;typename G&gt; : Callable&lt;G&gt; {
  ...
  axiom NonemptyRange(G&amp; g) {
    G::min() &lt; G::max();
  }
  ...
}
</pre></blockquote>

<p>
Since the parameter <tt>G</tt> is in scope throughout the concept, there is no
need for the axiom to be further parameterized, and so the axiom can be
slightly simplified as:
</p>

<blockquote><pre>axiom NonemptyRange()  {
  G::min() &lt; G::max();
}
</pre></blockquote>

<p>
We can further reformulate so as to avoid any axiom machinery as:
</p>

<blockquote><pre>requires True&lt; G::min() &lt; G::max() &gt;;
</pre></blockquote>

<p>
This is not only a simpler statement of the same requirement, but also
forces the requirement to be checked.
</p>

<p><i>[
Post-Rapperswil:
]</i></p>


<blockquote>
Moved to Tentatively Ready after 5 positive votes on c++std-lib.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
In X [rand.concept.urng], replace the <tt>NonemptyRange</tt> axiom by:
</p>

<blockquote><pre><del>axiom NonemptyRange(G&amp; g) { 
   G::min() &lt; G::max(); 
}</del>
<ins>requires True&lt; G::min() &lt; G::max() &gt;;</ins>
</pre></blockquote>






<hr>
<h3><a name="1150"></a>1150. wchar_t, char16_t and char32_t filenames</h3>
<p><b>Section:</b> 27.9.1.14 [fstream] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Future">NAD Future</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-28 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses JP 73</b></p>

   <p><b>Description</b></p>
        <p>It is a problem
        from C++98, <tt>fstream</tt> cannot appoint a filename of wide
        character string(<tt>const wchar_t</tt> and <tt>const wstring&amp;</tt>).</p>
<p><b>Suggestion</b></p>
        <p>Add
        interface corresponding to <tt>wchar_t</tt>, <tt>char16_t</tt> and <tt>char32_t</tt>.</p>

<p><i>[
2009-07-01 Alisdair notes that this is a duplicate of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#454">454</a> which has more
in-depth rationale.
]</i></p>


<p><i>[
2009-09-21 Daniel adds:
]</i></p>


<blockquote>
I suggest to mark this issue as NAD Future with the intend to
solve the issue with a single file path c'tor template assuming
a provision of a TR2 filesystem library.
</blockquote>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
NAD Future.  This is a duplicate of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#454">454</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1153"></a>1153. Standard library needs review for constructors to be
explicit to avoid treatment as initializer-list constructor</h3>
<p><b>Section:</b> 17 [library], 30 [thread], D [depr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-28 <b>Last modified:</b> 2010-10-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses DE 2</b></p>

<p><b>Description</b></p>
        <p>Marking a constructor with <tt>explicit</tt> has semantics
        even for a constructor with zero or several parameters:
        Such a constructor cannot be used with list-initialization
        in a copy-initialization context, see 13.3.1.7 [over.match.list]. The
        standard library apparently has not been reviewed for
        marking non-single-parameter constructors as <tt>explicit</tt>.</p>
<p><b>Suggestion</b></p>
        <p>Consider marking zero-parameter and multi-parameter
        constructors <tt>explicit</tt> in classes that have at least one
        constructor marked <tt>explicit</tt> and that do not have an
        initializer-list constructor.</p>

<p><b>Notes</b></p>
        <p>Robert Klarer to address this one.</p>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
Move to "Open". Robert Klarer has promised to provide wording.
</blockquote>

<p><i>[
2010 Pittsburgh:  Moved to NAD, rationale added below.
]</i></p>




<p><b>Rationale:</b></p>
<p>
We are unaware of any cases where initializer lists cause problem in this
context, but if problems arise in the future the issue can be reopened.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1154"></a>1154. <tt>complex</tt> should accept integral types</h3>
<p><b>Section:</b> 26.4 [complex.numbers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Future">NAD Future</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-28 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#complex.numbers">issues</a> in [complex.numbers].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses FR 35</b></p>

<p><b>Description</b></p>
        <p>Instantiations of the class
        template <tt>complex&lt;&gt;</tt> have to be allowed for integral
        types, to reflect existing practice and ISO standards
        (LIA-III).</p>
        
<p><b>Suggestion</b></p>

<p><i>[
2009-10-26 Proposed wording in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n3002.pdf">N3002</a>.
]</i></p>


<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote>
Moved to NAD Future.  Rationale added.
</blockquote>



<p><b>Rationale:</b></p>
<p>
There is no consensus for making this change at this time.
</p>


<p><b>Proposed resolution:</b></p>
Adopt
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n3002.pdf">N3002</a>.





<hr>
<h3><a name="1155"></a>1155. Reference should be to C99</h3>
<p><b>Section:</b> C.2 [diff.library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-28 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#diff.library">issues</a> in [diff.library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses FR 38</b></p>

<p><b>Description</b></p>
        <p>What is ISO/IEC 1990:9899/DAM
        1? My guess is that's a typo for ISO/IEC
        9899/Amd.1:1995 which I'd
        have expected to be referenced here (the tables
        make reference to things
        which were introduced by Amd.1).</p>
<p><b>Suggestion</b></p>
        <p>One need probably a reference
        to the document which introduce <tt>char16_t</tt> and
        <tt>char32_t</tt> in C (ISO/IEC TR 19769:2004?).</p>
<p><b>Notes</b></p>
<p>Create issue. Document in question should be C99, not C90+amendment1. The 
    rest of the section requires careful review for completeness. Example &lt;cstdint&gt; 
    18.4.1 [cstdint.syn]. Assign to C liasons.</p>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial. Already fixed.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1156"></a>1156. Constraints on bitmask and enumeration types to be tightened</h3>
<p><b>Section:</b> 17.5.2.1.2 [enumerated.types], 17.5.2.1.3 [bitmask.types] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-28 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 165</b></p>

<p><b>Description</b></p>
        <p>Constraints on
        bitmask and enumeration types were supposed to be tightened
        up as part of the motivation for the <tt>constexpr</tt> feature -
        see paper
        <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2235.pdf">N2235</a>
        for details</p>
<p><b>Suggestion</b></p>
        <p>Adopt wording in line with the motivation
        described in
        <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2235.pdf">N2235</a></p>
<p><b>Notes</b></p>
        <p>Robert Klarer to review</p>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
Move to Open. Ping Robert Klarer to provide wording, using N2235 as
guidance.
</blockquote>

<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote>
Moved to NAD.  Rationale added.
</blockquote>



<p><b>Rationale:</b></p>
<p>
UK NB did not sufficiently describe how to resolve their comment, and
therefore we cannot make a change for the FCD. If a resolution were
provided in the future, we would be happy to apply it.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1160"></a>1160. <tt>future_error</tt> public constructor is 'exposition only'</h3>
<p><b>Section:</b> 30.6.3 [futures.future_error] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-28 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 331</b></p>

<p><b>Description</b></p>
        <p>Not clear what
        it means for a public constructor to be 'exposition only'.
        If the intent is purely to support the library calling this
        constructor then it can be made private and accessed
        through friendship. Otherwise it should be documented for
        public consumption.</p>
<p><b>Suggestion</b></p>
        <p>Declare the constructor as private with a
        note about intended friendship, or remove the
        exposition-only comment and document the semantics.</p>
<p><b>Notes</b></p>
<p>Create an issue. Assigned to Detlef. Suggested resolution probably makes 
    sense.</p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Pending a paper from Anthony Williams / Detleff Volleman.
</blockquote>

<p><i>[
2009-10-14 Pending paper:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2967.html">N2967</a>.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2997.html">N2997</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1161"></a>1161. Unnecessary <tt>unique_future</tt> limitations</h3>
<p><b>Section:</b> 30.6.6 [futures.unique_future] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-28 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#futures.unique_future">issues</a> in [futures.unique_future].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 336</b></p>

<p><b>Description</b></p>

        <p>It is possible
        to transfer ownership of the asynchronous result from one
        unique_future instance to another via the move-constructor.
        However, it is not possible to transfer it back, and nor is
        it possible to create a default-constructed unique_future
        instance to use as a later move target. This unduly limits
        the use of <tt>unique_future</tt> in code. Also, the lack of a
        move-assignment operator restricts the use of <tt>unique_future</tt>
        in containers such as <tt>std::vector</tt> - <tt>vector::insert</tt> requires
        move-assignable for example.</p>
<p><b>Suggestion</b></p>
        <p>Add a default constructor with the
        semantics that it creates a <tt>unique_future</tt> with no
        associated asynchronous result. Add a move-assignment
        operator which transfers ownership.</p>
<p><b>Notes</b></p>
<p>Create an issue. Detlef will look into it.</p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Pending a paper from Anthony Williams / Detleff Volleman.
</blockquote>

<p><i>[
2009-10-14 Pending paper:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2967.html">N2967</a>.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2997.html">N2997</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1162"></a>1162. <tt>shared_future</tt> should support an efficient move constructor</h3>
<p><b>Section:</b> 30.6.7 [futures.shared_future] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-28 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#futures.shared_future">issues</a> in [futures.shared_future].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 337</b></p>

<p><b>Description</b></p>
        <p><tt>shared_future</tt>
        should support an efficient move constructor that can avoid
        unnecessary manipulation of a reference count, much like
        <tt>shared_ptr</tt></p>
<p><b>Suggestion</b></p>
        <p>Add a move constructor</p>
<p><b>Notes</b></p>
<p>Create an issue. Detlef will look into it.</p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Pending a paper from Anthony Williams / Detleff Volleman.
</blockquote>

<p><i>[
2009-10-14 Pending paper:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2967.html">N2967</a>.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2997.html">N2997</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1163"></a>1163. <tt>shared_future</tt> is inconsistent with <tt>shared_ptr</tt></h3>
<p><b>Section:</b> 30.6.7 [futures.shared_future] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-28 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#futures.shared_future">issues</a> in [futures.shared_future].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 338</b></p>

<p><b>Description</b></p>

        <p><tt>shared_future</tt> is currently
        CopyConstructible, but not CopyAssignable. This is
        inconsistent with <tt>shared_ptr</tt>, and will surprise users.
        Users will then write work-arounds to provide this
        behaviour. We should provide it simply and efficiently as
        part of shared_future. Note that since the shared_future
        member functions for accessing the state are all declared
        const, the original usage of an immutable shared_future
        value that can be freely copied by multiple threads can be
        retained by declaring such an instance as "<tt>const
        shared_future</tt>".</p>
<p><b>Suggestion</b></p>
        <p>Remove "=delete"
        from the copy-assignment operator of shared_future. Add a
        move-constructor <tt>shared_future(shared_future&amp;&amp;
        rhs)</tt>, and a move-assignment operator <tt>shared_future&amp;
        operator=(shared_future&amp;&amp; rhs)</tt>. The postcondition
        for the copy-assignment operator is that <tt>*this</tt> has the same
        associated state as <tt>rhs</tt>. The postcondition for the
        move-constructor and move assignment is that <tt>*this</tt> has the
        same associated as <tt>rhs</tt> had before the
        constructor/assignment call and that <tt>rhs</tt> has no associated
        state.</p>
<p><b>Notes</b></p>
<p>Create an issue. Detlef will look into it.</p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Pending a paper from Anthony Williams / Detleff Volleman.
</blockquote>

<p><i>[
2009-10-14 Pending paper:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2967.html">N2967</a>.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2997.htm">N2997</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1164"></a>1164. <tt>promise::swap</tt> should pass by rvalue reference</h3>
<p><b>Section:</b> 30.6.5 [futures.promise] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-28 <b>Last modified:</b> 2010-10-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#futures.promise">active issues</a> in [futures.promise].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#futures.promise">issues</a> in [futures.promise].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 341</b></p>

<p><b>Description</b></p>
<p><tt>promise::swap</tt> accepts its parameter by lvalue reference. This is
inconsistent with other types that provide a swap member function,
where those swap functions accept an rvalue reference</p>

<p><b>Suggestion</b></p>
<p>Change <tt>promise::swap</tt> to take an rvalue reference.</p>

<p><b>Notes</b></p>
<p>Create an issue. Detlef will look into it. Probably ready as it.</p>  

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
NAD, by virtue of the changed rvalue rules and swap signatures from Summit.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1165"></a>1165. Unneeded promise move constructor</h3>
<p><b>Section:</b> 30.6.5 [futures.promise] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-28 <b>Last modified:</b> 2010-10-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#futures.promise">active issues</a> in [futures.promise].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#futures.promise">issues</a> in [futures.promise].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 343</b></p>

<p><b>Description</b></p>
        <p>The move constructor of a std::promise
        object does not need to allocate any memory, so the
        move-construct-with-allocator overload of the constructor
        is superfluous.</p>
<p><b>Suggestion</b></p>
        <p>Remove the
        constructor with the signature <tt>template &lt;class
        Allocator&gt; promise(allocator_arg_t, const Allocator&amp;
        a, promise&amp; rhs);</tt></p>
<p><b>Notes</b></p>
<p>Create an issue. Detlef will look into it. Will solicit feedback from Pablo. 
    Note that rhs argument should also be an rvalue reference in any case.</p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
Pending a paper from Anthony Williams / Detleff Volleman.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2997.html">N2997</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1166"></a>1166. Allocator-specific move/copy break model of move-constructor and
        move-assignment</h3>
<p><b>Section:</b> X [allocator.propagation], X [allocator.propagation.map], 23 [containers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-28 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses US 77</b></p>

<p><b>Description</b></p>
        <p>Allocator-specific move and copy behavior for containers
        (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2525.pdf">N2525</a>) complicates a little-used and already-complicated
        portion of the standard library (allocators), and breaks
        the conceptual model of move-constructor and
        move-assignment operations on standard containers being
        efficient operations. The extensions for allocator-specific
        move and copy behavior should be removed from the working
        paper.</p>
        <p>With the
        introduction of rvalue references, we are teaching
        programmers that moving from a standard container (e.g., a
        <tt>vector&lt;string&gt;</tt>) is an efficient, constant-time
        operation. The introduction of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2525.pdf">N2525</a> removed that
        guarantee; depending on the behavior of four different
        traits (20.8.4), the complexity of copy and move operations
        can be constant or linear time. This level of customization
        greatly increases the complexity of standard containers,
        and benefits only a tiny fraction of the C++ community.</p>
<p><b>Suggestion</b></p>

        <p>Remove 20.8.4.</p>
        
        <p>Remove 20.8.5.</p>
        
        <p>Remove all references to the facilities in
        20.8.4 and 20.8.5 from clause 23.</p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Addressed by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2982.pdf">N2982</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1167"></a>1167. <tt>pair&lt;T,U&gt;</tt> doesn't model <tt>LessThanComparable</tt> in unconstrained code even if
      <tt>T</tt> and <tt>U</tt> do.</h3>
<p><b>Section:</b> 20.3.5 [pairs] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Dave Abrahams <b>Opened:</b> 2009-07-01 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#pairs">issues</a> in [pairs].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>LessThanComparable</tt> requires (and provides default
             implementations for) &lt;=,&gt;, and &gt;=.  However, the defaults
             don't take effect in unconstrained code.
</p>
<p>
Still, it's a problem to have types acting one way in
constrained code and another in unconstrained code, except in cases of
syntax adaptation.  It's also inconsistent with the containers, which
supply all those operators.
</p>
<p>
Totally Unbiased
Suggested Resolution:
</p>
<p>
accept the exported concept maps proposal and
                    change the way this stuff is handled to use an
                    explicit exported concept map rather than nested
                    function templates
</p>
<p>
e.g., remove from the body of <tt>std::list</tt>
</p>
<blockquote><pre>template &lt;LessThanComparable T, class Allocator&gt; 
bool operator&lt; (const list&lt;T,Allocator&gt;&amp; x, const list&lt;T,Allocator&gt;&amp; y); 
template &lt;LessThanComparable T, class Allocator&gt; 
bool operator&gt; (const list&lt;T,Allocator&gt;&amp; x, const list&lt;T,Allocator&gt;&amp; y); 
template &lt;LessThanComparable T, class Allocator&gt; 
bool operator&gt;=(const list&lt;T,Allocator&gt;&amp; x, const list&lt;T,Allocator&gt;&amp; y); 
template &lt;LessThanComparable T, class Allocator&gt; 
bool operator&lt;=(const list&lt;T,Allocator&gt;&amp; x, const list&lt;T,Allocator&gt;&amp; y); 
</pre></blockquote>
<p>
and add this concept_map afterwards:
</p>
<blockquote><pre>template &lt;LessThanComparable T, class Allocator&gt; 
export concept_map LessThanComparable&lt;list&lt;T,Allocator&gt; &gt;
{
    bool operator&lt;(const list&lt;T,Allocator&gt;&amp; x, const list&lt;T,Allocator&gt;&amp; y);
}
</pre></blockquote>
<p>
do similarly for <tt>std::pair</tt>.  While you're at it, do the same for
<tt>operator==</tt> and <tt>!=</tt> everywhere, and seek out other such opportunities.
</p>
<p>
Alternative Resolution: keep the ugly, complex specification and add the
                       missing operators to <tt>std::pair</tt>.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1168"></a>1168. Odd wording for bitset equality operators</h3>
<p><b>Section:</b> 20.5.2 [bitset.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-07-02 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#bitset.members">issues</a> in [bitset.members].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The following wording seems a little unusual to me:
</p>
<p>
p42/43 20.5.2 [bitset.members]
</p>

<blockquote>
<pre>bool operator==(const bitset&lt;N&gt;&amp; rhs) const;
</pre>
<blockquote>
-42- <i>Returns:</i> A nonzero value if the value of each bit in
<tt>*this</tt> equals the value of the corresponding bit in
<tt>rhs</tt>.
</blockquote>
<pre>bool operator!=(const bitset&lt;N&gt;&amp; rhs) const;
</pre>
<blockquote>
-43- <i>Returns:</i> A nonzero value if <tt>!(*this == rhs)</tt>.
</blockquote>
</blockquote>

<p>
"A nonzero value" may be well defined as equivalent to the literal '<tt>true</tt>'
for Booleans, but the wording is clumsy.  I suggest replacing "A nonzero value"
with the literal '<tt>true</tt>' (in appropriate font) in each case.
</p>

<p><i>[
2009-07-24 Alisdair recommends NAD Editorial.
]</i></p>


<p><i>[
2009-07-27 Pete adds:
]</i></p>


<blockquote>
It's obviously editorial. There's no need for further discussion.
</blockquote>

<p><i>[
2009-07-27 Howard sets to NAD Editorial.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Change 20.5.2 [bitset.members] p42-43:
</p>

<blockquote>
<pre>bool operator==(const bitset&lt;N&gt;&amp; rhs) const;
</pre>
<blockquote>
-42- <i>Returns:</i> <del>A nonzero value</del> <ins><tt>true</tt></ins> if the value of each bit in
<tt>*this</tt> equals the value of the corresponding bit in
<tt>rhs</tt>.
</blockquote>
<pre>bool operator!=(const bitset&lt;N&gt;&amp; rhs) const;
</pre>
<blockquote>
-43- <i>Returns:</i> <del>A nonzero value</del> <ins><tt>true</tt></ins> if <tt>!(*this == rhs)</tt>.
</blockquote>
</blockquote>






<hr>
<h3><a name="1172"></a>1172. <tt>select_on_container_(copy|move)_construction</tt> over-constrained</h3>
<p><b>Section:</b> X [allocator.concepts.members] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alberto Ganesh Barbati <b>Opened:</b> 2009-07-08 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I believe the two functions
<tt>select_on_container_(copy|move)_construction()</tt> are over-constrained. For
example, the return value of the "copy" version is (see
X [allocator.concepts.members]/21):
</p>
<blockquote>
<i>Returns:</i> <tt>x</tt> if the allocator should propagate from the existing
container to the new container on copy construction, otherwise <tt>X()</tt>.
</blockquote>
<p>
Consider the case where a user decides to provide an explicit concept
map for Allocator to adapt some legacy allocator class, as he wishes to
provide customizations that the <tt>LegacyAllocator</tt> concept map template
does not provide.  Now, although it's true that the legacy class is
required to have a default constructor, the user might have reasons to
prefer a different constructor to implement
<tt>select_on_container_copy_construction()</tt>. However, the current wording
requires the use of the default constructor.
</p>
<p>
Moreover, it's not said explicitly that <tt>x</tt> is supposed to be the
allocator of the existing container. A clarification would do no harm.
</p>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Editorial.  Addressed by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2982.pdf">N2982</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Replace X [allocator.concepts.members]/21 with:
</p>

<blockquote><pre>X select_on_container_copy_construction(const X&amp; x);
</pre>
<p>
-21- <i>Returns:</i> <del><tt>x</tt> if the allocator should propagate from the existing
container to the new container on copy construction, otherwise <tt>X()</tt>.</del>
<ins>an allocator object to be used by the new container on copy
construction. [<i>Note:</i> <tt>x</tt> is the allocator of the existing container that
is being copied. The most obvious choices for the return value are <tt>x</tt>, if
the allocator should propagate from the existing container, and <tt>X()</tt>.
<i> end note</i>]</ins>
</p>
</blockquote>

<p>
Replace X [allocator.concepts.members]/25 with:
</p>

<blockquote><pre>X select_on_container_move_construction(X&amp;&amp; x);
</pre>
<p>
-25- <i>Returns:</i> <del><tt>move(x)</tt> if the allocator should propagate from the existing
container to the new container on move construction, otherwise <tt>X()</tt>.</del>
<ins>an allocator object to be used by the new container on move
construction. [<i>Note:</i> <tt>x</tt> is the allocator of the existing container that
is being moved. The most obvious choices for the return value are <tt>move(x)</tt>, if
the allocator should propagate from the existing container, and <tt>X()</tt>.
<i> end note</i>]</ins>
</p>
</blockquote>






<hr>
<h3><a name="1173"></a>1173. "Equivalence" wishy-washiness</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Future">NAD Future</a>
 <b>Submitter:</b> David Abrahams <b>Opened:</b> 2009-07-14 <b>Last modified:</b> 2010-11-24</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Issue: The <tt>CopyConstructible</tt> requirements are wishy-washy.  It requires
that the copy is "equivalent" to the original, but "equivalent" is never
defined.
</p>
<p>
I believe this to be an example of a more general lack of rigor around
copy and assignment, although I haven't done the research to dig up all
the instances.
</p>
<p>
It's a problem because if you don't know what <tt>CopyConstructible</tt> means,
you also don't know what it means to copy a pair of <tt>CopyConstructible</tt>
types.  It doesn't prevent us from writing code, but it is a hole in our
ability to understand the meaning of copy.
</p>
<p>
Furthermore, I'm pretty sure that vector's copy constructor doesn't
require the elements to be <tt>EqualityComparable</tt>, so that table is actually
referring to some ill-defined notion of equivalence when it uses ==.
</p>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
Move to "Open". Dave is right that this is a big issue. Paper D2987
("Defining Move Special Member Functions", Bjarne Stroustrup and
Lawrence Crowl) touches on this but does not solve it. This issue is
discussed in Elements of Programming.
</blockquote>


<p><i>[
2010 Rapperswil:
]</i></p>


<blockquote>
This issue is quite vague, so it is difficult to know if and when it has been resolved.

John Lakos wrote a paper covering this area a while back, and there is a real interest in providing some sort of clean-up in the future.

We need a more clearly draughted issues with an addressable set of concerns, ideally with a paper proposing a resolution, but for a future revision of the standard.

Move to Tentatively NAD Future.
</blockquote>

<p><i>[
Moved to NAD Future at 2010-11 Batavia
]</i></p>




<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1176"></a>1176. Make <tt>thread</tt> constructor non-variadic</h3>
<p><b>Section:</b> 30.3.1.2 [thread.thread.constr] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-07-18 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.thread.constr">issues</a> in [thread.thread.constr].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The variadic <tt>thread</tt> constructor is causing controversy, e.g.
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2901.pdf">N2901</a>.
This issue has been created as a placeholder for this course of action.
</p>

<blockquote><pre>template &lt;class F<del>, class ...Args</del>&gt; thread(F&amp;&amp; f<del>, Args&amp;&amp;... args</del>);
</pre></blockquote>

<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#929">929</a> for wording which specifies an rvalue-ref signature but
with "decay behavior", but using variadics.
</p>

<p><i>[
2009-11-17 Moved to Tentatively NAD after 5 positive votes on c++std-lib. 
Rationale added below.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
</p>


<p><b>Rationale:</b></p>
<p>
The (tentative) concensus of the LWG is to keep the variadic thread constructor.
</p>





<hr>
<h3><a name="1179"></a>1179. Probably editorial in [structure.specifications]</h3>
<p><b>Section:</b> 17.5.1.4 [structure.specifications] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Robert Klarer <b>Opened:</b> 2009-07-21 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#structure.specifications">issues</a> in [structure.specifications].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
While reviewing <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#971">971</a> I noted that 17.5.1.4 [structure.specifications]/7 says:
</p>

<blockquote>
-7- Error conditions specify conditions where a function may fail. The
conditions are listed, together with a suitable explanation, as the <tt>enum
class errc</tt> constants (19.5) that could be used as an argument to
function <tt>make_error_condition</tt> (19.5.3.6).
</blockquote>

<p>
This paragraph should mention <tt>make_error_code</tt> or the text "that
could be used as an argument to function <tt>make_error_condition</tt>
(19.5.3.6)" should be deleted.  I believe this is editorial.
</p>

<p><i>[
2009-07-21 Chris adds:
]</i></p>


<blockquote>
<p>
I'm not convinced there's a problem there, because as far as the "Error
conditions" clauses are concerned, make_error_condition() is used by a
user to test for the condition, whereas make_error_code is not. For
example:
</p>

<blockquote><pre>void foobar(error_code&amp; ec = throws());
</pre></blockquote>

<p>
 Error conditions:
</p>
<blockquote>
permission_denied - Insufficient privilege to perform operation.
</blockquote>

<p>
When a user writes:
</p>

<blockquote><pre>error_code ec;
foobar(ec);
if (ec == errc::permission_denied)
   ...
</pre></blockquote>

<p>
the implicit conversion <tt>errc-&gt;error_condition</tt> makes the if-test
equivalent to:
</p>

<blockquote><pre>if (ec == make_error_condition(errc::permission_denied))
</pre></blockquote>

<p>
On the other hand, if the user had written:
</p>

<blockquote><pre>if (ec == make_error_code(errc::permission_denied))
</pre></blockquote>

<p>
the test is now checking for a specific error code. The test may
evaluate to <tt>false</tt> even though <tt>foobar()</tt> failed due to the documented
error condition "Insufficient privilege".
</p>
</blockquote>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
<p>
NAD Editorial.
</p>
<p>
What the WP says right now is literally true: these codes can be used as
an argument to <tt>make_error_condition</tt>. (It is also true that they can be
used as an argument to <tt>make_error_code</tt>, which the WP doesn't say.) Maybe
it would be clearer to just delete "that could be used as an argument to
function <tt>make_error_condition</tt>", since that fact is already implied by
other things that we say. We believe that this is editorial.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="1184"></a>1184. Feature request: dynamic bitset</h3>
<p><b>Section:</b> 23.4.1 [vector] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Future">NAD Future</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-07-29 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#vector">issues</a> in [vector].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Opened at Alisdair's request, steming from <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#96">96</a>.
Alisdair recommends NAD Future.
</p>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Future.  We want a heap allocated bitset, but we don't have one today and
don't have time to add one.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1185"></a>1185. iterator categories and output iterators</h3>
<p><b>Section:</b> 24.2 [iterator.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-07-31 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iterator.requirements">issues</a> in [iterator.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
(wording relative to
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a>
pending new working paper)
</p>

<p>
According to p3 24.2 [iterator.requirements], Forward iterators,
Bidirectional iterators and Random Access iterators all satisfy the
requirements for an Output iterator:
</p>

<blockquote>
XXX iterators satisfy all the requirements of the input and output iterators
and can be used whenever either kind is specified ...
</blockquote>

<p>
Meanwhile, p4 goes on to contradict this:
</p>

<blockquote>
Besides its category, a forward, bidirectional, or random access
iterator can also be mutable or constant...
</blockquote>

<blockquote>
... Constant iterators do not satisfy the requirements for output iterators
</blockquote>

<p>
The latter seems to be the overriding concern, as the iterator tag
hierarchy does not define <tt>forward_iterator_tag</tt> as multiply derived from
both <tt>input_iterator_tag</tt> and <tt>output_iterator_tag</tt>.
</p>

<p>
The work on concepts for iterators showed us that output iterator really
is fundamentally a second dimension to the iterator categories, rather
than part of the linear input -&gt; forward -&gt; bidirectional -&gt;
random-access sequence.  It would be good to clear up these words to
reflect that, and separately list output iterator requirements in the
requires clauses for the appropriate algorithms and operations.
</p>

<p><i>[
2010 Pittsburgh:  Moved to NAD Editorial.  Rationale added below.
]</i></p>




<p><b>Rationale:</b></p>
<p>
Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3066.html">N3066</a>.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1186"></a>1186. Forward list could model a stack</h3>
<p><b>Section:</b> 23.5.3 [stack] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Concepts">NAD Concepts</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-07-31 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Concepts">NAD Concepts</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The library template <tt>forward_list</tt> could easily model the idea of a
<tt>stack</tt>, where the operations work on the front of the list rather than
the back.  However, the standard library <tt>stack</tt> adaptor cannot support
this.
</p>

<p>
It would be relatively easy to write a partial specialization for <tt>stack</tt>
to support <tt>forward_list</tt>, but that opens the question of which header to
place it in.  A much better solution would be to add a <tt>concept_map</tt> for
the <tt>StackLikeContainer</tt> concept to the <tt>&lt;forward_list&gt;</tt> header and then
everything just works, including a user's own further uses in a
stack-like context.
</p>

<p>
Therefore while I am submitting the issue now so that it is on record, I
<em>strongly recommend</em> we resolve as "NAD Concepts" as any non-concepts
based solution will be inferior to the final goal, and the feature is
not so compelling it must be supported ahead of the concepts-based
library.
</p>

<p><i>[
2009-11-02 Howard adds:
]</i></p>


<blockquote>
Moved to Tentatively NAD Concepts after 5 positive votes on c++std-lib.
</blockquote>


<p><b>Rationale:</b></p>
<p>
Any non-concepts based solution will be inferior to the final goal, and the
feature is not so compelling it must be supported ahead of the concepts-based
library.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1188"></a>1188. Unordered containers should have a minimum load factor as well as a maximum</h3>
<p><b>Section:</b> 23.2.5 [unord.req], 23.7 [unord] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Future">NAD Future</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2009-08-10 <b>Last modified:</b> 2010-11-24</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#unord.req">active issues</a> in [unord.req].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unord.req">issues</a> in [unord.req].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Unordered associative containers have a notion of a maximum load factor:
when the number of elements grows large enough, the containers
automatically perform a rehash so that the number of elements per bucket
stays below a user-specified bound. This ensures that the hash table's
performance characteristics don't change dramatically as the size
increases.
</p>

<p>
For similar reasons, Google has found it useful to specify a minimum
load factor: when the number of elements shrinks by a large enough, the
containers automatically perform a rehash so that the number of elements
per bucket stays above a user-specified bound. This is useful for two
reasons. First, it prevents wasting a lot of memory when an unordered
associative container grows temporarily. Second, it prevents amortized
iteration time from being arbitrarily large; consider the case of a hash
table with a billion buckets and only one element. (This was discussed
even before TR1 was published; it was TR issue 6.13, which the LWG
closed as NAD on the grounds that it was a known design feature.
However, the LWG did not consider the approach of a minimum load
factor.)
</p>

<p>
The only interesting question is when shrinking is allowed. In principle
the cleanest solution would be shrinking on erase, just as we grow on
insert. However, that would be a usability problem; it would break a
number of common idioms involving erase. Instead, Google's hash tables
only shrink on insert and rehash.
</p>

<p>
The proposed resolution allows, but does not require, shrinking in
rehash, mostly because a postcondition for rehash that involves the
minimum load factor would be fairly complicated. (It would probably have
to involve a number of special cases and it would probably have to
mention yet another parameter, a minimum bucket count.)
</p>

<p>
The current behavior is equivalent to a minimum load factor of 0. If we
specify that 0 is the default, this change will have no impact on
backward compatibility.
</p>


<p><i>[
2010 Rapperswil:
]</i></p>


<blockquote>
This seems to a useful extension, but is too late for 0x.

Move to Tentatively NAD Future.
</blockquote>

<p><i>[
Moved to NAD Future at 2010-11 Batavia
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Add two new rows, and change rehash's postcondition in the unordered
associative container requirements table in 23.2.5 [unord.req]:
</p>

<blockquote>
<table border="1">
<caption>Table 87  Unordered associative container requirements
(in addition to container)</caption>

<tbody><tr>
<th>Expression</th><th>Return type</th><th>Assertion/note pre-/post-condition</th>
<th>Complexity</th>
</tr>
<tr>
<td><ins>
<tt>a.min_load_factor()</tt>
</ins></td>
<td><ins>
<tt>float</tt>
</ins></td>
<td><ins>
Returns a non-negative number that the container attempts to keep the
load factor greater than or equal to. The container automatically
decreases the number of buckets as necessary to keep the load factor
above this number.
</ins></td>
<td><ins>
constant
</ins></td>
</tr>

<tr>
<td><ins><tt>a.min_load_factor(z)</tt></ins></td>
<td><ins><tt>void</tt></ins></td>
<td><ins>Pre: <tt>z</tt> shall be non-negative. Changes the container's minimum
load factor, using <tt>z</tt> as a hint. [<i>Footnote:</i> the minimum
load factor should be significantly smaller than the maximum. 
If <tt>z</tt> is too large, the implementation may reduce it to a more sensible value.]
</ins></td>
<td><ins>
constant
</ins></td>
</tr>
<tr>
<td><tt>a.rehash(n)</tt></td>
<td><tt>void</tt></td>
<td>
Post: <ins><tt>a.bucket_count() &gt;= n</tt>, and <tt>a.size() &lt;= a.bucket_count()
* a.max_load_factor()</tt>. [<i>Footnote:</i> It is intentional that the
postcondition does not mention the minimum load factor.
This member function is primarily intended for cases where the user knows
that the container's size will increase soon, in which case the container's
load factor will temporarily fall below <tt>a.min_load_factor()</tt>.]</ins>
<del>
<tt>a.bucket_cout &gt; a.size() / a.max_load_factor()</tt> and <tt>a.bucket_count()
&gt;= n</tt>.
</del>
</td>
<td>
Average case linear in <tt>a.size()</tt>, worst case quadratic.
</td>
</tr>
</tbody></table>
</blockquote>

<p>
Add a footnote to 23.2.5 [unord.req] p12:
</p>

<blockquote>
<p>
The insert members shall not affect the validity of references to
container elements, but may invalidate all iterators to the container.
The erase members shall invalidate only iterators and references to the
erased elements.
</p>

<blockquote><ins>
[A consequence of these requirements is that while insert may change the
number of buckets, erase may not. The number of buckets may be reduced
on calls to insert or rehash.]
</ins></blockquote>
</blockquote>

<p>
Change paragraph 13:
</p>

<blockquote>
The insert members shall not affect the validity of iterators if
<del><tt>(N+n) &lt; z * B</tt></del> <ins><tt>zmin * B &lt;= (N+n) &lt;= zmax * B</tt></ins>,
where <tt>N</tt> is the number of elements in
the container prior to the insert operation, <tt>n</tt> is the number of
elements inserted, <tt>B</tt> is the container's bucket count,
<ins><tt>zmin</tt> is the container's minimum load factor,</ins>
and <tt>z<ins>max</ins></tt> is the container's maximum load factor.
</blockquote>

<p>
Add to the <tt>unordered_map</tt> class synopsis in section 23.7.1 [unord.map],
the <tt>unordered_multimap</tt> class synopsis
in 23.7.2 [unord.multimap], the <tt>unordered_set</tt> class synopsis in
23.7.3 [unord.set], and the <tt>unordered_multiset</tt> class synopsis
in 23.7.4 [unord.multiset]:
</p>

<blockquote><pre><ins>
float min_load_factor() const;
void min_load_factor(float z);
</ins></pre></blockquote>

<p>
In 23.7.1.1 [unord.map.cnstr], 23.7.2.1 [unord.multimap.cnstr], 23.7.3.1 [unord.set.cnstr], and
23.7.4.1 [unord.multiset.cnstr], change:
</p>

<blockquote>
... <tt>max_load_factor()</tt> returns 1.0 <ins>and
<tt>min_load_factor()</tt> returns 0</ins>.
</blockquote>





<hr>
<h3><a name="1190"></a>1190. Setting the maximum load factor should return the previous value</h3>
<p><b>Section:</b> 23.2.5 [unord.req], 23.7 [unord] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2009-08-10 <b>Last modified:</b> 2010-11-24</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#unord.req">active issues</a> in [unord.req].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unord.req">issues</a> in [unord.req].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The unordered associative container requirements table specifies that
<tt>a.set_max_load_factor(z)</tt> has return type <tt>void</tt>. However, there is a
useful piece of information to return: the previous value. Users who
don't need it can always ignore it.
</p>


<p><i>[
2010 Rapperswil:
]</i></p>


<blockquote>
The benefit seems minor, while breaking with the getter/setter idiom these overloads support.

Move to Tentatively NAD.
</blockquote>

<p><i>[
Moved to NAD at 2010-11 Batavia
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
In the unordered associative container requirements table, change:
</p>

<blockquote>
<table border="1">
<caption>Table 87  Unordered associative container requirements
(in addition to container)</caption>

<tbody><tr>
<th>Expression</th><th>Return type</th><th>Assertion/note pre-/post-condition</th>
<th>Complexity</th>
</tr>

<tr>
<td><tt>a.max_load_factor(z)</tt></td>
<td><tt><del>void</del> <ins>float</ins></tt></td>
<td>Pre: <tt>z</tt> shall be positive. Changes the container's maximum
<del>load</del> load factor, using <tt>z</tt> as a hint.
<ins>Returns: the previous value of
<tt>a.max_load_factor()</tt>.</ins>
</td>
<td>
constant
</td>
</tr>
<tr></tr>
</tbody></table>
</blockquote>

<p>
Change the return type of <tt>set_max_load_factor</tt>
in the class synopses in 23.7.1 [unord.map], 23.7.2 [unord.multimap],  23.7.3 [unord.set],
and 23.7.4 [unord.multiset].
</p>

<p>
If issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1188">1188</a> is also accepted, make the same changes for
<tt>min_load_factor</tt>.
</p>





<hr>
<h3><a name="1196"></a>1196. move semantics undefined for priority_queue</h3>
<p><b>Section:</b> 23.5.2.1 [priqueue.cons] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-08-19 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The class template <tt>priority_queue</tt> declares signatures for a move
constructor and move assignment operator in its class definition.
However, it does not provide a definition (unlike <tt>std::queue</tt>, and
proposed resolution for <tt>std::stack</tt>.) Nor does it provide a text clause
specifying their behaviour.
</p>

<p><i>[
2009-08-23 Daniel adds:
]</i></p>


<blockquote>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1194">1194</a> provides wording that solves this issue.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Mark NAD Editorial, solved by issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1194">1194</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1200"></a>1200. "surprising" <tt>char_traits&lt;T&gt;::int_type</tt> requirements</h3>
<p><b>Section:</b> 21.2.2 [char.traits.typedefs] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Sean Hunt <b>Opened:</b> 2009-09-03 <b>Last modified:</b> 2010-11-24</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#char.traits.typedefs">issues</a> in [char.traits.typedefs].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The footnote for <tt>int_type</tt> in 21.2.2 [char.traits.typedefs] says that
</p>

<blockquote>
If <tt>eof()</tt>
can be held in <tt>char_type</tt> then some iostreams implementations may give
surprising results.
</blockquote>

<p>
This implies that <tt>int_type</tt> should be a superset of
<tt>char_type</tt>. However, the requirements for <tt>char16_t</tt> and <tt>char32_t</tt> define
<tt>int_type</tt> to be equal to <tt>int_least16_t</tt> and <tt>int_least32_t</tt> respectively.
<tt>int_least16_t</tt> is likely to be the same size as <tt>char_16_t</tt>, which may lead
to surprising behavior, even if <tt>eof()</tt> is not a valid UTF-16 code unit.
The standard should not prescribe surprising behavior, especially
without saying what it is (it's apparently not undefined, just
surprising). The same applies for 32-bit types.
</p>

<p>
I personally recommend that behavior be undefined if <tt>eof()</tt> is a member
of <tt>char_type</tt>, and another type be chosen for <tt>int_type</tt> (my personal
favorite has always been a <tt>struct {bool eof; char_type c;}</tt>).
Alternatively, the exact results of such a situation should be defined,
at least so far that I/O could be conducted on these types as long as
the code units remain valid. Note that the argument that no one streams
<tt>char16_t</tt> or <tt>char32_t</tt> is not really valid as it would be perfectly
reasonable to use a <tt>basic_stringstream</tt> in conjunction with UTF character
types.
</p>

<p><i>[
2009-10-28 Ganesh provides two possible resolutions and expresses a preference
for the second:
]</i></p>


<blockquote>
<ol>
<li>
<p>
Replace 21.2.3.2 [char.traits.specializations.char16_t] para 3 with:
</p>

<blockquote>
The member <tt>eof()</tt> shall return <del>an implementation-defined
constant that cannot appear as a valid UTF-16 code unit</del>
<ins><tt>UINT_LEAST16_MAX</tt> [<i>Note:</i> this value is guaranteed to
be a permanently reserved UCS-2 code position if <tt>UINT_LEAST16_MAX ==
0xFFFF</tt> and it's not a UCS-2 code position otherwise  <i>end
note</i>]</ins>.
</blockquote>

<p>
Replace 21.2.3.3 [char.traits.specializations.char32_t] para 3 with:
</p>

<blockquote>
The member <tt>eof()</tt> shall return <del>an implementation-defined constant that
cannot appear as a Unicode code point</del>
<ins>
<tt>UINT_LEAST32_MAX</tt> [<i>Note:</i> this value is guaranteed to be a
permanently reserved UCS-4 code position if <tt>UINT_LEAST32_MAX ==
0xFFFFFFFF</tt> and it's not a UCS-4 code position otherwise  <i>end
note</i>]</ins>.
</blockquote>
</li>
<li>
<p>
In 21.2.3.2 [char.traits.specializations.char16_t], in the
definition of <tt>char_traits&lt;char16_t&gt;</tt> replace the definition of nested
typedef <tt>int_type</tt> with:
</p>

<blockquote><pre>namespace std {
  template&lt;&gt; struct char_traits&lt;char16_t&gt; {
    typedef char16_t         char_type;
    typedef <del>uint_least16_t</del> <ins>uint_fast16_t</ins> int_type;
     ...
</pre></blockquote>

<p>
Replace 21.2.3.2 [char.traits.specializations.char16_t] para 3 with:
</p>

<blockquote>
The member <tt>eof()</tt> shall return <del>an implementation-defined
constant that cannot appear as a valid UTF-16 code unit</del>
<ins><tt>UINT_FAST16_MAX</tt> [<i>Note:</i> this value is guaranteed to
be a permanently reserved UCS-2 code position if <tt>UINT_FAST16_MAX ==
0xFFFF</tt> and it's not a UCS-2 code position otherwise  <i>end
note</i>]</ins>.
</blockquote>

<p>
In 21.2.3.3 [char.traits.specializations.char32_t], in the
definition of <tt>char_traits&lt;char32_t&gt;</tt> replace the definition of nested
typedef <tt>int_type</tt> with:
</p>

<blockquote><pre>namespace std {
  template&lt;&gt; struct char_traits&lt;char32_t&gt; {
    typedef char32_t         char_type;
    typedef <del>uint_least32_t</del> <ins>uint_fast32_t</ins> int_type;
     ...
</pre></blockquote>

<p>
Replace 21.2.3.3 [char.traits.specializations.char32_t] para 3 with:
</p>

<blockquote>
The member <tt>eof()</tt> shall return <del>an implementation-defined constant that
cannot appear as a Unicode code point</del>
<ins>
<tt>UINT_FAST32_MAX</tt> [<i>Note:</i> this value is guaranteed to be a
permanently reserved UCS-4 code position if <tt>UINT_FAST32_MAX ==
0xFFFFFFFF</tt> and it's not a UCS-4 code position otherwise  <i>end
note</i>]</ins>.
</blockquote>
</li>
</ol>
</blockquote>


<p><i>[
2010 Rapperswil:
]</i></p>


<blockquote>
This seems an overspecification, and it is not clear what problem is being solved - these values can be used portably by using the named functions; there is no need for the value itself to be portable.

Move to Tentatively NAD.
</blockquote>

<p><i>[
Moved to NAD at 2010-11 Batavia
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="1201"></a>1201. Do we always want to unwrap <tt>ref</tt>-wrappers in <tt>make_tuple</tt></h3>
<p><b>Section:</b> 20.4.2.4 [tuple.creation], 20.3.5 [pairs] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Future">NAD Future</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-09-05 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#tuple.creation">issues</a> in [tuple.creation].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Spotting a recent thread on the boost lists regarding collapsing
optional representations in <tt>optional&lt;optional&lt;T&gt;&gt;</tt> instances, I wonder if
we have some of the same issues with <tt>make_tuple</tt>, and now <tt>make_pair</tt>?
</p>

<p>
Essentially, if my generic code in my own library is handed a
<tt>reference_wrapper</tt> by a user, and my library in turn delegates some logic
to <tt>make_pair</tt> or <tt>make_tuple</tt>, then I am going to end up with a <tt>pair</tt>/<tt>tuple</tt>
holding a real reference rather than the intended reference wrapper.
</p>

<p>
There are two things as a library author I can do at this point:
</p>

<ol type="i">
<li>
document my library also has the same reference-wrapper behaviour as
<tt>std::make_tuple</tt>
</li>
<li>
roll my own <tt>make_tuple</tt> that does not unwrap rereferences, a lost
opportunity to re-use the standard library.
</li>
</ol>

<p>
(There may be some metaprogramming approaches my library can use to wrap
the <tt>make_tuple</tt> call, but all will be significantly more complex than
simply implementing a simplified <tt>make_tuple</tt>.)
</p>

<p>
Now I don't propose we lose this library facility, I think unwrapping
references will be the common behaviour.  However, we might want to
consider adding another overload that does nothing special with
<tt>ref</tt>-wrappers.  Note that we already have a second overload of <tt>make_tuple</tt>
in the library, called <tt>tie</tt>.
</p>

<p><i>[
2009-09-30 Daniel adds:
]</i></p>


<blockquote>
<p>
I suggest to change the currently proposed paragraph for
<tt>make_simple_pair</tt>
</p>

<blockquote><pre>template&lt;typename... Types&gt;
  pair&lt;typename decay&lt;Types&gt;::type...&gt; make_simple_pair(Types&amp;&amp;... t);
</pre>
<blockquote>
<p>
<del><i>Type requirements:</i> <tt>sizeof...(Types) == 2</tt>.</del>
<ins><i>Remarks:</i> The program shall be ill-formed, if
<tt>sizeof...(Types) != 2</tt>.</ins>
</p>
<p>
...
</p>
</blockquote>
</blockquote>

<p>
or alternatively (but with a slightly different semantic):
</p>

<blockquote>
<blockquote>
<i>Remarks:</i> If <tt>sizeof...(Types) != 2</tt>, this function shall not
participate in overload resolution.
</blockquote>
</blockquote>

<p>
to follow a currently introduced style and because the library does
not have yet a specific "<i>Type requirements</i>" element. If such thing
would be considered as useful this should be done as a separate
issue. Given the increasing complexity of either of these wordings
it might be preferable to use the normal two-argument-declaration
style again in either of the following ways:
</p>

<ol type="A">
<li>
<pre>template&lt;class T1, class T2&gt;
pair&lt;typename decay&lt;T1&gt;::type, typename decay&lt;T2&gt;::type&gt;
make_simple_pair(T1&amp;&amp; t1, T2&amp;&amp; t2);
</pre>
</li>
<li>
<pre>template&lt;class T1, class T2&gt;
pair&lt;V1, V2&gt; make_simple_pair(T1&amp;&amp; t1, T2&amp;&amp; t2);
</pre>
<blockquote>
Let <tt>V1</tt> be <tt>typename decay&lt;T1&gt;::type</tt> and <tt>V2</tt> be
<tt>typename decay&lt;T2&gt;::type</tt>.
</blockquote>
</li>
</ol>

</blockquote>

<p><i>[
2009-10 post-Santa Cruz:
]</i></p>


<blockquote>
Mark as Tentatively NAD Future.
</blockquote>



<p><b>Rationale:</b></p>
<p>
Does not have sufficient support at this time. May wish to reconsider for a
future standard.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add the following function to 20.3.5 [pairs] and signature in
appropriate synopses:
</p>

<blockquote><pre>template&lt;typename... Types&gt;
  pair&lt;typename decay&lt;Types&gt;::type...&gt; make_simple_pair(Types&amp;&amp;... t);
</pre>
<blockquote>
<p>
<i>Type requirements:</i> <tt>sizeof...(Types) == 2</tt>.
</p>
<p>
<i>Returns:</i> <tt>pair&lt;typename decay&lt;Types&gt;::type...&gt;(std::forward&lt;Types&gt;(t)...)</tt>.
</p>
</blockquote>
</blockquote>

<p><i>[
Draughting note: I chose a variadic representation similar to <tt>make_tuple</tt>
rather than naming both types as it is easier to read through the
clutter of metaprogramming this way.  Given there are exactly two
elements, the committee may prefer to draught with two explicit template
type parameters instead
]</i></p>


<p>
Add the following function to 20.4.2.4 [tuple.creation] and
signature in appropriate synopses:
</p>

<blockquote><pre>template&lt;typename... Types&gt;
  tuple&lt;typename decay&lt;Types&gt;::type...&gt; make_simple_tuple(Types&amp;&amp;... t);
</pre>
<blockquote>
<p>
<i>Returns:</i> <tt>tuple&lt;typename decay&lt;Types&gt;::type...&gt;(std::forward&lt;Types&gt;(t)...)</tt>.
</p>
</blockquote>
</blockquote>





<hr>
<h3><a name="1202"></a>1202. <tt>integral_constant</tt> needs a spring clean</h3>
<p><b>Section:</b> 20.7.3 [meta.help] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-09-05 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta.help">issues</a> in [meta.help].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The specification of <tt>integral_constant</tt> has been inherited
essentially unchanged from TR1:
</p>

<blockquote><pre>template &lt;class T, T v&gt;
struct integral_constant {
  static const T value = v;
  typedef T value_type;
  typedef integral_constant&lt;T,v&gt; type;
};
</pre></blockquote>

<p>
In light of 0x language changes there are several things we might
consider changing, notably the form of specification for value.
</p>

<p>
The current form requires a static data member have storage allocated
for it, where we could now implement without this using the new enum
syntax:
</p>

<blockquote><pre>template &lt;class T, T v&gt;
struct integral_constant {
  <b>enum : T { value = v };</b>
  typedef T value_type;
  typedef integral_constant type;
};
</pre></blockquote>

<p>
The effective difference between these two implementation is:
</p>

<ol type="i">
<li>
No requirement to allocate storage for data member (which we hope but do
not guarantee compilers strip today)
</li>

<li>
You can no longer take the address of the constant as
<tt>&amp;integral_constant&lt;T,v&gt;::value;</tt>
</li>
</ol>

<p>
Also note the editorial change to drop the explicit qualification of
<tt>integral_constant</tt> in the <tt>typedef type</tt>.  This makes it quite clear we
mean the current instantiation, and cannot be mistaken for a recursive
metaprogram.
</p>

<p>
Even if we don't mandate this implementation, it would be nice to give
vendors freedom under QoI to choose their preferred representation.
</p>

<p>
The other side of this issue is if we choose to retain the static
constant form.  In that case we should go further and insist on
<tt>constexpr</tt>, much like we did throughout <tt>numeric_limits</tt>:
</p>

<blockquote><pre>template &lt;class T, T v&gt;
struct integral_constant {
  static <b>constexpr</b> T value = v;
  typedef T value_type;
  typedef integral_constant type;
};
</pre></blockquote>

<p>
[Footnote] It turns out <tt>constexpr</tt> is part of the Tentatively Ready
resolution for <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1019">1019</a>.  I don't want to interfere with that issue, but
would like a new issue to consider if the fixed-base enum implementation
should be allowed.
</p>

<p><i>[
2009-09-05 Daniel adds:
]</i></p>


<blockquote>
<p>
I think that the suggested resolution is incomplete and
may have some possible unwanted side-effects. To understand
why, note that <tt>integral_constant</tt> is <em>completely</em> specified
by code in 20.7.3 [meta.help]. While this is usually considered
as a good thing, let me give a possible user-defined
specialization that would break given the suggested changes:
</p>

<blockquote><pre>enum NodeColor { Red, Black };

std::integral_constant&lt;NodeColor, Red&gt; red;
</pre></blockquote>

<p>
The reason why that breaks is due to the fact that
current core language rules does only allow integral
types as enum-bases, see 7.2 [dcl.enum]/2.
</p>

<p>
So, I think that we cannot leave the implementation the
freedom to decide which way they would like to provide
the implementation, because that is easily user-visible
(I don't speak of addresses, but of instantiation errors),
therefore if applied, this should be either specified or
wording must be added that gives a note about this
freedom of implementation.
</p>

<p>
Another possible disadvantage seems to me that user-expectations
are easy to disappoint if they see a failure
of the test
</p>

<blockquote><pre>assert(typeid(std::integral_constant&lt;int, 0&gt;::value) == typeid(int));
</pre></blockquote>

<p>
or of
</p>

<blockquote><pre>static_assert(std::is_same&lt;decltype(std::integral_constant&lt;int, 0&gt;::value), const int&gt;::value, "Bad library");
</pre></blockquote>

</blockquote>

<p><i>[
2010-01-14 Moved to Tentatively NAD after 5 positive votes on c++std-lib.
]</i></p>




<p><b>Rationale:</b></p>
<p>
We think that the suggested resolution is incomplete and may have some possible
unwanted side-effects.  (see Daniel's 2009-09-05 comment for details).
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1203"></a>1203. More useful rvalue stream insertion</h3>
<p><b>Section:</b> 27.7.2.9 [ostream.rvalue], 27.7.1.6 [istream.rvalue] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Future">NAD Future</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-09-06 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<p>
27.7.2.9 [ostream.rvalue] was created to preserve the ability to insert
into (and extract from 27.7.1.6 [istream.rvalue]) rvalue streams:
</p>

<blockquote><pre>template &lt;class charT, class traits, class T&gt;
  basic_ostream&lt;charT, traits&gt;&amp;
  operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp;&amp; os, const T&amp; x);
</pre>
<blockquote>
<p>
1 <i>Effects:</i> <tt>os &lt;&lt; x</tt>
</p>
<p>
2 <i>Returns:</i> <tt>os</tt>
</p>
</blockquote>
</blockquote>

<p>
This is good as it allows code that wants to (for example) open, write to, and
close an <tt>ofstream</tt> all in one statement:
</p>

<blockquote><pre>std::ofstream("log file") &lt;&lt; "Some message\n";
</pre></blockquote>

<p>
However, I think we can easily make this "rvalue stream helper" even easier to
use.  Consider trying to quickly create a formatted string.  With the current
spec you have to write:
</p>

<blockquote><pre>std::string s = static_cast&lt;std::ostringstream&amp;&gt;(std::ostringstream() &lt;&lt; "i = " &lt;&lt; i).str();
</pre></blockquote>

<p>
This will store "<tt>i = 10</tt>" (for example) in the string <tt>s</tt>.  Note
the need to cast the stream back to <tt>ostringstream&amp;</tt> prior to using
the member <tt>.str()</tt>.  This is necessary because the inserter has cast
the <tt>ostringstream</tt> down to a more generic <tt>ostream</tt> during the
insertion process.
</p>

<p>
I believe we can re-specify the rvalue-inserter so that this cast is unnecessary.
Thus our customer now has to only type:
</p>

<blockquote><pre>std::string s = (std::ostringstream() &lt;&lt; "i = " &lt;&lt; i).str();
</pre></blockquote>

<p>
This is accomplished by having the rvalue stream inserter return an rvalue of
the same type, instead of casting it down to the base class.  This is done by
making the stream generic, and constraining it to be an rvalue of a type derived
from <tt>ios_base</tt>.
</p>

<p>
The same argument and solution also applies to the inserter.  This code has been
implemented and tested.
</p>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
NAD Future.  No concensus for change.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 27.7.1.6 [istream.rvalue]:
</p>

<blockquote><pre>template &lt;class <del>charT, class traits</del> <ins>Istream</ins>, class T&gt;
  <del>basic_istream&lt;charT, traits&gt;&amp;</del> <ins>Istream&amp;&amp;</ins>
  operator&gt;&gt;(<del>basic_istream&lt;charT, traits&gt;</del> <ins>Istream</ins>&amp;&amp; is, T&amp; x);
</pre>
<blockquote>
<p>
1 <i>Effects:</i> <tt>is &gt;&gt; x</tt>
</p>
<p>
2 <i>Returns:</i> <tt><ins>std::move(</ins>is<ins>)</ins></tt>
</p>
<p><ins>
3 <i>Remarks:</i> This signature shall participate in overload resolution if
and only if <tt>Istream</tt> is not an lvalue reference type and is derived from
<tt>ios_base</tt>.
</ins></p>
</blockquote>
</blockquote>

<p>
Change 27.7.2.9 [ostream.rvalue]:
</p>

<blockquote><pre>template &lt;class <del>charT, class traits</del> <ins>Ostream</ins>, class T&gt;
  <del>basic_ostream&lt;charT, traits&gt;&amp;</del> <ins>Ostream&amp;&amp;</ins>
  operator&lt;&lt;(<del>basic_ostream&lt;charT, traits&gt;</del> <ins>Ostream</ins>&amp;&amp; os, const T&amp; x);
</pre>
<blockquote>
<p>
1 <i>Effects:</i> <tt>os &lt;&lt; x</tt>
</p>
<p>
2 <i>Returns:</i> <tt><ins>std::move(</ins>os<ins>)</ins></tt>
</p>
<p><ins>
3 <i>Remarks:</i> This signature shall participate in overload resolution if
and only if <tt>Ostream</tt> is not an lvalue reference type and is derived from
<tt>ios_base</tt>.
</ins></p>
</blockquote>
</blockquote>






<hr>
<h3><a name="1210"></a>1210. iterator reachability should not require a container</h3>
<p><b>Section:</b> 24.2 [iterator.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-09-18 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iterator.requirements">issues</a> in [iterator.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
p6 Iterator requirements 24.2 [iterator.requirements]
</p>

<blockquote>
An iterator <tt>j</tt> is called reachable from an iterator <tt>i</tt> if and only if
there is a finite sequence of applications of the expression <tt>++i</tt> that
makes <tt>i == j</tt>. If <tt>j</tt> is reachable from <tt>i</tt>, they refer to the same
container.
</blockquote>

<p>
A good example would be stream iterators, which do not refer to a
container.  Typically, the end iterator from a range of stream iterators
will compare equal for many such ranges.  I suggest striking the second
sentence.
</p>

<p>
An alternative wording might be:
</p>

<blockquote>
If <tt>j</tt> is reachable from <tt>i</tt>, and both <tt>i</tt> and
<tt>j</tt> are dereferencable iterators, then they refer to the same
range.
</blockquote>

<p><i>[
2010 Pittsburgh:  Moved to NAD Editorial.  Rationale added below.
]</i></p>




<p><b>Rationale:</b></p>
<p>
Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3066.html">N3066</a>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 24.2 [iterator.requirements], p6:
</p>

<blockquote>
An iterator <tt>j</tt> is called <i>reachable</i> from an iterator
<tt>i</tt> if and only if there is a finite sequence of applications of
the expression <tt>++i</tt> that makes <tt>i == j</tt>. <del>If
<tt>j</tt> is reachable from <tt>i</tt>, they refer to the same
container.</del>
</blockquote>





<hr>
<h3><a name="1211"></a>1211. move iterators should be restricted as input iterators</h3>
<p><b>Section:</b> 24.5.3.1 [move.iterator] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-09-18 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#move.iterator">issues</a> in [move.iterator].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I contend that while we can support both bidirectional and random access
traversal, the category of a move iterator should never be better than
<tt>input_iterator_tag</tt>.
</p>

<p>
The contentious point is that you cannot truly have a multipass property
when values are moved from a range.  This is contentious if you view a
moved-from object as still holding a valid value within the range.  
</p>

<p>
The second reason comes from the Forward Iterator requirements table:
</p>

<blockquote>
<p>
Forward iterators 24.2.5 [forward.iterators]
</p>

<p>
Table 102 -- Forward iterator requirements
</p>

<blockquote>
For expression <tt>*a</tt> the return type is:
"<tt>T&amp;</tt> if <tt>X</tt> is mutable, otherwise <tt>const T&amp;</tt>"
</blockquote>
</blockquote>

<p>
There is a similar constraint on <tt>a-&gt;m</tt>.
</p>

<p>
There is no support for rvalue references, nor do I believe their should
be.  Again, opinions may vary but either this table or the definition of
<tt>move_iterator</tt> need updating.
</p>

<p>
Note: this requirement probably need updating anyway if we wish to
support proxy iterators but I am waiting to see a new working paper
before filing that issue.
</p>

<p><i>[
2009-10 post-Santa Cruz:
]</i></p>


<blockquote>
Move to Open. Howard to put his rationale mentioned above into the issue
as a note.
</blockquote>

<p><i>[
2009-10-26 Howard adds:
]</i></p>


<blockquote>
<p>
<tt>vector::insert(pos, iter, iter)</tt> is significantly more effcient when
<tt>iter</tt> is a random access iterator, as compared to when it is an
input iterator.
</p>

<p>
When <tt>iter</tt> is an input iterator, the best algorithm
is to append the inserted range to the end of the <tt>vector</tt> using
<tt>push_back</tt>.  This may involve several reallocations before the input
range is exhausted.  After the append, then one can use <tt>std::rotate</tt>
to place the inserted range into the correct position in the vector.
</p>

<p>
But when <tt>iter</tt> is a random access iterator, the best algorithm
is to first compute the size of the range to be inserted (<tt>last - first</tt>),
do a buffer reallocation if necessary, scoot existing elements in the <tt>vector</tt>
down to make the "hole", and then insert the new elements directly to their correct
place.
</p>

<blockquote><b>
The insert-with-random-access-iterators algorithm is considerably more efficient
than the insert-with-input-iterators algorithm
</b></blockquote>

<p>
Now consider:
</p>

<blockquote><pre>vector&lt;A&gt; v;
<font color="#C80000">//  ... build up a large vector of A ...</font>
vector&lt;A&gt; temp;
<font color="#C80000">//  ... build up a large temporary vector of A to later be inserted ...</font>
typedef move_iterator&lt;vector&lt;A&gt;::iterator&gt; MI;
<font color="#C80000">//  Now insert the temporary elements:</font>
v.insert(v.begin() + N, MI(temp.begin()), MI(temp.end()));
</pre></blockquote>

<p>
A major motivation for using <tt>move_iterator</tt> in the above example is the
expectation that <tt>A</tt> is cheap to move but expensive to copy.  I.e. the
customer is looking for <em>high performance</em>.  If we allow <tt>vector::insert</tt>
to subtract two <tt>MI</tt>'s to get the distance between them, the customer enjoys
substantially better performance, compared to if we say that <tt>vector::insert</tt>
can not subtract two <tt>MI</tt>'s.
</p>

<p>
I can find no rationale for not giving this performance boost to our customers.
Therefore I am strongly against restricting <tt>move_iterator</tt> to the
<tt>input_iterator_tag</tt> category.
</p>

<p>
I believe that the requirement that forward
iterators have a dereference that returns an lvalue reference to cause unacceptable
pessimization.  For example <tt>vector&lt;bool&gt;::iterator</tt> also does not return
a <tt>bool&amp;</tt> on dereference.  Yet I am not aware of a single vendor that
is willing to ship <tt>vector&lt;bool&gt;::iterator</tt> as an input iterator.
Everyone classifies it as a random access iterator.  Not only does this not
cause any problems, it prevents significant performance problems.
</p>

</blockquote>

<p><i>[
2010 Pittsburgh:  Moved to NAD Editorial.  Rationale added below.
]</i></p>




<p><b>Rationale:</b></p>
<p>
Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3066.html">N3066</a>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Class template move_iterator 24.5.3.1 [move.iterator]
</p>

<blockquote><pre>namespace std {
template &lt;class Iterator&gt;
class move_iterator {
public:
 ...
 typedef <del>typename iterator_traits&lt;Iterator&gt;::iterator_category</del> <ins>input_iterator_tag</ins> iterator_category;
</pre></blockquote>





<hr>
<h3><a name="1212"></a>1212. result of post-increment/decrement operator</h3>
<p><b>Section:</b> 24.2 [iterator.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-09-18 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iterator.requirements">issues</a> in [iterator.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Forward iterator and bidirectional iterator place different requirements on the result of post-increment/decrement operator.  The same form should be used in each case.
</p>

<p>
Merging row from:
</p>

<blockquote><pre>Table 102 -- Forward iterator requirements
Table 103 -- Bidirectional iterator requirements

    r++ : convertible to const X&amp;
    r-- : convertible to const X&amp;
    
    *r++ : T&amp; if X is mutable, otherwise const T&amp;
    *r-- : convertible to T
</pre></blockquote>

<p><i>[
2010 Pittsburgh:  Moved to NAD Editorial.  Rationale added below.
]</i></p>




<p><b>Rationale:</b></p>
<p>
Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3066.html">N3066</a>.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1217"></a>1217. Quaternion support</h3>
<p><b>Section:</b> 26.4 [complex.numbers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Future">NAD Future</a>
 <b>Submitter:</b> Ted Shaneyfelt <b>Opened:</b> 2009-09-26 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#complex.numbers">issues</a> in [complex.numbers].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Concerning mathematically proper operation of the type:
</p>

<blockquote><pre>complex&lt;complex&lt;T&gt; &gt;
</pre></blockquote>

<p>
Generally accepted mathematical semantics of such a construct correspond
to quaternions through Cayly-Dickson construct
</p>

<blockquote><pre>(w+xi) + (y+zi) j
</pre></blockquote>

<p>
The proper implementation seems straightforward by adding a few
declarations like those below. I have included operator definition for
combining real scalars and complex types, as well, which seems
appropriate, as algebra of complex numbers allows mixing complex and
real numbers with operators. It also allows for constructs such as
<tt>complex&lt;double&gt; i=(0,1),  x = 12.34 + 5*i;</tt>
</p>

<p>
Quaternions are often used in areas such as computer graphics, where,
for example, they avoid the problem of Gimbal lock when rotating objects
in 3D space, and can be more efficient than matrix multiplications,
although I am applying them to a different field.
</p>

<pre>/////////////////////////ALLOW OPERATORS TO COMBINE REAL SCALARS AND COMPLEX VALUES /////////////////////////
template&lt;typename T,typename S&gt; complex&lt;T&gt; operator+(const complex&lt;T&gt; x,const S a) {
    complex&lt;T&gt; result(x.real()+a, x.imag());
    return result;
}
template&lt;typename T,typename S&gt; complex&lt;T&gt; operator+(const S a,const complex&lt;T&gt; x) {
    complex&lt;T&gt; result(a+x.real(), x.imag());
    return result;
}
template&lt;typename T,typename S&gt; complex&lt;T&gt; operator-(const complex&lt;T&gt; x,const S a) {
    complex&lt;T&gt; result(x.real()-a, x.imag());
    return result;
}
template&lt;typename T,typename S&gt; complex&lt;T&gt; operator-(const S a,const complex&lt;T&gt; x) {
    complex&lt;T&gt; result(a-x.real(), x.imag());
    return result;
}
template&lt;typename T,typename S&gt; complex&lt;T&gt; operator*(const complex&lt;T&gt; x,const S a) {
    complex&lt;T&gt; result(x.real()*a, x.imag()*a);
    return result;
}
template&lt;typename T,typename S&gt; complex&lt;T&gt; operator*(const S a,const complex&lt;T&gt; x) {
    complex&lt;T&gt; result(a*x.real(), a*x.imag());
    return result;
}

/////////////////////////PROPERLY IMPLEMENT QUATERNION SEMANTICS/////////////////////////
template&lt;typename T&gt; double normSq(const complex&lt;complex&lt;T&gt; &gt;q) {
    return q.real().real()*q.real().real()
         + q.real().imag()*q.real().imag()
         + q.imag().real()*q.imag().real()
         + q.imag().imag()*q.imag().imag();
}
template&lt;typename T&gt; double norm(const complex&lt;complex&lt;T&gt; &gt;q) {
    return sqrt(normSq(q));
}
/////// Cayley-Dickson Construction
template&lt;typename T&gt; complex&lt;complex&lt;T&gt; &gt; conj(const complex&lt;complex&lt;T&gt; &gt; x) {
    complex&lt;complex&lt;T&gt; &gt; result(conj(x.real()),-x.imag());
    return result;
}
template&lt;typename T&gt; complex&lt;complex&lt;T&gt; &gt; operator*(const complex&lt;complex&lt;T&gt; &gt; ab,const complex&lt;complex&lt;T&gt; &gt; cd) {
    complex&lt;T&gt; re(ab.real()*cd.real()-conj(cd.imag())*ab.imag());
    complex&lt;T&gt; im(cd.imag()*ab.real()+ab.imag()*conj(cd.real()));
    complex&lt;complex&lt;double&gt; &gt; q(re,im);
    return q;
}
//// Quaternion division
template&lt;typename S,typename T&gt; complex&lt;complex&lt;T&gt; &gt; operator/(const complex&lt;complex&lt;T&gt; &gt; q,const S a) {
    return q * (1/a);
}
template&lt;typename S,typename T&gt; complex&lt;complex&lt;T&gt; &gt; operator/(const S a,const complex&lt;complex&lt;T&gt; &gt; q) {
    return a*conj(q)/normSq(q);
}
template&lt;typename T&gt; complex&lt;complex&lt;T&gt; &gt; operator/(const complex&lt;complex&lt;T&gt; &gt; n, const complex&lt;complex&lt;T&gt; &gt; d) {
    return n * (conj(d)/normSq(d));
}
</pre>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Future.  There is no consensus or time to move this into C++0X.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1219"></a>1219. unique_lock::lock and resource_deadlock_would_occur</h3>
<p><b>Section:</b> 30.4.2.2.2 [thread.lock.unique.locking] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2009-09-30 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.lock.unique.locking">issues</a> in [thread.lock.unique.locking].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1159">1159</a></p>
<p><b>Discussion:</b></p>



<p>
<tt>unique_lock::lock</tt> and friends raise
"<tt>resource_deadlock_would_occur</tt> -- if the current thread already
owns the mutex (i.e., on entry, <tt>owns</tt> is <tt>true</tt>)."  1)
The current thread owning a mutex is not the same as any particular
<tt>unique_lock::owns</tt> being <tt>true</tt>. 2) There's no need to
raise this exception for a <tt>recursive_mutex</tt> if <tt>owns</tt> is
<tt>false</tt>. 3) If <tt>owns</tt> is true, we need to raise some
exception or the unique_lock will lose track of whether to unlock itself
on destruction, but "deadlock" isn't it. For (3), s/bool owns/int
ownership_level/ would fix it.
</p>

<p><i>[
2009-11-11 Alisdair notes that this issue is very closely related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1159">1159</a>,
if not a dup.
]</i></p>


<p><i>[
2009-11-14 Moved to Tentatively Dup after 5 positive votes on c++std-lib.
]</i></p>




<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1223"></a>1223. condition_variable_any lock matching?</h3>
<p><b>Section:</b> 30.5.2 [thread.condition.condvarany] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2009-09-30 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.condition.condvarany">issues</a> in [thread.condition.condvarany].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
For <tt>condition_variable_any</tt>, must all lock arguments to concurrent wait calls
"match" in some way, similar to the requirement in
30.5.1 [thread.condition.condvar] that <tt>lock.mutex()</tt> returns the same
value for each of the lock arguments supplied by all concurrently
waiting threads (via <tt>wait</tt> or <tt>timed_wait</tt>)?
</p>

<p><i>[
2010-02-12 Moved to Tentatively NAD after 5 positive votes on c++std-lib. 
Rationale added below.
]</i></p>




<p><b>Rationale:</b></p>
<p>
The rationale is that it doesn't matter, and you can't check: the lock types may
be different, or the same and user-defined, so the implementation must provide
internal synchronization anyway.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1224"></a>1224. condition_variable_any support for recursive mutexes?</h3>
<p><b>Section:</b> 30.5.2 [thread.condition.condvarany] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2009-09-30 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.condition.condvarany">issues</a> in [thread.condition.condvarany].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
For <tt>condition_variable_any</tt>, are recursive mutexes allowed? (I think "no")
</p>

<p><i>[
2009-11-17 Moved to Tentatively NAD after 5 positive votes on c++std-lib. 
Rationale added below.
]</i></p>



<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>
<tt>condition_variable_any::wait</tt> accepts any type of mutex. It calls
<tt>unlock</tt> precisely once on entry and <tt>lock</tt> precisely once on
exit. It is up to the user to ensure that this provides the required
synchronization. Use of a recursive mutex is safe if either its lock count is 1,
so after the single unlock it can be acquired by another thread, or another
mechanism is used to synchronize the data.
</p>





<hr>
<h3><a name="1225"></a>1225. C++0x result_of issue </h3>
<p><b>Section:</b> X [func.ret] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Sebastian Gesemann <b>Opened:</b> 2009-10-05 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#func.ret">issues</a> in [func.ret].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I think the text about <tt>std::result_of</tt> could be a little more precise.
Quoting from
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2960.pdf">N2960</a>...
</p>

<blockquote>
<p>
X [func.ret] Function object return types
</p>

<pre>template&lt;class&gt; class result_of;

template&lt;class Fn, class... ArgTypes&gt;
class result_of&lt;Fn(ArgTypes...)&gt; {
public:
  typedef <i>see below</i> type;
};
</pre>

<p>
Given an rvalue <tt>fn</tt> of type <tt>Fn</tt> and values <tt>t1, t2,
..., tN</tt> of types <tt>T1, T2, ... TN</tt> in <tt>ArgTypes</tt>
respectivly, the <tt>type</tt> member is the result type of the
expression <tt>fn(t1,t2,...,tN)</tt>. the values <tt>ti</tt> are lvalues
when the corresponding type <tt>Ti</tt> is an lvalue-reference type, and
rvalues otherwise.
</p>
</blockquote>

<p>
This text doesn't seem to consider lvalue reference types for <tt>Fn</tt>.
Also, it's not clear whether this class template can be used for
"SFINAE" like <tt>std::enable_if</tt>. Example:
</p>

<blockquote><pre>template&lt;typename Fn, typename... Args&gt;
typename std::result_of&lt;Fn(Args...)&gt;::type
apply(Fn &amp;&amp; fn, Args &amp;&amp; ...args)
{
  // Fn may be an lvalue reference, too
  return std::forward&lt;Fn&gt;(fn)(std::forward&lt;Args&gt;(args)...);
}
</pre></blockquote>

<p>
Either <tt>std::result_of&lt;...&gt;</tt> can be instantiated and simply may not have
a typedef "<tt>type</tt>" (--&gt;SFINAE) or instantiating the class template for
some type combinations will be a "hard" compile-time error.
</p>

<p><i>[
2010-02-14 Daniel adds:
]</i></p>


<blockquote>
This issue should be considered resolved by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1255">1255</a> and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1270">1270</a>.  The wish to change <tt>result_of</tt> into a compiler-support
trait was beyond the actual intention of the submitter Sebastian.
</blockquote>

<p><i>[
2010 Pittsburgh:  Moved to NAD Editorial, rationale added below.
]</i></p>




<p><b>Rationale:</b></p>
<p>
Solved by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1270">1270</a>.
</p>


<p><b>Proposed resolution:</b></p>

<p><i>[
These changes will require compiler support
]</i></p>


<p>
Change X [func.ret]:
</p>

<blockquote><pre>template&lt;class&gt; class result_of; // <i>undefined</i>

template&lt;class Fn, class... ArgTypes&gt;
class result_of&lt;Fn(ArgTypes...)&gt; {
public:
  <del>typedef</del> <i>see below</i> <del>type;</del>
};
</pre>

<p><del>
Given an rvalue <tt>fn</tt> of type <tt>Fn</tt> and values <tt>t1, t2,
..., tN</tt> of types <tt>T1, T2, ... TN</tt> in <tt>ArgTypes</tt>
respectivly, the <tt>type</tt> member is the result type of the
expression <tt>fn(t1,t2,...,tN)</tt>. the values <tt>ti</tt> are lvalues
when the corresponding type <tt>Ti</tt> is an lvalue-reference type, and
rvalues otherwise.
</del></p>

<p>
<ins>The class template <tt>result_of</tt> shall meet the requirements of a
<i>TransformationTrait</i>: Given the types <tt>Fn</tt>, <tt>T1</tt>, <tt>T2</tt>, ..., <tt>TN</tt> every
template specialization <tt>result_of&lt;Fn(T1,T2,...,TN)&gt;</tt> shall define the
member typedef type equivalent to <tt>decltype(<i>RE</i>)</tt> if and only if
the expression <tt><i>RE</i></tt>
</ins></p>

<blockquote><pre><ins>
value&lt;Fn&gt;() ( value&lt;T1&gt;(), value&lt;T2&gt;(), ... value&lt;TN&gt;()  )
</ins></pre></blockquote>

<p><ins>
would be well-formed. Otherwise, there shall be no member typedef
<tt>type</tt> defined.
</ins></p>

</blockquote>
 
<p><i>[
The <tt>value&lt;&gt;</tt> helper function is a utility Daniel Krgler
proposed in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2958.html">N2958</a>.
]</i></p>






<hr>
<h3><a name="1226"></a>1226. Incomplete changes of #890</h3>
<p><b>Section:</b> 30.6.2 [futures.errors] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-10-05 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Defect issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#890">890</a> overlooked to adapt the <tt>future_category</tt> from
30.6.1 [futures.overview] and 30.6.2 [futures.errors]:
</p>

<blockquote><pre>extern const error_category* const future_category;
</pre></blockquote>

<p>
which should be similarly transformed into function form.
</p>

<p><i>[
2009-10-27 Howard:
]</i></p>


<blockquote>
Moved to Tentatively Ready after 5 positive votes on c++std-lib.
</blockquote>

<p><i>[
2009-11-11 Daniel adds:
]</i></p>


<blockquote>
<p>
I just observe that the proposed resolution of this issue
is incomplete and needs to reworded. The problem is that the
corresponding declarations
</p>

<blockquote><pre>constexpr error_code make_error_code(future_errc e);
constexpr error_condition make_error_condition(future_errc e);
</pre></blockquote>

<p>
as constexpr functions are incompatible to the requirements of constexpr
functions given their specified implementation. Note that the incompatibility
is <em>not</em> a result of the modifications proposed by the issue resolution,
but already existed within the
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2960.pdf">N2960</a>
state where we have
</p>

<blockquote><pre>extern const error_category* const future_category;
</pre></blockquote>

<p>
combined with
</p>

<blockquote><pre>constexpr error_code make_error_code(future_errc e);
</pre>
<blockquote>
3 <i>Returns:</i> <tt>error_code(static_cast&lt;int&gt;(e), *future_category)</tt>.
</blockquote>

<pre>constexpr error_code make_error_condition(future_errc e);
</pre>
<blockquote>
4 <i>Returns:</i> <tt>error_condition(static_cast&lt;int&gt;(e), *future_category)</tt>.
</blockquote>
</blockquote>

<p>
Neither is any of the constructors of <tt>error_code</tt> and <tt>error_condition</tt>
constexpr, nor does the expression <tt>*future_category</tt> satisfy the
requirements for a constant expression (5.19 [expr.const]/2 bullet 6 in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n3000.pdf">N3000</a>).
</p>

<p>
The simple solution is just to remove the constexpr qualifiers for both
functions, which makes sense, because none of the remaining <tt>make_error_*</tt>
overloads in the library is constexpr. One might consider to realize that
those <tt>make_*</tt> functions could satisfy the constexpr requirements, but this
looks not like an easy task to me, because it would need to rely on a not
yet existing language feature. If such a change is wanted, a new issue
should be opened after the language extension approval (if at all) [1].
</p>

<p>
If no-one complaints I would like to ask Howard to add the following
modifications to this issue, alternatively a new issue could be opened but I
don't know what the best solution is that would cause as little overhead
as possible.
</p>
<p>
What-ever the route is, the following is my proposed resolution for this issue
interaction part of the story:
</p>

<blockquote>
<p>
In 30.6.1 [futures.overview]/1, Header <tt>&lt;future&gt;</tt> synopsis <em>and</em>
in 30.6.2 [futures.errors]/3+4
change as indicated:
</p>

<blockquote><pre><del>constexpr</del> error_code make_error_code(future_errc e);
<del>constexpr</del> error_condition make_error_condition(future_errc e);
</pre></blockquote>
</blockquote>

<p>
[1] Let me add that we have a related  NAD issue here: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#832">832</a>
so the chances for realization are little IMO.
</p>

<p><i>[
Howard: I've updated the proposed wording as Daniel suggests and set to Review.
]</i></p>

</blockquote>

<p><i>[
2009-11-13 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>


<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote>
Moved to NAD Editorial.  Rationale added below.
</blockquote>



<p><b>Rationale:</b></p>
<p>
Solved by N3058.
</p>


<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
Change in 30.6.1 [futures.overview], header <tt>&lt;future&gt;</tt> synopsis:
</p>

<blockquote><pre><del>extern</del> const error_category<ins>&amp;</ins><del>* const</del> future_category<ins>()</ins>;
</pre></blockquote>
</li>

<li>
<p>
In 30.6.1 [futures.overview]/1, Header <tt>&lt;future&gt;</tt> synopsis 
change as indicated:
</p>

<blockquote><pre><del>constexpr</del> error_code make_error_code(future_errc e);
<del>constexpr</del> error_condition make_error_condition(future_errc e);
</pre></blockquote>
</li>

<li>
<p>
Change in 30.6.2 [futures.errors]:
</p>

<blockquote><pre><del>extern</del> const error_category<ins>&amp;</ins><del>* const</del> future_category<ins>()</ins>;
</pre>

<blockquote>
<p>
<del>1- <tt>future_category</tt> shall point to a statically initialized object
of a type derived from class <tt>error_category</tt>.</del>
</p>
<p>
<ins>1- <i>Returns:</i> A reference to an object of a type
derived from class <tt>error_category</tt>.</ins>
</p>
</blockquote>

<pre><del>constexpr</del> error_code make_error_code(future_errc e);
</pre>

<blockquote>
3 <i>Returns:</i> <tt>error_code(static_cast&lt;int&gt;(e),
<del>*</del>future_category<ins>()</ins>)</tt>.
</blockquote>

<pre><del>constexpr</del> error_<del>code</del><ins>condition</ins> make_error_condition(future_errc e);
</pre>

<blockquote>
4 <i>Returns:</i> <tt>error_condition(static_cast&lt;int&gt;(e),
<del>*</del>future_category<ins>()</ins>)</tt>.
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="1228"></a>1228. User-specialized nothrow type traits</h3>
<p><b>Section:</b> 20.7.4.3 [meta.unary.prop] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-10-07 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
According to p1 20.7.2 [meta.type.synop]:
</p>

<blockquote>
The behavior of a program that adds specializations for any of the class
templates defined in this subclause is undefined unless otherwise
specified.
</blockquote>

<p>
I believe we should 'otherwise specify' for the nothrow traits, are
these are exactly the use cases where the end user actually has more
information than the compiler.
</p>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Moved to Open.  Definitely need to give the users the ability to ensure
that the traits give the right answers. Unsure we want to give them the
ability to say this in more than one way. Believes the noexcept proposal
already gives this.
</blockquote>

<p><i>[
2010 Pittsburgh:  Moved to NAD, rationale added below.
]</i></p>




<p><b>Rationale:</b></p>
<p>
We believe the solution offered by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3050.html">N3050</a>
is superior.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add the following comment:
</p>

<blockquote>
user specialization permitted to derive from <tt>std::true_type</tt> when the
operation is known not to throw.
</blockquote>

<p>
to the following traits in 20.7.4.3 [meta.unary.prop] Table 43 Type
property predicates.
</p>

<p><i>[
This may require a new Comments column
]</i></p>


<blockquote><pre>has_nothrow_default_constructor
has_nothrow_copy_constructor
has_nothrow_assign
</pre></blockquote>





<hr>
<h3><a name="1229"></a>1229. <tt>error_code operator=</tt> typo</h3>
<p><b>Section:</b> 19.5.2.3 [syserr.errcode.modifiers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2009-10-08 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2960.pdf">N2960</a>
19.5.2.1 [syserr.errcode.overview] and 19.5.2.3 [syserr.errcode.modifiers] say:
</p>

<blockquote><pre> 
template &lt;class ErrorCodeEnum&gt;
  typename enable_if&lt;is_error_code_enum&lt;ErrorCodeEnum&gt;::value&gt;::type&amp;
    operator=(ErrorCodeEnum e);
</pre></blockquote>

<p>
They should say:
</p>

<blockquote><pre> 
template &lt;class ErrorCodeEnum&gt;
  typename enable_if&lt;is_error_code_enum&lt;ErrorCodeEnum&gt;::value, error_code&gt;::type&amp;
    operator=(ErrorCodeEnum e);
</pre></blockquote>

<p>
Or (I prefer this form):
</p>
 
<blockquote><pre> 
template &lt;class ErrorCodeEnum&gt;
  typename enable_if&lt;is_error_code_enum&lt;ErrorCodeEnum&gt;::value, error_code&amp;&gt;::type
    operator=(ErrorCodeEnum e);
</pre></blockquote>

<p>
This is because <tt>enable_if</tt> is declared as (20.7.7.6 [meta.trans.other]):
</p>
 
<blockquote><pre> 
template &lt;bool B, class T = void&gt; struct enable_if;
</pre></blockquote>

<p>
So, the current wording makes <tt>operator=</tt> return
<tt>void&amp;</tt>, which is not good.
</p>

<p> 
19.5.2.3 [syserr.errcode.modifiers]/4 says
</p>

<blockquote>
<i>Returns:</i> <tt>*this</tt>.
</blockquote>
<p>
which is correct.
</p>

<p>
Additionally,
</p>

<p>
19.5.3.1 [syserr.errcondition.overview]/1 says:
</p>
 
<blockquote><pre> 
template&lt;typename ErrorConditionEnum&gt;
  typename enable_if&lt;is_error_condition_enum&lt;ErrorConditionEnum&gt;, error_code&gt;::type &amp;
    operator=( ErrorConditionEnum e );
</pre></blockquote>

<p>
Which contains several problems (<tt>typename</tt> versus <tt>class</tt>
inconsistency, lack of <tt>::value</tt>, <tt>error_code</tt> instead of
<tt>error_condition</tt>), while 19.5.3.3 [syserr.errcondition.modifiers] says:
</p>
 
<blockquote><pre> 
template &lt;class ErrorConditionEnum&gt;
  typename enable_if&lt;is_error_condition_enum&lt;ErrorConditionEnum&gt;::value&gt;::type&amp;
    operator=(ErrorConditionEnum e);
</pre></blockquote>

<p>
Which returns <tt>void&amp;</tt>.  They should both say:
</p>
 
<blockquote><pre> 
template &lt;class ErrorConditionEnum&gt;
  typename enable_if&lt;is_error_condition_enum&lt;ErrorConditionEnum&gt;::value, error_condition&gt;::type&amp;
    operator=(ErrorConditionEnum e);
</pre></blockquote>

<p>
Or (again, I prefer this form):
</p>

<blockquote><pre> 
template &lt;class ErrorConditionEnum&gt;
  typename enable_if&lt;is_error_condition_enum&lt;ErrorConditionEnum&gt;::value, error_condition&amp;&gt;::type
    operator=(ErrorConditionEnum e);
</pre></blockquote>

<p>
Additionally, 19.5.3.3 [syserr.errcondition.modifiers] lacks a
"<i>Returns:</i> <tt>*this</tt>." paragraph, which is presumably
necessary.
</p>

<p><i>[
2009-10-18 Beman adds:
]</i></p>


<blockquote>
The proposed resolution for issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1237">1237</a> makes this issue
moot, so it should become NAD.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD, solved by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1237">1237</a>.
</blockquote>



<p><b>Proposed resolution:</b></p>

<p>
Change 19.5.2.1 [syserr.errcode.overview] and 19.5.2.3 [syserr.errcode.modifiers]:
</p>

<blockquote><pre>template &lt;class ErrorCodeEnum&gt;
  typename enable_if&lt;is_error_code_enum&lt;ErrorCodeEnum&gt;::value<ins>, error_code&amp;</ins>&gt;::type<del>&amp;</del>
    operator=(ErrorCodeEnum e);
</pre></blockquote>

<p>
Change 19.5.3.1 [syserr.errcondition.overview]:
</p>

<blockquote><pre>template&lt;<del>typename</del> <ins>class</ins> ErrorConditionEnum&gt;
  typename enable_if&lt;is_error_condition_enum&lt;ErrorConditionEnum&gt;<ins>::value</ins>, error_co<ins>ndition</ins><del>de</del><ins>&amp;</ins>&gt;::type<del> &amp;</del>
    operator=( ErrorConditionEnum e );
</pre></blockquote>

<p>
Change 19.5.3.3 [syserr.errcondition.modifiers]:
</p>

<blockquote><pre>template &lt;class ErrorConditionEnum&gt;
  typename enable_if&lt;is_error_condition_enum&lt;ErrorConditionEnum&gt;::value<ins>, error_condition&amp;</ins>&gt;::type<del>&amp;</del>
    operator=(ErrorConditionEnum e);
</pre>
<blockquote>
<p>
<i>Postcondition:</i> <tt>*this == make_error_condition(e)</tt>.
</p>
<p><ins>
<i>Returns:</i> <tt>*this</tt>.
</ins></p>
<p>
<i>Throws:</i> Nothing.
</p>
</blockquote>
</blockquote>






<hr>
<h3><a name="1230"></a>1230. <tt>mem_fn</tt> and variadic templates</h3>
<p><b>Section:</b> 20.8.13 [func.memfn] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-10-09 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#func.memfn">issues</a> in [func.memfn].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#920">920</a></p>
<p><b>Discussion:</b></p>



<p>
Since we have removed the entry in B [implimits] for the
library-specific limit for number of arguments passed to
<tt>function</tt>/<tt>tuple</tt>/etc. I believe we need to update the
spec for <tt>mem_fn</tt> to reflect this.
</p>

<p>
The "<i>Remarks:</i> Implementations may implement <tt>mem_fn</tt> as a set of
overloaded function templates." no longer holds, as we cannot create an
arbitrary number of such overloads.  I believe we should strike the
remark and add a second signature:
</p>

<blockquote><pre>template&lt;class R, class T, typename ... ArgTypes&gt;
  unspecified mem_fn(R (T::*pm)(ArgTypes...));
</pre></blockquote>

<p>
I believe we need two signatures as pointer-to-data-member and
pointer-to-member-function-taking-no-args appear to use subtly different
syntax.
</p>

<p><i>[
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#920">920</a> as a similar proposed resolution.
]</i></p>



<p><b>Proposed resolution:</b></p>
Add to 20.8 [function.objects] and 20.8.13 [func.memfn]:


<blockquote><pre>template&lt;class R, class T&gt; <i>unspecified</i> mem_fn(R T::* pm)

<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...));</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) const);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) volatile);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) const volatile);</ins>

<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...)&amp;);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) const&amp;);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) volatile&amp;);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) const volatile&amp;);</ins>

<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...)&amp;&amp;);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) const&amp;&amp;);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) volatile&amp;&amp;);</ins>
<ins>template&lt;class R, class T, class ...Args&gt; <i>unspecified</i> mem_fn(R (T::* pm)(Args...) const volatile&amp;&amp;);</ins>
</pre></blockquote>

<p>
Strike 20.8.13 [func.memfn], p5:
</p>

<blockquote>
<del><i>Remarks:</i> Implementations may implement <tt>mem_fn</tt> as a set
of overloaded function templates.</del>
</blockquote>




<hr>
<h3><a name="1232"></a>1232. Still <tt>swap</tt>'s with rvalue-references</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-10-11 <b>Last modified:</b> 2010-10-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current library contains still rvalue reference-swaps that seem to be
overlooked in the process of switching back to lvalue-ref swaps.
</p>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Editor accepts as NAD Editorial.
</blockquote>



<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
Change 20.3.5 [pairs]/1 as indicated:
</p>

<blockquote><pre>template &lt;class T1, class T2&gt;
struct pair {
  ...
  void swap(pair&amp;<del>&amp;</del> p);
};
</pre></blockquote>
</li>

<li>
<p>
Change 20.3.5 [pairs] before p. 17 as indicated:
</p>

<blockquote><pre>void swap(pair&amp;<del>&amp;</del> p);
</pre></blockquote>

</li>

<li>

<p>
Change 20.3.5 [pairs] before p. 21 as indicated:
</p>

<blockquote><pre>template&lt;class T1, class T2&gt; void swap(pair&lt;T1, T2&gt;&amp; x, pair&lt;T1, T2&gt;&amp; y);
<del>template&lt;class T1, class T2&gt; void swap(pair&lt;T1, T2&gt;&amp;&amp; x, pair&lt;T1, T2&gt;&amp; y);</del>
<del>template&lt;class T1, class T2&gt; void swap(pair&lt;T1, T2&gt;&amp; x, pair&lt;T1, T2&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 20.4.1 [tuple.general]/2, header <tt>&lt;tuple&gt;</tt> synopsis, as indicated:
</p>

<blockquote><pre>// 20.5.2.9, specialized algorithms:
template &lt;class... Types&gt;
void swap(tuple&lt;Types...&gt;&amp; x, tuple&lt;Types...&gt;&amp; y);
<del>template &lt;class... Types&gt;
void swap(tuple&lt;Types...&gt;&amp;&amp; x, tuple&lt;Types...&gt;&amp; y);
template &lt;class... Types&gt;
void swap(tuple&lt;Types...&gt;&amp; x, tuple&lt;Types...&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 20.4.2 [tuple.tuple] as indicated:
</p>

<blockquote><pre>// 20.5.2.3, tuple swap
void swap(tuple&amp;<del>&amp;</del>)
</pre></blockquote>

</li>

<li>
<p>
Change 20.4.2.3 [tuple.swap] before 1 as indicated:
</p>

<blockquote><pre>void swap(tuple&amp;<del>&amp;</del> rhs);
</pre></blockquote>

</li>

<li>
<p>
Change 20.8 [function.objects]/2, header <tt>&lt;functional&gt;</tt> synopsis, as indicated:
</p>

<blockquote><pre>template&lt;class R, class... ArgTypes&gt;
void swap(function&lt;R(ArgTypes...)&gt;&amp;, function&lt;R(ArgTypes...)&gt;&amp;);
<del>template&lt;class R, class... ArgTypes&gt;
void swap(function&lt;R(ArgTypes...)&gt;&amp;&amp;, function&lt;R(ArgTypes...)&gt;&amp;);
template&lt;class R, class... ArgTypes&gt;
void swap(function&lt;R(ArgTypes...)&gt;&amp;, function&lt;R(ArgTypes...)&amp;&amp;);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 20.8.14.2 [func.wrap.func], as indicated:
</p>

<blockquote><pre>// 20.7.15.2.2, function modifiers:
void swap(function&amp;<del>&amp;</del>);
template&lt;class F, class A&gt; void assign(F, const A&amp;);

[..]

// 20.7.15.2.7, specialized algorithms:
template &lt;class R, class... ArgTypes&gt;
void swap(function&lt;R(ArgTypes...)&gt;&amp;, function&lt;R(ArgTypes...)&gt;&amp;);
<del>template &lt;class R, class... ArgTypes&gt;
void swap(function&lt;R(ArgTypes...)&gt;&amp;&amp;, function&lt;R(ArgTypes...)&gt;&amp;);
template &lt;class R, class... ArgTypes&gt;
void swap(function&lt;R(ArgTypes...)&gt;&amp;, function&lt;R(ArgTypes...)&gt;&amp;&amp;);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 20.8.14.2.7 [func.wrap.func.alg] before 1 as indicated:
</p>

<blockquote><pre>template&lt;class R, class... ArgTypes&gt;
void swap(function&lt;R(ArgTypes...)&gt;&amp; f1, function&lt;R(ArgTypes...)&gt;&amp; f2);
<del>template&lt;class R, class... ArgTypes&gt;
void swap(function&lt;R(ArgTypes...)&gt;&amp;&amp; f1, function&lt;R(ArgTypes...)&gt;&amp; f2);
template&lt;class R, class... ArgTypes&gt;
void swap(function&lt;R(ArgTypes...)&gt;&amp; f1, function&lt;R(ArgTypes...)&gt;&amp;&amp; f2);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 20.9.10.2 [util.smartptr.shared]/1 as indicated:
</p>

<blockquote><pre>// 20.8.12.2.4, modifiers:
void swap(shared_ptr&amp;<del>&amp;</del> r);

[..]

// 20.8.12.2.9, shared_ptr specialized algorithms:
template&lt;class T&gt; void swap(shared_ptr&lt;T&gt;&amp; a, shared_ptr&lt;T&gt;&amp; b);
<del>template&lt;class T&gt; void swap(shared_ptr&lt;T&gt;&amp;&amp; a, shared_ptr&lt;T&gt;&amp; b);
template&lt;class T&gt; void swap(shared_ptr&lt;T&gt;&amp; a, shared_ptr&lt;T&gt;&amp;&amp; b);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 21.3 [string.classes]/1, header <tt>&lt;string&gt;</tt> synopsis, as indicated:
</p>

<blockquote><pre>// 21.4.8.8: swap
template&lt;class charT, class traits, class Allocator&gt;
void swap(basic_string&lt;charT,traits,Allocator&gt;&amp; lhs, basic_string&lt;charT,traits,Allocator&gt;&amp; rhs);
<del>template&lt;class charT, class traits, class Allocator&gt;
void swap(basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; lhs, basic_string&lt;charT,traits,Allocator&gt;&amp; rhs);
template&lt;class charT, class traits, class Allocator&gt;
void swap(basic_string&lt;charT,traits,Allocator&gt;&amp; lhs, basic_string&lt;charT,traits,Allocator&gt;&amp;&amp; rhs);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 23.3 [sequences]/1, header <tt>&lt;deque&gt;</tt> synopsis, as indicated:
</p>

<blockquote><pre>template &lt;class T, class Allocator&gt;
void swap(deque&lt;T,Allocator&gt;&amp; x, deque&lt;T,Allocator&gt;&amp; y);
<del>template &lt;class T, class Allocator&gt;
void swap(deque&lt;T,Allocator&gt;&amp;&amp; x, deque&lt;T,Allocator&gt;&amp; y);
template &lt;class T, class Allocator&gt;
void swap(deque&lt;T,Allocator&gt;&amp; x, deque&lt;T,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 23.3 [sequences]/1, header <tt>&lt;list&gt;</tt> synopsis, as indicated:
</p>

<blockquote><pre>template &lt;class T, class Allocator&gt;
void swap(list&lt;T,Allocator&gt;&amp; x, list&lt;T,Allocator&gt;&amp; y);
<del>template &lt;class T, class Allocator&gt;
void swap(list&lt;T,Allocator&gt;&amp;&amp; x, list&lt;T,Allocator&gt;&amp; y);
template &lt;class T, class Allocator&gt;
void swap(list&lt;T,Allocator&gt;&amp; x, list&lt;T,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 23.3 [sequences]/1, header <tt>&lt;queue&gt;</tt> synopsis, as indicated:
</p>

<blockquote><pre>template &lt;class T, class Allocator&gt;
void swap(queue&lt;T, Container&gt;&amp; x, queue&lt;T, Container&gt;&amp; y);
<del>template &lt;class T, class Container&gt;
void swap(queue&lt;T, Container&gt;&amp;&amp; x, queue&lt;T, Container&gt;&amp; y);
template &lt;class T, class Container&gt;
void swap(queue&lt;T, Container&gt;&amp; x, queue&lt;T, Container&gt;&amp;&amp; y);</del>

template &lt;class T, class Container = vector&lt;T&gt;, class Compare = less&lt;typename Container::value_type&gt; &gt;
class priority_queue;
template &lt;class T, class Container, class Compare&gt;
void swap(priority_queue&lt;T, Container, Compare&gt;&amp; x, priority_queue&lt;T, Container, Compare&gt;&amp; y);
<del>template &lt;class T, class Container, class Compare&gt;
void swap(priority_queue&lt;T, Container, Compare&gt;&amp;&amp; x, priority_queue&lt;T, Container, Compare&gt;&amp; y);
template &lt;class T, class Container, class Compare&gt;
void swap(priority_queue&lt;T, Container, Compare&gt;&amp; x, priority_queue&lt;T, Container, Compare&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 23.3 [sequences]/1, header <tt>&lt;stack&gt;</tt> synopsis, as indicated:
</p>

<blockquote><pre>template &lt;class T, class Container&gt;
void swap(stack&lt;T, Container&gt;&amp; x, stack&lt;T, Container&gt;&amp; y);
<del>template &lt;class T, class Container&gt;
void swap(stack&lt;T, Container&gt;&amp;&amp; x, stack&lt;T, Container&gt;&amp; y);
template &lt;class T, class Container&gt;
void swap(stack&lt;T, Container&gt;&amp; x, stack&lt;T, Container&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 23.3 [sequences]/1, header <tt>&lt;vector&gt;</tt> synopsis, as indicated:
</p>

<blockquote><pre>template &lt;class T, class Allocator&gt;
void swap(vector&lt;T,Allocator&gt;&amp; x, vector&lt;T,Allocator&gt;&amp; y);
<del>template &lt;class T, class Allocator&gt;
void swap(vector&lt;T,Allocator&gt;&amp;&amp; x, vector&lt;T,Allocator&gt;&amp; y);
template &lt;class T, class Allocator&gt;
void swap(vector&lt;T,Allocator&gt;&amp; x, vector&lt;T,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 23.3.2 [deque]/2 as indicated:
</p>

<blockquote><pre>iterator erase(const_iterator position);
iterator erase(const_iterator first, const_iterator last);
void swap(deque&lt;T,Allocator&gt;&amp;<del>&amp;</del>);
void clear();

[..]

// specialized algorithms:
template &lt;class T, class Allocator&gt;
void swap(deque&lt;T,Allocator&gt;&amp; x, deque&lt;T,Allocator&gt;&amp; y);
<del>template &lt;class T, class Allocator&gt;
void swap(deque&lt;T,Allocator&gt;&amp;&amp; x, deque&lt;T,Allocator&gt;&amp; y);
template &lt;class T, class Allocator&gt;
void swap(deque&lt;T,Allocator&gt;&amp; x, deque&lt;T,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 23.3.2.4 [deque.special] as indicated:
</p>

<blockquote><pre>template &lt;class T, class Allocator&gt;
void swap(deque&lt;T,Allocator&gt;&amp; x, deque&lt;T,Allocator&gt;&amp; y);
<del>template &lt;class T, class Allocator&gt;
void swap(deque&lt;T,Allocator&gt;&amp;&amp; x, deque&lt;T,Allocator&gt;&amp; y);
template &lt;class T, class Allocator&gt;
void swap(deque&lt;T,Allocator&gt;&amp; x, deque&lt;T,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 23.3.3 [forwardlist]/2 as indicated:
</p>

<blockquote><pre>iterator erase_after(const_iterator position);
iterator erase_after(const_iterator position, iterator last);
void swap(forward_list&lt;T,Allocator&gt;&amp;<del>&amp;</del>);

[..]

// 23.3.3.6 specialized algorithms:
template &lt;class T, class Allocator&gt;
void swap(forward_list&lt;T,Allocator&gt;&amp; x, forward_list&lt;T,Allocator&gt;&amp; y);
<del>template &lt;class T, class Allocator&gt;
void swap(forward_list&lt;T,Allocator&gt;&amp;&amp; x, forward_list&lt;T,Allocator&gt;&amp; y);
template &lt;class T, class Allocator&gt;
void swap(forward_list&lt;T,Allocator&gt;&amp; x, forward_list&lt;T,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 23.3.3.6 [forwardlist.spec] as indicated:
</p>

<blockquote><pre>template &lt;class T, class Allocator&gt;
void swap(forward_list&lt;T,Allocator&gt;&amp; x, forward_list&lt;T,Allocator&gt;&amp; y);
<del>template &lt;class T, class Allocator&gt;
void swap(forward_list&lt;T,Allocator&gt;&amp;&amp; x, forward_list&lt;T,Allocator&gt;&amp; y);
template &lt;class T, class Allocator&gt;
void swap(forward_list&lt;T,Allocator&gt;&amp; x, forward_list&lt;T,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 23.3.4 [list]/2 as indicated:
</p>

<blockquote><pre>iterator erase(const_iterator position);
iterator erase(const_iterator position, const_iterator last);
void swap(list&lt;T,Allocator&gt;&amp;<del>&amp;</del>);
void clear();

[..]

// specialized algorithms:
template &lt;class T, class Allocator&gt;
void swap(list&lt;T,Allocator&gt;&amp; x, list&lt;T,Allocator&gt;&amp; y);
<del>template &lt;class T, class Allocator&gt;
void swap(list&lt;T,Allocator&gt;&amp;&amp; x, list&lt;T,Allocator&gt;&amp; y);
template &lt;class T, class Allocator&gt;
void swap(list&lt;T,Allocator&gt;&amp; x, list&lt;T,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 23.3.4.5 [list.special] as indicated:
</p>

<blockquote><pre>template &lt;class T, class Allocator&gt;
void swap(list&lt;T,Allocator&gt;&amp; x, list&lt;T,Allocator&gt;&amp; y);
<del>template &lt;class T, class Allocator&gt;
void swap(list&lt;T,Allocator&gt;&amp;&amp; x, list&lt;T,Allocator&gt;&amp; y);
template &lt;class T, class Allocator&gt;
void swap(list&lt;T,Allocator&gt;&amp; x, list&lt;T,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 23.5.1.1 [queue.defn] as indicated:
</p>

<blockquote><pre>void swap(queue&amp;<del>&amp;</del> q) { c.swap(q.c); }

[..]

template &lt;class T, class Container&gt;
void swap(queue&lt;T, Container&gt;&amp; x, queue&lt;T, Container&gt;&amp; y);
<del>template &lt;class T, class Container&gt;
void swap(queue&lt;T, Container&gt;&amp;&amp; x, queue&lt;T, Container&gt;&amp; y);
template &lt;class T, class Container&gt;
void swap(queue&lt;T, Container&gt;&amp; x, queue&lt;T, Container&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 23.5.1.5 [queue.special] as indicated:
</p>

<blockquote><pre>template &lt;class T, class Container&gt;
void swap(queue&lt;T, Container&gt;&amp; x, queue&lt;T, Container&gt;&amp; y);
<del>template &lt;class T, class Container&gt;
void swap(queue&lt;T, Container&gt;&amp;&amp; x, queue&lt;T, Container&gt;&amp; y);
template &lt;class T, class Container&gt;
void swap(queue&lt;T, Container&gt;&amp; x, queue&lt;T, Container&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 23.5.2 [priority.queue]/1 as indicated:
</p>

<blockquote><pre>void swap(priority_queue&amp;<del>&amp;</del>);

// no equality is provided
template &lt;class T, class Container, class Compare&gt;
void swap(priority_queue&lt;T, Container, Compare&gt;&amp; x, priority_queue&lt;T, Container, Compare&gt;&amp; y);
<del>template &lt;class T, class Container, class Compare&gt;
void swap(priority_queue&lt;T, Container, Compare&gt;&amp;&amp; x, priority_queue&lt;T, Container, Compare&gt;&amp; y);
template &lt;class T, class Container, class Compare&gt;
void swap(priority_queue&lt;T, Container, Compare&gt;&amp; x, priority_queue&lt;T, Container, Compare&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 23.5.2.4 [priqueue.special] as indicated:
</p>

<blockquote><pre>template &lt;class T, class Container, Compare&gt;
void swap(priority_queue&lt;T, Container, Compare&gt;&amp; x, priority_queue&lt;T, Container, Compare&gt;&amp; y);
<del>template &lt;class T, class Container, Compare&gt;
void swap(priority_queue&lt;T, Container, Compare&gt;&amp;&amp; x, priority_queue&lt;T, Container, Compare&gt;&amp; y);
template &lt;class T, class Container, Compare&gt;
void swap(priority_queue&lt;T, Container, Compare&gt;&amp; x, priority_queue&lt;T, Container, Compare&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 23.5.3.1 [stack.defn] as indicated:
</p>

<blockquote><pre>void swap(stack&amp;<del>&amp;</del> s) { c.swap(s.c); }

[..]

template &lt;class T, class Allocator&gt;
void swap(stack&lt;T,Allocator&gt;&amp; x, stack&lt;T,Allocator&gt;&amp; y);
<del>template &lt;class T, class Allocator&gt;
void swap(stack&lt;T,Allocator&gt;&amp;&amp; x, stack&lt;T,Allocator&gt;&amp; y);
template &lt;class T, class Allocator&gt;
void swap(stack&lt;T,Allocator&gt;&amp; x, stack&lt;T,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>


</li>

<li>
<p>
Change 23.5.3.5 [stack.special] as indicated:
</p>

<blockquote><pre>template &lt;class T, class Container&gt;
void swap(stack&lt;T, Container&gt;&amp; x, stack&lt;T, Container&gt;&amp; y);
<del>template &lt;class T, class Container&gt;
void swap(stack&lt;T, Container&gt;&amp;&amp; x, stack&lt;T, Container&gt;&amp; y);
template &lt;class T, class Container&gt;
void swap(stack&lt;T, Container&gt;&amp; x, stack&lt;T, Container&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 23.4.1 [vector]/2 as indicated:
</p>

<blockquote><pre>void swap(vector&lt;T,Allocator&gt;&amp;<del>&amp;</del>);
void clear();

[..]

// specialized algorithms:
template &lt;class T, class Allocator&gt;
void swap(vector&lt;T,Allocator&gt;&amp; x, vector&lt;T,Allocator&gt;&amp; y);
<del>template &lt;class T, class Allocator&gt;
void swap(vector&lt;T,Allocator&gt;&amp;&amp; x, vector&lt;T,Allocator&gt;&amp; y);
template &lt;class T, class Allocator&gt;
void swap(vector&lt;T,Allocator&gt;&amp; x, vector&lt;T,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 23.4.1.2 [vector.capacity] before p. 8 as indicated:
</p>

<blockquote><pre>void swap(vector&lt;T,Allocator&gt;&amp;<del>&amp;</del> x);
</pre></blockquote>

</li>

<li>
<p>
Change 23.4.1.5 [vector.special] as indicated:
</p>

<blockquote><pre>template &lt;class T, class Allocator&gt;
void swap(vector&lt;T,Allocator&gt;&amp; x, vector&lt;T,Allocator&gt;&amp; y);
<del>template &lt;class T, class Allocator&gt;
void swap(vector&lt;T,Allocator&gt;&amp;&amp; x, vector&lt;T,Allocator&gt;&amp; y);
template &lt;class T, class Allocator&gt;
void swap(vector&lt;T,Allocator&gt;&amp; x, vector&lt;T,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 23.4.2 [vector.bool]/1 as indicated:
</p>

<blockquote><pre>iterator erase(const_iterator first, const_iterator last);
void swap(vector&lt;bool,Allocator&gt;&amp;<del>&amp;</del>);
static void swap(reference x, reference y);
</pre></blockquote>

</li>

<li>
<p>
Change 23.6 [associative]/1, header <tt>&lt;map&gt;</tt> synopsis as indicated:
</p>

<blockquote><pre>template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(map&lt;Key,T,Compare,Allocator&gt;&amp; x, map&lt;Key,T,Compare,Allocator&gt;&amp; y);
<del>template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(map&lt;Key,T,Compare,Allocator&amp;&amp; x, map&lt;Key,T,Compare,Allocator&gt;&amp; y);
template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(map&lt;Key,T,Compare,Allocator&amp; x, map&lt;Key,T,Compare,Allocator&gt;&amp;&amp; y);</del>

[..]

template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(multimap&lt;Key,T,Compare,Allocator&gt;&amp; x, multimap&lt;Key,T,Compare,Allocator&gt;&amp; y);
<del>template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(multimap&lt;Key,T,Compare,Allocator&amp;&amp; x, multimap&lt;Key,T,Compare,Allocator&gt;&amp; y);
template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(multimap&lt;Key,T,Compare,Allocator&amp; x, multimap&lt;Key,T,Compare,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 23.6 [associative]/1, header <tt>&lt;set&gt;</tt> synopsis as indicated:
</p>

<blockquote><pre>template &lt;class Key, class Compare, class Allocator&gt;
void swap(set&lt;Key,Compare,Allocator&gt;&amp; x, set&lt;Key,Compare,Allocator&gt;&amp; y);
<del>template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(set&lt;Key,T,Compare,Allocator&amp;&amp; x, set&lt;Key,T,Compare,Allocator&gt;&amp; y);
template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(set&lt;Key,T,Compare,Allocator&amp; x, set&lt;Key,T,Compare,Allocator&gt;&amp;&amp; y);</del>

[..]

template &lt;class Key, class Compare, class Allocator&gt;
void swap(multiset&lt;Key,Compare,Allocator&gt;&amp; x, multiset&lt;Key,Compare,Allocator&gt;&amp; y);
<del>template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(multiset&lt;Key,T,Compare,Allocator&amp;&amp; x, multiset&lt;Key,T,Compare,Allocator&gt;&amp; y);
template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(multiset&lt;Key,T,Compare,Allocator&amp; x, multiset&lt;Key,T,Compare,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 23.6.1 [map]/2 as indicated:
</p>

<blockquote><pre>iterator erase(const_iterator first, const_iterator last);
void swap(map&lt;Key,T,Compare,Allocator&gt;&amp;<del>&amp;</del>);
void clear();

[..]

// specialized algorithms:
template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(map&lt;Key,T,Compare,Allocator&gt;&amp; x, map&lt;Key,T,Compare,Allocator&gt;&amp; y);
<del>template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(map&lt;Key,T,Compare,Allocator&amp;&amp; x, map&lt;Key,T,Compare,Allocator&gt;&amp; y);
template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(map&lt;Key,T,Compare,Allocator&amp; x, map&lt;Key,T,Compare,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 23.6.1.5 [map.special] as indicated:
</p>

<blockquote><pre>template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(map&lt;Key,T,Compare,Allocator&gt;&amp; x, map&lt;Key,T,Compare,Allocator&gt;&amp; y);
<del>template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(map&lt;Key,T,Compare,Allocator&gt;&amp;&amp; x, map&lt;Key,T,Compare,Allocator&gt;&amp; y);
template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(map&lt;Key,T,Compare,Allocator&gt;&amp; x, map&lt;Key,T,Compare,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 23.6.2 [multimap]/2 as indicated:
</p>

<blockquote><pre>iterator erase(const_iterator first, const_iterator last);
void swap(multimap&lt;Key,T,Compare,Allocator&gt;&amp;<del>&amp;</del>);
void clear();

[..]

// specialized algorithms:
template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(multimap&lt;Key,T,Compare,Allocator&gt;&amp; x, multimap&lt;Key,T,Compare,Allocator&gt;&amp; y);
<del>template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(multimap&lt;Key,T,Compare,Allocator&amp;&amp; x, multimap&lt;Key,T,Compare,Allocator&gt;&amp; y);
template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(multimap&lt;Key,T,Compare,Allocator&amp; x, multimap&lt;Key,T,Compare,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 23.6.2.4 [multimap.special] as indicated:
</p>

<blockquote><pre>template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(multimap&lt;Key,T,Compare,Allocator&gt;&amp; x, multimap&lt;Key,T,Compare,Allocator&gt;&amp; y);
<del>template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(multimap&lt;Key,T,Compare,Allocator&gt;&amp;&amp; x, multimap&lt;Key,T,Compare,Allocator&gt;&amp; y);
template &lt;class Key, class T, class Compare, class Allocator&gt;
void swap(multimap&lt;Key,T,Compare,Allocator&gt;&amp; x, multimap&lt;Key,T,Compare,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 23.6.3 [set]/2 and 23.6.3.2 [set.special] as indicated: (twice!)
</p>

<blockquote><pre>// specialized algorithms:
template &lt;class Key, class Compare, class Allocator&gt;
void swap(set&lt;Key,Compare,Allocator&gt;&amp; x, set&lt;Key,Compare,Allocator&gt;&amp; y);
<del>template &lt;class Key, class Compare, class Allocator&gt;
void swap(set&lt;Key,Compare,Allocator&amp;&amp; x, set&lt;Key,Compare,Allocator&gt;&amp; y);
template &lt;class Key, class Compare, class Allocator&gt;
void swap(set&lt;Key,Compare,Allocator&amp; x, set&lt;Key,Compare,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 23.6.4 [multiset]/2 as indicated:
</p>

<blockquote><pre>iterator erase(const_iterator first, const_iterator last);
void swap(multiset&lt;Key,Compare,Allocator&gt;&amp;<del>&amp;</del>);
void clear();

[..]

// specialized algorithms:
template &lt;class Key, class Compare, class Allocator&gt;
void swap(multiset&lt;Key,Compare,Allocator&gt;&amp; x, multiset&lt;Key,Compare,Allocator&gt;&amp; y);
<del>template &lt;class Key, class Compare, class Allocator&gt;
void swap(multiset&lt;Key,Compare,Allocator&amp;&amp; x, multiset&lt;Key,Compare,Allocator&gt;&amp; y);
template &lt;class Key, class Compare, class Allocator&gt;
void swap(multiset&lt;Key,Compare,Allocator&amp; x, multiset&lt;Key,Compare,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>

<li>
<p>
Change 23.6.4.2 [multiset.special] as indicated:
</p>

<blockquote><pre>template &lt;class Key, class Compare, class Allocator&gt;
void swap(multiset&lt;Key,Compare,Allocator&gt;&amp; x, multiset&lt;Key,Compare,Allocator&gt;&amp; y);
<del>template &lt;class Key, class Compare, class Allocator&gt;
void swap(multiset&lt;Key,Compare,Allocator&gt;&amp;&amp; x, multiset&lt;Key,Compare,Allocator&gt;&amp; y);
template &lt;class Key, class Compare, class Allocator&gt;
void swap(multiset&lt;Key,Compare,Allocator&gt;&amp; x, multiset&lt;Key,Compare,Allocator&gt;&amp;&amp; y);</del>
</pre></blockquote>

</li>
</ol>





<hr>
<h3><a name="1233"></a>1233. Missing <tt>unique_ptr</tt> signatures in synopsis</h3>
<p><b>Section:</b> 20.9 [memory] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-10-11 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#memory">issues</a> in [memory].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Related to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#296">296</a>.  Some <tt>unique_ptr</tt> signatures are missing
from the synopsis in 20.9 [memory].
</p>

<p><i>[
2009-11-04 Howard adds:
]</i></p>


<blockquote>
Moved to Tentatively NAD Editorial.  The editor has adopted the fix.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Add in 20.9 [memory], Header <tt>&lt;memory&gt;</tt> synopsis
missing declarations as shown below:
</p>

<blockquote><pre>// 20.8.11 Class unique_ptr:
template &lt;class X&gt; class default_delete;
<ins>template&lt;class T&gt; struct default_delete&lt;T[]&gt;;</ins>
template &lt;class X, class D = default_delete&lt;T&gt;&gt; class unique_ptr;
<ins>template&lt;class T, class D&gt; class unique_ptr&lt;T[], D&gt;;</ins>

<ins>template&lt;class T, class D&gt; void swap(unique_ptr&lt;T, D&gt;&amp; x, unique_ptr&lt;T, D&gt;&amp; y);</ins>

<ins>template&lt;class T1, class D1, class T2, class D2&gt;
bool operator==(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);</ins>
<ins>template&lt;class T1, class D1, class T2, class D2&gt;
bool operator!=(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);</ins>
<ins>template&lt;class T1, class D1, class T2, class D2&gt;
bool operator&lt;(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);</ins>
<ins>template&lt;class T1, class D1, class T2, class D2&gt;
bool operator&lt;=(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);</ins>
<ins>template&lt;class T1, class D1, class T2, class D2&gt;
bool operator&gt;(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);</ins>
<ins>template&lt;class T1, class D1, class T2, class D2&gt;
bool operator&gt;=(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);</ins>
</pre></blockquote>





<hr>
<h3><a name="1235"></a>1235. Issue with C++0x random number proposal</h3>
<p><b>Section:</b> X [rand.concept.dist] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Future">NAD Future</a>
 <b>Submitter:</b> Matthias Troyer <b>Opened:</b> 2009-10-12 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There exist optimized, vectorized vendor libraries for the creation of
random number generators, such as Intel's MKL [1] and AMD's ACML [2]. In
timing tests we have seen a performance gain of a factor of up to 80
(eighty) compared to a pure C++ implementation (in Boost.Random) when
using these generator to generate a sequence of normally distributed
random numbers. In codes dominated by the generation of random numbers
(we have application codes where random number generation is more than
50% of the CPU time) this factor 80 is very significant.
</p>

<p>
To make use of these vectorized generators, we use a C++ class modeling
the <tt>RandomNumberEngine</tt> concept and forwarding the generation of random
numbers to those optimized generators. For example:
</p>

<blockquote><pre>namespace mkl {
 class mt19937 {.... };
}
</pre></blockquote>

<p>
For the generation of random variates we also want to dispatch to
optimized vectorized functions in the MKL or ACML libraries. See this
example:
</p>

<blockquote><pre>mkl::mt19937 eng;
std::normal_distribution&lt;double&gt; dist;

double n = dist(eng);
</pre></blockquote>

<p>
Since the variate generation is done through the <tt>operator()</tt> of the
distribution there is no customization point to dispatch to Intel's or
AMD's optimized functions to generate normally distributed numbers based
on the <tt>mt19937</tt> generator. Hence, the performance gain of 80 cannot be
achieved.
</p>

<p>
Contrast this with TR1:
</p>

<blockquote><pre>mkl::mt19937 eng;
std::tr1::normal_distribution&lt;double&gt; dist;
std::tr1::variate_generator&lt;mkl::mt19937,std::tr1::normal_distribution&lt;double&gt; &gt; rng(eng,dist);
double n = rng();
</pre></blockquote>

<p>
This - admittedly much uglier from an aestethic point of view - design
allowed optimization by specializing the <tt>variate_generator</tt> template for
<tt>mkl::mt19937</tt>:
</p>

<blockquote><pre>namespace std { namespace tr1 {

template&lt;&gt;
class variate_generator&lt;mkl::mt19937,std::tr1::normal_distribution&lt;double&gt; &gt; { .... };

} }
</pre></blockquote>

<p>
A similar customization point is missing in the C++0x design and
prevents the optimized vectorized version to be used.
</p>

<p>
Suggested resolution:
</p>

<p>
Add a customization point to the distribution concept. Instead of the
<tt>variate_generator</tt> template this can be done through a call to a
free function <tt>generate_variate</tt> found by ADL instead of
<tt>operator()</tt> of the distribution:
</p>

<blockquote><pre>template &lt;RandomNumberDistribution, class RandomNumberEngine&gt;
typename RandomNumberDistribution ::result_type
generate_variate(RandomNumberDistribution const&amp; dist, RandomNumberEngine&amp; eng);
</pre></blockquote>

<p>
This function can be overloaded for optimized enginges like
<tt>mkl::mt19937</tt>.
</p>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
NAD Future.  No time to add this feature for C++0X.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1236"></a>1236. reserved identifiers in programs not using the library</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Sean Hunt <b>Opened:</b> 2009-10-13 <b>Last modified:</b> 2010-10-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I wasn't sure whether to consider this a library or a language issue,
because the issue is I think it's incorrectly categorized as being part
of the library, so I thought I'd send a message to both of you and let
you sort it out.
</p>

<p>
Most reserved identifiers are treated as unilaterally available to the
implementation, such as to implement language extensions, or provide
macros documenting its functionality. However, the requirements for
reserved identifers are in 17.6.3.3 [reserved.names], which are a
subsection of 17.6.3 [constraints]. 17.6.3.1 [constraints.overview] appears only to apply to "C++ programs
that use the facilities of the C++ standard library", meaning that, in
theory, all implementations are erroneous in having any non-standard
identifiers predefined for programs that do not, at some point, include
a standard library header.
</p>

<p>
Furthermore, it's unclear whether the use of certain identifiers is UB
or results in an ill-formed program. In particular, 17.6.3.3.1 [macro.names] uses a "shall not", where 17.6.3.3.2 [global.names] says that names are "reserved to the
implementation". 17.6.3.3 [reserved.names] seems only to cover the
instance of a name being described as "reserved", so are implementations
required to diagnose a program that performs, as an example, "<tt>#undef
get</tt>"?
</p>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote>
Move to NAD. There may in theory be multiple interpretations possible,
but there's no evidence that this causes any genuine problems or
uncertainty about what implementations are allowed to do. We do not
believe this rises to the level of a defect.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1238"></a>1238. defining algorithms taking iterator for range</h3>
<p><b>Section:</b> 25 [algorithms] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Future">NAD Future</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-10-15 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#algorithms">issues</a> in [algorithms].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The library has many algorithms that take a source range represented by
a pair of iterators, and the start of some second sequence given by a
single iterator.  Internally, these algorithms will produce undefined
behaviour if the second 'range' is not as large as the input range, but
none of the algorithms spell this out in Requires clauses, and there is
no catch-all wording to cover this in clause 17 or the front matter of
25.
</p>

<p>
There was an attempt to provide such wording in paper
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2944.pdf">n2944</a>
but this
seems incidental to the focus of the paper, and getting the wording of
this issue right seems substantially more difficult than the simple
approach taken in that paper.  Such wording will be removed from an
updated paper, and hopefully tracked via the LWG issues list instead.
</p>

<p>
It seems there are several classes of problems here and finding wording
to solve all in one paragraph could be too much.  I suspect we need
several overlapping requirements that should cover the desired range of
behaviours.
</p>

<p>
Motivating examples:
</p>

<p>
A good initial example is the <tt>swap_ranges</tt> algorithm.  Here there is a
clear requirement that <tt>first2</tt> refers to the start of a valid range at
least as long as the range <tt>[first1, last1)</tt>.  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2944.pdf">n2944</a> tries to solve this
by positing a hypothetical <tt>last2</tt> iterator that is implied by the
signature, and requires <tt>distance(first2,last2) &lt; distance(first1,last1)</tt>.
 This mostly works, although I am uncomfortable assuming that <tt>last2</tt> is
clearly defined and well known without any description of how to obtain
it (and I have no idea how to write that).
</p>

<p>
A second motivating example might be the <tt>copy</tt> algorithm.  Specifically,
let us image a call like:
</p>

<blockquote><pre>copy(istream_iterator&lt;int&gt;(is),istream_iterator(),ostream_iterator&lt;int&gt;(os));
</pre></blockquote>

<p>
In this case, our input iterators are literally simple <tt>InputIterators</tt>,
and the destination is a simple <tt>OutputIterator</tt>.  In neither case am I
happy referring to <tt>std::distance</tt>, in fact it is not possible for the
<tt>ostream_iterator</tt> at all as it does not meet the requirements.  However,
any wording we provide must cover both cases.  Perhaps we might deduce
<tt>last2 == ostream_iterator&lt;int&gt;{}</tt>, but that might not always be valid for
user-defined iterator types.  I can well imagine an 'infinite range'
that writes to <tt>/dev/null</tt> and has no meaningful <tt>last2</tt>.
</p>

<p>
The motivating example in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2944.pdf">n2944</a> is <tt>std::equal</tt>, and that seems to fall somewhere between the
two.
</p>

<p>
Outlying examples might be <tt>partition_copy</tt> that takes two output
iterators, and the <tt>_n</tt> algorithms where a range is specified by a
specific number of iterations, rather than traditional iterator pair. 
We should also <em>not</em> accidentally apply inappropriate constraints to
<tt>std::rotate</tt> which takes a third iterator that is not intended to be a
separate range at all.
</p>

<p>
I suspect we want some wording similar to:
</p>

<blockquote>
For algorithms that operate on ranges where the end iterator of the
second range is not specified, the second range shall contain at least
as many elements as the first.
</blockquote>

<p>
I don't think this quite captures the intent yet though.  I am not sure
if 'range' is the right term here rather than sequence.  More awkwardly,
I am not convinced we can describe an Output sequence such as produce by
an <tt>ostream_iterator</tt> as "containing elements", at least not as a
precondition to the call before they have been written.
</p>

<p>
Another idea was to describe require that the trailing iterator support
at least distance(input range) applications of <tt>operator++</tt> and may be
written through the same number of times if a mutable/output iterator.
</p>

<p>
We might also consider handling the case of an output range vs. an input
range in separate paragraphs, if that simplifies how we describe some of
these constraints.
</p>

<p><i>[
2009-11-03 Howard adds:
]</i></p>


<blockquote>
Moved to Tentatively NAD Future after 5 positive votes on c++std-lib.
</blockquote>


<p><b>Rationale:</b></p>
<p>
Does not have sufficient support at this time. May wish to reconsider for a
future standard.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1239"></a>1239. Defect report</h3>
<p><b>Section:</b> 20.7.4.3 [meta.unary.prop] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> David Abrahams <b>Opened:</b> 2009-10-16 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Table 43 defines a number of traits that yield true for arrays of class
types with the trait's property, but not arrays of other types with that
property.  For example, <tt>has_trivial_default_constructor</tt>:
</p>

<blockquote>
<tt>T</tt> is a trivial type (3.9) or a class type with a trivial default
constructor (12.1) or an array of such a class type.
</blockquote>

<p><i>[
2009-10 post-Santa Cruz:
]</i></p>


<blockquote>
<p>
An array of a trivial type is a trivial type.
</p>
<p>
Mark as Tentatively NAD Editorial. The wording is OK as is,
since an array of a trivial type is a trivial type, but the wording as
proposed might be clearer.
</p>
</blockquote>



<p><b>Rationale:</b></p>
<p>
The wording is OK as is, since an array of a trivial type is a trivial type.
Project editor may wish to accept the suggested wording as editorial.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change all the traits in question following this pattern:
</p>

<blockquote>
<tt>T</tt> is a trivial type (3.9) or a class type with a trivial default
 constructor (12.1)<ins>,</ins> or an array of such a <del>class</del> type.
</blockquote>

<p>
i.e., add a comma and delete a "class."
</p>





<hr>
<h3><a name="1242"></a>1242. Enable SCARY iterators</h3>
<p><b>Section:</b> 23 [containers] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Future">NAD Future</a>
 <b>Submitter:</b> Herb Sutter <b>Opened:</b> 2009-10-21 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#containers">issues</a> in [containers].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<p>
See
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2980.pdf">N2980</a>.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1243"></a>1243. Missing <tt>operator+= (initializer_list&lt;T&gt;)</tt> for <tt>valarray</tt></h3>
<p><b>Section:</b> 26.6.2.6 [valarray.cassign] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2009-10-22 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#valarray.cassign">issues</a> in [valarray.cassign].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses JP 64</b></p>

<p>
During the additions of <tt>initializer_list</tt> overloads
<tt>basic_string</tt> added
</p>

<blockquote><pre>basic_string&amp; operator+=(initializer_list&lt;charT&gt;);
</pre></blockquote>

<p>
but
</p>

<blockquote><pre>valarray&lt;T&gt;&amp; operator+= (initializer_list&lt;T&gt;);
</pre></blockquote>

<p>
was not defined.
</p>

<p><i>[
Daniel adds on opening:
]</i></p>


<blockquote>
Recommend NAD. The <tt>operator+=</tt> overload of <tt>basic_string</tt>
behaves as-if calling <tt>append</tt>, which is completely different in
meaning as the existing <tt>operator+=</tt> overloads in
<tt>valarray</tt> which just sum the value or values to the existing
elements. The suggestion to add a corresponding append function to
<tt>valarray</tt> was not considered as appropriate and the request was
withdrawn (c++std-lib-24968).
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Mark as NAD.  Request has been withdrawn by NB.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add to 26.6.2.6 [valarray.cassign]:
</p>

<blockquote><pre>valarray&lt;T&gt;&amp; operator+= (initializer_list&lt;T&gt;);
</pre></blockquote>





<hr>
<h3><a name="1244"></a>1244. wait_*() in *future for synchronous functions</h3>
<p><b>Section:</b> 30.6 [futures] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Detlef Vollmann <b>Opened:</b> 2009-10-22 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#futures">issues</a> in [futures].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
With the addition of <tt>async()</tt>, a <tt>future</tt> might be
associated with a function that is not running in a different thread but
is stored to by run synchronously on the <tt>get()</tt> call. It's not
clear what the <tt>wait()</tt> functions should do in this case.
</p>

<p>
Suggested resolution:
</p>

<p>
Throw an exception.
</p>

<p><i>[
2010 Pittsburgh:  Moved to NAD Editorial.  Rationale added below.
]</i></p>




<p><b>Rationale:</b></p>
<p>
Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3058.html">N3058</a>.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1246"></a>1246. <tt>vector::resize()</tt> missing efficiency guarantee</h3>
<p><b>Section:</b> 23.4.1.2 [vector.capacity] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> David Abrahams <b>Opened:</b> 2009-10-24 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#vector.capacity">issues</a> in [vector.capacity].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
If <tt>v</tt> is a <tt>vector</tt>, I think repeated calls to
<tt>v.resize( v.size() + 1 )</tt> should be amortized O(1), but it's not
clear that's true from the text of the standard:
</p>

<blockquote><pre>void resize(size_type sz);
</pre>
<blockquote>
<i>Effects:</i> If <tt>sz &lt; size()</tt>, equivalent to <tt>erase(begin() + sz, end());</tt>. If
<tt>size() &lt; sz</tt>, appends <tt>sz - size()</tt> default constructed elements to the
sequence.
</blockquote>
</blockquote>

<p>
Seems to me if we used <tt>push_back</tt> instead of appends, we might be giving
the guarantee I'd like.  Thoughts?
</p>

<p><i>[
2009-11-10 Howard adds:
]</i></p>


<blockquote>
Moved to Tentatively NAD after 5 positive votes on c++std-lib.  Rationale added
below.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
In 23.4.1.2 [vector.capacity]/10, change
</p>

<blockquote><pre>void resize(size_type sz);
</pre>
<blockquote>
<i>Effects:</i> If <tt>sz &lt; size()</tt>, equivalent to <tt>erase(begin() + sz, end());</tt>. If
<tt>size() &lt; sz</tt>, <del>appends <tt>sz - size()</tt> default constructed elements to the
sequence</del>
<ins>equivalent to <tt>sz - size()</tt> consecutive evaluations of <tt>push_back(T())</tt></ins>.
</blockquote>
</blockquote>



<p><b>Rationale:</b></p>
<p>
The description in terms of <tt>push_back</tt> led some to believe that
one could expect the exact same growth pattern from both <tt>resize</tt> and
<tt>push_back</tt> (e.g.) which could lead to sub-optimal implementations.
Additionally, 23.4.1 [vector], p1 includes a statement that this container
"supports (amortized) constant time insert and erase operations at the end;",
therefore addressing the concern of this issue.
</p>





<hr>
<h3><a name="1248"></a>1248. Equality comparison for unordered containers</h3>
<p><b>Section:</b> 23.7 [unord] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Herb Sutter <b>Opened:</b> 2009-10-25 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unord">issues</a> in [unord].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
See
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2986.pdf">N2986</a>.
</p>

<p><i>[
2010-01-22 Alisdair Opens.
]</i></p>


<p><i>[
2010-01-24 Alisdair provides wording.
]</i></p>


<p><i>[
2010 Pittsburgh:  Moved to NAD Editorial.  Rationale added below.
]</i></p>




<p><b>Rationale:</b></p>
<p>
Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3068.pdf">N3068</a>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Apply paper
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2986.pdf">N2986</a>.
</p>





<hr>
<h3><a name="1251"></a>1251. move constructing <tt>basic_stringbuf</tt></h3>
<p><b>Section:</b> 27.8.1.1 [stringbuf.cons] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2009-10-29 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#stringbuf.cons">issues</a> in [stringbuf.cons].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I just came across issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1204">1204</a> -- Global permission to move, which
seems to address the concern raised by the example in c++std-lib-25030.
</p>
<p>
IIUC, the example violates the permission to assume that arguments
bound to rvalue references are unnamed temporaries granted to
implementations by the resolution of issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1204">1204</a> - Global permission
to move.
</p>

<p>
I.e., the <tt>ostringstream(ostringstream &amp;&amp;rhs)</tt> ctor can leave the <tt>rhs</tt>
pointers pointing to the newly constructed object's buffer just as
long as the dtor doesn't change or invalidate the buffer. The caller
may not make any assumptions about rhs after the move beyond it being
safe to destroy or reassign.
</p>

<p>
So unless I misunderstood something, I still think the <tt>basic_stringbuf</tt>
move ctor is overspecified. Specifically, I think the third sentence
in the Effects clause and the last 6 bullets in the Postconditions
clause can, and IMO should, be stricken.
</p>

<p><i>[
2010-01-31 Moved to Tentatively NAD after 5 positive votes on c++std-lib.
Rationale added below.
]</i></p>



<p><b>Rationale:</b></p>
<p>
The sense of 1251 appears to be that the <tt>basic_stringbuf</tt> move
constructor offers more guarantees than the minimum.  This is true, and quite
correct.  The additional words guarantee that the internal buffer has genuinely
transferred from one object to another, and further operations on the original
will not affect the buffer of the newly created object.  This is a very
important guarantee, much as we see that a moved-from <tt>unique_ptr</tt> is
guaranteed to be empty.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Strike from 27.8.1.1 [stringbuf.cons]:
</p>

<blockquote><pre>basic_stringbuf(basic_stringbuf&amp;&amp; rhs);
</pre>
<blockquote>
<p>
<i>Effects:</i> Move constructs from the rvalue <tt>rhs</tt>. It is
implementation-defined whether the sequence pointers in <tt>*this</tt>
(<tt>eback()</tt>, <tt>gptr()</tt>, <tt>egptr()</tt>, <tt>pbase()</tt>,
<tt>pptr()</tt>, <tt>epptr()</tt>) obtain the values which <tt>rhs</tt>
had. <del>Whether they do or not, <tt>*this</tt> and <tt>rhs</tt> reference
separate buffers (if any at all) after the construction.</del> The openmode,
locale and any other state of <tt>rhs</tt> is also copied.
</p>

<p>
<i>Postconditions:</i> Let <tt>rhs_p</tt> refer to the state of
<tt>rhs</tt> just prior to this construction and let <tt>rhs_a</tt>
referto the state of <tt>rhs</tt> just after this construction.
</p>
<ul>
<li>
<tt>str() == rhs_p.str()</tt>
</li>
<li>
<tt>gptr() - eback() == rhs_p.gptr() - rhs_p.eback()</tt>
</li>
<li>
<tt>egptr() - eback() == rhs_p.egptr() - rhs_p.eback()</tt>
</li>
<li>
<tt>pptr() - pbase() == rhs_p.pptr() - rhs_p.pbase()</tt>
</li>
<li>
<tt>epptr() - pbase() == rhs_p.epptr() - rhs_p.pbase()</tt>
</li>
<li><del>
if <tt>(eback()) eback() != rhs_a.eback()</tt>
</del></li>
<li><del>
if <tt>(gptr()) gptr() != rhs_a.gptr()</tt>
</del></li>
<li><del>
if <tt>(egptr()) egptr() != rhs_a.egptr()</tt>
</del></li>
<li><del>
if <tt>(pbase()) pbase() != rhs_a.pbase()</tt>
</del></li>
<li><del>
if <tt>(pptr()) pptr() != rhs_a.pptr()</tt>
</del></li>
<li><del>
if <tt>(epptr()) epptr() != rhs_a.epptr()</tt>
</del></li>
</ul>
</blockquote>
</blockquote>






<hr>
<h3><a name="1259"></a>1259. Should initializer-list constructors move elements?</h3>
<p><b>Section:</b> 23.2.3 [sequence.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Sean Hunt <b>Opened:</b> 2009-11-05 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#sequence.reqmts">issues</a> in [sequence.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
According to 23.2.3 [sequence.reqmts], <tt>X(il)</tt> is
equivalent to <tt>X(il.begin(), il.end())</tt>. Should it instead be
equivalent to <tt>X(move_iterator(il.begin()),
move_iterator(il.end()))</tt> so that needless copies are not made? This
doesn't seem ideal either - it may make more sense to provide two
overloads for the constructor, one for move and one for copy.
</p>

<p><i>[
2009-11-10 Howard adds:
]</i></p>


<blockquote>
I've moved this issue to Tentatively NAD after 5 positive votes on c++std-lib,
and added a rationale below.
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
</p>


<p><b>Rationale:</b></p>
<p>
There is no consensus at this time within EWG or CWG to make the
required language changes.  Therefore this is not something that the LWG
can even consider.  Should such language changes be made for a future
standard, no doubt there would need to be an accompanying library impact
survey.
</p>





<hr>
<h3><a name="1263"></a>1263. missing <tt>swap</tt> overloads for <tt>regex</tt></h3>
<p><b>Section:</b> 28.4 [re.syn] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-11-12 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses: UK 314</b></p>

<p>
In Message c++std-lib-25529, Alisdair writes:
</p>

<blockquote>
<p>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n3009.html#UK314">UK comment 314</a>
requests rvalue swap overloads in a couple of places they
were missed.
</p>

<p>
We have in general reverted to the single swap signature taking lvalue
references, which could be seen as the alternative solution to
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n3009.html#UK314">UK 314</a>,
bringing consistency to the standard &lt;g&gt;
</p>

<p>
Either way, I no longer expect to see any work to resolve this comment -
the work is complete and it should be either marked Rejected, or
Accepted with Modifications (namely, removing all other rvalue swaps!)
</p>
</blockquote>

<p><i>[
Moved to Tentatively NAD after 5 positive votes on c++std-lib.
]</i></p>



<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>
We have in general reverted to the single swap signature taking
lvalue references, which could be seen as the alternative solution to
UK 314, bringing consistency to the standard.
</p>





<hr>
<h3><a name="1265"></a>1265. <tt>longjmp</tt> and destructors</h3>
<p><b>Section:</b> 18.10 [support.runtime] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Sean Hunt <b>Opened:</b> 2009-11-16 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#support.runtime">issues</a> in [support.runtime].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
18.10 [support.runtime]/4 says that <tt>longjmp</tt> is undefined if
unwinding by the mechanism used by catch and throw would invoke any nontrivial
destructors. However, the text as written is rather vague, in particular when
dealing with <tt>catch(...)</tt>:
</p>

<blockquote><pre>void foo() {
  jump_buf buf;
  non_trivial_dtor n1; // 1
  if (!setjmp(buf)) {
    non_trivial_dtor n2; // 2
    try {
      longjmp(buf, 1);
    } catch (...) {
    }
  }
}
</pre></blockquote>

<p>
My interpretation of the meaning of 18.10 [support.runtime]/4 is that
declaration 2, but not 1, would cause the <tt>longjmp</tt> to be undefined
behavior. However,  it's not entirely clear from the text. Arguably, replacing
the <tt>setjmp</tt> and <tt>longjmp</tt> with <tt>catch</tt> would still cause
the destructor for <tt>n1</tt> to be called after the unwinding, which would
lead to undefined behavior. This is clearly not an intended consequence of the
wording. However, it is probably still UB, as <tt>n1</tt> now has
"indeterminate" value, and running its destructor on <tt>foo</tt>'s exit will
cause Bad Things.
</p>

<p>
Declarations 2 has a more interesting issue. The <tt>catch(...)</tt> muddles up
the definition that uses <tt>throw</tt> and <tt>catch</tt> - if
<tt>longjmp()</tt> were indeed a <tt>throw</tt>, control would never return to
the <tt>setjmp</tt>. As such, <tt>n2</tt>'s destructor wouldn't be called
(except by the argument for <tt>n1</tt>, which is that the destructor would be
called later as the frame was left in the normal control flow).
</p>

<p>
I suggest that paragraph 4 of 18.10 [support.runtime] should be replaced
with the following, or something that reads better but has the same effect:
</p>

<blockquote>
The function signature <tt>longjmp(jmp_buf jbuf, int val)</tt> has more
restricted behavior in this International Standard. A call to <tt>longjmp</tt>
has undefined behavior if any non-trivial destructors would be called were the
<tt>longjmp</tt> call replaced with a throw-expression whose nearest matching
handler were a (possibly imaginary) function-try-block on the function
containing the corresponding <tt>setjmp</tt> call.
</blockquote>

<p><i>[
2009-11-17 Moved to Tentatively NAD after 5 positive votes on c++std-lib. 
Rationale added below.
]</i></p>



<p><b>Proposed resolution:</b></p>
<p>
Change 18.10 [support.runtime]/4:
</p>

<blockquote>
The function signature <tt>longjmp(jmp_buf jbuf, int val)</tt> has more
restricted behavior in this International Standard. <del>A
<tt>setjmp</tt>/<tt>longjmp</tt> call pair has undefined behavior if replacing
the <tt>setjmp</tt> and <tt>longjmp</tt> by <tt>catch</tt> and <tt>throw</tt>
would invoke any non-trivial destructors for any automatic objects.</del>
<ins>A call to <tt>longjmp</tt> has undefined behavior if any non-trivial
destructors would be called were the <tt>longjmp</tt> call replaced with a
throw-expression whose nearest matching handler were a (possibly imaginary)
function-try-block on the function containing the corresponding <tt>setjmp</tt>
call.</ins>
</blockquote>


<p><b>Rationale:</b></p>
<p>
In the given example, it is clear that it is only <tt>n2</tt> and not
<tt>n1</tt> that is destroyed by the <tt>longjmp</tt>.
</p>
<p>
At this late stage in the standards process, we are focusing on issues that
impact users or implementers.  Trying to rewrite complex wording just for the
sake of improved clarity is likely to do more harm than good.
</p>





<hr>
<h3><a name="1266"></a>1266. <tt>shared_future::get</tt> and deferred async functions</h3>
<p><b>Section:</b> 30.6.7 [futures.shared_future] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Anthony Williams <b>Opened:</b> 2009-11-17 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#futures.shared_future">issues</a> in [futures.shared_future].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
If a <tt>shared_future</tt> is constructed with the result of an <tt>async</tt> call with a
deferred function, and two or more copies of that <tt>shared_future</tt> are created,
with multiple threads calling <tt>get()</tt>, it is not clear which thread runs the
deferred function. 30.6.7 [futures.shared_future]p22 from
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n3000.pdf">N3000</a>
says (minus editor's note):
</p>

<blockquote>
<i>Effects:</i> if the associated state contains a deferred function, executes
the deferred function. Otherwise, blocks until the associated state is ready.
</blockquote>

<p>
In the absence of wording to the contrary, this implies that every thread that
calls <tt>wait()</tt> will execute the deferred function.
</p>

<p><i>[
2010 Pittsburgh:  Moved to NAD Editorial.  Rationale added below.
]</i></p>




<p><b>Rationale:</b></p>
<p>
Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3058.html">N3058</a>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Replace 30.6.7 [futures.shared_future]p22 with the following:
</p>

<blockquote>
<p>
<i>Effects:</i> If the associated state 
<del>contains a deferred function, executes the deferred function. Otherwise,
blocks until the associated state is ready.</del>
<ins>was created by a <tt>promise</tt> or <tt>packaged_task</tt> object, block
until the associated state is ready. If the associated state is associated with
a thread created for an <tt>async</tt> call (30.6.9 [futures.async]), as
if <tt>associated-thread.join()</tt>.
</ins></p>

<p><ins>
If the associated state contains a deferred function, calls to <tt>wait()</tt>
on all <tt>shared_future</tt> objects that share the same associated state are
serialized. The first call to <tt>wait()</tt> that shares a given associated
state executes the deferred function and stores the return value or exception in
the associated state.
</ins></p>

<p><ins>
<i>Synchronization:</i> if the associated state was created by a
<tt>promise</tt> object, the completion of <tt>set_value()</tt> or
<tt>set_exception()</tt> to that <tt>promise</tt> happens before (1.10 [intro.multithread]) <tt>wait()</tt> returns. If the associated state
was created by a <tt>packaged_task</tt> object, the completion of the associated
task happens before <tt>wait()</tt> returns. If the associated state is
associated with a thread created for an <tt>async</tt> call (30.6.9 [futures.async]), the completion of the associated thread happens-before
<tt>wait()</tt> returns.
</ins></p>

<p><ins>
If the associated state contained a deferred function, the invocation of the
deferred function happens-before any call to <tt>wait()</tt> on a
<tt>future</tt> that shares that state returns.
</ins></p>
</blockquote>





<hr>
<h3><a name="1269"></a>1269. Associated state doesn't account for async</h3>
<p><b>Section:</b> 30.6.4 [futures.state] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Anthony Williams <b>Opened:</b> 2009-11-18 <b>Last modified:</b> 2010-10-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#futures.state">active issues</a> in [futures.state].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#futures.state">issues</a> in [futures.state].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current description of the associated state in 30.6.4 [futures.state]
does not allow for futures created by an <tt>async</tt> call. The description
therefore needs to be extended to cover that.
</p>

<p><i>[
2010 Pittsburgh:  Moved to NAD Editorial.  Rationale added below.
]</i></p>




<p><b>Rationale:</b></p>
<p>
Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3058.html">N3058</a>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add a new sentence to 30.6.4 [futures.state] p2:
</p>

<blockquote>
2 This <i>associated state</i> consists of some state information and some
(possibly not yet evaluated) <i>result</i>, which can be a (possibly
<tt>void</tt>) value or an exception. <ins>If the associated state was created
by a call to <tt>async</tt> (30.6.9 [futures.async]) then it may also
contain a deferred function or an associated <tt>thread</tt>.</ins>
</blockquote>

<p>
Add an extra bullet to 30.6.4 [futures.state] p3:
</p>

<blockquote>
<p>
The result of an associated state can be set by calling:
</p>
<ul>
<li>
<tt>promise::set_value</tt>,
</li>
<li>
<tt>promise::set_exception</tt>, <del>or</del>
</li>
<li>
packaged_task::operator()<del>.</del><ins>, or</ins>
</li>
<li>
<ins>a call to <tt>async</tt> (30.6.9 [futures.async]).</ins>
</li>
</ul>
</blockquote>





<hr>
<h3><a name="1272"></a>1272. confusing declarations of <tt>promise::set_value</tt></h3>
<p><b>Section:</b> 30.6.5 [futures.promise] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2009-11-22 <b>Last modified:</b> 2010-10-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#futures.promise">active issues</a> in [futures.promise].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#futures.promise">issues</a> in [futures.promise].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The definitions of <tt>promise::set_value</tt> need tidying up, the
synopsis says:
</p>

<blockquote><pre>// setting the result
void set_value(const R&amp; r);
void set_value(<i>see below</i>);
</pre></blockquote>

<p>
Why is the first one there?  It implies it is always present for all
specialisations of promise, which is not true.
</p>

<p>
The definition says:
</p>

<blockquote><pre>void set_value(const R&amp; r);
void promise::set_value(R&amp;&amp; r);
void promise&lt;R&amp;&gt;::set_value(R&amp; r);
void promise&lt;void&gt;::set_value();
</pre></blockquote>

<p>
The lack of qualification on the first one again implies it's present
for all specialisations, again not true.
</p>

<p><i>[
2010 Pittsburgh:  Moved to NAD Editorial.  Rationale added below.
]</i></p>




<p><b>Rationale:</b></p>
<p>
Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3058.html">N3058</a>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change the synopsis in 30.6.5 [futures.promise]:
</p>

<blockquote><pre>// setting the result
<del>void set_value(const R&amp; r);</del>
void set_value(<i>see below</i>);
</pre></blockquote>

<p>
And the definition be changed by qualifying the first signature:
</p>

<blockquote><pre>void <ins>promise::</ins>set_value(const R&amp; r);
void promise::set_value(R&amp;&amp; r);
void promise&lt;R&amp;&gt;::set_value(R&amp; r);
void promise&lt;void&gt;::set_value();
</pre></blockquote>





<hr>
<h3><a name="1273"></a>1273. <tt>future::valid</tt> should be callable on an invalid future</h3>
<p><b>Section:</b> 30.6.6 [futures.unique_future] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2009-11-22 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#futures.unique_future">issues</a> in [futures.unique_future].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
30.6.6 [futures.unique_future]/3 says:
</p>

<blockquote>
The effect of calling any member function other than the destructor or
the move-assignment operator on a <tt>future</tt> object for which <tt>valid() ==
false</tt> is undefined.
</blockquote>

<p>
This means calling <tt>future::valid()</tt> is undefined unless it will
return <tt>true</tt>, so you can only use it if you know the answer!
</p>

<p><i>[
2009-12-08 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>


<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote>
Moved to NAD Editorial.  Rationale added below.
</blockquote>



<p><b>Rationale:</b></p>
<p>
Solved by N3058.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 30.6.6 [futures.unique_future]/3:
</p>

<blockquote>
The effect of calling any member function other than the
destructor<ins>,</ins> or the move-assignment operator<ins>, or
<tt>valid</tt>,</ins> on a <tt>future</tt> object for which <tt>valid()
== false</tt> is undefined.
</blockquote>






<hr>
<h3><a name="1274"></a>1274. <tt>atomic_future</tt> constructor</h3>
<p><b>Section:</b> 30.6.8 [futures.atomic_future] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2009-11-22 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#futures.atomic_future">issues</a> in [futures.atomic_future].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 30.6.8 [futures.atomic_future] this constructor:
</p>

<blockquote><pre>atomic_future(future&lt;R&gt;&amp;&amp;);
</pre></blockquote>

<p>
is declared in the synopsis, but not defined. Instead
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2997.htm">n2997</a>
defines:
</p>

<blockquote><pre>atomic_future(const future&lt;R&gt;&amp;&amp; rhs);
</pre></blockquote>

<p>
and
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n3000.pdf">n3000</a>
defines
</p>

<blockquote><pre>atomic_future(atomic_future&lt;R&gt;&amp;&amp; rhs);
</pre></blockquote>

<p>
both of which are wrong. The constructor definition should be changed
to match the synopsis.
</p>

<p><i>[
2009-12-12 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>


<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote>
Moved to NAD Editorial.  Rationale added below.
</blockquote>



<p><b>Rationale:</b></p>
<p>
Solved by N3058.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Adjust the signature above 30.6.8 [futures.atomic_future]/6 like so:
</p>

<blockquote><pre>atomic_future(<del>atomic_</del>future<ins>&lt;R&gt;</ins>&amp;&amp; rhs);
</pre></blockquote>





<hr>
<h3><a name="1275"></a>1275. creating and setting futures</h3>
<p><b>Section:</b> 30.6 [futures] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2009-11-22 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#futures">issues</a> in [futures].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
30.6.6 [futures.unique_future]/1 should be updated to mention
<tt>async</tt>.
</p>

<p>
30.6.7 [futures.shared_future]/1 should also be updated for
<tt>async</tt>. That paragraph also says
</p>

<blockquote>
... Its value or exception can be set by use of a
<tt>shared_future</tt>, <tt>promise</tt> (30.6.5 [futures.promise]), or <tt>packaged_task</tt> (30.6.10 [futures.task]) object that shares the same associated state.
</blockquote>

<p>
How can the value be set by a <tt>shared_future</tt>?
</p>

<p>
30.6.8 [futures.atomic_future]/1 says
</p>

<blockquote>
An <tt>atomic_future</tt> object can only be created by use of a
<tt>promise</tt> (30.6.5 [futures.promise]) or
<tt>packaged_task</tt> (30.6.10 [futures.task]) object.
</blockquote>

<p>
which is wrong, it's created from a <tt>std::future</tt>, which could
have been default-cosntructed. That paragraph should be closer to the
text of 30.6.7 [futures.shared_future]/1, and should also mention
<tt>async</tt>.
</p>

<p><i>[
2010 Pittsburgh:  Moved to NAD Editorial.  Rationale added below.
]</i></p>




<p><b>Rationale:</b></p>
<p>
Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3058.html">N3058</a>.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1281"></a>1281. CopyConstruction and Assignment between ratios having the same normalized form</h3>
<p><b>Section:</b> 20.6.1 [ratio.ratio] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Vicente Juan Botet Escrib <b>Opened:</b> 2009-12-07 <b>Last modified:</b> 2010-11-24</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#ratio.ratio">issues</a> in [ratio.ratio].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
CopyConstruction and Assignment between <tt>ratio</tt>s having the same
normalized form. Current
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n3000.pdf">N3000</a>
do not allows to copy-construct or assign <tt>ratio</tt> instances of
<tt>ratio</tt> classes having the same normalized form.
</p>

<p>
Two <tt>ratio</tt> classes <tt>ratio&lt;N1,D1&gt;</tt> and
<tt>ratio&lt;N2,D2&gt;</tt> have the same normalized form if
</p>

<blockquote><pre>ratio&lt;N1, D1&gt;::num == ratio&lt;N2, D2&gt;::num &amp;&amp;
ratio&lt;N1, D1&gt;::den == ratio&lt;N2, D2&gt;::den
</pre></blockquote>

<p>
This simple example
</p>

<blockquote><pre>ratio&lt;1,3&gt; r1;
ratio&lt;3,9&gt; r2;
r1 = r2; // (1)
</pre></blockquote>

<p>
fails to compile in (1). Other example
</p>

<blockquote><pre>ratio&lt;1,3&gt; r1;
ratio_subtract&lt;ratio&lt;2,3&gt;, ratio&lt;1,3&gt;&gt;::type r2;
r1 = r2;  
</pre></blockquote>

<p>
The nested type of <tt>ratio_subtract&lt;ratio&lt;2,3&gt;,
ratio&lt;1,3&gt;&gt;</tt> could be <tt>ratio&lt;3,9&gt;</tt> so the compilation
could fail. It could also be <tt>ratio&lt;1,3&gt;</tt> and the compilation
succeeds.
</p>

<p>
In 20.6.2 [ratio.arithmetic] 3 and similar clauses
</p>

<blockquote>
3 The nested typedef <tt>type</tt> shall be a synonym for <tt>ratio&lt;T1,
T2&gt;</tt> where <tt>T1</tt> has the value <tt>R1::num * R2::den - R2::num *
R1::den</tt> and <tt>T2</tt> has the value <tt>R1::den * R2::den</tt>.
</blockquote>

<p>
the meaning of synonym let think that the result shall be a normalized
<tt>ratio</tt> equivalent to <tt>ratio&lt;T1, T2&gt;</tt>, but there is not an
explicit definition of what synonym means in this context.
</p>

<p>
Additionally we should add a typedef for accessing the normalized
<tt>ratio</tt>, and  change 20.6.2 [ratio.arithmetic] to return only this
<em>normalized</em> result.
</p>

<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote>
<p>
There is no consensus to add the converting copy constructor or converting copy
assignment operator.  However there was consensus to add the typedef.
</p>

<p>
Proposed wording modified.  Original proposed wording preserved here.  Moved to
Review.
</p>

<blockquote class="note">
<p>
Make <tt>ratio</tt> default constructible, copy-constructible and assignable
from any <tt>ratio</tt> which has the same reduced form.
</p>

<p>
Add to 20.6.1 [ratio.ratio] synopsis
</p>

<blockquote><pre>template &lt;intmax_t N, intmax_t D = 1&gt;
class ratio {
public:
  static constexpr intmax_t num;
  static constexpr intmax_t den;

  <ins>typedef ratio&lt;num, den&gt; type;</ins>

  <ins>ratio() = default;
  template &lt;intmax_t N2, intmax_t D2&gt;
    ratio(const ratio&lt;N2, D2&gt;&amp;);
  template &lt;intmax_t N2, intmax_t D2&gt;
    ratio&amp; operator=(const ratio&lt;N2, D2&gt;&amp;);</ins>
};
</pre></blockquote>

<p>
Add to 20.6.1 [ratio.ratio]:
</p>

<blockquote>
<p>
Two ratio classes <tt>ratio&lt;N1,D1&gt;</tt> and <tt>ratio&lt;N2,D2&gt;</tt>
have the same reduced form if <tt>ratio&lt;N1,D1&gt;::type</tt> is the same
type as <tt>ratio&lt;N2,D2&gt;::type</tt>
</p>

</blockquote>

<p>
Add a new section: [ratio.cons]
</p>

<blockquote>
<p><b>
Construction and assignment  [ratio.cons]
</b></p>

<pre>template &lt;intmax_t N2, intmax_t D2&gt;
  ratio(const ratio&lt;N2, D2&gt;&amp; r);
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs a <tt>ratio</tt> object.
</p>
<p>
<i>Remarks:</i> This constructor shall not participate in overload resolution
unless <tt>r</tt> has the same reduced form as <tt>*this</tt>.
</p>
</blockquote>

<pre>template &lt;intmax_t N2, intmax_t D2&gt;
  ratio&amp; operator=(const ratio&lt;N2, D2&gt;&amp; r);
</pre>

<blockquote>
<p>
<i>Effects:</i> None.
</p>
<p>
<i>Returns:</i> <tt>*this</tt>.
</p>
<p>
<i>Remarks:</i> This operator shall not participate in overload resolution
unless <tt>r</tt> has the same reduced form as <tt>*this</tt>.
</p>
</blockquote>

</blockquote>

<p>
Change 20.6.2 [ratio.arithmetic] 
</p>

<blockquote>
<p>
Implementations may use other algorithms to compute these values. If overflow
occurs, a diagnostic shall be issued.
</p>

<pre>template &lt;class R1, class R2&gt; struct ratio_add {
  typedef <i>see below</i> type;
};
</pre>

<blockquote>
The nested typedef <tt>type</tt> shall be a synonym for <tt>ratio&lt;T1,
T2&gt;<ins>::type</ins></tt> where <tt>T1</tt> has the value <tt>R1::num *
R2::den + R2::num * R1::den</tt> and <tt>T2</tt> has the value <tt>R1::den *
R2::den</tt>.
</blockquote>

<pre>template &lt;class R1, class R2&gt; struct ratio_subtract {
  typedef <i>see below</i> type;
};
</pre>

<blockquote>
The nested typedef <tt>type</tt> shall be a synonym for <tt>ratio&lt;T1,
T2&gt;<ins>::type</ins></tt> where <tt>T1</tt> has the value <tt>R1::num *
R2::den - R2::num * R1::den</tt> and <tt>T2</tt> has the value <tt>R1::den *
R2::den</tt>.
</blockquote>

<pre>template &lt;class R1, class R2&gt; struct ratio_multiply {
  typedef <i>see below</i> type;
};
</pre>

<blockquote>
The nested typedef <tt>type</tt> shall be a synonym for <tt>ratio&lt;T1,
T2&gt;<ins>::type</ins></tt> where <tt>T1</tt> has the value <tt>R1::num *
R2::num</tt> and <tt>T2</tt> has the value <tt>R1::den * R2::den</tt>.
</blockquote>

<pre>template &lt;class R1, class R2&gt; struct ratio_divide {
  typedef <i>see below</i> type;
};
</pre>

<blockquote>
The nested typedef <tt>type</tt> shall be a synonym for <tt>ratio&lt;T1,
T2&gt;<ins>::type</ins></tt> where <tt>T1</tt> has the value <tt>R1::num *
R2::den</tt> and <tt>T2</tt> has the value <tt>R1::den * R2::num</tt>.
</blockquote>

</blockquote>

</blockquote>

</blockquote>

<p><i>[
2010-03-27 Howard adds:
]</i></p>


<blockquote>
<p>
Daniel brought to my attention the recent addition of the typedef <tt>type</tt>
to the FCD
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3092.pdf">N3092</a>:
</p>

<blockquote><pre>typedef ratio type;
</pre></blockquote>

<p>
This issue was discussed in Pittsburgh, and the decision there was to accept the
typedef as proposed and move to Review.  Unfortunately the issue was accidently
applied to the FCD, and incorrectly.  The FCD version of the typedef refers to
<tt>ratio&lt;N, D&gt;</tt>, but the typedef is intended to refer to
<tt>ratio&lt;num, den&gt;</tt> which in general is not the same type.
</p>

<p>
I've updated the wording to diff against
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3092.pdf">N3092</a>.
</p>

</blockquote>

<p><i>[Batavia: NAD Editorial - see rationale below]</i></p>




<p><b>Rationale:</b></p>Already fixed in working draft

<p><b>Proposed resolution:</b></p>
<p>
Add to 20.6.1 [ratio.ratio] synopsis
</p>

<blockquote><pre>template &lt;intmax_t N, intmax_t D = 1&gt;
class ratio {
public:
  static constexpr intmax_t num;
  static constexpr intmax_t den;

  typedef ratio<ins>&lt;num, den&gt;</ins> type;
};
</pre></blockquote>






<hr>
<h3><a name="1282"></a>1282. A proposal to add std::split algorithm</h3>
<p><b>Section:</b> 25 [algorithms] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Future">NAD Future</a>
 <b>Submitter:</b> Igor Semenov <b>Opened:</b> 2009-12-07 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#algorithms">issues</a> in [algorithms].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<ol type="I">

<li>
<p>
Motivation and Scope
</p>
<p>
Splitting strings into parts by some set of delimiters is an often task, but
there is no simple and generalized solution in C++ Standard. Usually C++
developers use <tt>std::basic_stringstream&lt;&gt;</tt> to split string into
parts, but there are several inconvenient restrictions:
</p>

<ul>
<li>
we cannot explicitly assign the set of delimiters;
</li>
<li>
this approach is suitable only for strings, but not for other types of
containers;
</li>
<li>
we have (possible) performance leak due to string instantiation.
</li>
</ul>
</li>

<li>
<p>
Impact on the Standard
</p>
<p>
This algorithm doesn't interfere with any of current standard algorithms.
</p>
</li>

<li>
<p>
Design Decisions
</p>
<p>
This algorithm is implemented in terms of input/output iterators. Also, there is
one additional wrapper for <tt>const CharType *</tt> specified delimiters.
</p>
</li>

<li>
<p>
Example implementation
</p>
<pre>template&lt; class It, class DelimIt, class OutIt &gt;
void split( It begin, It end, DelimIt d_begin, DelimIt d_end, OutIt out )
{
   while ( begin != end )
   {
       It it = std::find_first_of( begin, end, d_begin, d_end );
       *out++ = std::make_pair( begin, it );
       begin = std::find_first_of( it, end, d_begin, d_end,
           std::not2( std::equal_to&lt; typename It::value_type &gt;() ) );
   }
}

template&lt; class It, class CharType, class OutIt &gt;
void split( It begin, It end, const CharType * delim, OutIt out )
{
   split( begin, end, delim, delim + std::strlen( delim ), out );
}
</pre>
</li>

<li>
<p>
Usage
</p>
<pre>std::string ss( "word1 word2 word3" );
std::vector&lt; std::pair&lt; std::string::const_iterator, std::string::const_iterator &gt; &gt; v;
split( ss.begin(), ss.end(), " ", std::back_inserter( v ) );

for ( int i = 0; i &lt; v.size(); ++i )
{
   std::cout &lt;&lt; std::string( v[ i ].first, v[ i ].second ) &lt;&lt; std::endl;
}
// word1
// word2
// word3
</pre>
</li>

</ol>

<p><i>[
2010-01-22 Moved to Tentatively NAD Future after 5 positive votes on c++std-lib.
Rationale added below.
]</i></p>



<p><b>Rationale:</b></p>
<p>
The LWG is not considering completely new features for standardization at this
time.  We would like to revisit this good suggestion for a future TR and/or
standard.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add to the synopsis in 25.1 [algorithms.general]:
</p>

<blockquote><pre>template&lt; class ForwardIterator1, class ForwardIterator2, class OutputIterator &gt;
  void split( ForwardIterator1 first, ForwardIterator1 last,
              ForwardIterator2 delimiter_first, ForwardIterator2 delimiter_last,
              OutputIterator result );

template&lt; class ForwardIterator1, class CharType, class OutputIterator &gt;
  void split( ForwardIterator1 first, ForwardIterator1 last,
              const CharType * delimiters, OutputIterator result );
</pre></blockquote>

<p>
Add a new section [alg.split]:
</p>

<blockquote><pre>template&lt; class ForwardIterator1, class ForwardIterator2, class OutputIterator &gt;
  void split( ForwardIterator1 first, ForwardIterator1 last,
              ForwardIterator2 delimiter_first, ForwardIterator2 delimiter_last,
              OutputIterator result );
</pre>

<blockquote>
<p>
1. <i>Effects:</i> splits the range <tt>[first, last)</tt> into parts, using any
element of <tt>[delimiter_first, delimiter_last)</tt> as a delimiter. Results
are pushed to output iterator in the form of <tt>std::pair&lt;ForwardIterator1,
ForwardIterator1&gt;</tt>. Each of these pairs specifies a maximal subrange of
<tt>[first, last)</tt> which does not contain a delimiter.
</p>
<p>
2. <i>Returns:</i> nothing.
</p>
<p>
3. <i>Complexity:</i> Exactly <tt>last - first</tt> assignments.
</p>
</blockquote>

<pre>template&lt; class ForwardIterator1, class CharType, class OutputIterator &gt;
  void split( ForwardIterator1 first, ForwardIterator1 last,
              const CharType * delimiters, OutputIterator result );
</pre>

<blockquote>
<p>
1. <i>Effects:</i> split the range <tt>[first, last)</tt> into parts, using any
element of <tt>delimiters</tt> (interpreted as zero-terminated string) as a
delimiter. Results are pushed to output iterator in the form of
<tt>std::pair&lt;ForwardIterator1, ForwardIterator1&gt;</tt>. Each of these
pairs specifies a maximal subrange of <tt>[first, last)</tt> which does not
contain a delimiter.
</p>
<p>
2. <i>Returns:</i> nothing.
</p>
<p>
3. <i>Complexity:</i> Exactly <tt>last - first</tt> assignments.
</p>
</blockquote>

</blockquote>





<hr>
<h3><a name="1289"></a>1289. Generic casting requirements for smart pointers</h3>
<p><b>Section:</b> 20.3 [utility] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Future">NAD Future</a>
 <b>Submitter:</b> Ion Gaztaaga <b>Opened:</b> 2009-12-14 <b>Last modified:</b> 2010-11-24</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#utility">issues</a> in [utility].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In section 20.2.5 [allocator.requirements], Table 40  Allocator requirements,
the following expression is required for allocator pointers:
</p>

<blockquote>
<table border="1">
<caption>Table 40  Allocator requirements</caption>
<tbody><tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion/note<br>pre-/post-condition</th>
<th>Default</th>
</tr>
<tr>
<td><tt>static_cast&lt;X::pointer&gt;(w)</tt></td>
<td><tt>X::pointer</tt></td>
<td><tt>static_cast&lt;X::pointer&gt;(w) == p</tt></td>
<td>&nbsp;</td>
</tr>
</tbody></table>
</blockquote>

<p>
To achieve this expression, a smart pointer writer must introduce an explicit
conversion operator from <tt>smart_ptr&lt;void&gt;</tt> to
<tt>smart_ptr&lt;T&gt;</tt> so that
<tt>static_cast&lt;pointer&gt;(void_ptr)</tt> is a valid expression.
Unfortunately this explicit conversion weakens the safety of a smart pointer
since the following expression (invalid for raw pointers) would become valid:
</p>

<blockquote><pre>smart_ptr&lt;void&gt; smart_v = ...;
smart_ptr&lt;T&gt; smart_t(smart_v);
</pre></blockquote>

<p>
On the other hand, <tt>shared_ptr</tt> also defines its own casting functions in
20.9.10.2.10 [util.smartptr.shared.cast], and although it's unlikely that a
programmer will use <tt>shared_ptr</tt> as <tt>allocator::pointer</tt>, having
two different ways to do the same cast operation does not seem reasonable. A
possible solution would be to replace <tt>static_cast&lt;X::pointer&gt;(w)</tt>
expression with a user customizable (via ADL)
<tt>static_pointer_cast&lt;value_type&gt;(w)</tt>, and establish the
<tt>xxx_pointer_cast</tt> functions introduced by <tt>shared_ptr</tt> as the
recommended generic casting utilities of the standard.
</p>

<p>
Unfortunately, we've experienced problems in Boost when trying to establish
<tt>xxx_pointer_cast</tt> as customization points for generic libraries (<a href="http://objectmix.com/c/40424-adl-lookup-explicit-template-parameters.html">http://objectmix.com/c/40424-adl-lookup-explicit-template-parameters.html</a>)
because these casting functions are called with explicit template parameters and
the standard says in 14.8.1 [temp.arg.explicit] p.8 "Explicit template
argument specification":
</p>

<blockquote>
8 ...But when a function template with explicit template arguments is used, the
call does not have the correct syntactic form unless there is a function
template with that name visible at the point of the call. If no such name is
visible, the call is not syntactically well-formed and argument-dependent lookup
does not apply.
</blockquote>

<p>
So we can do this:
</p>

<blockquote><pre>template&lt;class BasePtr&gt;
void generic_ptr_swap(BasePtr p)
{
  //ADL customization point
  swap(p, p);
  //...
}
</pre></blockquote>

<p>
but not the following:
</p>

<blockquote><pre>template&lt;class BasePtr&gt;
void generic_ptr_algo(BasePtr p)
{
  typedef std::pointer_traits&lt;BasePtr&gt;::template
     rebind&lt;Derived&gt; DerivedPtr;
  DerivedPtr dp = static_pointer_cast&lt;Derived&gt;(p);
}
</pre></blockquote>

<p>
The solution to make <tt>static_pointer_cast</tt> a customization point is to
add a generic declaration (no definition) of <tt>static_pointer_cast</tt> in a
namespace (like <tt>std</tt>) and apply "<tt>using
std::static_pointer_cast</tt>" declaration to activate ADL:
</p>

<blockquote><pre>namespace std{

template&lt;typename U, typename T&gt;
<i>unspecified</i>
static_pointer_cast(T&amp;&amp;) = delete;

}

template&lt;class BasePtr&gt;
void generic_ptr_algo(BasePtr p)
{
  typedef std::pointer_traits&lt;BasePtr&gt;::template
     rebind&lt;Derived&gt; DerivedPtr;

  //ADL applies because static_pointer_cast is made
  //  visible according to [temp.arg.explicit]/8
  using std::static_pointer_cast;

  DerivedPtr dp = static_pointer_cast&lt;Derived&gt;(p);

  //...
}
</pre></blockquote>

<p>
A complete solution will need also the definition of
<tt>static_pointer_cast</tt> for raw pointers, and this definition has been
present in Boost (<a href="http://www.boost.org/boost/pointer_cast.hpp">http://www.boost.org/boost/
pointer_cast.hpp</a>) for years.
</p>

<p><i>[
2010-03-26 Daniel made editorial adjustments to the proposed wording.
]</i></p>


<p><i>[
Moved to NAD Future at 2010-11 Batavia
]</i></p>

<blockquote>
This is a new feature rather than a defect. 
It can be added later: "this is such a hairy area that people will put up with changes"
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add to section 20.3 [utility] Utility components, Header
<tt>&lt;utility&gt;</tt> synopsis:
</p>

<blockquote><pre>// 20.3.X, generic pointer cast functions

template&lt;typename U, typename T&gt;
<i>unspecified</i>
static_pointer_cast(T&amp;&amp;) = delete;

template&lt;typename U, typename T&gt;
<i>unspecified</i>
dynamic_pointer_cast(T&amp;&amp;) = delete;

template&lt;typename U, typename T&gt;
<i>unspecified</i>
const_pointer_cast(T&amp;&amp;) = delete;

//Overloads for raw pointers
template&lt;typename U, typename T&gt;
auto static_pointer_cast(T* t) -&gt; decltype(static_cast&lt;U*&gt;(t));

template&lt;typename U, typename T&gt;
auto dynamic_pointer_cast(T* t) -&gt; decltype(dynamic_cast&lt;U*&gt;(t));

template&lt;typename U, typename T&gt;
auto const_pointer_cast(T* t) -&gt; decltype(const_cast&lt;U*&gt;(t));
</pre></blockquote>

<p>
Add to section 20.3 [utility] Utility components, a new subclause
20.3.X Pointer cast utilities [pointer.cast]:
</p>

<blockquote>
<p>
20.3.X Pointer cast utilities [pointer.cast]
</p>

<p>
1 The library defines generic pointer casting function templates so that template code
can explicitly make these names visible and activate argument-dependent lookup
for pointer cast calls.
</p>

<pre>//Generic declarations
template&lt;typename U, typename T&gt;
<i>unspecified</i>
static_pointer_cast(T&amp;&amp;) = delete;

template&lt;typename U, typename T&gt;
<i>unspecified</i>
dynamic_pointer_cast(T&amp;&amp;) = delete;

template&lt;typename U, typename T&gt;
<i>unspecified</i>
const_pointer_cast(T&amp;&amp;) = delete;
</pre>

<p>
2 The library also defines overloads of these functions for raw pointers.
</p>

<pre>//Overloads for raw pointers
template&lt;typename U, typename T&gt;
auto static_pointer_cast(T* t) -&gt; decltype(static_cast&lt;U*&gt;(t));
</pre>

<blockquote>
<i>Returns:</i> <tt>static_cast&lt;U*&gt;(t)</tt>
</blockquote>

<pre>template&lt;typename U, typename T&gt;
auto dynamic_pointer_cast(T* t) -&gt; decltype(dynamic_cast&lt;U*&gt;(t));
</pre>

<blockquote>
<i>Returns:</i> <tt>dynamic_cast&lt;U*&gt;(t)</tt>
</blockquote>

<pre>template&lt;typename U, typename T&gt;
auto const_pointer_cast(T* t) -&gt; decltype(const_cast&lt;U*&gt;(t));
</pre>

<blockquote>
<i>Returns:</i> <tt>const_cast&lt;U*&gt;(t)</tt>
</blockquote>

<p>
[<i>Example:</i>
</p>

<blockquote><pre>#include &lt;utility&gt; //static_pointer_cast
#include &lt;memory&gt;  //pointer_traits

class Base{};
class Derived : public Base{};

template&lt;class BasePtr&gt;
void generic_pointer_code(BasePtr b)
{
   typedef std::pointer_traits&lt;BasePtr&gt;::template
      rebind&lt;Derived&gt; DerivedPtr;

   using std::static_pointer_cast;
   //ADL applies now that static_pointer_cast is visible
   DerivedPtr d = static_pointer_cast&lt;Derived&gt;(b);
}
</pre></blockquote>

<p>
 <i>end example</i>]
</p>

</blockquote>

<p>
Replace in section 20.2.5 [allocator.requirements] Table 40  Allocator
requirements, the following table entries for allocator pointers:
</p>

<blockquote>
<table border="1">
<caption>Table 40  Allocator requirements</caption>
<tbody><tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion/note<br>pre-/post-condition</th>
<th>Default</th>
</tr>

<tr>
<td><tt>static<ins>_pointer</ins>_cast&lt;<del>X::pointer</del><ins>T</ins>&gt;(w)</tt></td>
<td><tt>X::pointer</tt></td>
<td><tt>static<ins>_pointer</ins>_cast&lt;<del>X::pointer</del><ins>T</ins>&gt;(w) == p</tt></td>
<td>&nbsp;</td>
</tr>

<tr>
<td><tt>static<ins>_pointer</ins>_cast&lt;<del>X::const_pointer</del><ins>const T</ins>&gt;(w)</tt></td>
<td><tt>X::const_pointer</tt></td>
<td><tt>static<ins>_pointer</ins>_cast&lt;<del>X::const_pointer</del><ins>const T</ins>&gt;(z) == q</tt></td>
<td>&nbsp;</td>
</tr>

</tbody></table>
</blockquote>






<hr>
<h3><a name="1291"></a>1291. exceptions thrown during <tt>promise::set_value</tt></h3>
<p><b>Section:</b> 30.6.5 [futures.promise] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2009-12-18 <b>Last modified:</b> 2010-10-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#futures.promise">active issues</a> in [futures.promise].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#futures.promise">issues</a> in [futures.promise].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 30.6.5 [futures.promise]
</p>

<p>
Does <tt>promise&lt;R&gt;::set_value</tt> return normally if the copy/move
constructor of <tt>R</tt> throws?
</p>

<p>
The exception could be caught and set using
<tt>promise&lt;R&gt;::set_exception</tt>, or it could be allowed to leave the
<tt>set_value</tt> call, but it's not clear which is intended. I suggest the
exception should not be caught.
</p>

<p>
N.B. This doesn't apply to <tt>promise&lt;R&amp;&gt;::set_value</tt> or
<tt>promise&lt;void&gt;::set_value</tt> because they don't construct a new
object.
</p>

<p><i>[
2010 Pittsburgh:  Moved to NAD Editorial.  Rationale added below.
]</i></p>




<p><b>Rationale:</b></p>
<p>
Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3058.html">N3058</a>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 30.6.5 [futures.promise]/18:
</p>

<blockquote>
18 <i>Throws:</i> <tt>future_error</tt> if its associated state is already
ready<ins> or, for the first version an exception thrown by the copy constructor
of <tt>R</tt>, or for the second version an exception thrown by the move
constructor of <tt>R</tt></ins>.
</blockquote>





<hr>
<h3><a name="1296"></a>1296. <tt>map</tt> and <tt>multimap value_compare</tt> overspecified</h3>
<p><b>Section:</b> 23.6.1 [map] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-12-22 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#map">issues</a> in [map].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The container class templates <tt>map</tt> and <tt>multimap</tt> both contain a
nested type called <tt>value_compare</tt>, that is used to compare the
<tt>value_type pair</tt> elements, an adaptor of the user-supplied comparison
function-like object.
</p>

<p>
I believe these types are over-specified, as we require a distinct type for each
template, even though the allocator plays no part in the comparator, and
<tt>map</tt> and <tt>multimap value_compare</tt> classes could easily be shared.
 The benefits are similar to the SCARY iterator proposal (although on a much
smaller scale!) but unlike SCARY, this is not a QoI issue today but actively
prohibited.
</p>

<p>
If the <tt>value_compare</tt> classes were marked 'exposition only', a vendor
would be free to experiment with implementations that do not produce so many
template instantiations with negligible impact on conforming programs.  (There
is a minor risk that programs could no longer portably overload functions taking
<tt>value_compare</tt> types.  This scenario is extremely unlikely outside
conformance suites.)
</p>

<p>
(Note that there are no similar problems for unordered maps, nor any of the set
variants)
</p>

<p><i>[
2010-01-31 Moved to Tentatively NAD after 5 positive votes on c++std-lib.
Rationale added below.
]</i></p>


<p><b>Rationale:</b></p>
<p>
The <tt>value_compare</tt> specification is an unfortunate bit from the past
that we have to live with.  Fortunately vendors can work around the problems
mentioned in this issue.
</p>




<p><b>Proposed resolution:</b></p>
<p>
p2 23.6.1 [map]:
Above the declaration of class <tt>value_compare</tt> in the map synopsis, add:
</p>

<blockquote><pre>template &lt;class Key, class T, class Compare = less&lt;Key&gt;,
          class Allocator = allocator&lt;pair&lt;const Key, T&gt; &gt; &gt;
class map {
public:
  // types:
  ...
  <ins>// exposition only.</ins>
  class value_compare
    : public binary_function&lt;value_type,value_type,bool&gt; {
    ...
</pre></blockquote>



<p>
p2 23.6.2 [multimap]:
Above the declaration of class <tt>value_compare</tt> in the map synopsis, add:
</p>

<blockquote><pre>template &lt;class Key, class T, class Compare = less&lt;Key&gt;,
          class Allocator = allocator&lt;pair&lt;const Key, T&gt; &gt; &gt;
class multimap {
public:
  // types:
  ...
  <ins>// exposition only.</ins>
  class value_compare
    : public binary_function&lt;value_type,value_type,bool&gt; {
    ...
</pre></blockquote>





<hr>
<h3><a name="1300"></a>1300. circular definition of <tt>promise::swap</tt></h3>
<p><b>Section:</b> 30.6.5 [futures.promise] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2009-12-26 <b>Last modified:</b> 2010-10-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#futures.promise">active issues</a> in [futures.promise].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#futures.promise">issues</a> in [futures.promise].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
30.6.5 [futures.promise]/12 defines the effects of
<tt>promise::swap(promise&amp;)</tt> as
</p>

<blockquote><pre>void swap(promise&amp; other);
</pre>
<blockquote>
12 <i>Effects:</i> <tt>swap(*this, other)</tt>
</blockquote>
</blockquote>

<p>
and 30.6.5 [futures.promise]/25 defines <tt>swap(promise&lt;R&amp;&gt;,
promise&lt;R&gt;&amp;)</tt> as
</p>

<blockquote><pre>template &lt;class R&gt;
  void swap(promise&lt;R&gt;&amp; x, promise&lt;R&gt;&amp; y);
</pre>
<blockquote>
25 <i>Effects:</i> <tt>x.swap(y)</tt>.
</blockquote>
</blockquote>

<p><i>[
2010-01-13 Daniel added "Throws: Nothing."
]</i></p>


<p><i>[
2010-01-14 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>


<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote>
Moved to NAD Editorial.  Rationale added below.
</blockquote>



<p><b>Rationale:</b></p>
<p>
Solved by N3058.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change 30.6.5 [futures.promise] paragraph 12
</p>

<blockquote><pre>void swap(promise&amp; other);
</pre>
<blockquote>
<p>
12 <i>Effects:</i> <del><tt>swap(*this, other)</tt></del> <ins>Exchanges the
associated
states of <tt>*this</tt> and <tt>other</tt>.</ins>
</p>
<p>
13 ...
</p>
<p><ins>
<i>Throws:</i> Nothing.
</ins></p>
</blockquote>
</blockquote>






<hr>
<h3><a name="1301"></a>1301. <tt>clear()</tt> and assignment</h3>
<p><b>Section:</b> 23.2.3 [sequence.reqmts] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Nicolai Josuttis <b>Opened:</b> 2010-01-01 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#sequence.reqmts">issues</a> in [sequence.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I propose that <tt>clear()</tt> be defined to be equivalent to
<tt>erase(begin(),end())</tt> except not using copy or move of elements.
</p>

<blockquote>
<p>
To: C++ libraries mailing list<br>
Message c++std-lib-26465
</p>

<p>
and specifiying as post: <tt>size()==0</tt> might also not be appropriate
because forward-Lists provide no <tt>size()</tt>, this it should be:
post: <tt>empty()==true</tt>
</p>

<p>
Bjarne Stroustrup schrieb/wrote:
</p>

<blockquote>
<p>
To: C++ libraries mailing list<br>
Message c++std-lib-26458
</p>

<p>
in table 94 we define <tt>clear()</tt> as:
</p>

<blockquote><pre>a.clear() void erase(begin(), end())
post: size() == 0
</pre></blockquote>

<p>
Now <tt>erase</tt> requires assignment (<tt>MoveAssignable</tt>) which makes
sense if we have to move an element, but why should that be required from
<tt>clear()</tt> where all elements are destroyed?
</p>
</blockquote>
</blockquote>

<p><i>[
2010-01-23 Alisdiar provides wording.
]</i></p>


<p><i>[
2010-01-30 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>


<p><i>[
2010-01-30 Daniel opens:
]</i></p>


<blockquote>
<p>
First, I read the newly proposed spec for <tt>clear()</tt> that it does in
general <em>not</em> invalidate a previous past-the-end iterator value, but
<tt>deque</tt> says in 23.3.2.3 [deque.modifiers] for the semantics of
<tt>erase</tt> that erasures at the end will invalidate the past-the-end
iterator. With removal of a direct binding between <tt>clear()</tt> and
<tt>erase()</tt> there seem to be some fixes necessary. One way to fix that
would be to mention in Table 94 that this "may also invalidate the past-the-end
iterator" and then to mention for all specific containers where this does not
happen, the exception, [1] e.g. in <tt>std::vector</tt>. <tt>std::vector</tt>
has no own specification of <tt>clear()</tt> and one aspect of the closed issue
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1102">1102</a> was to realize just that (indirectly via <tt>erase</tt>). IMO
we should now add an extra specification for <tt>clear()</tt>. Btw.:
<tt>std::vector::erase</tt> reads to me that it would invalidate previous
past-the-end values (and that seems correct in general).
</p>
<p>
Before I will provide explicit wording, I would like to
discuss these points.
</p>

<p>
[1] <tt>std::list</tt> does fortunately specify that clear does not invalidate
the past-the-end iterator.
</p>
</blockquote>

<p><i>[
2010-02-08 Moved to Tentatively NAD Editorial after 5 positive votes on c++std-lib.
Rationale added below.
]</i></p>




<p><b>Rationale:</b></p>
<p>
Solved as proposed by LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#704">704</a>.
</p>


<p><b>Proposed resolution:</b></p>

<p>
Change 23.2.1 [container.requirements.general]/10:
</p>

<blockquote>
<p>
Unless otherwise specified (see 23.2.4.1, 23.2.5.1, 23.3.2.3, and 23.3.6.4) all
container types defined in this Clause meet the following additional
requirements:
</p>

<ul>
<li>
..
</li>

<li>
no <tt>erase()</tt>, <ins><tt>clear()</tt>,</ins> <tt>pop_back()</tt> or
<tt>pop_front()</tt> function throws an exception.
</li>

<li>
...
</li>
</ul>

</blockquote>

<p>
Replace the following words from Table 94  Sequence container
requirements (in addition to container) in 23.2.3 [sequence.reqmts]:
</p>

<blockquote>
<table border="1">
<caption>Table 94  Sequence container requirements (in addition to
container)</caption>
<tbody><tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion/note<br>pre-/post-condition</th>
</tr>

<tr>
<td><tt>a.clear()</tt></td>
<td><tt>void</tt></td>
<td><del><tt>erase(begin(), end())</tt></del><br>
<ins>Destroys all elements in the container a. Invalidates all references,
pointers, and iterators referring to the elements of <tt>a</tt> and may
invalidate the past-the-end iterator.</ins><br>
post: <tt><del>size() == 0</del> <ins>a.empty() == true</ins></tt>.  </td>
</tr>
</tbody></table>
</blockquote>

<p>
Add a new paragraph after 23.3.3.4 [forwardlist.modifiers]/23:
</p>

<blockquote><pre>void clear();
</pre>

<blockquote>
<p>
23 <i>Effects:</i> Erases all elements in the range <tt>[begin(),end())</tt>.
</p>
<p><ins>
<i>Remarks:</i> Does not invalidate past-the-end iterators.
</ins></p>
</blockquote>
</blockquote>






<hr>
<h3><a name="1302"></a>1302. different <tt>emplace</tt> semantics for sequence and associated containers</h3>
<p><b>Section:</b> 23.2.4 [associative.reqmts], 23.2.5 [unord.req] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Nicolai Josuttis <b>Opened:</b> 2010-01-03 <b>Last modified:</b> 2010-10-23</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
According to the new naming scheme introduced with
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2680.pdf">N2680</a>
</p>

<blockquote><pre>vector&lt;T&gt; v;
v.emplace(v.begin(),x,y,z)
</pre></blockquote>

<p>
now has a different semantics than
</p>

<blockquote><pre>set&lt;T&gt; s;
s.emplace(s.begin(),x,y,z);
</pre></blockquote>

<p>
While the version for <tt>vector</tt>s takes the first argument as position and
the remaining for construction, the version for <tt>set</tt>s takes all
arguments for construction.
</p>

<p>
IMO, this is a serious design mistake for a couple of reasons:
</p>

<ul>
<li>
<p>
First, in principle, all STL member functions should have the same behavior with
the same member function to avoid confusion and allow to write proper generic
code.
</p>
<p>
In fact, when I write the following simple function template:
</p>
<blockquote><pre>template &lt;typename T&gt;
void doEmplace (T&amp; cont)
{
   cont.emplace(cont.begin(),"nico","josuttis",42);
}
</pre></blockquote>
<p>
the semantics depends on the type of the container.
</p>
</li>
<li>
<p>
In addition, I also guess using the name <tt>emplace_hint()</tt> instead of
<tt>emplace()</tt> for associative containers is a design mistake. According to
my knowledge, it was a design goal of the original STL to provide ONE
<tt>insert</tt> function, which works for ALL containers. This was
<tt>insert(pos,val)</tt>.
</p>
<p>
The trick to declare <tt>pos</tt> as a hint, allowed that we could implement a
generic <tt>insert</tt> for all containers. Now, with the new <tt>emplace</tt>
naming scheme, this trick is gone for the new kind of insertion.
</p>
</li>
</ul>

<p>
I consider this to be a serious design penalty because once this
is specified we can't fix that without breaking backward compatibility.
</p>

<p>
However, we have two choices for a fix:
</p>

<ul>
<li>
rename <tt>emplace_hint(pos,val)</tt> for associative containers back to
<tt>emplace(pos,val)</tt>. However to avoid the overloading problems, we also
have to rename the existing <tt>emplace(val)</tt> functions to something else (I
don't have a good name here at hand).
</li>
<li>
Keep <tt>emplace(val)</tt> for associative containers as it is, but rename
<tt>emplace(pos,val)</tt> for sequence containers and
<tt>emplace_hint(pos,val)</tt> to something like <tt>emplace_at(pos,val)</tt>,
declaring that <tt>pos</tt> is a hint for associative containers.
</li>
</ul>

<p><i>[
2010 Pittsburgh:  Moved to NAD, rationale added below.
]</i></p>




<p><b>Rationale:</b></p>
<p>
There was no consensus to make this change.
</p>


<p><b>Proposed resolution:</b></p>
<p> In 23.2.5 [unord.req], change: </p>
<blockquote> 
  <table border="1">
    <caption>Table 96  Associative container requirements (in addition to 
    container)</caption>
    <tbody><tr> 
      <th>expression</th>
      <th>Return type</th>
      <th>Assertion/note pre-/post-condition</th>
      <th>Post-condition</th>
    </tr>
    <tr> 
      <td colspan="4">...</td>
    </tr>
    <tr> 
      <td><tt>a_uniq.emplace<ins>_value</ins>(args)</tt></td>
      <td><tt>pair&lt;iterator, bool&gt;</tt></td>
      <td>inserts a T object t constructed with std::forward&lt;Args&gt;(args)...<br>
        if and only if there is no element in the container with key equivalent 
        to the key of t.<br>
        The bool component of the returned pair is true if and only if the insertion 
        takes place, and the iterator component of the pair points to the element 
        with key equivalent to the key of t.</td>
      <td>logarithmic</td>
    </tr>
    <tr> 
      <td><tt>a_eq.emplace<ins>_value</ins>(args)</tt></td>
      <td><tt>iterator</tt></td>
      <td>inserts a T object t constructed with std::forward&lt;Args&gt;(args)... 
        and returns the iterator pointing to the newly inserted element.</td>
      <td>logarithmic</td>
    </tr>
    <tr> 
      <td><tt>a.emplace<del>_hint</del>(p,args)</tt></td>
      <td><tt>iterator</tt></td>
      <td>equivalent to
      <tt>a.emplace<ins>_value</ins>(std::forward&lt;Args&gt;(args)...)</tt>.
      Return value is an iterator pointing to the element with the key
      equivalent to the newly inserted element. The const_iterator p is a hint
      pointing to where the search should start. Implementations are permitted
      to ignore the hint.</td> <td>logarithmic in general, but amortized
      constant if the element is inserted right after p</td>
    </tr>
    <tr> 
      <td colspan="4">... </td>
    </tr>
  </tbody></table>
  
</blockquote>
<p> In 23.2.5 [unord.req], change: </p>
<blockquote>
  <table border="1">
    <caption>Table 98  Unordered associative container requirements (in 
    addition to container)</caption>
    <tbody><tr> 
      <th>expression</th>
      <th>Return type</th>
      <th>Assertion/note pre-/post-condition</th>
      <th>Post-condition</th>
    </tr>
    <tr> 
      <td colspan="4">...</td>
    </tr>
    <tr> 
      <td><tt>a_uniq.emplace<ins>_value</ins>(args)</tt></td>
      <td><tt>pair&lt;iterator, bool&gt;</tt></td>
      <td>inserts a <tt>T</tt> object <tt>t</tt> constructed with <tt>std::forward&lt;Args&gt;(args)...</tt> if 
        and only if there is no element in the container with key equivalent to 
        the key of <tt>t</tt>. The bool component of the returned pair is true if and only 
        if the insertion takes place, and the iterator component of the pair points 
        to the element with key equivalent to the key of t.</td>
      <td>Average case O(1), worst case O(a_uniq.size()).</td>
    </tr>
    <tr> 
      <td><tt>a_eq.emplace<ins>_value</ins>(args)</tt></td>
      <td><tt>iterator</tt></td>
      <td>inserts a T object t constructed with std::forward&lt;Args&gt;(args)... 
        and returns the iterator pointing to the newly inserted element.</td>
      <td>Average case O(1), worst case O(a_eq.size()).</td>
    </tr>
    <tr> 
      <td><tt>a.emplace<del>_hint</del>(p,args)</tt></td>
      <td><tt>iterator</tt></td>
      <td>equivalent to
      <tt>a.emplace<ins>_value</ins>(std::forward&lt;Args&gt;(args)...)</tt>.
      Return value is an iterator pointing to the element with the key
      equivalent to the newly inserted element. The const_iterator p is a hint
      pointing to where the search should start. Implementations are permitted
      to ignore the hint.</td> <td>Average case O(1), worst case
      O(a.size()).</td>
    </tr>
    <tr> 
      <td colspan="4">... </td>
    </tr>
  </tbody></table>
</blockquote>

<p>
In 23.6.1 [map], 23.6.3 [set], 23.7.1 [unord.map], 23.7.3 [unord.set], change:
</p>
<blockquote> 
  <p><i>// modifiers:</i><br>
    <tt>template &lt;class... Args&gt; pair&lt;iterator, bool&gt; emplace<ins>_value</ins>(Args&amp;&amp;... 
    args);<br>
    template &lt;class... Args&gt; iterator emplace<del>_hint</del>(const_iterator 
    position, Args&amp;&amp;... args);</tt></p>
</blockquote>

<p>
In 23.6.2 [multimap], 23.6.4 [multiset], 23.7.2 [unord.multimap], 23.7.4 [unord.multiset], change:
</p>
<blockquote> 
  <p><i>// modifiers:<br></i><tt>template &lt;class... Args&gt; iterator emplace<ins>_value</ins>(Args&amp;&amp;... 
    args);<br>
    template &lt;class... Args&gt; iterator emplace<del>_hint</del>(const_iterator position, 
    Args&amp;&amp;... args);<br>
    </tt> </p>
</blockquote>





<hr>
<h3><a name="1304"></a>1304. missing preconditions for <tt>shared_future</tt></h3>
<p><b>Section:</b> 30.6.7 [futures.shared_future] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2010-01-23 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#futures.shared_future">issues</a> in [futures.shared_future].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The revised futures package in the current working paper simplified the
<tt>is_ready/has_exception/has_value</tt> set of APIs, replacing them with a
single 'valid' method.  This method is used in many places to signal pre- and
post- conditions, but that edit is not complete.  Each method on a
<tt>shared_future</tt> that requires an associated state should have a
pre-condition that <tt>valid() == true</tt>.
</p>

<p><i>[
2010-01-28 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>


<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote>
Moved to NAD Editorial.  Rationale added below.
</blockquote>



<p><b>Rationale:</b></p>
<p>
Solved by N3058.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Insert the following extra paragraphs:
</p>

<p>
In 30.6.7 [futures.shared_future]
</p>

<blockquote><pre>shared_future();
</pre>
<blockquote>
<p>
4 <i>Effects:</i> constructs ...
</p>

<p><ins>
<i>Postcondition:</i> <tt>valid() == false</tt>.
</ins></p>

<p><ins>
<i>Throws:</i> nothing.
</ins></p>
</blockquote>
</blockquote>

<blockquote><pre>void wait() const;
</pre>
<blockquote>

<p><ins>
<i>Requires:</i> <tt>valid() == true</tt>.
</ins></p>

<p>
22 <i>Effects:</i> if the associated ...
</p>
</blockquote>
</blockquote>

<blockquote><pre>template &lt;class Rep, class Period&gt;
  bool wait_for(const chrono::duration&lt;Rep, Period&gt;&amp; rel_time) const;
</pre>
<blockquote>

<p><ins>
<i>Requires:</i> <tt>valid() == true</tt>.
</ins></p>

<p>
23 <i>Effects:</i> if the associated ...
</p>
</blockquote>
</blockquote>

<blockquote><pre>template &lt;class Clock, class Duration&gt;
  bool wait_until(const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time) const;
</pre>
<blockquote>

<p><ins>
<i>Requires:</i> <tt>valid() == true</tt>.
</ins></p>

<p>
25 <i>Effects:</i> blocks until ...
</p>
</blockquote>
</blockquote>






<hr>
<h3><a name="1305"></a>1305. preconditions for <tt>atomic_future</tt></h3>
<p><b>Section:</b> 30.6.8 [futures.atomic_future] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2010-01-23 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#futures.atomic_future">issues</a> in [futures.atomic_future].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The revised futures package in the current working paper simplified the
<tt>is_ready/has_exception/has_value</tt> set of APIs, replacing them with a
single 'valid' method.  This method is used in many places to signal pre- and
post- conditions, but that edit is not complete.  
</p>

<p>
Atomic future retains the extended earlier API, and provides defined,
synchronized behaviour for all calls.  However, some preconditions and throws
clauses are missing, which can easily be built around the new <tt>valid()</tt>
api.  Note that for consistency, I suggest <tt>is_ready/has_exception/has_value
throw</tt> an exception if <tt>valid()</tt> is not <tt>true</tt>, rather than
return <tt>false</tt>.  I think this is implied by the existing pre-condition on
<tt>is_ready</tt>.
</p>

<p><i>[
2010-01-23 See discussion starting with Message c++std-lib-26666.
]</i></p>


<p><i>[
2010 Pittsburgh:  Moved to NAD Editorial.  Rationale added below.
]</i></p>




<p><b>Rationale:</b></p>
<p>
Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3058.html">N3058</a>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Insert the following extra paragraphs:
</p>

<p>
In 30.6.8 [futures.atomic_future]
</p>

<blockquote><pre>bool is_ready() const;
</pre>
<blockquote>
<p>
17 <i><del>Precondition</del> <ins>Requires</ins>:</i> <tt>valid() == true</tt>.
</p>

<p>
18 <i>Returns:</i> <tt>true</tt> only if the associated state is ready.
</p>

<p><ins>
<i>Throws:</i> <tt>future_error</tt> with an error condition of
<tt>no_state</tt> if the precondition is not met.
</ins></p>

</blockquote>
</blockquote>

<blockquote><pre>bool has_exception() const;
</pre>
<blockquote>

<p><ins>
<i>Requires:</i> <tt>valid() == true</tt>.
</ins></p>

<p>
19 <i>Returns:</i> <tt>true</tt> only if the associated state is ready and
contains an exception.
</p>

<p><ins>
<i>Throws:</i> <tt>future_error</tt> with an error condition of
<tt>no_state</tt> if the precondition is not met.
</ins></p>

</blockquote>
</blockquote>

<blockquote><pre>bool has_value() const;
</pre>
<blockquote>

<p><ins>
<i>Requires:</i> <tt>valid() == true</tt>.
</ins></p>

<p>
20 <i>Returns:</i> <tt>true</tt> only if the associated state is ready and
contains a value.
</p>

<p><ins>
<i>Throws:</i> <tt>future_error</tt> with an error condition of
<tt>no_state</tt> if the precondition is not met.
</ins></p>

</blockquote>
</blockquote>

<blockquote><pre>void wait() const;
</pre>
<blockquote>

<p><ins>
<i>Requires:</i> <tt>valid() == true</tt>.
</ins></p>

<p>
22 <i>Effects:</i> blocks until ...
</p>

<p><ins>
<i>Throws:</i> <tt>future_error</tt> with an error condition of
<tt>no_state</tt> if the precondition is not met.
</ins></p>

</blockquote>
</blockquote>

<blockquote><pre>template &lt;class Rep, class Period&gt;
  bool wait_for(const chrono::duration&lt;Rep, Period&gt;&amp; rel_time) const;
</pre>
<blockquote>

<p><ins>
<i>Requires:</i> <tt>valid() == true</tt>.
</ins></p>

<p>
23 <i>Effects:</i> blocks until ...
</p>

<p>
24 <i>Returns:</i> <tt>true</tt> only if ...
</p>

<p><ins>
<i>Throws:</i> <tt>future_error</tt> with an error condition of
<tt>no_state</tt> if the precondition is not met.
</ins></p>

</blockquote>
</blockquote>

<blockquote><pre>template &lt;class Clock, class Duration&gt;
  bool wait_until(const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time) const;
</pre>
<blockquote>

<p><ins>
<i>Requires:</i> <tt>valid() == true</tt>.
</ins></p>

<p>
25 <i>Effects:</i> blocks until ...
</p>

<p>
26 <i>Returns:</i> <tt>true</tt> only if ...
</p>

<p><ins>
<i>Throws:</i> <tt>future_error</tt> with an error condition of
<tt>no_state</tt> if the precondition is not met.
</ins></p>

</blockquote>
</blockquote>






<hr>
<h3><a name="1308"></a>1308. Concerns about <tt>initializer_list</tt> overloads of <tt>min</tt>,
<tt>max</tt>, and <tt>minmax</tt></h3>
<p><b>Section:</b> 25.4.7 [alg.min.max] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Niels Dekker <b>Opened:</b> 2010-02-02 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.min.max">issues</a> in [alg.min.max].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In San Francisco, June 2008, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2722.pdf">N2722</a>
was adopted, replacing the variadic templates <tt>min</tt>, <tt>max</tt>, and
<tt>minmax</tt> by overloads that have an <tt>initializer_list&lt;T&gt;</tt>
parameter. The paper showed benchmark results wherein <tt>initializer_list</tt>
versions of <tt>min</tt> appeared to outperform the corresponding variadic
template. Unfortunately, in October 2009 a very serious error was detected in
the benchmark. (<a href="http://accu.org/cgi-bin/wg21/message?wg=lib&msg=25210">c++std-lib-25210</a>).
In fact, an <tt>initializer_list&lt;T&gt;</tt> version of <tt>min</tt> often
appears to perform <i>worse</i> than the corresponding variadic template,
especially when <tt>T</tt> has an expensive copy constructor (<a href="http://accu.org/cgi-bin/wg21/message?wg=lib&msg=25253">c++std-lib-25253</a>,
<a href="http://www.xs4all.nl/~nd/dekkerware/issues/n2772_fix">http://www.xs4all.nl/~nd/dekkerware/issues/n2772_fix</a>).
</p>
<p>
IMO, the biggest problem of the <tt>initializer_list</tt> overloads is that they
pass and return <tt>T</tt> objects <i>by value</i>. Which has the following
consequences:
</p>

<ol>
<li>
They require that <tt>T</tt> is CopyConstructible. IMO that is too much of a
constraint for a generic, general purpose function like
<tt>std::min&lt;T&gt;</tt>.
</li>
<li>
They potentially throw an exception, even if <tt>T</tt>'s less-than-operator
throws nothing. (And of course, less-than typically throws nothing.)
</li>
<li>
They are inconsistent with C++03 std::<tt>min</tt> and std::<tt>max</tt>.
Consider the subtle difference between <tt>const T&amp; c1 = min(a,b);</tt> and
<tt>const T&amp; c2 = min({a,b});</tt> (<a href="http://accu.org/cgi-bin/wg21/message?wg=lib&msg=25265">c++std-lib-25265</a>)
</li>
<li>
They do not conveniently support use cases that need to have a reference to the
minimum or maximum object <i>itself</i>, rather than just a copy.
</li>
<li>
They potentially perform badly: possibly <i>O(n)</i>, when the arguments
themselves have a size of <i>n</i>.
</li>
</ol>

<p>
In the future, this problem might be solvable by using an
<tt>initializer_list</tt> of <i>const references</i>, instead:
</p>
<blockquote><pre>const T&amp; min(initializer_list&lt;const T&amp;&gt;);
const T&amp; max(initializer_list&lt;const T&amp;&gt;);
pair&lt;const T&amp;, const T&amp;&gt; minmax(initializer_list&lt;const T&amp;&gt;);
</pre></blockquote>

<p>
It is unlikely that C++0x will support <tt>initializer_list&lt;const
T&amp;&gt;</tt>, but technically it seems possible to add such a language
feature after C++0x (<a href="http://accu.org/cgi-bin/wg21/message?wg=core&msg=15428">c++std-core-15428</a>).
</p>
<p>
Variadic templates of <tt>min</tt>, <tt>max</tt>, and <tt>minmax</tt>, as
proposed by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2551.pdf">N2551</a>
(Sylvain Pion), do have some other advantages over <tt>initializer_list</tt>
overloads:
</p>
<ol>
<li>
It is likely that those variadic templates can be declared <tt>constexpr</tt>,
now that <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n3006.html#991">
CWG issue #991</a> is in drafting status.
</li>
<li>
They provide complete compile-time protection against accidentally passing zero
arguments.
</li>
</ol>

<p>
Unfortunately, the variadic templates of <tt>min</tt>, <tt>max</tt>, and
<tt>minmax</tt> may still need further improvement, before having them in the
Standard Library. Especially the optional <tt>Compare</tt> parameter appears to
be a concern. So for this moment I recommend to keep both versions out of C++0x,
and postpone further discussion until after C++0x.
</p>

<p><i>[
2010 Pittsburgh:  Discussed and the LWG still prefers the initializer list
solution of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2772.pdf">N2772</a>.
]</i></p>




<p><b>Rationale:</b></p>
We prefer the solution of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2772.pdf">N2772</a>
which will be reapplied.


<p><b>Proposed resolution:</b></p>
<p>
Remove both variadic templates and <tt>initializer_list</tt> overloads of
<tt>min</tt>, <tt>max</tt>, and <tt>minmax</tt> from the synopsis in
25.1 [algorithms.general] and from 25.4.7 [alg.min.max].
</p>

<blockquote>
<p><i>[
Note: This proposed resolution will resolve LWG <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#915">915</a> as NAD.
]</i></p>

</blockquote>





<hr>
<h3><a name="1311"></a>1311. multi-pass property of Forward Iterator underspecified</h3>
<p><b>Section:</b> 24.2.5 [forward.iterators] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2010-02-07 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#forward.iterators">issues</a> in [forward.iterators].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The following example demonstrates code that would meet the guarantees of a
Forward Iterator, but only permits a single traversal of the underlying
sequence:
</p>

<blockquote><pre>template&lt; typename ForwardIterator&gt;
struct bad_iterator {
  shared_ptr&lt;ForwardIterator&gt; impl;

  bad_iterator( ForwardIterator iter ) {
     : impl{new ForwardIterator{iter} } 
     {
  }

  auto operator*() const -&gt; decltype(*ForwardIterator{}) {
     return **impl;
  }

  auto operator-&gt;() const -&gt; ForwardIterator {
     return *impl;
  }

  auto operator==(bad_iterator const &amp; rhs) {
     return impl == rhs.impl;
  }

  auto operator++() {
     ++(*imp);
  }
  // other operations as necessary...
};
</pre></blockquote>

<p>
Here, we use <tt>shared_ptr</tt> to wrap a forward iterator, so all iterators
constructed from the same original iterator share the same 'value', and
incrementing any one copy increments all others.
</p>

<p>
There is a missing guarantee, expressed by the following code sequence
</p>

<blockquote><pre>FwdIter x = seq.begin();  // obtain forward iterator from a sequence
FwdIter y = x;            // copy the iterator
assert(x == y);           // iterators must be the same
++x;                      // increment *just one* iterator
assert(x != y);           // iterators *must now be different*
++y;                      // increment the other iterator
assert(x == y);           // now the iterators must be the same again
</pre></blockquote>

<p>
That inequality in the middle is an essential guarantee.  Note that this list is
simplified, as each assertion should also note that they refer to exactly the
same element <tt>(&amp;*x == &amp;*y)</tt> but I am not complicating the issue
with tests to support proxy iterators, or value types overloading unary
<tt>operator+</tt>.
</p>

<p>
I have not yet found a perverse example that can meet this additional
constraint, and not meet the multi-pass expectations of a Forward Iterator
without also violating other Forward Iterator requirements.
</p>

<p>
Note that I do not yet have standard-ready wording to resolve the problem, as
saying this neatly and succinctly in 'standardese' is more difficult.
</p>

<p><i>[
2010 Pittsburgh:  Moved to NAD Editorial.  Rationale added below.
]</i></p>




<p><b>Rationale:</b></p>
<p>
Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3066.html">N3066</a>.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1313"></a>1313. Seed sequence's param function not useful for pure  output iterator</h3>
<p><b>Section:</b> 26.5.7.1 [rand.util.seedseq] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Daniel Krgler <b>Opened:</b> 2010-02-07 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#rand.util.seedseq">issues</a> in [rand.util.seedseq].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The Seed sequence requirements (26.5.1.2 [rand.req.seedseq]) require the
existence of a member function
</p>

<blockquote><pre>template&lt;typename OutputIterator&gt;
void param(OutputIterator ob);
</pre></blockquote>

<p>
The fact that this function returns <tt>void</tt> instead of the value of
<tt>ob</tt> after accepting the sequence data leads to the same problem as in
issue <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#865">865</a> - In case of pure output iterators there is no way to
serialize further data into that data sink.
</p>

<p><i>[
2010-02-07 Howard adds:
]</i></p>


<blockquote>
At the time this issue was opened, the suggested changes are with respect to an
anticipated draft which does not yet exist.
</blockquote>

<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote>
No technical counterarguments, but it is simply too late in the process
to make this change at this point.
</blockquote>


<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
In Table 109  Seed sequence requirements, expression "<tt>r.param(ob)</tt>"
change the<br>
Return type entry:
</p>

<blockquote><pre><del>void</del><ins>OutputIterator</ins>
</pre></blockquote>
</li>

<li>
<p>
In 26.5.7.1 [rand.util.seedseq], class seed_seq synopsis change
</p>

<blockquote><pre>template&lt;class OutputIterator&gt;
<del>void</del><ins>OutputIterator</ins> param(OutputIterator dest) const;
</pre></blockquote>
</li>

</ol>






<hr>
<h3><a name="1314"></a>1314. <tt>NULL</tt> and <tt>nullptr</tt></h3>
<p><b>Section:</b> 18.2 [support.types] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Sean Hunt <b>Opened:</b> 2010-02-07 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#support.types">issues</a> in [support.types].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, the 18.2 [support.types]/3 allows <tt>NULL</tt> to be any
null pointer constant. The footnote marks that 0 or 0L might be appropriate.
However, this definition also allows the implementation to define <tt>NULL</tt>
to be <tt>nullptr</tt>. This may lead to overload and conversion issues more
serious than with the C++98 version:
</p>

<blockquote><pre>void f(void*);
void f(int);

void g()
{
 // calls f(int) if NULL is integral
 // calls f(void*) if NULL is nullptr
 f(NULL);
}
</pre></blockquote>

<p>
Possible resolutions:
</p>
<ul>
<li>
Forbid <tt>NULL</tt> from being <tt>nullptr</tt>
</li>
<li>
Require <tt>NULL</tt> to be <tt>nullptr</tt>
</li>
<li>
Leave it as is
</li>
</ul>

<p>
Making <tt>NULL</tt> <tt>nullptr</tt> would improve code correctness, and
breaking backwards compatibility shouldn't be a huge concern as <tt>NULL</tt>
shouldn't be used except as a null pointer constant anyways.
</p>

<p><i>[
2010-02-10  Chris provided wording.
]</i></p>


<p><i>[
2010 Pittsburgh:  Moved to NAD, rationale added below.
]</i></p>




<p><b>Rationale:</b></p>
<p>
The LWG discussed the proposed resolution and several other options.  There was
no concensus to make this or any other changes.
</p>


<p><b>Proposed resolution:</b></p>
<p>
18.2 [support.types]
</p>

<blockquote>
<p>
3 The macro <tt>NULL</tt> <ins>is defined to be <tt>nullptr</tt>.</ins> <del>is
an implementation-defined C++ null pointer constant in this International
Standard (4.10).<sup>196</sup></del>
</p>

<p><del>
196) Possible definitions include <tt>0</tt> and <tt>0L</tt>, but not
<tt>(void*)0</tt>.
</del></p>
</blockquote>

<p>
20.9.13 [c.malloc]
</p>

<blockquote>
7 The contents are the same as the Standard C library header
<tt>&lt;string.h&gt;</tt>, with the change to <tt>memchr()</tt> specified in
21.6 <ins>and the macro <tt>NULL</tt> defined to be <tt>nullptr</tt></ins>.
</blockquote>


<p>
20.12 [date.time]
</p>

<blockquote>
2 The contents are the same as the Standard C library header
<tt>&lt;time.h&gt;</tt><del>.</del><sup>232</sup> <ins>except the macro
<tt>NULL</tt>, which is defined to be <tt>nullptr</tt>.</ins> The functions
<tt>asctime</tt>, <tt>ctime</tt>, <tt>gmtime</tt>, and <tt>localtime</tt> are
not required to avoid data races (17.6.4.8).
</blockquote>


<p>
22.6 [c.locales]
</p>

<blockquote>
2 The contents are the same as the Standard C library header
<tt>&lt;locale.h&gt;</tt> <ins>except the macro <tt>NULL</tt>, which is defined
to be <tt>nullptr</tt></ins>.
</blockquote>

<p>
C.2.2.4 [diff.null]
</p>

<blockquote>
1 The macro <tt>NULL</tt>, defined in any of <tt>&lt;clocale&gt;</tt>,
<tt>&lt;cstddef&gt;</tt>, <tt>&lt;cstdio&gt;</tt>, <tt>&lt;cstdlib&gt;</tt>,
<tt>&lt;cstring&gt;</tt>, <tt>&lt;ctime&gt;</tt>, or <tt>&lt;cwchar&gt;</tt>, is
<ins>nullptr</ins> <del>an implementation-defined C++ null pointer constant in
this International Standard (18.2).</del>
</blockquote>






<hr>
<h3><a name="1315"></a>1315. return type of <tt>async</tt></h3>
<p><b>Section:</b> 30.6.9 [futures.async] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2009-02-09 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#futures.async">issues</a> in [futures.async].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Both overloads of <tt>async</tt> return <tt>future&lt;typename
F::result_type&gt;</tt> which requires that <tt>F</tt> has a nested type. This
prevents <tt>async</tt> being used with function pointers and makes the example
in 30.6.9 [futures.async] invalid. I believe this is unintentional.
</p>

<p>
The proposed resolution also addresses editorial issues with the
<tt>launch_policy</tt> function parameter.
</p>

<p>
For the first overload it is not sufficient to return <tt>future&lt;typename
result_of&lt;F(ArgTypes...)&gt;::type&gt;</tt>.  Calling <tt>async(launch::xxx,
foo, bar)</tt> performs argument deduction on both <tt>async</tt> overloads,
which for the first overload attempts to instantiate <tt>result_of&lt;launch(F,
ArgTypes...)&gt;</tt>, which is invalid. SFINAE must be used to prevent that.
</p>

<p><i>[
2010-02-12 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>


<p><i>[
2010-02-12 Daniel opens:
]</i></p>


<blockquote>
<p>
[..] if <tt>decay&lt;F&gt;::type</tt> is of type <tt>std::launch</tt>.
</p>
<p>
or
</p>
<p>
[..] if <tt>remove_cv&lt;remove_reference&lt;F&gt;::type&gt;::type</tt> is of
type <tt>std::launch</tt>.
</p>

<p>
The latter is the more specific form, but the former is equivalent to
the latter for all cases that can occur here. I suggest to use the
former for simplicity, but expect that implementations can effectively
use the latter.

</p>
</blockquote>

<p><i>[
2010-02-12 Moved to Tentatively Ready after 5 positive votes on c++std-lib.
]</i></p>


<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote>
Moved to NAD Editorial.  Rationale added below.
</blockquote>



<p><b>Rationale:</b></p>
<p>
Solved by N3058.
</p>


<p><b>Proposed resolution:</b></p>
<p>
In 30.6.1 [futures.overview] paragraph 1:
</p>

<blockquote><pre>template &lt;class F, class... Args&gt;
  <del>future&lt;typename F::result_type&gt;</del>
  <ins>future&lt;typename result_of&lt;F(Args...)&gt;::type&gt;</ins>
  async(F&amp;&amp; f, Args&amp;&amp;... args);
template &lt;class F, class... Args&gt;
  <del>future&lt;typename F::result_type&gt;</del>
  <ins>future&lt;typename result_of&lt;F(Args...)&gt;::type&gt;</ins>
  async(launch policy, F&amp;&amp; f, Args&amp;&amp;... args);
</pre></blockquote>

<p>
In 30.6.9 [futures.async] before paragraph 1
</p>

<blockquote><pre>template &lt;class F, class... Args&gt;
  <del>future&lt;typename F::result_type&gt;</del>
  <ins>future&lt;typename result_of&lt;F(Args...)&gt;::type&gt;</ins>
  async(F&amp;&amp; f, Args&amp;&amp;... args);
template &lt;class F, class... Args&gt;
  <del>future&lt;typename F::result_type&gt;</del>
  <ins>future&lt;typename result_of&lt;F(Args...)&gt;::type&gt;</ins>
  async(launch policy, F&amp;&amp; f, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>...</p>
<p><ins>
<i>Remarks:</i> The first signature shall not participate in overload resolution
if <tt>decay&lt;F&gt;::type</tt> is <tt>std::launch</tt>.
</ins></p>
</blockquote>
</blockquote>






<hr>
<h3><a name="1317"></a>1317. make_hash</h3>
<p><b>Section:</b> 20.8.15 [unord.hash] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Future">NAD Future</a>
 <b>Submitter:</b> Nicolai M. Josuttis <b>Opened:</b> 2010-02-10 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#unord.hash">issues</a> in [unord.hash].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, the library lacks a convenient way to provide a hash function that
can be used with the provided unordered containers to allow the usage of non
trivial element types.
</p>

<p>
While we can easily declare an
</p>

<blockquote><pre>std::unordered_set&lt;int&gt;
</pre></blockquote>

<p>
or
</p>

<blockquote><pre>std::unordered_set&lt;std::string&gt;
</pre></blockquote>

<p>
we have no easy way to declare an <tt>unordered_set</tt> for a user defined
type. IMO, this is a big obstacle to use unordered containers in practice. Note
that in Java, the wide usage of <tt>HashMap</tt> is based on the fact that there
is always a default hash function provided.
</p>

<p>
Of course, a default hash function implies the risk to provide poor hash
functions. But often even poor hash functions are good enough.
</p>

<p>
While I really would like to see a default hash function, I don't propose it
here because this would probably introduce a discussion that's too big for this
state of C++0x.
</p>

<p>
However, I strongly suggest at least to provide a convenience variadic template
function <tt>make_hash&lt;&gt;()</tt> to allow an easy definition of a (possibly
poor) hash function.
</p>

<p>
As a consequence for a user-defined type such as
</p>

<blockquote><pre>class Customer {
   friend class CustomerHash;
   private:
     string firstname;
     string lastname;
     long   no;
   ...
 };
</pre></blockquote>

<p>
would allow to specify:
</p>

<blockquote><pre>class CustomerHash : public std::unary_function&lt;Customer, std::size_t&gt;
{
  public:
    std::size_t operator() (const Customer&amp; c) const  {
       return make_hash(c.firstname,c.lastname,c.no);
    }
};
</pre></blockquote>

<p>
instead of:
</p>

<blockquote><pre>class CustomerHash : public std::unary_function&lt;Customer, std::size_t&gt;
{
  public:
    std::size_t operator() (const Customer&amp; c) const  {
       return std::hash&lt;std::string&gt;()(c.firstname) +
              std::hash&lt;std::string&gt;()(c.lastname) +
              std::hash&lt;long&gt;()(c.no);
    }
};
</pre></blockquote>

<p>
Note that, in principle, we can either specify that
</p>

<blockquote>
<tt>make_hash</tt> returns the sum of a call of
<tt>std::hash&lt;T&gt;()(x)</tt> for each argument <tt>x</tt> of type
<tt>T</tt>
</blockquote>

<p>
or we can specify that
</p>

<blockquote>
<tt>make_hash</tt> provides a hash value for each argument, for which a
<tt>std::hash()</tt> function is provided
</blockquote>

<p>
with the possible note that the hash value may be poor or only a good hash value
if the ranges of all passed arguments is equally distributed.
</p>

<p>
For my convenience, I propose wording that describes
the concrete implementation.
</p>

<p><i>[
2010 Pittsburgh:  Moved to NAD Editorial, rationale added below.
]</i></p>




<p><b>Rationale:</b></p>
<p>
There is no consensus to make this change at this time.
</p>


<p><b>Proposed resolution:</b></p>
<p>
In Function objects 20.8 [function.objects]
in paragraph 2 at the end of the Header <tt>&lt;functional&gt;</tt> synopsis
insert:
</p>

<blockquote><pre>// convenience functions
template &lt;class T&gt;
  size_t make_hash (const T&amp;);
template &lt;class T, class... Types&gt;
  size_t make_hash (const T&amp;, const Types&amp;...);
</pre></blockquote>

<p>
In Class template hash 20.8.15 [unord.hash]
add:
</p>

<blockquote>
<p>
<b>20.7.16.1 Hash creation functions [hash.creation]</b>
</p>

<pre>template &lt;class T&gt;
  size_t make_hash (const T&amp; val);
</pre>

<blockquote>
<i>Returns:</i> <tt>hash&lt;T&gt;()(val);</tt>
</blockquote>

<pre>template &lt;class T, class... Types&gt;
  size_t make_hash (const T&amp; val, const Types&amp;... args);
</pre>

<blockquote>
<i>Returns:</i> <tt>hash&lt;T&gt;()(val) + std::make_hash(args...)</tt>
</blockquote>

</blockquote>






<hr>
<h3><a name="1329"></a>1329. Data races on <code>vector&lt;bool&gt;</code></h3>
<p><b>Section:</b> 23.2.2 [container.requirements.dataraces] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Jeffrey Yaskin <b>Opened:</b> 2010-03-09 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The common implementation of <tt>vector&lt;bool&gt;</tt> is as an
unsynchronized bitfield.  The addition of 23.2.2 [container.requirements.dataraces]/2 would require either a
change in representation or a change in access synchronization, both of
which are undesireable with respect to compatibility and performance.
</p>

<p><i>[
2010 Pittsburgh:  Moved to NAD Editorial.  Rationale added below.
]</i></p>




<p><b>Rationale:</b></p>
<p>
Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3069.html">N3069</a>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Container data races 23.2.2 [container.requirements.dataraces]
</p>

<p>
Paragraph 1 is unchanged as follows:
</p>

<blockquote>
1 For purposes of avoiding data races (17.6.4.8), implementations shall
consider the following functions to be <code>const</code>:
<code>begin</code>, <code>end</code>, <code>rbegin</code>,
<code>rend</code>, <code>front</code>, <code>back</code>,
<code>data</code>, <code>find</code>, <code>lower_bound</code>,
<code>upper_bound</code>, <code>equal_range</code>, and, except in
associative containers, <code>operator[]</code>.
</blockquote>

<p>
Edit paragraph 2 as follows:
</p>

<blockquote>
2 Notwithstanding (17.6.4.8), implementations are required to avoid data
races when the contents of the contained object in different elements in
the same sequence<ins>, excepting <code>vector&lt;bool&gt;</code>,</ins>
are modified concurrently.
</blockquote>

<p>
Edit paragraph 3 as follows:
</p>

<blockquote>
3 [<i>Note:</i>
For a <code>vector&lt;int&gt; x</code> with a size greater than one,
<code>x[1] = 5</code> and <code>*x.begin() = 10</code>
can be executed concurrently without a data race,
but <code>x[0] = 5</code> and <code>*x.begin() = 10</code>
executed concurrently may result in a data race.
<ins>As an exception to the general rule,
for a <code>vector&lt;bool&gt; y</code>,
<code>y[i] = true</code> may race with <code>y[j] = true</code>.</ins>
<i>end note</i>]
</blockquote>






<hr>
<h3><a name="1331"></a>1331. incorporate move special member functions into library</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2010-03-10 <b>Last modified:</b> 2010-11-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Review the library portion of the spec and incorporate the newly added
core feature Move Special Member Functions (N3044).
</p>

<p><b>Rationale:</b></p>
2010 Batavia: This has now been done to a large extent.




<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1350"></a>1350. [FCD] Implicit contructors accidentally made some library types move-only</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Switzerland <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-25</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1421">1421</a></p>
<p><b>Discussion:</b></p>
<p><b>Addresses CH-15</b></p>
<p>
Due to the new rules about implicit copy and move
constructors some library facilities are now move-only.
</p>

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<p>
Make them copyable again.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1351"></a>1351. [FCD] Replace dynamic exception specifications with <tt>noexcept</tt></h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Switzerland <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-25</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1344">1344</a></p>
<p><b>Discussion:</b></p>

<p><b>Addresses CH-16</b></p>
<p>
Dynamic exception specifications are deprecated.
Deprecated features shouldn't be used in the Standard.
</p>

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<p>
Replace dynamic exception specifications with <tt>noexcept</tt>.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1352"></a>1352. [FCD] Apply <tt>noexcept</tt> where library specification says "Throws: Nothing"</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Switzerland <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-25</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1346">1346</a></p>
<p><b>Discussion:</b></p>

<p><b>Addresses CH-17</b></p>
<p>
The introduction of <tt>noexcept</tt> makes "Throws: Nothing" clauses looking strange.
</p>

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<p>
Consider replacing "Throws: Nothing." clause by
the respective noexcept specification.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1359"></a>1359. [FCD] Add <tt>&lt;tuple&gt;</tt> and <tt>&lt;utility&gt;</tt> to freestanding implementations</h3>
<p><b>Section:</b> 17.6.1.3 [compliance] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#compliance">issues</a> in [compliance].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-56</b></p>
<p>
The <tt>&lt;utility&gt;</tt> header provides support for several
important C++ idioms with <tt>move</tt>, <tt>forward</tt> and <tt>swap</tt>.
Likewise, <tt>declval</tt> will be frequently used like a type trait.
In order to complete cycles introduced by <tt>std::pair</tt>, the
<tt>&lt;tuple&gt;</tt> header should also be made available. This is a
similarly primitive set of functionality, with no dependency
of a hosted environment, but does go beyond the minimal
set of functionality otherwise suggested by the
freestanding libraries.
</p>
<p>
Alternatively, split the <tt>move</tt>/<tt>forward</tt>/<tt>swap</tt>/<tt>declval</tt>
functions out of <tt>&lt;utility&gt;</tt> and into a new primitive header,
requiring only that of freestanding implementation.
</p>

<p><i>[
Summary of Rapperswil discusions
]</i></p>

<p>
The preference of the meeting was to extract the rvalue-reference related utilities and swap into a freestanding header, but there was no clear preference for a name.  Howard suggested simply dropping them into <tt>&lt;type_traits&gt;</tt> as both these utilities and type traits are used pretty much everywhere in the library implementation, it is the most convenient place to keep them (from an implementer's perspective).
</p>

<p>
Poll: Two-way: New header for forward, move, swap, move_with_noexcept and declval vs. calling out forward, move, swap, move_with_noexcept and declval as freestanding explicitly?

SF new header: 4 WF new header: 3 WF call out as freestanding: 1 SF call out as freestanding: 2

Alisdair: Willing to write up both solutions, give us some time to think on it.

Action: Need an issue and proposed wording for GB 56 - Alisdair to draft both options as in the last poll. 
</p>

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<blockquote>
<p>
Add <tt>&lt;utility&gt;</tt> and <tt>&lt;tuple&gt;</tt> to table 15, headers
required for a free-standing implementation.
</p>
</blockquote>

<p><i>[
2010-Batavia:
]</i></p>

<p>
Closed as NAD, reversing the decision at Rapperswil.
</p>
<p>
The consensus was that
any freestanding implementation is going to feel compelled to offer the important
features of <tt>&lt;utility&gt;</tt> even if we do not make them a freestanding
requirement; breaking out additional small headers may have additional costs at
compile time, and while the critical <tt>move</tt>-related functions could migrate
to <tt>&lt;type_traits&gt;</tt>, the header name is far from appealing; adding the
whole of <tt>&lt;utility&gt;</tt> starts to drag in dependencies on <tt>&lt;tuple&gt;</tt>
and <tt>&lt;memory&gt;</tt>, so we prefer to place the burden of slicing or supporting
this whole header on free-standing vendors.
</p>



<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>No consensus for a change at this time. 





<hr>
<h3><a name="1361"></a>1361. [FCD] Does use of <tt>std::size_t</tt> in a header imply that typedef name is available to users?</h3>
<p><b>Section:</b> 17.6.2 [using] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-58</b></p>
<p>
It is not clear whether a library header specified in terms
of a typedef name makes that same typedef name
available for use, or if it simply requires that the specified
type is an alias of the same type, and so the typedef name
cannot be used without including the specific header that
defines it. For example, is the following code required to
be accepted:
</p>
<blockquote><pre>#include &lt;vector&gt;
std::size_t x = 0;
</pre></blockquote>
<p>
Most often, this question concerns the typedefs defined in
header <tt>&lt;cstddef&gt;</tt>
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<p>
Add a paragraph under 17.6.2 [using] clarifying whether
or not headers specified in terms of <tt>std::size_t</tt> can
be used to access the typedef <tt>size_t</tt>, or whether
the header <tt>&lt;cstddef&gt;</tt> must be included to reliably
use this name.
</p>
<p><i>[Batavia: NAD - see rationale below]</i></p>




<p><b>Proposed resolution:</b></p>

<p><b>Rationale:</b></p>The standard is correct as written.




<hr>
<h3><a name="1373"></a>1373. [FCD] Customizable traits should have their own headers</h3>
<p><b>Section:</b> 20.3 [utility] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#utility">issues</a> in [utility].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-79</b></p>
<p>
The library provides several traits mechanisms intended a
customization points for users. Typically, they are
declared in headers that are growing quite large. This is
not a problem for standard library vendors, who can
manage their internal file structure to avoid large
dependencies, but can be a problem for end users who
have no option but to include these large headers.
</p>

<p><i>[
2010 Rapperswil
]</i></p>

<p>
There was no enthusiasm for touching <tt>char_traits</tt> or <tt>regex_traits</tt>.
Consensus to move <tt>iterator_traits</tt>, <tt>allocator_traits</tt>
and <tt>pointer_traits</tt> to their own respective headers once wording supplied.
</p>

<p><i>[
2010 Rapperswil
]</i></p>

<p>
After some discussion, consensus is that moving these features into separate
headers does not buy much in practice, as the larger headers will inevitably
be included anyway.  Resolve as NAD.
</p>

<p><i>[
Resolution proposed in ballot comment
]</i></p>

<p>
Move the following traits classes into their own
headers, and require the existing header to
<tt>#include</tt> the traits header to support backwards
compatibility:
</p>
<blockquote><pre>iterator_traits (plus the iterator tag-types)
allocator_traits
pointer_traits
char_traits
regex_traits
</pre></blockquote>

<p><i>[
2010 Batavia:
]</i></p>

<p>
Closed as NAD with the rationale below.
</p>



<p><b>Rationale:</b></p>
This suggest is not a defect, as the likely benefit is small, if any,
compared to the cost of not just implementating the feature, but also
explaining/teaching it.


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1375"></a>1375. [FCD] <tt>reference_type</tt> should not have been removed from the
allocator requirements</h3>
<p><b>Section:</b> 20.2.5 [allocator.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1318">1318</a></p>
<p><b>Discussion:</b></p>

<p><b>Addresses US-87</b></p>
<p>
<tt>reference_type</tt> should not have been removed from the
allocator requirements. Even if it is always the same as
<tt>value_type&amp;</tt>, it is an important customization point for
extensions and future features.
</p>


<p><b>Proposed resolution:</b></p>
<p>
In [allocator.requirements] Table 42 - Allocotor Requirements, 
Add a row (after <tt>value_type</tt>) with columns:
</p>
<blockquote>
Expression: <ins><tt>X::reference_type</tt></ins><br>
Return type: <ins><tt>T&amp;</tt></ins><br>
Assertion/note...: (empty)<br>
Default: <ins><tt>T&amp;</tt></ins><br>
</blockquote>
<p>
[allocator.traits]:
</p> 
<blockquote><pre>namespace std {
  template &lt;class Alloc&gt; struct allocator_traits {
    typedef Alloc allocator_type;
    
    typedef typename Alloc::value_type value_type;

    typedef <i>see below</i>   pointer;
    typedef <i>see below</i>   const_pointer;
    typedef <i>see below</i>   void_pointer;
    typedef <i>see below</i>   const_void_pointer;
    <ins>typedef value_type&amp; reference_type;</ins>
</pre></blockquote>

Add <tt>reference_type</tt> to
allocator_traits template, defaulted to
value_type&amp;.





<hr>
<h3><a name="1376"></a>1376. [FCD] Allocator interface is not backward compatible</h3>
<p><b>Section:</b> 20.2.5 [allocator.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-88</b></p>
<p>
Allocator interface is not backward compatible.
</p>

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<p>
See Appendix 1 - Additional Details
</p>

<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3165.pdf">n3165</a> provides an alternative resolution.
</blockquote>

<p><i>[
2910 Batavia:
]</i></p>

<p>
Closed as NAD - withdrawn by the submitter.
</p>


<p><b>Proposed resolution:</b></p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3165.pdf">n3165</a>


<p><b>Rationale:</b></p>Withdrawn by the submitter.




<hr>
<h3><a name="1395"></a>1395. [FCD] Ballot Comment JP-32</h3>
<p><b>Section:</b> 20.7.6 [meta.rel] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Japan <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#meta.rel">issues</a> in [meta.rel].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses JP-32</b></p>
<p>
Representations of reference link are not unified.
Most reference links to clause (table) number, say X, are
in the form "Clause X" ("Table X") capitalized, and
subsection Y.Y.Y is referenced with its number only in the
form "Y.Y.Y". Whether they are parenthesized or not
depends on the context.
However there are some notations "(Z)" consisting of only
a number Z in parentheses to confer Clause or Table
number Z.
</p>


<p><b>Proposed resolution:</b></p>
Change "(10)" to "(Clause 10)".





<hr>
<h3><a name="1398"></a>1398. [FCD] Users should be able to specialize functors without depending on whole <tt>&lt;functional&gt;</tt> header</h3>
<p><b>Section:</b> 20.8 [function.objects] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#function.objects">issues</a> in [function.objects].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-96</b></p>
<p>
The function templates <tt>hash</tt>, <tt>less</tt> and <tt>equal_to</tt>
are important customization points for user-defined types to
be supported by several standard containers. These are
accessed through the <tt>&lt;functional&gt;</tt> header which has
grown significantly larger in C++0x, exposing many more
facilities than a user is likely to need through there own
header, simply to declare the necessary specialization.
There should be a smaller header available for users to
make the necessary customization.
</p>

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<p>
Provide a tiny forwarding header for important
functor types in the <tt>&lt;functional&gt;</tt> header that a
user may want to specialize. This should contain
the template declaration for <tt>equal_to</tt>, <tt>hash</tt> and
<tt>less</tt>.
</p>

<p><i>[
Rapperswill summary
]</i></p>

<p>Alisdair: Would recommend NAD unless someone takes the issue. </p>

<p>Daniel: Volunteers to write a paper for this. </p>

<p><i>[
2010-11-07 Daniel provides a paper available on the Batavia document list
]</i></p>


<p><i>[
2010 Batavia:
]</i></p>

<p>
Closed as NAD - the consensus was that forwarding headers such as
<tt>&lt;iosfwd&gt;</tt> do not bring the expected benefits, and are
not widely used (to the surprise of some active users in the room!).
Without real experience reporting a benefit, there is no further interest
in pursuing this issue as an extension - hence NAD rather than NAD Future.
</p>



<p><b>Rationale:</b></p>No consensus to make a change

<p><b>Proposed resolution:</b></p>
See paper "Forwarding <tt>&lt;functional&gt;</tt> functor templates"
on the Batavia LWG document list





<hr>
<h3><a name="1406"></a>1406. [FCD] Support hashing smart-pointers based on <i>owner</i></h3>
<p><b>Section:</b> 20.9.10.2 [util.smartptr.shared] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Future">NAD Future</a>
 <b>Submitter:</b> Japan <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#util.smartptr.shared">issues</a> in [util.smartptr.shared].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses JP-5</b></p>
<p>
Hash support based on ownership sharing should be
supplied for <tt>shared_ptr</tt> and <tt>weak_ptr</tt>.
For two <tt>shared_ptr</tt> objects <tt>p</tt> and <tt>q</tt>, two distinct
equivalence relations can be defined. One is based on
equivalence of pointer values, which is derived from the
expression <tt>p.get() == q.get()</tt> (hereafter called <i>address based
equivalence relation</i>), the other is based on
equivalence of ownership sharing, which is derived from
the expression <tt>!p.owner_before(q) &amp;&amp; !q.owner_before(p)</tt>
(hereafter called <i>ownership-based equivalence relation</i>).
These two equivalence relations are independent in
general. For example, a <tt>shared_ptr</tt> object created by the
constructor of the signature <tt>shared_ptr(shared_ptr&lt;U&gt;
const &amp;, T *)</tt> could reveal a difference between these two
relations. Therefore, hash support based on each
equivalence relation should be supplied for <tt>shared_ptr</tt>.
However, while the standard library provides the hash
support for address-based one (20.9.11.6 paragraph 2), it
lacks the hash support for ownership-based one. In
addition, associative containers work well in combination
with the <tt>shared_ptr</tt>'s ownership-based comparison but
unordered associative containers don't. This is
inconsistent.
</p>
<p>
For the case of <tt>weak_ptr</tt>, hash support for the ownership based
equivalence relation can be safely defined on
<tt>weak_ptr</tt>s, and even on expired ones. The absence of
hash support for the ownership-based equivalence
relation is fatal, especially for expired <tt>weak_ptr</tt>s. And the
absence of such hash support precludes some quite
effective use-cases, e.g. erasing the <tt>unordered_map</tt> entry
of an expired <tt>weak_ptr</tt> key from a customized deleter
supplied to <tt>shared_ptr</tt>s.
</p>
<p>
Hash support for the ownership-based equivalence
relation cannot be provided by any user-defined manner
because information about ownership sharing is not
available to users at all. Therefore, the only way to provide
ownership-based hash support is to offer it intrusively by
the standard library.
</p>
<p>
As far as we know, such hash support is implementable.
Typical implementation of such hash function could return
the hash value of the pointer of the counter object that is
internally managed by <tt>shared_ptr</tt> and <tt>weak_ptr</tt>.
</p>

<p><i>[2010 Rapperswil:]</i></p>

<blockquote>
<p>No consensus to make this change at this time.</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Add the following non-static member functions to
<tt>shared_ptr</tt> and <tt>weak_ptr</tt> class template;
</p>
<p>
Update [util.smartptr.shared], 20.9.11.2 paragraph 1
</p>
<pre>namespace std{
template&lt;class T&gt; class shared_ptr {
public:
...
  <ins>size_t owner_hash() const;</ins>
...
};
}
</pre>
<p>
Update [util.smartptr.weak], 20.9.11.3 paragraph 1
</p>
<pre>namespace std{
template&lt;class T&gt; class weak_ptr {
public:
...
  <ins>size_t owner_hash() const;</ins>
...
};
}
</pre>
<p>
These functions satisfy the following
requirements. Let <tt>p</tt> and <tt>q</tt> be objects of either
<tt>shared_ptr</tt> or <tt>weak_ptr</tt>, <tt>H</tt> be a hypothetical
function object type that satisfies the hash
requirements ([hash.requirements], 20.2.4) and <tt>h</tt> be an object of the
type <tt>H</tt>. The expression <tt>p.owner_hash()</tt> behaves
as if it were equivalent to the expression <tt>h(p)</tt>. In
addition, <tt>h(p) == h(q)</tt> must become <tt>true</tt> if <tt>p</tt> and
<tt>q</tt> share ownership.
</p>





<hr>
<h3><a name="1411"></a>1411. [FCD] Add a compile-time flag to detect <tt>monotonic_clock</tt></h3>
<p><b>Section:</b> X [time.clock.monotonic] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> DIN <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#time.clock.monotonic">issues</a> in [time.clock.monotonic].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1410">1410</a></p>
<p><b>Discussion:</b></p>

<p><b>Addresses DE-20</b></p>

The library component <tt>monotonic_clock</tt> is conditionally
supported, but no compile-time flag exists that allows
user-code to query its existence. Further-on there exist no
portable means to simulate such a query. (To do so, user
code would be required to add types to namespace
<tt>std::chrono</tt>.)


<p><b>Proposed resolution:</b></p>
Provide a compile-time flag (preferably a macro)
that can be used to query the existence of
<tt>monotonic_clock</tt>.





<hr>
<h3><a name="1415"></a>1415. [FCD] iterator stability bans the short-string optimization</h3>
<p><b>Section:</b> 23.2.1 [container.requirements.general] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#container.requirements.general">active issues</a> in [container.requirements.general].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#container.requirements.general">issues</a> in [container.requirements.general].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
Requirements on iterators swapping allegiance would
disallow the small-string optimization.

<p><i>[
Resolved in Rapperswil by paper N3108.
]</i></p>




<p><b>Proposed resolution:</b></p>
Add an exclusion for <tt>basic_string</tt> to the sentence
beginning Every iterator referring to an
element.... Add a sentence to 21.4.6.8/2 saying
that iterators and references to string elements
remain valid, but it is not specified whether they
refer to the same string or the other string.





<hr>
<h3><a name="1419"></a>1419. [FCD] Ballot Comment US-117</h3>
<p><b>Section:</b> 23.3.3 [forwardlist] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#forwardlist">issues</a> in [forwardlist].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-117</b></p>

forward_list::erase_after should return an iterator.

<p><i>[
Resolved in Rapperswil by a motion to directly apply the words from the ballot comment in N3102.
]</i></p>




<p><b>Proposed resolution:</b></p>
See Appendix 1 - Additional Details





<hr>
<h3><a name="1422"></a>1422. [FCD] vector&lt;bool&gt; iterators are not random access</h3>
<p><b>Section:</b> 23.4.2 [vector.bool] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Future">NAD Future</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#vector.bool">issues</a> in [vector.bool].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-118</b></p>
<p>
<tt>vector&lt;bool&gt;</tt> iterators are not random access iterators
because their reference type is a special class, and not
<tt>bool &amp;</tt>. All standard libary operations taking iterators
should treat this iterator as if it was a random access iterator, rather
than a simple input iterator.
</p>

<p><i>[
Resolution proposed in ballot comment
]</i></p>

<p>
Either revise the iterator requirements to support proxy iterators
(restoring functionality that was lost when the Concept facility was
removed) or add an extra paragraph to the <tt>vector&lt;bool&gt;</tt>
specification requiring the library to treat <tt>vector&lt;bool&gt;</tt>
iterators as-if they were random access iterators, despite having the wrong
reference type.
</p>

<p><i>[
Rapperswil Review
]</i></p>

<p>
The consensus at Rapperswil is that it is too late for full support for
proxy iterators, but requiring the library to respect <tt>vector&amp;;t;bool&gt;</tt>
iterators as-if they were random access would be preferable to flagging
this container as deliberately incompatible with standard library algorithms.
</p>
<p>
Alisdair to write the note, which may become normative <i>Remark</i> depending
on the preferences of the project editor.
</p>

<p><i>[
Post-Rapperswil Alisdair provides wording
]</i></p>

<p>
Initial wording is supplied, deliberately using <i>Note</i> in preference to
<i>Remark</i> although the author notes his preference for <i>Remark</i>.  The
issue of whether <tt>iterator_traits&lt;vector&lt;bool&gt;&gt;::iterator_category</tt>
is permitted to report <tt>random_access_iterator_tag</tt> or must report 
<tt>input_iterator_tag</tt> is not addressed.
</p>

<p><i>[
Old Proposed Resolution:
]</i></p>

<blockquote>
<p>
Insert a new paragraph into 23.4.2 [vector.bool] between p4 and p5:
</p>
<blockquote>
[<i>Note</i> All functions in the library that take a pair of iterators to
denote a range shall treat <tt>vector&lt;bool&gt;</tt> iterators as-if they were
random access iterators, even though the <tt>reference</tt> type is not a
true reference.<i>-- end note</i>]
</blockquote>
</blockquote>

<p><i>[
2010-11 Batavia:
]</i></p>

<blockquote>
Closed as NAD Future, because the current iterator categories cannot correctly describe
<tt>vector&lt;bool&gt;::iterator</tt>. But saying that they are Random Access Iterators
is also incorrect, because it is not too hard to create a corresponding test that fails.
We should deal with the more general proxy iterator problem in the future, and see no
benefit to take a partial workaround specific to <tt>vector&lt;bool&gt;</tt> now.
</blockquote>



<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
No consensus to make this change at this time.





<hr>
<h3><a name="1433"></a>1433. [FCD] Ballot Comment GB-119</h3>
<p><b>Section:</b> 25.3.12 [alg.random.shuffle] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-23</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.random.shuffle">issues</a> in [alg.random.shuffle].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1432">1432</a></p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-119</b></p>

The functions random_shuffle and shuffle both take
arguments providing a source of randomness, but one
take its argument by rvalue reference, and the other
requires an lvalue reference. The technical merits of which
form of argument passing should be settled for this
specific case, and a single preferred form used
consistently.


<p><b>Proposed resolution:</b></p>
[DEPENDS ON WHETHER RVALUE OR
LVALUE REFERENCE IS THE PREFERRED
FORM]





<hr>
<h3><a name="1434"></a>1434. [FCD] Ballot Comment US-122</h3>
<p><b>Section:</b> 25.4.7 [alg.min.max] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#alg.min.max">issues</a> in [alg.min.max].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-122</b></p>

It was the LWG's intent in Pittsburgh that N2772 be
applied to the WP.

<p><i>[
Resolved in Rapperswil by paper N3106.
]</i></p>




<p><b>Proposed resolution:</b></p>
Apply N2772 to the WP.





<hr>
<h3><a name="1442"></a>1442. [FCD] "happens-before" should be "synchronizes-with"</h3>
<p><b>Section:</b> 30 [thread] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Canada <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-18</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread">issues</a> in [thread].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1443">1443</a></p>
<p><b>Discussion:</b></p>
<p><b>Addresses CA-9, GB-122</b></p>

<p><i>[CA-9:]</i></p>


Imposed happens-before edges should be in
synchronizes-with<br>
Each use of the words "happens-before" should be
replaced with the words "synchronizes-with" in the
following sentences:<br>
27.2.3p2<br>
30.3.1.2p6<br>
30.3.1.5p7<br>
30.6.4p7<br>
30.6.9p5<br>
30.6.10.1p23<br>
Rationale: Happens-before is defined in 1.10p11 in a way
that (deliberately) does not make it explicitly transitively
closed. Adding edges to happens-before directly, as in
27.2.3p2 etc., does not provide transitivity with
sequenced-before or any other existing happens-before
edge. This lack of transitivity seems to be unintentional.

<p><i>[GB-122]</i></p>


<p>At various points in the standard new edges are added to
happens-before, for example 27.2.3:2 adds happens-before edges between
writes and reads from a stream:</p>

<p>If one thread makes a library call a that writes a value to a
stream and, as a result, another thread reads this value from the
stream through a library call b such that this does not result in a
data race, then a happens before b.</p>

<p>Happens-before is defined in 1.10:11 in a deliberate way that makes it
not explicitly transitively closed. Adding edges to happens-before
directly, as in 27.2.3:2, does not provide transitivity with
sequenced-before or any other existing happens-before edge. This lack
of transitivity seems to be unintentional. In order to achieve
transitivity we suggest each edge be added to
inter-thread-happens-before as a synchronises-with edge (as per
conversation with Hans Boehm). In the standard, each use of the words
"happens-before" should be replaced with the words "synchronizes-with"
in the following sentences:</p>

<p>27.2.3:2,
30.3.1.2:6,
30.3.1.5:7,
30.6.4:7,
30.6.9:5,
30.6.10.1:23</p>

<p><b>Proposed resolution:</b></p>

<p><i>[Beman provided specific wording for the proposed resolution.]</i></p>


<p>Change 27.2.3 Thread Safety [iostreams.threadsafety] paragraph 2:</p>

<p>If one thread makes a library call <tt>a</tt> that writes a value to a stream and, as a result, another thread reads this value from the stream through a library call <tt>b</tt> such that this does not result in a data race, then <tt>a</tt> <del>happens before</del> <ins>synchronizes with</ins> <tt>b</tt>.</p>

<p>Change 30.3.1.2 thread constructors [thread.thread.constr] paragraph 6:</p>

<p><i>Synchronization:</i> The invocation of the constructor <del>happens before</del> <ins>synchronizes with</ins> the invocation of the copy of <tt>f</tt>.</p>

<p>Change 30.3.1.5 thread members [thread.thread.member] paragraph 7:</p>

<p><i>Synchronization:</i> The completion of the thread represented by <tt>*this</tt> <del>happens before</del> <ins>synchronizes with</ins> (1.10) <tt>join()</tt> <del>returns</del> <ins>returning</ins>. [ Note: Operations on <tt>*this</tt> are not synchronized. --end note ]</p>

<p>Change 30.6.4 Associated asynchronous state [futures.state] paragraph 7:</p>

<p>Calls to functions that successfully set the stored result of an associated asynchronous state synchronize
with (1.10) calls to functions successfully detecting the ready state resulting from that setting. The storage of the result (whether normal or exceptional) into the associated asynchronous state <del>happens before</del> <ins>synchronizes with</ins> (1.10) that state <del>is</del> <ins>being</ins> set to ready.</p>

<p>Change 30.6.9 Function template async [futures.async] paragraph 5:</p>

<p><i>Synchronization:</i> the invocation of <tt>async</tt> <del>happens before</del> <ins>synchronizes with</ins> (1.10) the invocation of <tt>f</tt>. [ Note: this
statement applies even when the corresponding future object is moved to another thread. --end
note ] If the invocation is not deferred, a call to a waiting function on an asynchronous return object
that shares the associated asynchronous state created by this async call shall block until the associated
thread has completed. If the invocation is not deferred, the <tt>join()</tt> on the created thread <del>happens before</del> <ins>synchronizes with</ins>
(1.10) the first function that successfully detects the ready status of the associated asynchronous
state returns or before the function that gives up the last reference to the associated asynchronous
state returns, whichever happens first. If the invocation is deferred, the completion of the invocation
of the deferred function <del>happens before</del> <ins>synchronizes with</ins> the calls to the waiting functions return.</p>

<p>Change 30.6.10.1 packaged_task member functions [futures.task.members] paragraph 23:</p>

<p><i>Synchronization:</i> a successful call to <tt>operator()</tt> synchronizes with (1.10) a call to any member function of a <tt>future</tt>, <tt>shared_future</tt>, or <tt>atomic_future</tt> object that shares the associated asynchronous
state of <tt>*this</tt>. The completion of the invocation of the stored task and the storage of the result
(whether normal or exceptional) into the associated asynchronous state <del>happens before</del> <ins>synchronizes with</ins> (1.10) the
state <del>is</del> <ins>being</ins> set to ready. [ Note: <tt>operator()</tt> synchronizes and serializes with other functions through the
associated asynchronous state. end note ]</p>






<hr>
<h3><a name="1443"></a>1443. [FCD] Imposed happens-before edges are not made transitive</h3>
<p><b>Section:</b> 30 [thread] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-27</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread">issues</a> in [thread].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#1442">1442</a></p>
<p><b>Discussion:</b></p>


<p><b>Addresses GB-122</b></p>

<p>At various points in the standard new edges are added to
happens-before, for example 27.2.3:2 adds happens-before edges between
writes and reads from a stream:</p>

<p>If one thread makes a library call a that writes a value to a
stream and, as a result, another thread reads this value from the
stream through a library call b such that this does not result in a
data race, then a happens before b.</p>

<p>Happens-before is defined in 1.10:11 in a deliberate way that makes it
not explicitly transitively closed. Adding edges to happens-before
directly, as in 27.2.3:2, does not provide transitivity with
sequenced-before or any other existing happens-before edge. This lack
of transitivity seems to be unintentional. In order to achieve
transitivity we suggest each edge be added to
inter-thread-happens-before as a synchronises-with edge (as per
conversation with Hans Boehm). In the standard, each use of the words
"happens-before" should be replaced with the words "synchronizes-with"
in the following sentences:</p>

<p>27.2.3:2,
30.3.1.2:6,
30.3.1.5:7,
30.6.4:7,
30.6.9:5,
30.6.10.1:23</p>


<p><b>Proposed resolution:</b></p>
Request the concurrency working group to
determine if changes are needed





<hr>
<h3><a name="1444"></a>1444. [FCD] <tt>OFF_T</tt> is not defined</h3>
<p><b>Section:</b> 27.5.3.2 [fpos.operations] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-28</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#fpos.operations">issues</a> in [fpos.operations].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1414">1414</a></p>
<p><b>Discussion:</b></p>

<p><b>Addresses GB-123</b></p>

Several rows in table 124 specify a Return type of
'OFF_T', which does not appear to be a type defined in
this standard.


<p><b>Proposed resolution:</b></p>
Resolve outstanding references to the removed
type 'OFF_T'.





<hr>
<h3><a name="1446"></a>1446. [FCD] Move and swap for I/O streams</h3>
<p><b>Section:</b> 27.7 [iostream.format] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#iostream.format">issues</a> in [iostream.format].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-138</b></p>

For istreams and ostreams, the move-constructor does
not move-construct, the move-assignment operator does
not move-assign, and the swap function does not swap
because these operations do not manage the <tt>rdbuf()</tt>
pointer. Useful applications of these operations are
prevented both by their incorrect semantics and because
they are protected.

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<p>
In short: reverse the resolution of issue 900, then
change the semantics to move and swap the
<tt>rdbuf()</tt> pointer. Add a new protected constructor
that takes an rvalue reference to a stream and a
pointer to a streambuf, a new protected <tt>assign()</tt>
operator that takes the same arguments, and a
new protected <tt>partial_swap()</tt> function that doesn't
swap <tt>rdbuf()</tt>.
See Appendix 1 - Additional Details
</p>

<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3179.pdf">n3179</a> would solve this issue.
</blockquote>

<p><i>[
2010-11 Batavia
]</i></p>

<p>
Closed as NAD.
</p>
<blockquote>
The Library Working Group reviewed <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3179.pdf">n3179</a> and 
concluded that this change alone was not sufficient, as it would require changes to some of the derived stream types in the library.  
The preference is to not make such a broad fix, and retain the current semantics. This is closed as NAD rather than NAD future as it 
will be difficult to rename the new functions introduced in the C++0x revision of the standard at a later date.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1451"></a>1451. [FCD] <tt>regex</tt> should support allocators</h3>
<p><b>Section:</b> 28.8 [re.regex] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#re.regex">issues</a> in [re.regex].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1396">1396</a></p>
<p><b>Discussion:</b></p>

<p><b>Addresses US-141</b></p>

std::basic_regex should have an allocator for all the
reasons that a std::string does. For example, I can use
boost::interprocess to put a string or vector in shared
memory, but not a regex.


<p><b>Proposed resolution:</b></p>
Add allocators to regexes; see paper <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3171.pdf">N3171</a>
in the pre-Batavia mailing.





<hr>
<h3><a name="1454"></a>1454. [FCD] Ensure C compatibility for atomics</h3>
<p><b>Section:</b> 29 [atomics] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#atomics">active issues</a> in [atomics].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics">issues</a> in [atomics].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1455">1455</a></p>
<p><b>Discussion:</b></p>

<p><b>Addresses GB-128</b></p>
<p>
WG14 has made some late changes to their specification
of atomics, and care should be taken to ensure that we
retain a common subset of language/library syntax to
declare headers that are portable to both languages.
Ideally, such headers would not require users to define
their own macros, especially not macros that map to
keywords (which remains undefined behaviour)
</p>


<p><i>[
Resolution proposed by ballot comment
]</i></p>

<p>
Depends on result of the review of WG14 work,
which is expected to be out to ballot during the
time wg21 is resolving its own ballot comments.
Liaison may also want to file comments in WG14
to ensure compatibity from both sides.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1458"></a>1458. [FCD] Overlapping evaluations are allowed</h3>
<p><b>Section:</b> 29.3 [atomics.order] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-26</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics.order">issues</a> in [atomics.order].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1459">1459</a></p>
<p><b>Discussion:</b></p>

<p><b>Addresses GB-131</b></p>

29.4 [atomics.lockfree] p.8 states:
<p></p><blockquote>
An atomic store shall only store a value that has been computed
from constants and program input values by a finite sequence of
program evaluations, such that each evaluation observes the values
of variables as computed by the last prior assignment in the
sequence.
</blockquote><p></p>
<p>
... but 1.9 [intro.execution] p.13 states:
</p>
<p></p><blockquote>
If A is not sequenced before B and B is not sequenced before A,
then A and B are unsequenced. [ <em>Note</em>: The execution of unsequenced
evaluations can overlap.  <em>end note</em> ]
</blockquote><p></p>
<p>
Overlapping executions can make it impossible to construct the sequence
described in 29.4 [atomics.lockfree] p.8. We are not sure of the intention here and do not
offer a suggestion for change, but note that 29.4 [atomics.lockfree] p.8 is the condition
that prevents out-of-thin-air reads.
</p>


<p><b>Proposed resolution:</b></p>
Request the concurrency working group to
determine if changes are needed. Consider
changing the use of "sequence" in 29.4 [atomics.lockfree]





<hr>
<h3><a name="1463"></a>1463. [FCD] Inconsistent value assignment for <tt>atomic_bool</tt></h3>
<p><b>Section:</b> 29.5.1 [atomics.types.integral] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics.types.integral">issues</a> in [atomics.types.integral].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1462">1462</a></p>
<p><b>Discussion:</b></p>

<p><b>Addresses US-157</b></p>

<tt>atomic_bool</tt> has a <tt>volatile</tt> assignment operator but not a
non-<tt>volatile</tt> operator. The other integral types have both.


<p><b>Proposed resolution:</b></p>
Add a non-volatile assignment operator to <tt>atomic_bool</tt>.





<hr>
<h3><a name="1470"></a>1470. [FCD] "Same-ness" curiosities</h3>
<p><b>Section:</b> 29.6 [atomics.types.operations] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#atomics.types.operations">active issues</a> in [atomics.types.operations].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics.types.operations">issues</a> in [atomics.types.operations].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1474">1474</a></p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-165</b></p>

According to 29.6 [atomics.types.operations] p. 23:
<p></p><blockquote>
is the same that same as that of is not grammatical (and is not clear)
</blockquote><p></p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1471"></a>1471. [FCD] Default constructor of atomics needs specification</h3>
<p><b>Section:</b> 29.6 [atomics.types.operations] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-18</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#atomics.types.operations">active issues</a> in [atomics.types.operations].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics.types.operations">issues</a> in [atomics.types.operations].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-168</b></p>

29.6 [atomics.types.operations] around p. 4: The definition of the default constructor needs exposition.


<p><b>Proposed resolution:</b></p>
Insert a new general prototype description following the current 29.6 [atomics.types.operations] p. 3 as indicated:
<p>
</p>
<blockquote>
3 [<em>Note</em>: Many operations are volatile-qualified. The volatile as device register semantics have not changed
in the standard. This qualification means that volatility is preserved when applying these operations to
volatile objects. It does not mean that operations on non-volatile objects become volatile. Thus, volatile
qualified operations on non-volatile objects may be merged under some conditions. -- <em>end note</em>]
</blockquote>
<blockquote><pre><ins>A::A() = default;</ins>
</pre><blockquote>
<ins>? <em>Effects</em>: Leaves the atomic object in an uninitialized state.
[<em>Note</em>: These semantics ensure compatiblity with <tt>C</tt>. -- <em>end note</em>]</ins>
</blockquote></blockquote>
<blockquote><pre>constexpr A::A(C desired);
[..]
</pre></blockquote>





<hr>
<h3><a name="1472"></a>1472. [FCD] Incorrect semantics of <tt>atomic_init</tt></h3>
<p><b>Section:</b> 29.6 [atomics.types.operations] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-12</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#atomics.types.operations">active issues</a> in [atomics.types.operations].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics.types.operations">issues</a> in [atomics.types.operations].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-171</b></p>

As of 29.6 [atomics.types.operations] p. 7:
<p>
The <tt>atomic_init</tt> definition "Non-atomically assigns the
value" is not quite correct, as the <tt>atomic_init</tt> purpose is
initialization.


</p><p><b>Proposed resolution:</b></p>
Change  29.6 [atomics.types.operations] p. 7 as indicated:
<blockquote><pre>void atomic_init(volatile A *object, C desired);
void atomic_init(A *object, C desired);
</pre><blockquote>
7 <em>Effects</em>: <del>Non-atomically assigns the value desired to <tt>*object</tt></del><ins>Initializes <tt>*object</tt> with value
<tt>desired</tt></ins>. Concurrent access from another thread, even via an atomic operation, constitutes a data race.
<ins>[<em>Note</em>: This function should only be applied to objects that have been default constructed. These semantics ensure
compatibility with <tt>C</tt>.  <em>end note</em>]</ins>
</blockquote></blockquote>





<hr>
<h3><a name="1473"></a>1473. [FCD] Incomplete memory order specifications</h3>
<p><b>Section:</b> 29.6 [atomics.types.operations] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD">NAD</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#atomics.types.operations">active issues</a> in [atomics.types.operations].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics.types.operations">issues</a> in [atomics.types.operations].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD">NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-172</b></p>

As of 29.6 [atomics.types.operations] p. 9, 13, 17, 20:
<p>
The order specifications are incomplete because the non-<tt>_explicit</tt>
functions do not have such parameters.
</p><p>
Add a new sentence: "If the program does not specify an order, it shall be
<tt>memory_order_seq_cst</tt>." Or perhaps: "The non-_explicit
non-member functions shall affect memory as though they were _explicit with
<tt>memory_order_seq_cst</tt>."


</p><p><i>[
2010 Batavia
]</i></p>

<p>
The Concurrency subgroup reviewed this, and deemed it NAD according to
29.6 [atomics.types.operations] paragraph 2, bullet 4. 
</p>

<p><b>Rationale:</b></p>The working paper is correct as written.



<p><b>Proposed resolution:</b></p>
<ol>
<li>Change 29.6 [atomics.types.operations] p. 9 as indicated:
<blockquote><pre>void atomic_store(volatile A* object, C desired);
void atomic_store(A* object, C desired);
void atomic_store_explicit(volatile A *object, C desired, memory_order order);
void atomic_store_explicit(A* object, C desired, memory_order order);
void A::store(C desired, memory_order order = memory_order_seq_cst) volatile;
void A::store(C desired, memory_order order = memory_order_seq_cst);
</pre><blockquote>
8 <em>Requires</em>: The order argument shall not be <tt>memory_order_consume</tt>, <tt>memory_order_acquire</tt>, nor
<tt>memory_order_acq_rel</tt>.
<p>
9 <em>Effects</em>: Atomically replaces the value pointed to by <tt>object</tt> or by this with the value of <tt>desired</tt>.
Memory is affected according to the value of <tt>order</tt>. <ins>If the program does not specify an order, it shall be
<tt>memory_order_seq_cst</tt>.</ins>
</p></blockquote></blockquote>
</li>
<li>Change 29.6 [atomics.types.operations] p. 13 as indicated:
<blockquote><pre>C atomic_load(const volatile A* object);
C atomic_load(const A* object);
C atomic_load_explicit(const volatile A* object, memory_order);
C atomic_load_explicit(const A* object, memory_order);
C A::load(memory_order order = memory_order_seq_cst) const volatile;
C A::load(memory_order order = memory_order_seq_cst) const;
</pre><blockquote>
12 <em>Requires</em>: The order argument shall not be <tt>memory_order_release</tt> nor <tt>memory_order_acq_rel</tt>.
<p>
13 <em>Effects</em>: Memory is affected according to the value of <tt>order</tt>. <ins>If the program does not specify an order, it shall be
<tt>memory_order_seq_cst</tt>.</ins>
</p><p>
14 <em>Returns</em>: Atomically returns the value pointed to by <tt>object</tt> or by <tt>this</tt>.
</p></blockquote></blockquote>
</li>
<li>Change 29.6 [atomics.types.operations] p. 17 as indicated:
<blockquote><pre>C atomic_exchange(volatile A* object, C desired);
C atomic_exchange(A* object, C desired);
C atomic_exchange_explicit(volatile A* object, C desired, memory_order);
C atomic_exchange_explicit(A* object, C desired, memory_order);
C A::exchange(C desired, memory_order order = memory_order_seq_cst) volatile;
C A::exchange(C desired, memory_order order = memory_order_seq_cst);
</pre><blockquote>
17 <em>Effects</em>: Atomically replaces the value pointed to by <tt>object</tt> or by <tt>this</tt> with <tt>desired</tt>. Memory
is affected according to the value of <tt>order</tt>. These operations are atomic read-modify-write operations
(1.10). <ins>If the program does not specify an order, it shall be <tt>memory_order_seq_cst</tt>.</ins>
<p>
18 <em>Returns</em>: Atomically returns the value pointed to by <tt>object</tt> or by <tt>this</tt> immediately before the effects.
</p></blockquote></blockquote>
</li>
<li>Change 29.6 [atomics.types.operations] p. 20 as indicated:
<blockquote><pre>bool atomic_compare_exchange_weak(volatile A* object, C * expected, C desired);
bool atomic_compare_exchange_weak(A* object, C * expected, C desired);
bool atomic_compare_exchange_strong(volatile A* object, C * expected, C desired);
bool atomic_compare_exchange_strong(A* object, C * expected, C desired);
bool atomic_compare_exchange_weak_explicit(volatile A* object, C * expected, C desired,
  memory_order success, memory_order failure);
bool atomic_compare_exchange_weak_explicit(A* object, C * expected, C desired,
  memory_order success, memory_order failure);
bool atomic_compare_exchange_strong_explicit(volatile A* object, C * expected, C desired,
  memory_order success, memory_order failure);
bool atomic_compare_exchange_strong_explicit(A* object, C * expected, C desired,
  memory_order success, memory_order failure);
bool A::compare_exchange_weak(C &amp; expected, C desired,
  memory_order success, memory_order failure) volatile;
bool A::compare_exchange_weak(C &amp; expected, C desired,
  memory_order success, memory_order failure);
bool A::compare_exchange_strong(C &amp; expected, C desired,
  memory_order success, memory_order failure) volatile;
bool A::compare_exchange_strong(C &amp; expected, C desired,
  memory_order success, memory_order failure);
bool A::compare_exchange_weak(C &amp; expected, C desired,
  memory_order order = memory_order_seq_cst) volatile;
bool A::compare_exchange_weak(C &amp; expected, C desired,
  memory_order order = memory_order_seq_cst);
bool A::compare_exchange_strong(C &amp; expected, C desired,
  memory_order order = memory_order_seq_cst) volatile;
bool A::compare_exchange_strong(C &amp; expected, C desired,
  memory_order order = memory_order_seq_cst);
</pre><blockquote>
19 <em>Requires</em>: The <tt>failure</tt> argument shall not be <tt>memory_order_release</tt> nor <tt>memory_order_acq_rel</tt>.
The <tt>failure</tt> argument shall be no stronger than the success argument.
<p>
20 <em>Effects</em>: Atomically, compares the contents of the memory pointed to by <tt>object</tt> or by <tt>this</tt> for equality
with that in <tt>expected</tt>, and if true, replaces the contents of the memory pointed to by <tt>object</tt> or by
<tt>this</tt> with that in <tt>desired</tt>, and if false, updates the contents of the memory in expected with the
contents of the memory pointed to by <tt>object</tt> or by <tt>this</tt>. Further, if the comparison is true, memory
is affected according to the value of <tt>success</tt>, and if the comparison is false, memory is affected
according to the value of <tt>failure</tt>. When only one <tt>memory_order</tt> argument is supplied, the value of
<tt>success</tt> is <tt>order</tt>, and the value of <tt>failure</tt> is <tt>order</tt> except that a value of 
<tt>memory_order_acq_rel</tt> shall be replaced by the value <tt>memory_order_acquire</tt> and a value of 
<tt>memory_order_release</tt> shall be replaced by the value <tt>memory_order_relaxed</tt>. <ins>If 
the program does not specify an order, it shall be <tt>memory_order_seq_cst</tt>.</ins> If the operation returns <tt>true</tt>, 
these operations are atomic read-modify-write operations (1.10). Otherwise, these operations are atomic load operations.
</p><p>
[..]
</p></blockquote></blockquote>
</li>
</ol>





<hr>
<h3><a name="1475"></a>1475. [FCD] weak compare-and-exchange confusion II</h3>
<p><b>Section:</b> 29.6 [atomics.types.operations] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> Switzerland <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-29</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#atomics.types.operations">active issues</a> in [atomics.types.operations].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics.types.operations">issues</a> in [atomics.types.operations].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1474">1474</a></p>
<p><b>Discussion:</b></p>
<p><b>Addresses CH-23</b></p>

29.6 [atomics.types.operations] p. 23: The first sentence has non-English syntax.

<p><i>[
Resolution proposed in ballot comment:
]</i></p>


<p>
Change to "The weak compare-and-exchange
operations may fail spuriously, that is, return false
while leaving the contents of memory pointed to
by expected unchanged."
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1476"></a>1476. [FCD] Ballot Comment US-177</h3>
<p><b>Section:</b> 29.6 [atomics.types.operations] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-07</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#atomics.types.operations">active issues</a> in [atomics.types.operations].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics.types.operations">issues</a> in [atomics.types.operations].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1474">1474</a></p>
<p><b>Discussion:</b></p>

<p><b>Addresses US-177</b></p>

The first sentence of this paragraph doesn't make sense.

<p><i>[
Resolution proposed in ballot comment
]</i></p>

<p>
Figure out what it's supposed to say, and say it.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1477"></a>1477. [FCD] weak compare-and-exchange confusion III</h3>
<p><b>Section:</b> 29.6 [atomics.types.operations] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#Dup">Dup</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-31</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#atomics.types.operations">active issues</a> in [atomics.types.operations].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#atomics.types.operations">issues</a> in [atomics.types.operations].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#Dup">Dup</a> status.</p>
<p><b>Duplicate of:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#1474">1474</a></p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-135</b></p>

The first sentence of 29.6 [atomics.types.operations] p.23 was changed by n2992 but
now makes no sense: "that is, return <tt>false</tt> while leaving
the contents of memory pointed to by <tt>expected</tt> before the
operation is the same that same as that of the <tt>object</tt> and
the same as that of <tt>expected</tt> after the operation."
There's a minor editorial difference between n2992 ("is
that same as that" vs "is the same that same as that") but
neither version makes sense.
Also, the remark talks about "<tt>object</tt>" which should
probably be "<tt>object</tt> or <tt>this</tt>" to cover the member functions
which have no object parameter.

<p><i>[
Resolution proposed in ballot comment:
]</i></p>

<p>
Fix the Remark to say whatever was intended.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1483"></a>1483. [FCD] <tt>__STDCPP_THREADS spelling</tt></h3>
<p><b>Section:</b> 30.3 [thread.threads] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> DIN <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-26</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses DE-23</b></p>

Predefined macros usually start and end with two
underscores, see 16.8 and FDIS 29124 = WG21 N3060
clause 7. __STDCPP_THREADS should blend in.

<p><i>[
Resolved in Rapperswil by a motion to directly apply the words from the ballot comment in N3102.
]</i></p>




<p><b>Proposed resolution:</b></p>
Change the macro name to
__STDCPP_THREADS__.





<hr>
<h3><a name="1484"></a>1484. [FCD] Need a way to join a thread with a timeout</h3>
<p><b>Section:</b> 30.3.1 [thread.thread.class] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Future">NAD Future</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-29</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-183</b></p>

There is no way to join a thread with a timeout.

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote>
Add <tt>join_for</tt> and <tt>join_until</tt>. Or decide one should
never join a thread with a timeout since <tt>pthread_join</tt> doesn't have a 
timeout version.
</blockquote>

<p><i>[
2010 Batavia
]</i></p>

<p>
The concurrency working group deemed this an extension beyond the scope of C++0x.
</p>
<p><b>Rationale:</b></p>The LWG does not wish to make a change at this time.



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1488"></a>1488. [FCD] Improve interoperability between
the C++0x and C1x threads APIs</h3>
<p><b>Section:</b> 30.4 [thread.mutex] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Future">NAD Future</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.mutex">issues</a> in [thread.mutex].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-185</b></p>

Cooperate with WG14 to improve interoperability between
the <tt>C++0x</tt> and <tt>C1x</tt> threads APIs. In particular, <tt>C1x</tt>
mutexes should be conveniently usable with a <tt>C++0x</tt>
<tt>lock_guard</tt>. Performance overheads for this combination
should be considered.

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote>
Remove <tt>C++0x</tt> <tt>timed_mutex</tt> and
<tt>timed_recursive_mutex</tt> if that facilitates
development of more compatible APIs.
</blockquote>

<p><i>[
2010 Batavia
]</i></p>

<p>
The concurrency sub-group reviewed the options, and decided that closer harmony should wait until both standards are published.
</p>

<p><b>Rationale:</b></p>
The LWG does not wish to make any change at this time.




<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1489"></a>1489. [FCD] <tt>unlock</tt> functions and unlock
mutex requirements are inconsistent</h3>
<p><b>Section:</b> 30.4 [thread.mutex] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Switzerland <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-12</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.mutex">issues</a> in [thread.mutex].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses CH-26</b></p>

Specifications of <tt>unlock</tt> member functions and <tt>unlock</tt>
mutex requirements are inconsistent wrt to exceptions and
pre- and postconditions.

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote>
<tt>unlock</tt> should specifiy the precondition that the
current thread "owns the lock", this will make calls
without holding the locks "undefined behavior".
<tt>unlock</tt> in  [mutex.requirements] should either be
<tt>noexcept(true)</tt> or be allowed to throw
<tt>system_error</tt> like <tt>unique_lock::unlock</tt>, or the latter
should be <tt>nothrow(true)</tt> and have the precondition
<tt>owns == true</tt>.
Furthermore <tt>unique_lock</tt>'s postcondition is wrong
in the case of a recursive mutex where <tt>owns</tt>
might stay true, when it is not the last <tt>unlock</tt>
needed to be called.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1493"></a>1493. [FCD] Add <tt>mutex</tt>, <tt>recursive_mutex</tt>, <tt>is_locked</tt> function</h3>
<p><b>Section:</b> 30.4.1 [thread.mutex.requirements] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Future">NAD Future</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.mutex.requirements">issues</a> in [thread.mutex.requirements].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-189</b></p>

<tt>mutex</tt> and <tt>recursive_mutex</tt> should have an <tt>is_locked()</tt>
member function. <tt>is_locked</tt> allows a user to test a lock
without acquiring it and can be used to implement a lightweight
<tt>try_try_lock</tt>.

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote>
Add a member function:
<pre>bool is_locked() const;
</pre>
to <tt>std::mutex</tt> and <tt>std::recursive_mutex</tt>. These
functions return true if the current thread would
not be able to obtain a mutex. These functions do
not synchronize with anything (and, thus, can
avoid a memory fence).
</blockquote>

<p><i>[
2010 Batavia
]</i></p>

<p>
The Concurrency subgroup reviewed this issue and deemed it to be an extension to be handled after publishing C++0x.
</p>

<p><b>Rationale:</b></p>The LWG does not wish to make a change at this time.



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1495"></a>1495. [FCD] Condition variable <tt>wait_for</tt> return insufficient</h3>
<p><b>Section:</b> 30.5 [thread.condition] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-12</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.condition">issues</a> in [thread.condition].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-191</b></p>

The condition variable <tt>wait_for</tt> returning <tt>cv_status</tt> is insufficient.

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote>
Return a duration of timeout remaining instead.
See Appendix 1 of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3141.pdf">n3141</a> - Additional Details, p. 211
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1496"></a>1496. [FCD] <tt>condition_variable</tt> not implementable</h3>
<p><b>Section:</b> 30.5.1 [thread.condition.condvar] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Switzerland <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-12</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.condition.condvar">issues</a> in [thread.condition.condvar].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses CH-28</b></p>

Requiring wait_until makes it impossible to implement
condition_variable correctly using respective objects
provided by the operating system (i.e. implementing the
native_handle() function) on many platforms (e.g. POSIX,
Windows, MacOS X) or using the same object as for the
condition variable proposed for C.

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote>
Remove the <tt>wait_until</tt> functions or make them at least conditionally supported.
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1499"></a>1499. [FCD] Condition variables preclude wakeup optimization</h3>
<p><b>Section:</b> 30.5 [thread.condition] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Future">NAD Future</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-29</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.condition">issues</a> in [thread.condition].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Future">NAD Future</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-193</b></p>

Condition variables preclude a wakeup optimization.

<p><i>[
Resolution proposed by ballot comment:
]</i></p>


<blockquote>
Change condition_variable to allow such
optimization. See Appendix 1 - Additional Details
</blockquote>

<p><i>[
2010 Batavia
]</i></p>

<p>
The Concurrency subgroup reviewed the issue, and deemed it an extension to be handled after C++0x.
</p>

<p><b>Rationale:</b></p>The LWG does not wish to make the change at this time.



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1500"></a>1500. [FCD] Consider removal of <tt>native_handle()</tt></h3>
<p><b>Section:</b> 30.5.2 [thread.condition.condvarany] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> Switzerland <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-28</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#thread.condition.condvarany">issues</a> in [thread.condition.condvarany].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses CH-32</b></p>

Given that the lock type can be something the underlying
doesn't know 'native_handle()' is probably
unimplementable on essentially all platforms.

<p><i>[
Resolved in Rapperswil by a motion to directly apply the words from the ballot comment in N3102.
]</i></p>




<p><b>Proposed resolution:</b></p>
Consider the removal of 'native_handle()'.





<hr>
<h3><a name="1506"></a>1506. [FCD] set_exception with a null pointer</h3>
<p><b>Section:</b> 30.6.5 [futures.promise] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index-open.html#futures.promise">active issues</a> in [futures.promise].</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#futures.promise">issues</a> in [futures.promise].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-198</b></p>

promise::set_exception can be called with a null pointer,
but none of the descriptions of the get() functions for the
three types of futures say what happens for this case.

<p><i>[
Resolved in Rapperswil by a motion to directly apply the words from the ballot comment in N3102.
]</i></p>




<p><b>Proposed resolution:</b></p>
Add the following sentence to the end of
30.6.5/22: The behavior of a program that calls
set_exception with a null pointer is undefined.





<hr>
<h3><a name="1509"></a>1509. [FCD] No restriction on calling <tt>future::get</tt> more than once</h3>
<p><b>Section:</b> 30.6.8 [futures.atomic_future] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-12</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#futures.atomic_future">issues</a> in [futures.atomic_future].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-202</b></p>
<p>
The note in this paragraph says "unlike <tt>future</tt>, calling <tt>get</tt>
more than once on the same <tt>atomic_future</tt> object is well
defined and produces the result again." There is nothing
in <tt>future</tt> that says anything negative about calling <tt>get</tt>
more than once.
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<p>
Remove this note, or add words to the
requirements for future that reflect what this note
says.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1510"></a>1510. [FCD] Should be undefined behaviour to call <tt>atomic_future</tt> operations unless <tt>valid()</tt></h3>
<p><b>Section:</b> 30.6.8 [futures.atomic_future] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-12</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#futures.atomic_future">issues</a> in [futures.atomic_future].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-203</b></p>
<p>
Both <tt>future</tt> and <tt>shared_future</tt> specify that calling most
member functions on an object for which <tt>valid() == false</tt>
produces undefined behavior. There is no such statement
for <tt>atomic_future</tt>.
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<p>
Add a new paragraph after 30.6.8 [futures.atomic_future]/2 with the same words as
30.6.7 [futures.shared_future]/3.
</p>

<p><i>[
2010-11-02 Daniel translates proposed changes into specific deltas and comments:
]</i></p>


<blockquote>
While applying the wording, I notice that 30.6.7 [futures.shared_future]/3 does
speak of the move-assignment operator, and <em>not</em> of the copy-assignment operator.
<tt>atomic_future</tt> obviously needs this to be true for the copy-assignment operator,
but I strongly assume that <tt>shared_future</tt> needs to mention both special member
assignment operators in this paragraph. To keep this consistent, the following P/R also
provides wording to fix the corresponding location for <tt>shared_future</tt>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<ol>
<li>Change 30.6.7 [futures.shared_future]/3 as indicated:
<blockquote>
3 The effect of calling any member function other than the destructor<ins>, the 
copy-assignment operator</ins>, the move-assignment operator, or <tt>valid()</tt> 
on a <tt>shared_future</tt> object for which <tt>valid() == false</tt> is undefined.
</blockquote>
</li>
<li>Following 30.6.8 [futures.atomic_future]/2, add a new paragraph:
<blockquote>
<ins>? The effect of calling any member function other than the destructor, the copy-assignment operator, or <tt>valid()</tt>
on a <tt>atomic_future</tt> object for which <tt>valid() == false</tt> is undefined.</ins>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="1511"></a>1511. [FCD] Synchronize the move-constructor for <tt>atomic_future</tt></h3>
<p><b>Section:</b> 30.6.8 [futures.atomic_future] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-12</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#futures.atomic_future">issues</a> in [futures.atomic_future].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-204</b></p>
<p>
According to the definition of <tt>atomic_future</tt>, all members
of <tt>atomic_future</tt> are synchronizing except constructors.
However, it would probably be appropriate for a move
constructor to be synchronizing on the source object. If
not, the postconditions on paragraphs 7-8, might not be
satisfied. This may be applicable if a collection of futures
are being doled out to a set of threads that process their
value.
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<p>
Make the move constructor for atomic future lock
the source
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1512"></a>1512. [FCD] Conflict in spec: block or join?</h3>
<p><b>Section:</b> 30.6.9 [futures.async] <b>Status:</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#NAD Editorial">NAD Editorial</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-12</p>
<p><b>View all other</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#futures.async">issues</a> in [futures.async].</p>
<p><b>View all issues with</b> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-status.html#NAD Editorial">NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-205</b></p>
<p>
30.6.9 [futures.async] p. 3: The third sentence says 
"If the invocation is not deferred, a call to a waiting function 
on an asynchronous return object that shares the associated asynchronous state
created by this <tt>async</tt> call shall block until the associated
thread has completed." The next sentence says "If the
invocation is not deferred, the <tt>join()</tt> on the created
thread..." Blocking until a thread completes is not
necessarily a join.
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<p>
Decide whether the requirement is to block until
finished or to call join, and rewrite to match.
</p>



<p><b>Proposed resolution:</b></p>







</body></html>